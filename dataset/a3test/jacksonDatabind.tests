@Test public void isAnnotationBundle() throws NoSuchFieldException { Field field = AnnotatedTestClass.class.getDeclaredField("field"); Field field2 = AnnotatedTestClass2.class.getDeclaredField("field2"); Field field3 = AnnotatedTestClass3.class.getDeclaredField("field3"); Field field4 = AnnotatedTestClass4.class.getDeclaredField("field4"); Field field5 = AnnotatedTestClass5.class.getDeclaredField("field5"); Field field6 = AnnotatedTestClass6.class.getDeclaredField("field6"); Field field7 = AnnotatedTestClass7.class.getDeclaredField("field7"); Field field8 = AnnotatedTestClass8.class.getDeclaredField("field8"); Field field9 = AnnotatedTestClass9.class.getDeclaredField("field9"); Field field10 = AnnotatedTestClass10.class.getDeclaredField("field10"); Field field11 = AnnotatedTestClass10.class.getDeclaredField("field11"); Field field12 = AnnotatedTestClass10.class.getDeclaredField("field12"); Field field13 = AnnotatedTestClass12.class.getDeclaredField("field13"); Field field14 = AnnotatedTestClass14.class.getDeclaredField("field14"); Field field15 = AnnotatedTestClass15.class.getDeclaredField("field15"); Field field16 = Annotated
@Test public void test_annotation_bundle() throws NoSuchMethodException { Field field = TestAnnotatedClass.class.getDeclaredField("noAnnotation"); Field field2 = TestAnnotatedClass.class.getDeclaredField("noAnnotation2"); Field field3 = TestAnnotatedClass.class.getDeclaredField("noAnnotation3"); Field field4 = TestAnnotatedClass.class.getDeclaredField("noAnnotation4"); Field field5 = TestAnnotatedClass.class.getDeclaredField("noAnnotation5"); Field field6 = TestAnnotatedClass.class.getDeclaredField("noAnnotation6"); Field field7 = TestAnnotatedClass.class.getDeclaredField("noAnnotation7"); Field field8 = TestAnnotatedClass.class.getDeclaredField("noAnnotation8"); Field field9 = TestAnnotatedClass.class.getDeclaredField("noAnnotation9"); Field field10 = TestAnnotatedClass.class.getDeclaredField("noAnnotation10"); Field field11 = TestAnnotatedClass.class.getDeclaredField("noAnnotation11"); Field field12 = TestAnnotatedClass.class.getDeclaredField("noAnnotation12"); Field field13 = TestAnnotatedClass.class.getDeclaredField("noAnnotation13"); Field field14 = TestAnnotatedClass.class.
@Test public void should_find_properties_to_ignore_if_annotation_does_not_exist() throws NoSuchFieldException { Annotation notAnnotated = createAnnotatedMember(NotAnnotated.class, "notAnnotated"); String[] ignoreProperties = new AnnotationIntrospector().findPropertiesToIgnore(notAnnotated); Assert.assertNotNull(ignoreProperties); Assert.assertEquals(1, ignoreProperties.length); Assert.assertEquals("notAnnotated", ignoreProperties[0]); }
@Test public void findPropertiesToIgnore_shouldReturnNullIfAnnotationIgnoreIsNull() throws NoSuchFieldException { Field f = AnnotatedTestClass.class.getDeclaredField("ignore"); f.setAccessible(true); AnnotatedTestClass test = (AnnotatedTestClass) f.get(AnnotatedTestClass.class); assertNull(new JsonIgnoreProperties().findPropertiesToIgnore(test)); }
@Test public void findPropertiesToIgnore_null() throws NoSuchFieldException { Assert.assertNull(jsonIgnoreProps.findPropertiesToIgnore(null)); }
@Test public void should_find_ignore_unknown_properties_in_the_inner_class_without_annotation() throws NoSuchMethodException { Class<?> inner = Inner.class; AnnotatedClass ac = inner.getDeclaredMethod("ignoreUnknownProperties", JsonIgnoreProperties.class); Assert.assertTrue(ac.findIgnoreUnknownProperties(ac)); }
@Test public void findIgnoreUnknownProperties() throws NoSuchFieldException { Field f = TestAnnotation.class.getDeclaredField("ignoreUnknown"); f.setAccessible(true); AnnotatedClass ac = (AnnotatedClass) f.get(TestAnnotation.class); Assert.assertTrue(f.findIgnoreUnknownProperties(ac)); }
@Test public void should_return_null_for_IgnoreUnknownProperties() { Assert.assertNull(jsonIgnoreProperties.ignoreUnknown()); AnnotatedClass ac = AnnotatedClassCreator.createAnnotatedClass(MyIgnore.class, "ignoreUnknown"); Assert.assertNull(jsonIgnoreProperties.ignoreUnknown()); ac.getAnnotation(JsonIgnoreProperties.class).setIgnoreUnknown(true); Assert.assertNull(jsonIgnoreProperties.ignoreUnknown()); ac.getAnnotation(JsonIgnoreProperties.class).setIgnoreUnknown(null); Assert.assertNull(jsonIgnoreProperties.ignoreUnknown()); }
@Test public void isIgnorableType_ignoreUnknown() throws NoSuchFieldException { AnnotatedClass ac = AnnotatedClassFactory.findClassWithAnnotation(IgnoreUnknown.class, "test"); Assert.assertTrue(new JacksonAnnotationIntrospector().isIgnorableType(ac)); }
@Test public void should_ignore_unknown_property() throws NoSuchFieldException { Field f = TestAnnotation.class.getDeclaredField("ignoreUnknownProperties"); f.setAccessible(true); AnnotatedClass ac = (AnnotatedClass) f.get(TestAnnotation.class); Assert.assertTrue(new JacksonAnnotationIntrospector().isIgnorableType(ac)); }
@Test public void should_return_null_if_no_ignore_type() throws NoSuchFieldException { Field f = AnnotatedTestClass.class.getDeclaredField("noIgnore"); Assert.assertNull(f.get(null)); Assert.assertNull(f.get(new FieldAnnotation(null, JsonIgnoreType.class)).value()); Assert.assertNull(f.get(new FieldAnnotation(null, JsonIgnoreType.class)).value()); Assert.assertNull(f.get(new FieldAnnotation(null, JsonIgnoreType.class)).value()); Assert.assertNull(f.get(new FieldAnnotation(null, JsonIgnoreType.class)).value()); Assert.assertNull(f.get(new FieldAnnotation(null, JsonIgnoreType.class)).value()); Assert.assertNull(f.get(new FieldAnnotation(null, JsonIgnoreType.class)).value()); Assert.assertNull(f.get(new FieldAnnotation(null, JsonIgnoreType.class)).value()); Assert.assertNull(f.get(new FieldAnnotation(null, JsonIgnoreType.class)).value()); Assert.assertNull(f.get(new FieldAnnotation(null, JsonIgnoreType.class)).value
@Test public void findFilterId() { AnnotatedTestClass ac = AnnotatedTestClass.class.getDeclaredMethod("findFilterId", String.class, String.class); Assert.assertEquals("id", ac.findFilterId(ac)); ac = AnnotatedTestClass.class.getDeclaredMethod("findFilterId", String.class, String.class); Assert.assertEquals("id", ac.findFilterId(ac)); ac = AnnotatedTestClass.class.getDeclaredMethod("findFilterId", String.class, String.class); Assert.assertEquals("id", ac.findFilterId(ac)); ac = AnnotatedTestClass.class.getDeclaredMethod("findFilterId", String.class, String.class); Assert.assertEquals("id", ac.findFilterId(ac)); ac = AnnotatedTestClass.class.getDeclaredMethod("findFilterId", String.class, String.class); Assert.assertEquals("id", ac.findFilterId(ac)); ac = AnnotatedTestClass.class.getDeclaredMethod("findFilterId", String.class, String.class); Assert.assertEquals("id", ac.findFilterId(ac)); }
@Test public void findFilterId() throws Exception { AnnotatedClass ac = AnnotatedClassHelper.findClassWithAnnotation(TestJsonFilter.class, TestJsonFilter.class); Assert.assertNotNull(ac); Assert.assertEquals("test", ac.findFilterId(ac)); ac = AnnotatedClassHelper.findClassWithAnnotation(TestJsonFilterWithAnnotation.class, TestJsonFilterWithAnnotation.class); Assert.assertNotNull(ac); Assert.assertEquals("test", ac.findFilterId(ac)); ac = AnnotatedClassHelper.findClassWithAnnotation(TestJsonFilterWithAnnotation.class, TestJsonFilterWithAnnotation.class); Assert.assertNotNull(ac); Assert.assertEquals("test", ac.findFilterId(ac)); ac = AnnotatedClassHelper.findClassWithAnnotation(TestJsonFilterWithAnnotation.class, TestJsonFilterWithAnnotation.class); Assert.assertNotNull(ac); Assert.assertEquals("test", ac.findFilterId(ac)); ac = AnnotatedClassHelper.findClassWithAnnotation(TestJsonFilterWithAnnotation.class, TestJsonFilterWithAnnotation.class); Assert.assertNotNull(ac); Assert.assertEquals("test", ac.findFilterId(ac)); ac
@Test public void findFilterId() { AnnotationFilter filter = new AnnotationFilter() { @Override public void annotationType(AnnotatedClass ac) { ac.getAnnotation(JsonFilter.class); } }; Assert.assertEquals("null", new String(new Object[] {filter.value(), null})); Assert.assertEquals("null", new String(new Object[] {filter.value(), null})); Assert.assertEquals("null", new String(new Object[] {filter.value(), null})); Assert.assertEquals("null", new String(new Object[] {filter.value(), null})); Assert.assertEquals("null", new String(new Object[] {filter.value(), null})); Assert.assertEquals("null", new String(new Object[] {filter.value(), null})); Assert.assertEquals("null", new String(new Object[] {null, null})); Assert.assertEquals("null", new String(new Object[] {null, null})); Assert.assertEquals("null", new String(new Object[] {null, null})); Assert.assertEquals("null", new String(new Object[] {null, null})); Assert.assertEquals("null", new String(new Object
@Test public void findFilterId() throws NoSuchFieldException, SecurityException, IllegalArgumentException, IllegalAccessException { Field f = TestAnnotatedClass.class.getDeclaredField("filterId"); f.setAccessible(true); AnnotatedClass ac = (AnnotatedClass) f.get(TestAnnotatedClass.class); Object id = ac.findFilterId(ac); Assert.assertNotNull(id); Assert.assertEquals("filterId", id.toString()); }
@Test public void findReferenceType_managedReference() throws NoSuchMethodException { Class<?> ac = AnnotatedTestClass.class; Method m = ac.getDeclaredMethod("managedReference", Object.class); Member member = annotatedClass.getMethod("getMember", Object.class); ReferenceProperty ref = (ReferenceProperty) m.invoke(ac, member); Assert.assertNotNull(ref); Assert.assertEquals(AnnotationIntrospector.ReferenceProperty.managed("foo"), ref.propertyName()); }
@Test public void findReferenceType_back() throws Exception { AnnotatedMember member = annotatedClassWithAnnotation(JsonBackReference.class, "foo"); JsonBackReference ref1 = member.getAnnotation(JsonBackReference.class); Assert.assertNotNull(ref1); Assert.assertEquals(AnnotationIntrospector.ReferenceProperty.back("foo"), ref1.value()); Assert.assertNull(ref1.findReferenceType(member)); }
@Test public void findReferenceType_back() throws NoSuchMethodException { Class<?> ac = AnnotatedTestClass.class; Method m = ac.getDeclaredMethod("back", Object.class); Member member = ac.getAnnotation(JsonBackReference.class); AnnotationIntrospectorIntrospectorIntrospector introspector = new JacksonAnnotationIntrospector(); Assert.assertTrue(introspector.findReferenceType(member).equals(AnnotationIntrospector.ReferenceProperty.back(null))); }
@Test public void findReferenceType_noRef() throws Exception { AnnotatedMember member = AnnotatedMember.create(TestBean.class, "test", null); JsonBackReference ref2 = member.getAnnotation(JsonBackReference.class); assertNull(ref2); }
@Test public void findReferenceType_back() throws Exception { AnnotatedMember member = AnnotatedMember.create(TestBean.class, "foo", "bar"); AnnotationIntrospectorIntrospector introspector = new JacksonAnnotationIntrospector(); Assert.assertNull(introspector.findReferenceType(member)); }
@Test public void findReferenceType_memberFound() throws NoSuchMethodException { Field fooField = AnnotatedClassWithMethods.class.getDeclaredField("fooField"); AnnotatedMember member = annotatedClassWithMethods.getDeclaredMember("fooMember"); Assert.assertNull(introspector.findReferenceType(member)); }
@Test public void testFindUnwrappingNameTransformer() throws Exception { AnnotatedMember member = AnnotatedMemberFactory.createClassMember(MyAnnotatedClass.class, "myField", String.class); NameTransformer transformer =Introspector.findUnwrappingNameTransformer(member); assertNotNull(transformer); assertEquals("myField", transformer.transform(MyAnnotatedClass.class, "myField")); }
@Test public void testFindUnwrappingNameTransformer_enabled() throws Exception { AnnotatedMember member = AnnotatedMemberUtils.findMember(TestBean.class, "test"); NameTransformer transformer =Introspector.findUnwrappingNameTransformer(member); assertNotNull(transformer); }
@Test public void findUnwrappingNameTransformer_enabled() throws Exception { AnnotationConfig config = AnnotationConfig.create(TestAnnotatedClass.class); config.setEnabled(true); Annotation annotation = config.findAnnotation(TestAnnotatedClass.class); NameTransformer transformer = annotation.findUnwrappingNameTransformer(null); assertNotNull(transformer); assertTrue(transformer instanceof JsonUnwrapped); }
@Test public void testFindUnwrappingNameTransformer_enabled() throws Exception { Assume.assumeTrue(SystemUtils.IS_OS_LINUX); AnnotatedMember member = AnnotatedMemberFactory.createAnnotatedMember(MyAnnotatedClass.class, "myField", MyAnnotatedClass.class); NameTransformer transformer =Introspector.findUnwrappingNameTransformer(member); Assert.assertNotNull(transformer); Assert.assertTrue(transformer instanceof JsonUnwrapped); }
@Test public void testHasRequiredMarker() throws NoSuchFieldException, SecurityException, IllegalArgumentException, IllegalAccessException { new NonStrictExpectations() { { FieldUtils.getField(AnnotatedClassWithAnnotation.class, "required"); result = true; } }; Assert.assertTrue(new NoAnnotationFound(AnnotatedClassWithAnnotation.class).hasRequiredMarker(AnnotatedClassWithAnnotation.class.getDeclaredField("required"))); Assert.assertNull(new NoAnnotationFound(AnnotatedClassWithAnnotation.class).hasRequiredMarker(AnnotatedClassWithAnnotation.class.getDeclaredField("null"))); Assert.assertNull(new NoAnnotationFound(AnnotatedClassWithAnnotation.class).hasRequiredMarker(AnnotatedClassWithAnnotation.class.getDeclaredField("null"))); }
@Test public void hasRequiredMarker() throws NoSuchFieldException { Field f = TestAnnotatedClass.class.getDeclaredField("required"); f.setAccessible(true); assertTrue(f.get(null).hasRequiredMarker(null)); assertFalse(f.get(null).hasRequiredMarker(AnnotatedMember.get(TestAnnotatedClass.class))); }
@Test public void testHasRequiredMarker() throws NoSuchFieldException, SecurityException, IllegalArgumentException, IllegalAccessException { Field f = TestAnnotatedClass.class.getDeclaredField("required"); f.setAccessible(true); Assert.assertTrue(f.hasRequiredMarker(null)); f.set(TestAnnotatedClass.class.getDeclaredField("noRequired")); Assert.assertFalse(f.hasRequiredMarker(null)); f.set(TestAnnotatedClass.class.getDeclaredField("noRequired")); Assert.assertFalse(f.hasRequiredMarker(null)); f.set(TestAnnotatedClass.class.getDeclaredField("noRequired")); Assert.assertFalse(f.hasRequiredMarker(null)); }
@Test public void testRequiredMarker() throws NoSuchFieldException, SecurityException, IllegalArgumentException { Field f = TestAnnotatedClass.class.getDeclaredField("required"); f.setAccessible(true); Assert.assertTrue(f.get(null).required()); f.set(null, "foo"); Assert.assertFalse(f.get(null).required()); f.set(null, "bar"); Assert.assertTrue(f.get(null).required()); f.set(null, "baz"); Assert.assertFalse(f.get(null).required()); }
@Test public void testHasRequiredMarker() throws NoSuchFieldException, SecurityException, IllegalArgumentException, IllegalAccessException { Assert.assertNull(new NoAnnotationFound(JsonProperty.class).hasRequiredMarker(null)); Assert.assertTrue(new NoAnnotationFound(JsonProperty.class).hasRequiredMarker(new AnnotatedMember(MyAnnotatedClass.class, "noAnnotationFound"))); Assert.assertTrue(new NoAnnotationFound(JsonProperty.class).hasRequiredMarker(new AnnotatedMember(MyAnnotatedClass.class, "noAnnotationFound"))); Assert.assertTrue(new NoAnnotationFound(JsonProperty.class).hasRequiredMarker(new AnnotatedMember(MyAnnotatedClass.class, "noAnnotationFound"))); Assert.assertTrue(new NoAnnotationFound(JsonProperty.class).hasRequiredMarker(new AnnotatedMember(MyAnnotatedClass.class, "noAnnotationFound"))); Assert.assertTrue(new NoAnnotationFound(JsonProperty.class).hasRequiredMarker(new AnnotatedMember(MyAnnotatedClass.class, "noAnnotationFound"))); Assert.assertTrue(new NoAnnotationFound(JsonProperty.class).hasRequiredMarker(new AnnotatedMember(MyAnnotatedClass.class, "noAnnotationFound"))); Assert.assertTrue(new NoAnnotationFound(JsonProperty.class).
@Test public void findPropertyTypeResolver_container_type() throws NoSuchMethodException, SecurityException, IllegalArgumentException, IllegalAccessException { MapperConfig<?> config = mapperConfig(_rootType, "containerType"); JavaType baseType = mock(JavaType.class); Method method = getClass().getDeclaredMethod("method", Container.class); TypeResolverBuilder<?> resolver = _resolver.findPropertyTypeResolver(config, null, baseType); assertThat(resolver, nullValue()); }
@Test public void findPropertyTypeResolver_withContainerType() throws Exception { TypeResolverBuilder<?> builder = _mapper.findTypeResolver(_config, AnnotatedMember.class, JavaType.get(String.class)); Assert.assertNotNull(builder); Assert.assertEquals(JavaTypes.STRING, builder.build().getInternalType()); builder = _mapper.findTypeResolver(_config, AnnotatedMember.class, JavaType.get(String.class)); Assert.assertNotNull(builder); Assert.assertEquals(JavaTypes.STRING, builder.build().getInternalType()); builder = _mapper.findTypeResolver(_config, AnnotatedMember.class, JavaType.get(String.class)); Assert.assertNotNull(builder); Assert.assertEquals(JavaTypes.STRING, builder.build().getInternalType()); }
@Test public void findPropertyTypeResolver() throws Exception { TypeResolverBuilder<?> resolver = _findTypeResolver(mapperConfig, AnnotatedMember.class, JavaType.get(String.class)); Assert.assertNotNull(resolver); Assert.assertEquals(JavaType.get(String.class), resolver.resolve(String.class)); }
@Test public void findPropertyContentTypeResolver_forContainer() throws NoSuchMethodException, SecurityException, IllegalArgumentException { MapperConfig<?> config = mapperConfig(_rootMember, "bar"); JavaType containerType = JavaTypes.getContainerType(Foo.class); TypeResolverBuilder<?> resolver = _introspector.findPropertyContentTypeResolver(config, _rootMember, containerType); assertThat(resolver, instanceOf(ContainerTypeResolver.class)); }
@Test public void findPropertyContentTypeResolver_forContainerType() throws NoSuchMethodException, SecurityException, IllegalArgumentException { JavaType containerType = new JavaType(String.class, ".util.List"); MapperConfig<?> config = mapperConfig(_mapperConfig, _member, containerType); TypeResolverBuilder<?> resolver = _resolver.findPropertyContentTypeResolver(_mapperConfig, _member, containerType); assertThat(resolver, instanceOf(TypeResolverBuilder.class)); }
@Test public void findPropertyContentTypeResolver() throws Exception { MapperConfig<?> mapperConfig = new MapperConfig<>(); mapperConfig.setClass(MyBean.class); AnnotatedMember am = AnnotatedMember.create(MyBean.class, "bar", String.class); TypeResolverBuilder<?> resolver = _resolver.findTypeResolver(mapperConfig, am, JavaType.get(String.class)); TypeResolverBuilder<?> builder = resolver.findPropertyContentTypeResolver(mapperConfig, am, JavaType.get(String.class)); assertTrue(builder instanceof TypeResolverBuilder<?>); }
@Test public void testFindSubtypes() throws Exception { Annotation p = AnnotationFactory.createAnnotation(JsonSubTypes.class, Root.class, Root.class, Root.class); List<NamedType> subtypes = introspector.findSubtypes(p); Assert.assertEquals(1, subtypes.size()); NamedType subtype = subtypes.get(0); Assert.assertEquals("root", subtype.name()); }
@Test public void testFindSubtypes() throws Exception { Annotated ac = createBundle(MyBundle.class); JsonSubTypes t = ac.getAnnotation(JsonSubTypes.class); Assert.assertNotNull(t); List<NamedType> subtypes = t.findSubtypes(ac); Assert.assertNotNull(subtypes); Assert.assertEquals(1, subtypes.size()); NamedType subtype = subtypes.get(0); Assert.assertEquals("myBundle", subtype.name()); }
@Test public void findSubtypes_null() { Assert.assertNull(Introspector.findSubtypes(null)); }
@Test public void should_find_type_by_annotation_name() throws NoSuchFieldException { AnnotatedTestClassWithAnnotation nameAnnotated = AnnotatedTestClassWithAnnotation.class.getDeclaredField("nameAnnotated"); Assert.assertEquals(".lang.String", nameAnnotated.findTypeName(nameAnnotated)); }
@Test public void findTypeName_noAnnotationFound() throws NoSuchMethodException { AnnotatedTestClass ac = createAnnotatedClass(NoAnnotationFound.class, "noAnnotationFound"); Assert.assertNull(ac.findTypeName(ac)); }
@Test public void findTypeNameReturnsNullIfAnnotationHasNoAnnotation() { AnnotationConfig config = AnnotationConfig.create(TestAnnotatedClass.class); String tn = config.findTypeName(config); assertNull(tn); }
@Test public void findSerializer() throws Exception { Annotated a = Annotated.class.getDeclaredMethod("findSerializer", String.class, String.class, String.class); Assert.assertEquals(JsonSerializer.class, a.getAnnotation(JsonSerialize.class).getClass()); Assert.assertEquals(JsonSerializer.None.class, a.getAnnotation(JsonRawValue.class).getClass()); Assert.assertEquals(JsonSerializer.class, a.getAnnotation(JsonRawValue.class).getClass()); }
@Test public void findSerializer() throws Exception { Annotation[] annotations = getClass().getDeclaredAnnotations(); Annotation[] annotationsArray = annotationsArray.length; for (Annotation annotation : annotationsArray) { if (annotation.isAnnotationBundle(annotation)) { continue; } Annotation[] annotationsWithAnnotation = annotation.getAnnotations(); if (annotation.isAnnotationBundle(annotationArray)) { continue; } Class<?> type = annotation.getAnnotation(JsonSerializer.class); if (annotation.isAnnotation(JsonRawValue.class)) { Object value = annotation.value(); if (value instanceof RawSerializer) { RawSerializer<?> rawValue = (RawSerializer<?>) value; assertEquals(rawValue.class, rawValue.class); } } } }
@Test public void findSerializer_None() throws Exception { Annotated annotator = Annotated.class.getDeclaredMethod("none", String.class, String.class); Object result = annotator.findSerializer(annotated); assertThat(result).isNull(); }
@Test public void findContentSerializer() throws NoSuchFieldException, SecurityException, IllegalArgumentException, IllegalAccessException { Annotated annotated = getClass().getDeclaredField("jsonSerialize"); Class<? extends JsonSerializer<?>> serClass = annotated.findContentSerializer(annotated); assertEquals(JsonSerializer.None.class, serClass); }
@Test public void findContentSerializer_none() throws Exception { Annotated annotated = Annotated.create(TestBean.class, "none", null); Class<? extends JsonSerializer<?>> serClass = annotated.getAnnotation(JsonSerialize.class); Assert.assertEquals(null, serClass); }
@Test public void findContentSerializer() { Annotated annotator = Annotated.create(MyBean.class); Class<? extends JsonSerializer<?>> serClass = annotator.findContentSerializer(annotated); Assert.assertEquals(JsonSerialize.class, serClass); }
@Test public void testFindContentSerializer() throws NoSuchFieldException, SecurityException, IllegalArgumentException, IllegalAccessException { Field f = TestAnnotated.class.getDeclaredField("jsonSerializer"); f.setAccessible(true); Class<? extends JsonSerializer<?>> serClass = f.findContentSerializer(TestAnnotated.class); Assert.assertEquals(JsonSerializer.None.class, serClass); }
@Test public void findSerializationInclusion_should_return_default_if_default_annotation_is_non_empty() throws Exception { ClassWithAnnotation annotation = new ClassWithAnnotation(); annotation.setAnnotation(JsonInclude.NON_EMPTY); JsonInclude.Include actual = introspector.findSerializationInclusion(annotation, JsonInclude.Include.DEFAULT); assertThat(actual).isEqualTo(JsonInclude.Include.NON_EMPTY); }
@Test public void findSerializationInclusion_should_return_default_if_property_is_null() throws Exception { Class<?> type = getClass(); Annotated a = mock(Annotated.class); when(a.getAnnotation(JsonInclude.class)).thenReturn(null); JsonInclude.Include defValue = JsonInclude.Include.DEFAULT; Jackso.Include result = jackso.context.getIncludeResolver().resolve(type, null); assertSame(result, defValue); }
@Test public void findSerializationInclusion() { JsonInclude.Include default = JsonInclude.Include.DEFAULT; JsonInclude.Include nonEmpty = JsonInclude.Include.NON_EMPTY; JsonInclude.Include empty = JsonInclude.Include.EMPTY; JsonInclude.Include always = JsonInclude.Include.ALWAYS; Annotated annotated = new Annotated() { @Override public void write(@NotNull JsonInclude.Include value) { } }; JsonInclude.Include tracing = JsonInclude.Include.TRACE; JsonInclude.Include tracing2 = JsonInclude.Include.TRACE; JsonInclude.Include json = new JsonInclude() { @Override public void write(@NotNull JsonInclude value) { } }; JsonInclude.Include json2 = new JsonInclude() { @Override public void write(@NotNull JsonInclude value) { } }; JsonInclude.Include json2 = new JsonInclude() { @Override public void write(@NotNull JsonInclude value) { } }; JsonInclude.Include json2 = new JsonInclude() { @Override public void write(@NotNull JsonInclude value) { } }; JsonInclude.Include json2 = new JsonInclude() { @Override public void write(@NotNull JsonInclude value) { } }; JsonInclude.Include json2 = new
@Test public void findSerializationInclusion_default() { JsonSerialize.Include default = JsonInclude.Include.DEFAULT; JsonSerialize.Include nonEmpty = JsonInclude.Include.NON_EMPTY; Annotated annotated = new Annotated() { @Override public void annotationType(JsonSerialize.class) { } }; JsonInclude.Include def = JsonInclude.Include.NON_EMPTY; JsonInclude.Include include = JsonInclude.Include.DEFAULT; JsonInclude.Include test = Ja.DEFAULT; JsonInclude.Include test2 = Ja.DEFAULT; JsonInclude.Include test3 = Ja.DEFAULT; JsonInclude.Include test4 = Ja.DEFAULT; JsonInclude.Include test5 = Ja.DEFAULT; JsonInclude.Include test6 = Ja.DEFAULT; assertEquals(default, test.findSerializationInclusion(annotated, default)); assertEquals(nonEmpty, test.findSerializationInclusion(nonEmpty, def)); assertEquals(nonEmpty, test.findSerializationInclusion(nonEmpty, def)); assertEquals(test5, test.findSerializationInclusion(test5, def)); assertEquals(test6, test.findSerializationInclusion(test3, def)); assertEquals(test4, test.findSerializationInclusion(test5, def
@Test public void findSerializationInclusion() { JsonInclude.Include default = JsonInclude.Include.DEFAULT; JsonInclude.Include nonNull = JsonInclude.Include.NON_DEFAULT; JsonInclude.Include empty = JsonInclude.Include.EMPTY; JsonInclude.Include nullOut = JsonInclude.Include.NULL; JsonInclude.Include nullErr = JsonInclude.Include.NON_DEFAULT; JsonInclude.Include nullErr = JsonInclude.Include.NON_EMPTY; JsonInclude.Include nullIn = JsonInclude.Include.NON_DEFAULT; JsonInclude.Include nullOut = JsonInclude.Include.NON_EMPTY; JsonInclude.Include nullErr = JsonInclude.Include.NON_EMPTY; JsonInclude.Include nullOut = JsonInclude.Include.NON_EMPTY; JsonInclude.Include nullErr = JsonInclude.Include.NON_EMPTY; JsonInclude.Include nullOut = JsonInclude.Include.EMPTY; JsonInclude.Include nullErr = JsonInclude.Include.NON_EMPTY; JsonInclude.Include nullOut = JsonInclude.Include.EMPTY; JsonInclude.Include nullErr = JsonInclude.Include.NON_EMPTY; JsonInclude.Include nullErr = JsonInclude.Include.EMPTY; JsonInclude.
@Test public void testFindSerializationInclusion() { JsonInclude.Include default = JsonInclude.Include.DEFAULT; JsonInclude.Include nonEmpty = JsonInclude.Include.NON_EMPTY; JsonInclude.Include empty = JsonInclude.Include.EMPTY; Annotated annotated = new AnnotatedImpl(Annotated.class); JsonInclude.Include i = new JsonInclude.Include(JsonInclude.Include.DEFAULT, JsonInclude.Include.NON_EMPTY, JsonInclude.Include.NON_DEFAULT, default, empty); JsonInclude.Include i2 = new JsonInclude.Include(JsonInclude.Include.DEFAULT, JsonInclude.Include.NON_EMPTY, JsonInclude.Include.NON_EMPTY, empty); JsonInclude.Include i3 = new JsonInclude.Include(JsonInclude.Include.DEFAULT, JsonInclude.Include.NON_EMPTY, JsonInclude.Include.NON_EMPTY, empty); JsonInclude.Include i4 = new JsonInclude.Include(JsonInclude.Include.DEFAULT, JsonInclude.Include.NON_EMPTY, JsonInclude.Include.NON_EMPTY, JsonInclude.Include.NON_EMPTY, empty); JsonInclude.Include i5 = new JsonInclude.Include(JsonInclude.Include.DEFAULT, JsonInclude
@Test public void findSerializationInclusion() { JsonInclude.Include default = JsonInclude.Include.DEFAULT; JsonInclude.Include nonEmpty = JsonInclude.Include.NON_EMPTY; JsonInclude.Include empty = JsonInclude.Include.EMPTY; JsonInclude.Include always = JsonInclude.Include.ALWAYS; JsonInclude.Include json = JsonInclude.Include.JSON; JsonInclude.Include json2 = JsonInclude.Include.NON_DEFAULT; Annotation a = new Annotation("json"); a.setAnnotation(blazz); Annotation.class = new Annotation("json"); a.setAnnotation(blazz); Annotation.class2 = new Annotation("json"); a.setAnnotation(blazz2); Annotation.class2 = new Annotation("json"); a.setAnnotation(blazz2); Annotation.class2 = new Annotation("json"); a.setAnnotation(blazz2); Annotation.class2 = new Annotation("json"); a.setAnnotation(blazz2); Annotation.class2 = new Annotation("json"); a.setAnnotation(blazz2); JsonInclude.Include i2 = JsonInclude.Include.ALWAYS; JsonInclude.Include i = i.findSerializationInclusion(a, default); JsonInclude.Include i
@Test public void testFindSerializationInclusion() { JsonInclude.Include default = JsonInclude.Include.DEFAULT; JsonInclude.Include nonEmpty = JsonInclude.Include.NON_EMPTY; JsonInclude.Include empty = JsonInclude.Include.EMPTY; Annotated annotated = new Annotated() { @Override public String value() { return "value"; } }; JsonInclude.Include result =Introspector.Introspector.findSerializationInclusion(annotated, default); assertEquals(default, result); }
@Test public void testJacksonSerializationInclusion() { assertThat(new JacksonAnnotationIntrospepe(false).findSerializationInclusion(Annotated.class, JsonInclude.Include.ALWAYS)).isEqualTo(JsonInclude.Include.ALWAYS); assertThat(new JacksonAnnotationIntrospe(false).findSerializationInclusion(Annotated.class, JsonInclude.Include.NON_DEFAULT)).isEqualTo(JsonInclude.Include.NON_DEFAULT); assertThat(new JacksonAnnotationIntrospe(false).findSerializationInclusion(Annotated.class, JsonInclude.Include.NON_EMPTY)).isEqualTo(JsonInclude.Include.NON_EMPTY); assertThat(new JacksonAnnotationIntrospe(false).findSerializationInclusion(Annotated.class, JsonInclude.Include.ALWAYS)).isEqualTo(JsonInclude.Include.ALWAYS); assertThat(new JacksonAnnotationIntrospe(false).findSerializationInclusion(Annotated.class, JsonInclude.Include.ALWAYS)).isEqualTo(JsonInclude.Include.ALWAYS); assertThat(new JacksonAnnotationIntrospe(false).findSerializationInclusion(Annotated.class, JsonInclude.Include.ALWAYS)).isEqualTo(JsonInclude.Include.ALWAYS); assertThat(new JacksonAnnotation
@Test public void findSerializationInclusion_default() { JsonInclude.Include default = JsonInclude.Include.DEFAULT; JsonInclude.Include nonEmpty = JsonInclude.Include.NON_EMPTY; JsonInclude.Include empty = JsonInclude.Include.EMPTY; Annotated annotated = new Annotated() { @Override public void annotationType(Class<? extends Annotation> annotationType) { } }; JsonInclude.Include actual = introspector.findSerializationInclusion(annotated, default); assertEquals(default, actual); }
@Test public void findSerializationType() { AnnotationDescriptor<NoClass> ann = new AnnotationDescriptor<NoClass>(NoClass.class); ann.setAnnotation(JsonSerialize.class, new NoClass()); Class<?> cls = ann.as(); Assert.assertEquals(NoClass.class, cls); }
@Test public void findSerializationType() { Annotation anno = AnnotationUtils.findAnnotation(TestSerialization.class, TestSerialization.class); assertEquals(String.class, anno.getType()); }
@Test public void findSerializationKeyType() throws Exception { Annotated ac = AnnotatedTestClass.class.getDeclaredMethod("findSerializationKeyType", Object.class, JavaType.class); Class<?> result =Introspector.findSerializationKeyType(ac, JavaType.class); Assert.assertEquals(Object.class, result); }
@Test public void findSerializationKeyType_null() throws Exception { Annotation[] annotations = new Annotation[] { new SimpleAnnotated() }; Annotated m = annotations[0]; Class<?> result = m.findSerializationKeyType(m, NoClass.class); assertNull(result); }
@Test public void findSerializationKeyType() { AnnotationKey<JacksonSerialize.class> key = AnnotationKey.create(JsonSerialize.class); AnnotationKey<JacksonSerialize.class> map = AnnotationKey.create(NoClass.class); AnnotationKey<JacksonSerialize.class> map2 = AnnotationKey.create(Map.class); AnnotationKey<JacksonSerialize.class> map3 = AnnotationKey.create(Map.class); AnnotationKey<JacksonSerialize.class> map4 = AnnotationKey.create(Map.class); AnnotationKey<JacksonSerialize.class> map5 = AnnotationKey.create(Map.class); AnnotationKey<JacksonSerialize.class> map6 = AnnotationKey.create(Map.class); map.put(Map.class, map2); map2.put(Map.class, map3); AnnotationKey<JacksonSerialize.class> map7 = AnnotationKey.create(Map.class); map7.put(Map.class, map1); map7.put(Map.class, map2); AnnotationKey<JacksonSerialize.class> map8 = AnnotationKey.create(Map.class); map8.put(Map.class, map1); map8.put(Map.class, map2); AnnotationKey<Class<?
@Test public void findSerializationKeyType_noClass() throws Exception { Assert.assertNull(Introspector.findSerializationKeyType(null, NoClass.class)); }
@Test public void findSerializationContentType() { AnnotationDescriptor<JacksonSerialize> ann = AnnotationDescriptor.create(JsonSerialize.class); ann.contentAs(String.class); Assert.assertEquals(String.class,Introspector.findSerializationContentType(ann, JavaType.JAVA)); }
@Test public void testFindSerializationContentType() { AnnotationDescriptor<Class<?>> descriptor = AnnotatedTestClass.class.getDeclaredField("jsonSerialize").getAnnotation(JsonSerialize.class); descriptor.setAccessible(true); Class<?> result = introspector.findSerializationContentType(descriptor, JavaType.class); Assert.assertEquals(Class.class, result); }
@Test public void findSerializationContentType() { AnnotationDescriptor<JacksonSerialize.class> desc = AnnotationDescriptor.create(JsonSerialize.class); desc.addAnnotation(new JsonSerializeAnnotation(true)); Annotated ann = desc.getAnnotation(JsonSerialize.class); Class<?> ct = ann.contentAs(); assertEquals(String.class, ct); }
@Test public void testFindSerializationContentType() { Assert.assertNull(refPrspector.findSerializationContentType(null, JavaType.JAVA)); Assert.assertNull(refPrspector.findSerializationContentType(null, JavaType.JAVA)); Assert.assertNull(refPrspector.findSerializationContentType(null, JavaType.JAVA)); }
@Test public void should_find_serialization_typing_for_annotated_method() throws NoSuchMethodException { Class<? extends Annotated> annotated = AnnotatedTestClass.class; JsonSerialize.Typing typing = this.mocker.getComponentUnderTest().findSerializationTyping(annotated); Assert.assertNotNull(typing); Assert.assertEquals(JsonSerialize.Typing.class, typing.getClass()); }
@Test public void findSerializationTyping_null() throws Exception { Annotated m = AnnotatedTestClass.class.getDeclaredMethod("findSerializationTyping", String.class, String.class); Assert.assertNull(m.findSerializationTyping(null)); }
@Test public void findSerializationTypingNull() { Assert.assertNull(jsonSerialize.findSerializationTyping(null)); }
@Test public void findSerializationConverter() { Annotated annotator = AnnotatedTestClass.class.getAnnotated(Converter.class); Object result = annotator.converter(); assertEquals(Converter.None.class, result); }
@Test public void findSerializationConverter() { Annotation[] annotations = AnnotatedTestClass.getAnnotatedAnnotations(JsonSerialize.class); assertEquals(null, annotations[0]); assertEquals(null, annotations[1]); annotations[2] = AnnotatedTestClass.getAnnotatedAnnotations(JsonSerialize.class); assertEquals(null, annotations[2]); annotations[3].setConverter(null); annotations[3].setConverter(null); annotations[3].setConverter(null); Annotation[] converters = AnnotatedTestClass.getAnnotatedAnnotations(Converter.class); assertEquals(null, converters[0]); assertEquals(null, converters[1]); assertEquals(null, converters[2]); annotations[3].setConverter(null); Converter.None converter = AnnotatedTestClass.getAnnotatedAnnotations(Converter.None.class); assertEquals(null, converters[3]); annotations[3].setConverter(null); annotations[3].setConverter(null); annotations[3].setConverter(null); annotations[3].setConverter(null); annotations[3].setConverter(null); annotations[3].setConverter(null); annotations[3].setConverter(null); annotations[3].setConverter(null); Annotation[] converters2 = AnnotatedTestClass.getAnnotatedAnnotations(Converter.class); assertEquals(null, converters2); Converter.None converter2 = AnnotatedTestClass.getAnnotatedAnnotations(Converter.None.class);
@Test public void testFindSerializationContentConverter() throws NoSuchFieldException, SecurityException, IllegalArgumentException, IllegalAccessException { AnnotatedMember a = AnnotatedMemberFactory.createAnnotatedMember(MyConverter.class, "converter", null); Object result = this.deserialized.findSerializationContentConverter(a); Assert.assertNotNull(result); Assert.assertEquals(Converter.None.class, result); }
@Test public void findSerializationContentConverter() throws Exception { AnnotationDescriptor<Object> de = AnnotationIntrospector.annotatedClass(TestBean.class).getAnnotation(JsonSerialize.class); de.getAnnotation(JsonSerialize.class).setContentConverter(Converter.None.class); assertEquals(Converter.None.class, de.getAnnotation(JsonSerialize.class).contentConverter()); de = AnnotationIntrospector.annotatedClass(TestBean.class).getAnnotation(JsonSerialize.class); de.getAnnotation(JsonSerialize.class).setContentConverter(Converter.None.class); assertEquals(null, de.findSerializationContentConverter(De.getAnnotation(JsonSerialize.class))); de = AnnotationIntrospector.annotatedClass(TestBean.class).getAnnotation(JsonSerialize.class); de.getAnnotation(JsonSerialize.class).setContentConverter(Converter.None.class); assertEquals(null, de.findSerializationContentConverter(De.getAnnotation(JsonSerialize.class))); }
@Test public void findSerializationContentConverter() { AnnotatedMember a = AnnotatedMemberFactory.createAnnotatedMember(Converter.class, "converter", "Converter.None"); Assert.assertNull(a.findSerializationContentConverter(null)); AnnotatedMember b = AnnotatedMemberFactory.createAnnotatedMember(Converter.class, "converter", "Converter.None"); Assert.assertNull(b.findSerializationContentConverter(a)); AnnotatedMember c = AnnotatedMemberFactory.createAnnotatedMember(Converter.class, "converter", "Converter.None"); Assert.assertNull(c.findSerializationContentConverter(a)); AnnotatedMember d = AnnotatedMemberFactory.createAnnotatedMember(Converter.class, "converter", "Converter.None"); Assert.assertNull(d.findSerializationContentConverter(a)); AnnotatedMember e = AnnotatedMemberFactory.createAnnotatedMember(Converter.class, "converter", "Converter.None"); Assert.assertNull(e.findSerializationContentConverter(a)); AnnotatedMember f = AnnotatedMemberFactory.createAnnotatedMember(Converter.class, "converter", "Converter.None"); Assert.assertNull(f.findSerializationContentConverter(a)); AnnotatedMember g = AnnotatedMemberFactory.createAnnotatedMember(Converter.class, "
@Test public void testFindSerializationContentConverter() throws NoSuchFieldException, SecurityException, IllegalArgumentException, IllegalAccessException { Field f = TestAnnotatedMember.class.getDeclaredField("converter"); f.setAccessible(true); AnnotationMember annotator = f.getAnnotation(Annotator.class); Object result = annotator.findSerializationContentConverter(annotatedMember); Assert.assertNotNull(result); Assert.assertEquals(Converter.None.class, result); }
@Test public void findViews_noAnnotationFound() throws NoSuchFieldException, SecurityException { Annotated testAnnotated = getClass().getDeclaredField("noAnnotationFound"); Class<?>[] classes =Introspector.findViews(testAnnotated); Assert.assertNull(classes); }
@Test public void findViews_annotationBundle() throws NoSuchFieldException, SecurityException { Field f = TestAnnotatedClass.class.getDeclaredField("annotationBundle"); f.setAccessible(true); AnnotatedAnnotation annotation = f.getAnnotation(JsonView.class); Class<?>[] classes = annotation.findViews(annotation); Assert.assertNotNull(classes); Assert.assertEquals(1, classes.length); Assert.assertEquals(TestAnnotatedClass.class, classes[0]); Assert.assertEquals(TestAnnotatedClass.class, classes[1]); }
@Test public void findViews() { Annotation[] annotations = getClass().getAnnotations(JsonView.class); Assert.assertNull(annotations[0]); Assert.assertNull(annotations[1]); Assert.assertNull(annotations[2]); Assert.assertNull(annotations[3]); Assert.assertNull(annotations[4]); Annotated[] annotations2 = new Annotated() { @Override public Class<?>[] findViews(Annotated a) { return new Class<?>[] { String.class, Boolean.class, Boolean.class, String.class, String.class, Boolean.class, String.class, String.class, Boolean.class, String.class, Boolean.class, String.class, Boolean.class, String.class, Boolean.class, Boolean.class, Boolean.class, Boolean.class, Boolean.class, Boolean.class, Boolean.class, Boolean.class, Boolean.class, Boolean.class, Boolean.class, Boolean.class, Boolean.class, Boolean.class, Boolean.class, Boolean.class, Boolean.class, Boolean.class, Boolean.class, Boolean.class, Boolean.class, Boolean.class, Boolean.class, Boolean.class, Boolean.class, Boolean.class, Boolean.class, Boolean.class
@Test public void isTypeId_shouldReturnTrueIfMemberHasAnnotationOfTypeJsonTypeId() throws NoSuchFieldException { Field field = TestAnnotatedClass.class.getDeclaredField("jsonTypeId"); AnnotatedMember annotatedMember = field.getAnnotatedMember(TestAnnotatedClass.class); Assert.assertTrue(Introspector.INSTANCE.isTypeId(annotatedMember)); }
@Test public void should_return_false_when_type_not_found() throws NoSuchMethodException { Class<?> type = getClass().getDeclaredMethod("notFound", String.class); AnnotatedMember member = annotatedClass.getMethod("notFound", String.class); assertFalse(type.isTypeId(member)); }
@Test public void testFindObjectReferenceInfo_jsonIdentityReference() throws Exception { String json = "{\"id\":\"id\"}"; Annotated ann = getClass().getClassLoader().getResource(json).getAnnotated(JsonIdentityReference.class); ObjectIdInfo info =Introspector.findObjectReferenceInfo(ann, null); assertThat(info.getObjectId()).isEqualTo("id"); }
@Test public void testFindNameForSerialization() throws Exception { PropertyName name =Introspector.findNameForSerialization(getClass().getMethod("testField", String.class)); assertNotNull(name); assertEquals(PropertyName.USE_DEFAULT, name.getDeclaringClass().getName()); assertEquals(PropertyName.NAME, name.getFullyQualifiedName()); }
@Test public void testFindNameForSerialization() throws NoSuchFieldException, SecurityException, IllegalArgumentException, IllegalAccessException { Field f = TestBean.class.getDeclaredField("testBean"); PropertyName name = new JacksonAnnotationIntrospector().findNameForSerialization(f); assertEquals("testBean", name.getName()); }
@Test public void testFindNameForSerialization() throws Exception { PropertyName name =Introspector.findNameForSerialization(AnnotatedField.class); assertNotNull(name); assertEquals(PropertyName.USE_DEFAULT, name.getSimpleName()); name =Introspector.findNameForSerialization(AnnotatedField.class); assertNotNull(name); assertEquals(PropertyName.USE_DEFAULT, name.getSimpleName()); name =Introspector.findNameForSerialization(AnnotatedMethod.class); assertNotNull(name); assertEquals(PropertyName.USE_DEFAULT, name.getSimpleName()); name =Introspector.findNameForSerialization(AnnotatedMethod.class); assertNotNull(name); assertEquals(PropertyName.USE_DEFAULT, name.getSimpleName()); }
@Test public void testFindSerializationName() throws Exception { Assert.assertEquals("json", new String(json.findSerializationName(AnnotatedMethod.class))); Assert.assertEquals("json", new String(json.findSerializationName(AnnotatedMethod.class))); Assert.assertEquals("json", new String(json.findSerializationName(AnnotatedMethod.class))); Assert.assertEquals("json", new String(json.findSerializationName(AnnotatedMethod.class))); Assert.assertEquals("json", new String(json.findSerializationName(AnnotatedMethod.class))); Assert.assertEquals("json", new String(json.findSerializationName(AnnotatedMethod.class))); Assert.assertEquals("json", new String(json.findSerializationName(AnnotatedMethod.class))); Assert.assertEquals("json", new String(json.findSerializationName(AnnotatedMethod.class))); Assert.assertEquals("json", new String(json.findSerializationName(AnnotatedMethod.class))); Assert.assertEquals("json", new String(json.findSerializationName(AnnotatedMethod.class))); Assert.assertEquals("json", new String(json.findSerializationName(AnnotatedMethod.class))); Assert.assertEquals("json", new String(json.find
@Test public void testFindSerializationName() throws Exception { Assert.assertEquals("", introspector.findSerializationName(TestBean.class)); }
@Test public void findDeserializer_None() { Annotation ann = TestAnnotation.annotated(NoDeserializer.class).getAnnotation(JsonDeserialize.None.class); Class<? extends JsonDeserializer<?>> deserClass = ann.using(); assertEquals(Deserializer.None.class, deserClass); }
@Test public void findDeserializer() { Assert.assertEquals(Deserializer.None.class, introspector.findDeserializer(JsonDeserialize.class).getClass()); Assert.assertEquals(Deserializer.class, introspector.findDeserializer(JsonDeserialize.class).getClass()); Assert.assertEquals(Deserializer.class, introspector.findDeserializer(NoAnnotation.class).getClass()); Assert.assertEquals(Deserializer.class, introspector.findDeserializer(NoAnnotation.class).getClass()); Assert.assertEquals(Deserializer.class, introspector.findDeserializer(NoAnnotation.class).getClass()); Assert.assertEquals(Deserializer.class, introspector.findDeserializer(NoAnnotation.class).getClass()); Assert.assertEquals(Deserializer.class, introspector.findDeserializer(NoAnnotation.class).getClass()); Assert.assertEquals(Deserializer.class, introspector.findDeserializer(NoAnnotation.class).getClass()); Assert.assertEquals(Deserializer.class, introspector.findDeserializer(NoAnnotation.class).getClass()); Assert.assertEquals(Deserializer.class, introspector.findDeserializer(NoAnnotation.class).getClass()); Assert.assertEquals(Deserializer.class, introspector.findDeserializer(NoAnnotation.class).getClass()); Assert.assert
@Test public void findDeserializer() throws NoSuchFieldException, SecurityException, IllegalArgumentException, IllegalAccessException { Class<? extends JsonDeserializer<?>> deserClass = this.mapper.findDeserializer(this.getClass()); Assert.assertEquals(Deserializer.None.class, deserClass); }
@Test public void testFindContentDeserializer() throws NoSuchFieldException, SecurityException, IllegalArgumentException, IllegalAccessException { Annotated annotated = getClass().getDeclaredField("jsondeserializer"); Class<? extends JsonDeserializer<?>> deserClass = introspector.findContentDeserializer(annotated); assertEquals(JsonDeserializer.None.class, deserClass); }
@Test public void testFindContentDeserializer() throws Exception { Annotated annotated = getClass().getDeclaredMethod("contentDeserializer", JsonDeserializer.class); JsonDeserialize deser = annotated.getAnnotation(JsonDeserialize.class); assertEquals(Deserializer.None.class, deser.contentUsing()); }
@Test public void findContentDeserializer() { Annotated a = getClass().getDeclaredMethod("contentDeserializer", JsonDeserializer.class); Class<? extends JsonDeserializer<?>> deser = a.getAnnotation(JsonDeserializer.class); Assert.assertNotNull(deser); Assert.assertEquals(JsonDeserializer.class, deser.getCanonicalName()); Assert.assertEquals(JsonDeserializer.None.class, deser.getCanonicalName()); }
@Test public void testFindContentDeserializer() throws NoSuchFieldException, SecurityException, IllegalArgumentException, IllegalAccessException { Field f = TestBean.class.getDeclaredField("jsonDeserializer"); f.setAccessible(true); Annotated annotated = f.getAnnotation(JsonDeserialize.class); Class<? extends JsonDeserializer<?>> deser = annotated.findContentDeserializer(declared); Assert.assertNotNull(deser); Assert.assertEquals(JsonDeserializer.None.class, deser.getAnnotation(JsonDeserializer.None.class)); }
@Test public void should_return_Class_for_Deserialization_type() throws Exception { Annotation anno = AnnotationUtils.findAnnotation(NoClass.class, NoClass.class); Class<?> cls = anno.as(); assertThat(cls).isSameAs(NoClass.class); }
@Test public void findDeserializationType() { NoClass noClass = new NoClass(); Class<?> result = introspector.findDeserializationType(noClass, JavaType.class); assertNotNull(result); }
@Test public void findDeserializationType() { assertEquals(NoClass.class, introspector.findDeserializationType(Annotated.class, NoClass.class)); assertNull(introspector.findDeserializationType(Annotated.class, JavaType.class)); }
@Test public void findDeserializationKeyType_noAnnotationFound() throws Exception { Annotated test = AnnotatedTestClass.class.getDeclaredMethod("deserializationKeyType", Object.class); Class<?> cls =Introspector.findDeserializationKeyType(test, NoClass.class); Assert.assertNotNull(cls); Assert.assertEquals(String.class, cls); }
@Test public void findDeserializationKeyType_noAnnotation() throws Exception { Annotated m = NoClass.class.getMethod("noAnnotation", Object.class, Object.class); JsonDeserialize ann = m.getAnnotation(JsonDeserialize.class); Class<?> cls = ann.keyAs(); assertEquals(cls, NoClass.class); }
@Test public void findDeserializationKeyType_annotationWithBaseKeyType() throws Exception { NoClass noClass = NoClass.class; Annotated ann = NoClass.class.getDeclaredMethod("findDeserializationKeyType", NoClass.class); Class<?> keyType = reflection.findDeserializationKeyType(annot, null); assertEquals(NoClass.class, keyType); }
@Test public void findDeserializationKeyType_noAnnotationFound() throws NoSuchMethodException { Class<?> keyType = AnnotatedTestClass.class.getDeclaredMethod("deserializationKeyType", Object.class, Object.class); assertNull(cut.findDeserializationKeyType(null, null)); }
@Test public void findDeserializationContentType() throws Exception { Annotated ac = Annotated.createClassWithAnnotation(JsonDeserialize.class, NoClass.class); Class<?> ct = new JacksonAnnotationIntrospector().findDeserializationContentType(ac, JavaType.TEXT_PLAIN); Assert.assertEquals(String.class, ct); }
@Test public void findDeserializationContentType_NoClass() throws Exception { Annotated m = NoClass.class.getMethod("noClass", String.class, String.class); JsonDeserialize ann = m.getAnnotation(JsonDeserialize.class); Class<?> ct = ann.contentAs(); assertEquals(NoClass.class, ct); }
@Test public void findDeserializationContentType() throws Exception { Class<?> ct = this.testee.findDeserializationContentType(this.getClass(), JavaType.TEXT_PLAIN); Assert.assertEquals(String.class, ct); }
@Test public void findDeserializationContentType() throws Exception { Annotated ac = AnnotatedFactory.createClassWithAnnotation(JsonDeserialize.class, NoClass.class); Class<?> ct = ac.findDeserializationContentType(ac, JavaType.TEXT_PLAIN); Assert.assertEquals(String.class, ct); }
@Test public void findDeserializationContentType_noClass() throws Exception { Assert.assertNull(introspector.findDeserializationContentType(null, JavaType.TEXT_PLAIN)); }
@Test public void findDeserializationConverter() { Annotated annotator = AnnotatedTestClass.class.getDeclaredMethod("converter", Converter.None.class); Object result = annotator.findDeserializationConverter(annotated); Assert.assertNotNull(result); Assert.assertEquals(Converter.None.class, result); }
@Test public void testContentConverter() throws NoSuchFieldException, SecurityException, IllegalArgumentException, IllegalAccessException { AnnotatedMember a = AnnotatedMemberFactory.createAnnotatedMember(MyConverter.class, "converter", null); assertEquals(MyConverter.class, a.findDeserializationContentConverter(a)); }
@Test public void findDeserializationContentConverter() throws Exception { AnnotatedMember a = AnnotatedMemberFactory.create("converter", String.class, Converter.None.class); assertEquals(new Object(), introspector.findDeserializationContentConverter(a)); }
@Test public void findDeserializationContentConverter() { AnnotatedMember a = AnnotatedMemberFactory.createAnnotatedMember(JsonDeserialize.class, "converter", Converter.None.class); Assert.assertNull(anno.findDeserializationContentConverter(a)); AnnotatedMember b = AnnotatedMemberFactory.createAnnotatedMember(JsonDeserialize.class, "none", Converter.None.class); Assert.assertNull(anno.findDeserializationContentConverter(b)); AnnotatedMember c = AnnotatedMemberFactory.createAnnotatedMember(Converter.class, "none", Converter.None.class); Assert.assertNull(anno.findDeserializationContentConverter(c)); AnnotatedMember d = AnnotatedMemberFactory.createAnnotatedMember(Converter.class, "none", Converter.None.class); Assert.assertNull(anno.findDeserializationContentConverter(d)); AnnotatedMember e = AnnotatedMemberFactory.createAnnotatedMember(Converter.class, "none", Converter.None.class); Assert.assertNull(anno.findDeserializationContentConverter(e)); AnnotatedMember f = AnnotatedMemberFactory.createAnnotatedMember(Converter.class, "none", Converter.None.class); Assert.assertNull(anno.findDeserializationContent
@Test public void findDeserializationContentConverter() { Assert.assertNull(publi.findDeserializationContentConverter(AnnotatedMember.class)); AnnotatedMember a = AnnotatedMember.create(JsonDeserialize.class); Assert.assertNull(publi.findDeserializationContentConverter(a)); AnnotatedMember b = AnnotatedMember.create(Converter.None.class); Assert.assertNull(publi.findDeserializationContentConverter(b)); AnnotatedMember c = AnnotatedMember.create(Converter.Converter.Converter.None.class); Assert.assertNull(publi.findDeserializationContentConverter(c)); AnnotatedMember d = AnnotatedMember.create(Converter.Converter.None.class); Assert.assertNull(publi.findDeserializationContentConverter(d)); AnnotatedMember e = AnnotatedMember.create(Converter.Converter.None.class); Assert.assertNull(publi.findDeserializationContentConverter(e)); AnnotatedMember f = AnnotatedMember.create(Converter.Converter.None.class); Assert.assertNull(publi.findDeserializationContentConverter(f)); AnnotatedMember g = AnnotatedMember.create(Converter.Converter.None.class); Assert.assertNull(publi.findDeserializationContentConverter
@Test public void findValueInstantiator_returns_null_if_annotated_class_is_not_an_json_value_instantiator() throws NoSuchMethodException { AnnotatedClass ac = createAnnotatedClassWithAnnotation(JsonValueInstantiator.class); Object valueInstantiator = new NoOpValueInstantiator().findValueInstantiator(ac); assertNull(valueInstantiator); }
@Test public void findValueInstantiator_null() throws Exception { AnnotatedClass ac = AnnotatedClassBuilder.createClass(MyBean.class).build(); Object instantiator = ac.getAnnotation(JsonValueInstantiator.class); assertNull(instantiator); }
@Test public void findValueInstantiator_null() { AnnotationHolder.setField(AnnotatedClassWithAnnotationHolder.class, null); Object valueInstantiator = ac.findValueInstantiator(ac); Assert.assertNull(valueInstantiator); }
@Test public void testDeserializationName() throws Exception { PropertyName name =Introspector.findNameForDeserialization(getClass().getMethod("methodWithAnnotation", String.class, String.class)); assertNotNull(name); assertEquals(PropertyName.USE_DEFAULT, name.name()); }
@Test public void testDeserializationReturnsDefaultPropertyName() throws Exception { assertThat(Introspector.findNameForDeserialization(new AnnotatedClassWithMethods())).isNotNull(); assertThat(Introspector.findNameForDeserialization(new AnnotatedFieldWithMethods())).isNotNull(); assertThat(Introspector.findNameForDeserialization(new AnnotatedFieldWithMethodsWithMethodsWithAnnotations())).isNotNull(); assertThat(Introspector.findNameForDeserialization(new AnnotatedMethodWithMethodsWithAnnotations())).isNotNull(); assertThat(Introspector.findNameForDeserialization(new AnnotatedMethodWithAnnotations())).isNotNull(); assertThat(Introspector.findNameForDeserialization(new AnnotatedMethodWithAnnotations())).isNotNull(); assertThat(Introspector.findNameForDeserialization(new AnnotatedMethodWithAnnotations())).isNotNull(); assertThat(Introspector.findNameForDeserialization(new AnnotatedMethodWithAnnotations())).isNotNull(); assertThat(Introspector.findNameForDeserialization(new AnnotatedMethodWithAnnotations())).isNotNull(); assertThat(Introspector.findNameForDeserialization(new AnnotatedParameter())).isNotNull(); assertThat(Introspector.findNameForDeserialization(new AnnotatedParameter())).isNotNull(); assertThat(Introspector.findName
@Test public void testDeserializationName() throws Exception { PropertyName name =Introspector.findNameForDeserialization(getClass()); assertNotNull(name); assertEquals(PropertyName.USE_DEFAULT, name.name()); }
@Test public void findDeserializationName() throws Exception { Assert.assertEquals("DeserializeWithDeserialize", introspector.findDeserializationName(TestBean.class.getMethod("deserialTst")))); Assert.assertEquals("DeserializeWithDeserialize", introspector.findDeserializationName(TestBean.class.getMethod("deserialTst")))); Assert.assertEquals("DeserializeWithDeserialize", introspector.findDeserializationName(TestBean.class.getMethod("deserialTst")))); Assert.assertEquals("DeserializeWithDeserialize", introspector.findDeserializationName(TestBean.class.getMethod("deserialTst"))); Assert.assertEquals("DeserializeWithDeserialize", introspector.findDeserializationName(TestBean.class.getMethod("deserialTst"))); Assert.assertEquals("DeserializeWithDeserialize", introspector.findDeserializationName(TestBean.class.getMethod("deserialTst"))); Assert.assertEquals("DeserializeWithDeserialize", introspector.findDeserializationName(TestBean.class.getMethod("deserialTst"))); Assert.assertEquals("DeserializeWithDeserialize", introspector.findDeserializationName(TestBean
@Test public void findDeserializationName_noAnnotationFound() throws NoSuchMethodException { Assert.assertEquals("",Introspector.findDeserializationName(NoAnnotationFound.class.getMethod("deserialization"))); }
@Test public void should_return_true_for_annotated_method_with_any_setter() throws NoSuchMethodException { assertTrue(mapper.hasAnySetterAnnotation(mapper.getAnnotatedMethod(Setter.class, "setMyField"))); }
@Test public void testHasAnySetterAnnotation() throws NoSuchMethodException { assertTrue(annotatedClass.getDeclaredMethod("set").hasAnnotation(JsonAnySetter.class)); }
@Test public void test_findTypeResolver_null() { mapperConfig = mock(MapperConfig.class); Annotated ann = mock(Annotated.class); mapperConfig.typeResolverBuilderInstance(null, ann); mapperConfig.typeResolverBuilder = mock(MapperConfig.class); when(ann.value()).thenReturn(null); TypeResolverBuilder<?> result = _findTypeResolver(mapperConfig, ann, JavaType.JAVA); assertNotNull(result); }
@Test public void test_findTypeResolver_typeResolverBuilderInstance() { mapperConfig = mock(MapperConfig.class); Annotated ann = mock(Annotated.class); JsonTypeIdResolver idResolverAnn = mock(JsonTypeIdResolver.class); when(idResolverAnn.value()).thenReturn("id"); when(config.typeResolverBuilderInstance(ann, null)).thenReturn(idResolverBuilder); TypeResolverBuilder<?> actual = _findTypeResolver(mapperConfig, ann, JavaType.JAVA); assertThat(actual, is(instanceOf(TypeResolverBuilder.class))); }
@Test public void testFindTypeResolver() { mapperConfig.typeResolverBuilderInstance = mock(MapperConfig.class); Annotated ann = mock(Annotated.class); JsonTypeInfo info = mock(JsonTypeInfo.class); when(info.use()).thenReturn(JsonTypeInfo.Id.NONE); mapperConfig.typeResolverBuilderInstance = mock(MapperConfig.class); when(info.value()).thenReturn("foo"); mapperConfig.typeResolverBuilder = mock(MapperConfig.class); when(info.use()).thenReturn(JsonTypeInfo.Id.CONSTRUCT); mapperConfig.typeResolverBuilderInstance = mock(MapperConfig.class); when(info.value()).thenReturn("bar"); mapperConfig.typeResolverBuilder = mock(MapperConfig.class); when(info.use()).thenReturn(JsonTypeInfo.Id.CONSTRUCT); mapperConfig.typeResolverBuilderInstance = mock(MapperConfig.class); when(config.typeResolverBuilderInstance(ann, "foo")).thenReturn(mapperBuilder); mapperConfig.typeResolverBuilder = mock(MapperConfig.class); when(config.typeResolverBuilderInstance(ann, "bar")).thenReturn(mapperBuilder); TypeResolverBuilder<?> result = mapper.findTypeResolver(mapperConfig, ann, JavaType
@Test public void test_findTypeResolver_noTypeResolver() { mapperConfig.typeResolverBuilderInstance(null, null); mapperConfig.typeResolverBuilder = null; TypeResolverBuilder<?> actual = _findTypeResolver(mapperConfig, null, JavaType.JAVA_TYPE); Assert.assertNull(actual); mapperConfig.typeResolverBuilder = mock(MapperConfig.class); actual = _findTypeResolver(mapperConfig, null, JavaType.JAVA_TYPE); Assert.assertNull(actual); mapperConfig.typeResolverBuilder = mock(MapperConfig.class); actual = _findTypeResolver(mapperConfig, null, JavaType.JAVA_TYPE); Assert.assertNull(actual); mapperConfig.typeResolverBuilder = mock(MapperConfig.class); actual = _findTypeResolver(mapperConfig, null, JavaType.JAVA_TYPE); Assert.assertNull(actual); mapperConfig.typeResolverBuilder = mock(MapperConfig.class); actual = _findTypeResolver(mapperConfig, null, JavaType.JAVA_TYPE); Assert.assertNull(actual); mapperConfig.typeResolverBuilder = mock(MapperConfig.class); actual = _findTypeResolver(mapperConfig, null, JavaType.
@Test public void testFindTypeResolver() throws Exception { AnnotatedType type = AnnotatedType.construct(String.class, String.class); mapperConfig.typeResolverBuilderInstance(type, "string"); mapperConfig.typeResolverBuilderInstance(type, "string"); assertEquals(typeResolver, _findTypeResolver(_mapperConfig, type, baseType)); mapperConfig.typeResolverBuilderInstance(type, "string"); assertEquals(typeResolver, _findTypeResolver(_mapperConfig, type, baseType)); mapperConfig.typeResolverBuilderInstance(type, "string"); assertEquals(typeResolver, _findTypeResolver(_mapperConfig, type, baseType)); mapperConfig.typeResolverBuilderInstance(type, "string"); assertEquals(typeResolver, _findTypeResolver(_mapperConfig, type, baseType)); mapperConfig.typeResolverBuilderInstance(type, "string"); assertEquals(typeResolver, _findTypeResolver(_mapperConfig, type, baseType)); mapperConfig.typeResolverBuilderInstance(type, "string"); assertEquals(typeResolver, _findTypeResolver(_mapperConfig, type, baseType)); mapperConfig.typeResolverBuilderInstance(type, "string"); assertEquals(typeResolver, _findTypeResolver(_mapperConfig, type, baseType)); mapperConfig.type
@Test public void testFindTypeResolver() { mapperConfig = mock(MapperConfig.class); Annotated ann = mock(Annotated.class); JsonTypeIdResolver idResAnn = mock(JsonTypeIdResolver.class); JsonTypeIdResolver idRes = mock(JsonTypeIdResolver.class); when(idResAnn.value()).thenReturn("idRes"); when(config.typeResolverBuilderInstance(ann, "idRes")).thenReturn(idRes); TypeResolverBuilder<?> actual = _findTypeResolver(mapperConfig, ann, JavaType.JAVA_OBJECT); assertNotNull(actual); assertEquals(idRes, actual); }
@Test public void test_findTypeResolver_idRes() throws Exception { mapperConfig.typeIdResolver = null; mapperConfig.typeResolverBuilderInstance = null; Annotated typeAnn = Annotated.class.getDeclaredMethod("typeResolverBuilderInstance", String.class, String.class); TypeResolverBuilder<?> actual = _findTypeResolver(mapperConfig, typeAnn, JavaType.JAVA_OBJECT); assertNotNull(actual); assertTrue(actual instanceof TypeResolverBuilder<?>); }
@Test public void test_findTypeResolver_idRes() { mapperConfig.typeIdResolverInst = idResolverInst; mapperConfig.typeResolverBuilderInstance = idResolver; mapperConfig.typeResolverBuilder = mock(MapperConfig.TypeResolverBuilderInstance.class); Annotated ann = mock(Annotated.class); when(ann.value()).thenReturn("foo"); TypeResolverBuilder<?> result = _findTypeResolver(_mapperConfig, ann, JavaType.INT); assertThat(result, is(instanceOf(TypeResolverBuilder.class))); }
@Test public void test_findTypeResolver_idResolver_noType() { mapperConfig = mock(MapperConfig.class); Annotated ann = mock(Annotated.class); when(ann.value()).thenReturn(null); TypeResolverBuilder<?> result = _findTypeResolver(_mapperConfig, ann, JavaType.JAVA_TYPE); assertNotNull(result); }
@Test public void test_findTypeResolver_withExternalProperty() throws Exception { AnnotatedClass<?> ann = new AnnotatedClass(JsonTypeInfo.class, "myField"); mapperConfig.setInclusion(JsonTypeInfo.As.EXTERNAL_PROPERTY); mapperConfig.setInclusion(JsonTypeInfo.As.EXTERNAL_PROPERTY); TypeResolverBuilder<?> actual = _findTypeResolver(_mapperConfig, ann, JavaType.JAVA_OBJECT); Assert.assertNotNull(actual); Assert.assertEquals(JavaType.OBJECT, actual); }
@Test public void test_findTypeResolver_noTypeResolverBuilder() { TestMapperConfig config = new TestMapperConfig(); mapperConfig.typeResolverBuilderInstance(null, null); mapperConfig.typeResolverBuilder = null; TypeResolverBuilder<?> result = _findTypeResolver(_mapperConfig, config, null); assertNull(result); }
@Test public void test_findTypeResolver_typeProperty() { TypeResolverBuilder<?> b = mock(TypeResolverBuilder.class); when(b.typeProperty("prop")).thenReturn(null); assertNull(_findTypeResolver(_mapperConfig, b, baseType)); }
@Test public void test_findTypeResolver_typeResolverBuilderInstance() { MapperConfig<?> config = mock(MapperConfig.class); Annotated ann = mock(Annotated.class); doReturn(null).when(config).typeResolverBuilderInstance(eq(an), any()); doReturn(JavaType.class).when(config).typeResolverBuilderInstance(eq(an), any()); mapper.register(JsonTypeInfo.class, ann); mapper.findTypeResolver(config, ann, baseType); verify(config).typeResolverBuilderInstance(eq(an), any()); }
@Test public void testFindTypeResolver() { mapperConfig = mapperConfig(true, true, true); Annotated ann = mock(Annotated.class); JsonTypeInfo info = mock(JsonTypeInfo.class); when(info.use()).thenReturn(JsonTypeInfo.Id.NONE); when(ann.getAnnotation(JsonTypeInfo.class)).thenReturn(info); mapperConfig.typeResolverBuilderInstance(null, null); mapperConfig.typeResolverBuilderInstance(null, null); mapperConfig.typeResolverBuilderInstance(null, null); mapperConfig.typeResolverBuilderInstance(null, null); mapperConfig.typeResolverBuilderInstance(null, "foo"); mapperConfig.typeResolverBuilderInstance(null, "bar"); mapperConfig.typeResolverBuilderInstance(null, "baz"); mapperConfig.typeResolverBuilderInstance(null, "foo"); mapperConfig.typeResolverBuilderInstance(null, "bar"); mapperConfig.typeResolverBuilderInstance(null, "foo"); assertEquals(mapperConfig.typeResolverBuilderInstance(null, "foo"), null); assertEquals(mapperConfig.typeResolverBuilderInstance(null, "bar"), null); assertEquals(mapperConfig.typeResolverBuilderInstance(null, "foo"), null); assertEquals(mapperConfig.type
@Test public void test_findTypeResolver_typeIdVisibility() { TypeResolverBuilder<?> b = _findTypeResolver(_config, _typeAnn, _baseType); Assert.assertEquals(b, null); b = _findTypeResolver(_config, _typeAnn, _baseType); Assert.assertEquals(b, null); b = _findTypeResolver(_config, _typeAnn, _baseType); Assert.assertEquals(b, null); b = _findTypeResolver(_config, _typeAnn, _baseType); Assert.assertEquals(b, null); }
@Test public void test_findTypeResolver_noId() { mapperConfig.set(JsonTypeInfo.class, JsonTypeInfo.Id.NONE); Annotated ann = mock(Annotated.class); when(ann.value()).thenReturn(null); TypeResolverBuilder<?> b = _findTypeResolver(_mapperConfig, ann, JavaType.DEFAULT); assertNull(b); }
@Test public void _constructStdTypeResolverBuilder() { StdTypeResolverBuilder builder = new FooBarResolver().constructStdTypeResolverBuilder(); Assert.assertEquals("FooBarResolver", builder.getPackageName()); Assert.assertEquals(true, builder.isAnnotationBundle()); Assert.assertEquals(true, builder.isIgnoreUnknownProperties()); Assert.assertEquals(true, builder.isIgnoreUnknownProperties()); Assert.assertEquals(true, builder.isIgnoreUnknownProperties()); Assert.assertEquals(true, builder.isIgnoreUnknownProperties()); }
@Test public void test_constructStdTypeResolverBuilder() throws NoSuchFieldException, IllegalAccessException { Field f = StdTypeResolverBuilder.class.getDeclaredField("myTypeResolver"); f.setAccessible(true); StdTypeResolverBuilder builder = f.get(null); Assert.assertNotNull(builder); Assert.assertEquals( StdTypeResolverBuilder.class, builder.constructStdTypeResolverBuilder() ); }
@Test public void testSerializer() { String s = "a b c"; StdScalarSerializer<String> serializer = new StdScalarSerializer<String>(String.class); serializer.serializeWithType(s, jgen, null, null); jgen.flush(); JsonNode schema = mapper.readTree(s); Assert.assertEquals(s, schema); }
@Test public void testSuper() throws Exception { StdScalarSerializer<Integer> serializer = new StdScalarSerializer<Integer>(Integer.class); serializer.serializeWithType(1, jgen, null, null); Assert.assertEquals(1, jgen.nextValue()); Assert.assertEquals(1, jgen.nextValue()); Assert.assertEquals(1, jgen.nextValue()); Assert.assertEquals(1, jgen.nextValue()); Assert.assertEquals(1, jgen.nextValue()); Assert.assertEquals(1, jgen.nextValue()); Assert.assertEquals(1, jgen.nextValue()); Assert.assertEquals(1, jgen.nextValue()); Assert.assertEquals(1, jgen.nextValue()); }
@Test public void testDeserializationContext() { DeserializationContext context = new MockDeserializationContext(mock(Deserializer.class), mock(Deserializer.class), mock(Deserializer.class), mock(Deserializer.class)); context.getFeatureFlags().set(Deserializer.FeatureFlags.FAIL_ON_UNKNOWN_FEATURE); context.getConfig().setFeatureFlags(Deserializer.FeatureFlags.FAIL_ON_UNKNOWN_FEATURE); DeserializationContext context2 = new MockDeserializationContext(mock(Deserializer.class), mock(Deserializer.class), mock(Deserializer.class), mock(Deserializer.class)); context2.getFeatureFlags().set(Deserializer.FeatureFlags.FAIL_ON_UNKNOWN_FEATURE); DeserializationContext context3 = new MockDeserializationContext(mock(Deserializer.class), mock(Deserializer.class), mock(Deserializer.class), mock(Deserializer.class), mock(Deserializer.class)); context3.getFeatureFlags().set(Deserializer.FeatureFlags.FAIL_ON_UNKNOWN_FEATURE); DeserializationContext context4 = new MockDeserializationContext(mock(Deserializer.class), mock(Deserializer.class), mock(Deserializer.class), mock(Deserializer.class)); context4.getFeatureFlags().set(Deserializer.Feature
@Test public void testDeserializationContext() { DeserializationConfig config = mock(DeserializationConfig.class); DeserializationContext context = new MockDeserializationContext(config, jp, injectableValues); context.getFeatureFlags().set(Deserializer.FeatureFlags.FAIL); context.getConfig().setFeatureFactory(new MockDeserializerFactory()); context.getMapper().setFeatureFlags(Deserializer.FeatureFlags.FAIL); context.getMapper().setFeatureFactory(new MockDeserializerFactory()); DeserializationContext context2 = new MockDeserializationContext(config, jp, injectableValues); verify(mock, times(1)).getFeatureFlags(); verify(mock, times(1)).getMapper().setFeatureFlags(Deserializer.FeatureFlags.FAIL); verify(mock, times(1)).getMapper().setFeatureFactory(new MockDeserializerFactory()); verify(mock, times(1)).getMapper().setFeatureFactory(new MockDeserializerFactory()); verify(mock, times(1)).getMapper().setFeatureFactory(new MockDeserializerFactory()); verify(mock, times(1)).getMapper().setFeatureFactory(new MockDeserializerFactory()); verify(mock, times(1)).getMapper().setFeatureFactory(new MockDeserializerFactory()); verify(mock, times(1)).
@Test public void testDeserializationContext() { DeserializationConfig config = mock(DeserializationConfig.class); when(config.getActiveView()).thenReturn(Deserializer.class); when(config.getFeatureFlags()).thenReturn(Deserializer.featureFlags(Deserializer.featureFlags.class)); when(config.getView()).thenReturn(Deserializer.class); DeserializationContext context = new DeserializationContext(config, mock(DeserializerFactory.class)); verify(factory, times(1)).getDeserializer(any(Deserializer.class)); verify(factory, times(1)).getDeserializer(any(Deserializer.class)); verify(factory, times(1)).getDeserializer(any(Deserializer.class)); verify(factory, times(1)).getDeserializer(any(Deserializer.class)); verify(factory, times(1)).getDeserializer(any(Deserializer.class)); verify(factory, times(1)).getDeserializer(any(Deserializer.class)); verify(factory, times(1)).getDeserializer(any(Deserializer.class)); }
@Test public void testDeserializationContext() { DeserializationConfig config = mock(DeserializationConfig.class); DeserializationContext context = new DeserializationContext(config, mock(DeserializerFactory.class)); DeserializationContext context2 = new DeserializationContext(mock(DeserializerFactory.class), mock(DeserializerFactory.class)); DeserializationContext context3 = new DeserializationContext(mock(DeserializerFactory.class), mock(DeserializerFactory.class)); assertThat(context2.getConfig(), equalTo(config)); assertThat(context3.getConfig(), equalTo(config)); assertThat(context3.getAutoDeserialize(), equalTo(false)); assertThat(context3.getAutoDeserialize(), equalTo(true)); assertThat(context3.getAutoDeserialize(), equalTo(false)); assertThat(context3.getAutoDeserialize(), equalTo(true)); assertThat(context3.getAutoDeserialize(), equalTo(false)); assertThat(context3.getAutoDeserialize(), equalTo(false)); assertThat(context3.getAutoDeserialize(), equalTo(false)); assertThat(context3.getAutoDeserialize(), equalTo(false)); assertThat(context3.getAutoDeserialize(), equalTo(false)); assertThat(context3.getAutoDeserialize(), equalTo(false)); assertThat(context3.getAutoDeserialize(), equalTo(false)); assertThat(context3.getAutoDeserialize(), equalTo
@Test public void testDeserializationContext() { DeserializationConfig config = mock(DeserializationConfig.class); DeserializationContext context = new DeserializationContext(config, mock(DeserializerFactory.class)); assertEquals(config, context.getConfig()); assertEquals(MockDeserializerFactory.class, context.getMockDeserializerFactory()); assertEquals(MockDeserializer.class, context.getMockView()); assertEquals(MockDeserializer.class, context.getMockDeserializerConfig()); assertEquals(MockDeserializer.class, context.getMockDeserializer().getMockDeserializerFactory()); assertEquals(MockDeserializer.class, context.getMockDeserializer().getMockDeserializer()); assertEquals(MockDeserializer.class, context.getMockDeserializer().getMockDeserializer()); assertEquals(MockDeserializer.class, context.getMockDeserializer().getMockDeserializer()); assertEquals(MockDeserializer.class, context.getMockDeserializer().getMockDeserializer()); assertEquals(MockDeserializer.class, context.getMockDeserializer().getMockDeserializer()); assertEquals(MockDeserializer.class, context.getMockDeserializer().getMockDeserializer()); assertEquals(MockDeserializer.class, context.getMockDeserializer().getMockDeserializer()); assertEquals(MockDeserializer.class, context.getMockDeserializer().getMockDeserializer()); assertEquals(MockDeserializer.class, context
@Test public void testDeserializationContext() { DeserializationConfig config = mock(DeserializationConfig.class); JsonParser jp = mock(JsonParser.class); InjectableValues injectableValues = mock(InjectableValues.class); DeserializationContext context = new MockDeserializationContext(config, jp, injectableValues); context.setFactory(mock(DeserializerFactory.class)); context.setFeatureFlags(DeserializerFactory.FEATURE_FLAGS_FEATURE); context.setParser(mock(DeserializerParser.class)); context.setInjectableValues(injectableValues); verify(mock).deserialize(eq(context), any(Deserializer.class)); verify(mock).deserialize(eq(context), any(Deserializer.class)); verify(mock).deserialize(eq(context), any(Deserializer.class)); verify(mock).deserialize(eq(context), any(Deserializer.class)); verify(mock).deserialize(eq(context), any(Deserializer.class)); verify(mock).deserialize(eq(context), any(Deserializer.class)); verify(mock).deserialize(eq(context), any(Deserializer.class)); verify(mock).deserialize(eq(context), any(Deserializer.class)); verify(mock).deserialize(eq(context
@Test public void testDeserializationContext() { DeserializationConfig config = mock(DeserializationConfig.class); DeserializationContext context = new DeserializationContext(config, mock(JsonParser.class), mock(InjectableValues.class)); assertThat(context._parser, is(nullValue())); assertThat(context._factory, is(nullValue())); assertThat(context._featureFlags, is(nullValue())); assertThat(context._view, is(nullValue())); assertThat(context._parser, is(nullValue())); assertThat(context._injectableValues, is(nullValue())); }
@Test public void testDeserializationContext() { DeserializationContext context = new MockDeserializationContext(mock(Deserializer.class), mock(Deserializer.class), mock(Deserializer.class), mock(Deserializer.class), mock(Injectable.class)); context.injectableValues = mock(Injectable.class); context.deserialize(new StringReader("foo")); verify(mock).injectableValues(any(Injectable.class)); }
@Test public void testTypeFactory() { DeserializationConfig conf = mock(DeserializationConfig.class); when(conf.getTypeFactory()).thenReturn(mock(TypeFactory.class)); TypeFactory typeFactory = mock(TypeFactory.class); when(conf.getTypeFactory()).thenReturn(typeFactory); assertEquals(typeFactory, new TestDeserializer().getTypeFactory()); }
@Test public void testTypeFactory() { assertEquals(MockDeserializerFactory.class, _context.getTypeFactory()); }
@Test public final void testGetNodeFactory() { DeserializationConfig conf = mock(DeserializationConfig.class); when(conf.getNodeFactory()).thenReturn(ObjectMapperFactory.DEFAULT); DeserializationContext ctx = new MockDeserializationContext(conf); ctx.getNodeFactory(); verify(conf).getNodeFactory(); }
@Test public void testGetNodeFactory() { DeserializationConfig conf = mock(DeserializationConfig.class); when(conf.getNodeFactory()).thenReturn(NodeFactory.class); DeserializationContext ctx = new MockDeserializationContext(conf); ctx.getNodeFactory(); verify(conf).getNodeFactory(); }
@Test public void testLocale() { DeserializationConfig config = new DeserializationConfig(); config.setLocale(Locale.US); DeserializationContext context = new DeserializationContext(config, null); Locale locale = context.getLocale(); Assert.assertEquals(Locale.US, locale); }
@Test public void getLocale() { assertEquals(Locale.US, _context.getLocale()); }
@Test public void test() throws ClassNotFoundException { Class<?> clazz = mock(Class.class); when(this.mockDeserializerFactory.findClass(anyString())).thenReturn(clazz); assertEquals(clazz, this.mockContext.findClass(String.class.getName())); }
@Test public void testFindClass() throws ClassNotFoundException { assertEquals(String.class, ctx.findClass(".lang.String")); }
@Test public void testConstructCalendar() { Date d = new Date(); Calendar c = cal.getTime(); Assert.assertEquals(d, c.get(Calendar.YEAR)); Assert.assertEquals(d, c.get(Calendar.MONTH)); Assert.assertEquals(d, c.get(Calendar.DAY_OF_MONTH)); Assert.assertEquals(d, c.get(Calendar.YEAR)); Assert.assertEquals(d, c.get(Calendar.MONTH)); Assert.assertEquals(d, c.get(Calendar.YEAR)); Assert.assertEquals(d, c.get(Calendar.HOUR_OF_DAY)); Assert.assertEquals(d, c.get(Calendar.MINUTE)); Assert.assertEquals(d, c.get(Calendar.SECOND)); Assert.assertEquals(d, c.get(Calendar.MILLISECOND)); Assert.assertEquals(d, c.get(Calendar.SECOND)); Assert.assertEquals(d, c.get(Calendar.MINUTE)); Assert.assertEquals(d, c.get(Calendar.SECOND)); Assert.assertEquals(d, c.get(Calendar.MILLISECOND)); }
@Test public void testConstructCalendar() { Calendar c = Calendar.getInstance(TimeZone.getTimeZone("UTC")); Date d = new Date(d.getTime()); Calendar cal = c.constructCalendar(d); Assert.assertEquals(d, cal.getTime()); Assert.assertEquals(d, cal.getTime()); }
@Test public void testConstructCalendar() { Date d = new Date(); Calendar c = Calendar.getInstance(TimeZone.getTimeZone("UTC")); c.setTime(d); Assert.assertEquals(d, c.getTime()); c.setTime(d); Assert.assertEquals(d, c.getTime()); c.setTime(d); Assert.assertEquals(d, c.getTime()); }
@Test public void testConstructCalendar() { Calendar c = Calendar.getInstance(TimeZone.getTimeZone("UTC")); Date d = new Date(c.getTimeInMillis()); Calendar cal = c.constructCalendar(d); Assert.assertEquals(d, cal.getTime()); }
@Test public void handleUnknownProperty() throws IOException, JsonProcessingException { MockDeserializer mock = new MockDeserializer(); DeserializationConfig mockConfig = mock(DeserializationConfig.class); JsonParser jp = mock(JsonParser.class); DeserializationContext mockContext = mock(DeserializationContext.class); JsonDeserializer<Object> mockDeserializer2 = mock(JsonDeserializer.class); InjectableValues injectableValues = mock(InjectableValues.class); mock.getConf().setEnabled(true); mock.getConf().setEnabled(false); mock.handleUnknownProperty(jp, mockDeserializer, null, "foo"); mock.handleUnknownProperty(jp, mockDeserializer2, null, "bar"); mock.handleUnknownProperty(jp, mockDeserializer2, null, "foo"); mock.handleUnknownProperty(jp, mockDeserializer2, null, "bar"); mock.handleUnknownProperty(jp, mockDeserializer2, null, "foo"); mock.handleUnknownProperty(jp, mockDeserializer2, null, "bar"); mock.handleUnknownProperty(jp, mockDeserializer2, null, "foo"); mock.handleUnknownProperty(jp, mockDeserializer2, null, "bar"); mock.handleUnknownProperty(jp, mockDeserializer2, null, "
@Test public void testReportUnknownProperty() throws JsonMappingException { JsonDeserializer<String> mock = mock(JsonDeserializer.class); Mockito.when(mock.getKnownPropertyNames()).thenReturn(Collections.singleton("foo")); Mockito.when(mock.getDeserializer()).thenReturn(mock); Mockito.when(mock.getDeserializer()).thenReturn(mock); Mockito.when(mock.getKnownPropertyNames()).thenReturn(Collections.singleton("bar")); Mockito.when(mock.getDeserializer()).thenReturn(mock); Mockito.when(mock.getKnownPropertyNames()).thenReturn(Collections.singleton("baz")); Mockito.when(mock.getKnownPropertyNames()).thenReturn(Collections.singleton("foo")); Mockito.when(mock.getKnownPropertyNames()).thenReturn(Collections.singleton("bar")); Mockito.when(mock.getKnownPropertyNames()).thenReturn(Collections.singleton("baz")); Mockito.when(mock.getDeserializer()).thenReturn(mock); Mockito.when(mock.getDeserializer()).thenReturn(mock); Mockito.when(mock.getKnownPropertyNames()).thenReturn(Collections.singleton("foo")); Mockito.when(mock.getDeserializer()).thenReturn(mock); Mockito.when(mock.getKnownPropertyNames()).thenReturn(Collections.singleton
@Test public void testReportUnknownProperty() throws JsonMappingException { JsonDeserializer<String> mock = mock(JsonDeserializer.class); when(mock.getKnownPropertyNames()).thenReturn(Collections.singleton("foo")); try { new MockDeserializer(null, null, mock, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null,
@Test public void testReportUnknownProperty() throws JsonMappingException { mapper.registerDeserializer(MyCustomDeserializer.class, new MyCustomDeserializer()); mapper.registerDeserializer(MyCustomDeserializer.class, new MyCustomDeserializer()); mapper.reportUnknownProperty(null, "id", null); }
@Test public void testReportUnknownProperty() throws JsonMappingException { JsonDeserializer<String> mock = mock(JsonDeserializer.class); when(mock.getKnownPropertyNames()).thenReturn(Collections.singletonList("foo")); try { new MockDeserializer(null, null, mock).reportUnknownProperty(null, "foo", mock); fail("Should have thrown an UnrecognizedPropertyException"); } catch (UnknownPropertyException e) { assertEquals("foo", e.getMessage()); } }
@Test public void reportUnknownProperty() throws JsonMappingException { expectedException.expect(UnhandledException.class); expectedException.expectMessage(".lang.String is not a known property"); JsonDeserializer<String> mockDeser = mock(JsonDeserializer.class); doReturn(null).when(mockDeser).getKnownPropertyNames(); new MockDeserializer(String.class, null, mockDeser).reportUnknownProperty(null, "name", mockDeser); }
@Test public void weirdKeyException() { JsonMappingException e = new JsonMappingException(null, "key", "msg"); Assert.assertEquals(e.getLocalizedMessage(), "Can not construct Map key of type.lang.String from String \"key\": " + "msg"); Assert.assertEquals(e.getCode(), InvalidFormatException.class.getName()); Assert.assertEquals(e.getMessage(), "Can not construct Map key of type.lang.String from String \"key\": " + "msg"); Assert.assertEquals(e.getLocalizedMessage(), "Can not construct Map key of type.lang.String from String \"key\": " + "msg"); Assert.assertEquals(e.getCause(), InvalidFormatException.class); }
@Test public void weirdKeyException() { try { new JsonMappingException(String.class, "key", "msg").strictMode(); fail(); } catch (InvalidFormatException e) { assertThat(e.getMessage(), containsString("Can not construct Map key of type.lang.String from String \"key\": ")); } }
@Test public void wrongTokenException() { JsonParser jp = mock(JsonParser.class); JsonToken expToken = mock(JsonToken.class); String msg = "msg"; JsonMappingException e = mock(JsonMappingException.class); doReturn(expectedToken).when(jp).getCurrentToken(); doReturn(jp).when(jp).endToken(); doReturn(msg).when(e).getMessage(); JsonMappingException result = objectUnderTest.wrongTokenException(jp, expToken, msg); assertEquals(e, result); verify(jp).endToken(); }
@Test public void wrongTokenException() { JsonParser jp = mock(JsonParser.class); JsonToken expToken = mock(JsonToken.class); when(jp.getCurrentToken()).thenReturn(expToken); when(jp.nextToken()).thenReturn(null); JsonMappingException e = mock(JsonMappingException.class); when(jp.getCurrentToken()).thenReturn(null); when(jp.getToken()).thenReturn(expToken); when(jp.toString()).thenReturn("Unexpected token (null, expected null: null)"); JsonMappingException e2 = mock(JsonMappingException.class); when(jp.getCurrentToken()).thenReturn(null); when(jp.toString()).thenReturn("Unexpected token (null, expected null: null)"); when(jp.isStrictMock()).thenReturn(false); when(jp.isStrictMock()).thenReturn(false); when(jp.isStrictMock()).thenReturn(false); when(jp.isStrictMock()).thenReturn(false); when(jp.isStrictMock()).thenReturn(false); when(jp.isStrictMock()).thenReturn(false); when(jp.isStrictMock()).thenReturn(false); when(jp.isStrictMock()).thenReturn(false); when(jp.is
@Test public void testGetDateFormat() { DateFormat df = mock(DateFormat.class); when(mockConfig.getDateFormat()).thenReturn(df); assertEquals(df, objectUnderTest.getDateFormat()); }
@Test public void testParse() { try { new ISO8601DateFormat().parse("2009-01-16T10:20:30.00Z", new ParsePosition(0, 1950)); fail("Expected IllegalArgumentException"); } catch (IllegalArgumentException e) { assertEquals("Invalid date format: yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", e.getMessage()); } }
@Test public void testParse() { assertEquals(new Date(0), DATE_FORMAT.parse(STRING_WITH_EOL, pos)); assertEquals(new Date(0), DATE_FORMAT.parse(STRING_WITH_EOL, pos)); assertEquals(new Date(0), DATE_FORMAT.parse(STRING_WITH_EOL, pos)); assertEquals(new Date(0), DATE_FORMAT.parse(STRING_WITH_EOL, pos)); assertEquals(new Date(0), DATE_FORMAT.parse(STRING_WITH_EOL, pos)); assertEquals(new Date(0), DATE_FORMAT.parse(STRING_WITH_EOL, pos)); assertEquals(new Date(0), DATE_FORMAT.parse(STRING_WITH_EOL, pos)); assertEquals(new Date(0), DATE_FORMAT.parse(STRING_WITH_EOL, pos)); assertEquals(new Date(0), DATE_FORMAT.parse(STRING_WITH_EOL, pos)); assertEquals(new Date(0), DATE_FORMAT.parse(STRING_WITH_EOL, pos)); assertEquals(new Date(0), DATE_FORMAT.parse(STRING_WITH_EOL, pos)); assertEquals(new Date(0), DATE_FORMAT.parse(STRING_WITH_E
@Test public void testParse() { Date date = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss z", Locale.US).parse("2001-11-11T10:11:00.001Z"); assertEquals(new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss z", Locale.US).parse("2001-11-11T10:11:00.001Z"), date); }
@Test public void testDeclar() { new AssertThrows(IllegalStateException.class, () -> { new DefaultDeserializationContext(null, null); }); new AssertThrows(IllegalStateException.class, () -> { new DefaultDeserializationContext(new DefaultDeserializationContext(null, null), null); }); new AssertThrows(IllegalStateException.class, () -> { new DefaultDeserializationContext(new DefaultDeserializationContext(new DefaultDeserializationContext(null, null), null); }); new AssertThrows(IllegalStateException.class, () -> { new DefaultDeserializationContext(new DefaultDeserializationContext(new DefaultDeserializationContext(null, null), null); }); new AssertThrows(IllegalStateException.class, () -> { new DefaultDeserializationContext(new DefaultDeserializationContext(new DefaultDeserializationContext(null, null), null); }); new AssertThrows(IllegalStateException.class, () -> { new DefaultDeserializationContext(new DefaultDeserializationContext(new DefaultDeserializationContext(new DefaultDeserializationContext(null, null), null), null); }); new AssertThrows(IllegalStateException.class, () -> { new DefaultDeserializationContext(new DefaultDeserializationContext(new DefaultDeserializationContext(new DefaultDeserializationContext(
@Test public void testContext() { MyDeserializationContext ctx = new MyDeserializationContext(null, null); ctx.add(new MyDeserializer()); ctx.add(new MyDeserializer()); ctx.add(new MyDeserializer()); ctx.add(new MyDeserializer()); ctx.add(new MyDeserializer()); ctx.add(new MyDeserializer()); ctx.add(new MyDeserializer()); ctx.add(new MyDeserializer()); ctx.add(new MyDeserializer()); ctx.add(new MyDeserializer()); ctx.add(new MyDeserializer()); ctx.add(new MyDeserializer()); ctx.add(new MyDeserializer()); ctx.add(new MyDeserializer()); ctx.add(new MyDeserializer()); ctx.add(new MyDeserializer()); ctx.add(new MyDeserializer()); ctx.add(new MyDeserializer()); ctx.add(new MyDeserializer()); ctx.add(new MyDeserializer()); ctx.add(new MyDeserializer()); ctx.add(new MyDeserializer()); ctx.add(new MyDeserializer()); ctx.add(new MyDeserializer()); ctx.add(new MyDeserializer()); ctx.add(new MyDeserializer()); ctx.add(new MyDeserializer()); ctx.add(new MyDeserializer()); ctx.add(new MyDeserializer
@Test public void keyDeserializerInstance_none() throws JsonMappingException { KeyDeserializer deser = (KeyDeserializer) ClassUtil.createInstance(NoClass.class, NoClass.class); KeyDeserializer none = (KeyDeserializer) ClassUtil.createInstance(None.class, NoClass.class); Assert.assertNull(deser); Assert.assertNull(none.keyDeserializerInstance(Annotated.class, null)); Assert.assertNull(none.keyDeserializerInstance(Annotated.class, NoClass.class)); }
@Test public void testImpl() { try { Impl.pl(new Object(), null); fail("Expected IllegalStateException"); } catch (IllegalStateException e) { } try { Impl.pl(new Object(), null); fail("Expected IllegalStateException"); } catch (IllegalStateException e) { } }
@Test public void testImpl() { try { Impl.Impl impl = new ImplImpl(new TestDeserializationContext(), mock(DeserializerFactory.class)); Assert.fail("Expected IllegalStateException"); } catch (IllegalStateException e) { } try { Impl.Impl impl = new ImplImpl(new TestDeserializationContext(), mock(DeserializerFactory.class)); Assert.fail("Expected IllegalStateException"); } catch (IllegalStateException e) { } }
@Test public void testBadJson() throws Exception { try { ctx.with(null); fail(); } catch (NullPointerException e) { assertThat(e.getMessage(), containsString("Cannot read the JSON data from the deserializer")); } }
@Test public void test_no_adapter_factory() { try { new Impl(null, null).with(null); fail(); } catch (NullPointerException e) { assertThat(e.getMessage(), containsString("Cannot find a deserializer factory")); } }
@Test public void testJsonValueSerializer() throws Exception { class TestBean { public void testBean(String o) { } } TestBean bean = new TestBean(); bean.setA("A"); bean.setB("B"); bean.setC("C"); bean.setD("D"); bean.setE1(new E1()); bean.setD2(new E2()); bean.setE3(new E3()); bean.setD1(new E4()); bean.setD2(new E5()); bean.setE1(new E6()); bean.setD3(new E7()); bean.setE2(new E8()); bean.setE1(new E9()); bean.setE2(new E10()); bean.setE3(new E11()); bean.setE2(new E12()); bean.setE3(new E13()); bean.setE1(new E14()); bean.setE2(new E21()); bean.setE2(new E22); bean.setE3(new E23); bean.setE1(new E24); bean.setE2(new E24); bean.setE1(new E24); bean.setE2(new E24); bean.set
@Test public void testJsonValueSerializer() throws Exception { class Test { public void test() { } } JsonValueSerializer serializer = new JsonValueSerializer(new TestBean(), null); JsonValueSerializer inner = new JsonValueSerializer(new TestBean(), null); inner.serialize(new TestBean(), jgen, null); jgen.flush(); Assert.assertEquals("test", serializer.getValue()); inner.serialize(new TestBean(), jgen, null); jgen.flush(); Assert.assertEquals("test", serializer.getValue()); inner.serialize(new TestBean(), jgen, null); jgen.flush(); Assert.assertEquals("test", serializer.getValue()); inner.serialize(new TestBean(), jgen, null); jgen.flush(); Assert.assertEquals("test", serializer.getValue()); }
@Test public void testJsonValueSerializer() throws Exception { class Test { public void test() { } } JsonValueSerializer<Object> src = new JsonValueSerializer<Object>(new TestMethod(), null); JsonValueSerializer<Object> dest = new JsonValueSerializer<Object>(src, null); JsonValueSerializer<Object> src2 = new JsonValueSerializer<Object>(src2, null); JsonValueSerializer<Object> dest2 = new JsonValueSerializer<Object>(src2, null); JsonValueSerializer<Object> src3 = new JsonValueSerializer<Object>(src3, null); JsonValueSerializer<Object> dest3 = new JsonValueSerializer<Object>(src3, null); JsonValueSerializer<Object> dest4 = new JsonValueSerializer<Object>(src4, null); JsonValueSerializer<Object> dest5 = new JsonValueSerializer<Object>(src5, null); JsonValueSerializer<Object> dest6 = new JsonValueSerializer<Object>(src6, null); JsonValueSerializer<Object> dest7 = new JsonValueSerializer<Object>(dest5, null); JsonValueSerializer<Object> dest8 = new JsonValueSerializer<Object>(src8, null); JsonValueSerializer<Object> dest9 = new JsonValueSerializer
@Test public void testJsonValueSerializer() throws Exception { class Test { public void test() { } } JsonValueSerializer serializer = new JsonValueSerializer(new TestBean(), new JsonSerializer<Object>() { @Override public void serialize(Object o, JsonGenerator jgen, SerializerProvider prov) throws IOException { System.out.println("test"); } }); JsonValueSerializer inner = new JsonValueSerializer(new TestBean(), new JsonSerializer<Object>() { @Override public void serialize(Object o, JsonGenerator jgen, SerializerProvider prov) throws IOException { System.out.println("inner"); } }); inner.serialize(); }
@Test public void testJsonValueSerializer() throws Exception { JsonValueSerializer src = new JsonValueSerializer(getClass().getDeclaredMethod("property"), null); BeanProperty bean = new BeanProperty(); bean.setId("id"); bean.setString("str"); bean.setBoolean(true); bean.setBoolean(false); bean.setBoolean(true); bean.setBoolean(false); bean.setBoolean(true); bean.setBoolean(false); bean.setBoolean(true); bean.setBoolean(false); bean.setBoolean(true); bean.setBoolean(false); bean.setBoolean(true); bean.setBoolean(false); bean.setBoolean(true); bean.setBoolean(false); bean.setBoolean(false); bean.setBoolean(true); bean.setBoolean(false); bean.setBoolean(false); bean.setBoolean(true); bean.setBoolean(false); bean.setBoolean(false); bean.setBoolean(true); bean.setBoolean(false); bean.setBoolean(true); bean.setBoolean(false); bean.setBoolean(true); bean.setBoolean(false); bean.setBoolean(true); bean.setBoolean(
@Test public void testJsonValueSerializer() throws Exception { class TestBean { public void test() { } } JsonValueSerializer serializer = new JsonValueSerializer(new TestBean(), new JsonSerializer<Object>() { @Override public void serialize(Object value, JsonGenerator jgen, SerializerProvider prov) throws IOException { } }); assertEquals("{\"test\":{\"foo\":\"bar\"}}", serializer.serialize(new TestBean(), null, null)); assertEquals("{\"test\":{\"foo\":\"bar\"}}", serializer.serialize(new TestBean(), null, null)); assertEquals("{\"test\":{\"foo\":\"bar\"}}", serializer.serialize(new TestBean(), null, null)); assertEquals("{\"test\":{\"foo\":\"bar\"}}", serializer.serialize(new TestBean(), null, null)); assertEquals("{\"test\":{\"foo\":\"bar\"}}", serializer.serialize(new TestBean(), null, null)); assertEquals("{\"test\":{\"foo\":\"bar\"}}", serializer.serialize(new TestBean(), null, null)); assertEquals("{\"test\":{\"foo\":\"bar\"}}", serializer.serialize(new TestBean(), null, null)); assertEquals("{\"test\":{\"foo\":\"bar\"}}",
@Test public void testJsonValueSerializer() throws Exception { JsonValueSerializer<?> bean = new JsonValueSerializer(new JsonValueSerializer<?>(), null, null, false); BeanProperty beanProperty = new BeanProperty("name", "value"); bean.setAccessorMethod(new Method() { @Override public Object deserialize(JsonReader reader, Type type) throws JsonMappingException { Object obj = reader.readObject(); return obj; } }); JsonValueSerializer<?> serializer = new JsonValueSerializer<>(bean, beanProperty, null, false); assertEquals(bean, serializer); bean.setAccessorMethod(new Method() { @Override public Object deserialize(JsonReader reader, Type type) throws JsonMappingException { Object obj = reader.readObject(); return obj; } }); bean.setProperty(beanProperty); serializer = new JsonValueSerializer(bean, beanProperty, null, false); assertEquals(bean, serializer); bean.setProperty(beanProperty); serializer = new JsonValueSerializer(bean, beanProperty, null, false); assertEquals(bean, serializer); bean.setProperty(beanProperty); serializer = new JsonValueSerializer(bean, beanProperty, null, false); assertEquals(bean, serializer); }
@Test public void testJsonValueSerializer() throws Exception { JsonValueSerializer mock = mock(JsonValueSerializer.class); when(mock.handledType()).thenReturn(String.class); JsonValueSerializer serializer = new JsonValueSerializer(mock, null, mock, false); assertEquals(mock, serializer); }
@Test public void testJsonValueSerializer() throws Exception { JsonValueSerializer src = new JsonValueSerializer(new MethodValueMethod("foo"), new JsonSerializer<Object>() { @Override public Object deserialize(JsonValueSerializer jsonValueSerializer) throws JsonMappingException { return null; } }); JsonValueSerializer val = new JsonValueSerializer(src, new BeanProperty(), new JsonSerializer<Object>() { @Override public Object deserialize(JsonValueSerializer jsonValueSerializer) throws JsonMappingException { return null; } }); val.serialize(new Object(), new JsonGene("foo")); assertEquals("foo", val.getAsString()); val = new JsonValueSerializer(new MethodValueMethod("bar"), new JsonSerializer<Object>() { @Override public Object deserialize(JsonValueSerializer jsonValueSerializer) throws JsonMappingException { return null; } }); val.serialize(new Object(), new JsonGene("bar")); assertEquals("bar", val.getAsString()); }
@Test public void testJsonSerializer() throws Exception { JsonValueSerializer src = new JsonValueSerializer(Foo.class.getMethod("foo"), new JsonSerializer<Object>() { @Override public void serialize(Object bean) { bean.set("foo"); } }); JsonValueSerializer dst = new JsonValueSerializer(Foo.class.getMethod("bar"), new JsonSerializer<Object>() { @Override public void serialize(Object bean) { bean.set("bar"); } }); JsonValueSerializer src2 = new JsonValueSerializer(Foo.class.getMethod("foo"), new JsonSerializer<Object>() { @Override public void serialize(Object bean) { bean2.set("bar"); } }); JsonValueSerializer dst2 = new JsonValueSerializer(Foo.class.getMethod("bar"), new JsonSerializer<Object>() { @Override public void serialize(Object bean) { bean2.set("bar"); } }); JsonValueSerializer src3 = new JsonValueSerializer(Foo.class.getMethod("foo"), new JsonSerializer<Object>() { @Override public void serialize(Object bean) { bean2.set("bar"); } }); JsonValueSerializer src4 = new JsonValueSerializer(Foo.class.getMethod("foo"), new
@Test public void testJsonValueSerializer() throws Exception { JsonValueSerializer<?> bean = new JsonValueSerializer<>(new JsonValueSerializer<?>(), new BeanProperty("name"), new JsonSerializer<?>(), false); bean.handle(new Object()); bean.handle(new Object()); bean.handle(new Object()); bean.handle(new Object()); bean.handle(new Object()); bean.handle(new Object()); bean.handle(new Object()); bean.handle(new Object()); bean.handle(new Object()); bean.handle(new Object()); bean.handle(new Object()); bean.handle(new Object()); bean.handle(new Object()); bean.handle(new Object()); bean.handle(new Object()); bean.handle(new Object()); bean.handle(new Object()); bean.handle(new Object()); bean.handle(new Object()); bean.handle(new Object()); }
@Test public void testJsonValueSerializer() throws Exception { JsonValueSerializer victim = new JsonValueSerializer(new JsonValueSerializer(String.class.getDeclaredMethod("string"), new JsonSerializer<?>())); BeanProperty bean = new BeanProperty("name", "value"); victim.serialize(bean, null, null); assertTrue(bean.isValid()); }
@Test public void test_notNullClass() { assertEquals(Object.class, _notNullClass(Object.class).getClass()); }
@Test public void testNotNullClass() { assertEquals(Object.class, _notNullClass(Object.class).getClass()); }
@Test public void withResolved() throws Exception { BeanProperty bean = new BeanPropertyImpl(); bean.setId("id"); bean.setString("str"); bean.setInteger(123); bean.setLong(234L); bean.setDouble(234.0); JsonValueSerializer actual = _valueClass(_innerVal, bean).withResolved(bean, _jsonSerializer, true); JsonValueSerializer expected = _valueClass(_innerVal, bean, true); assertEquals(expected, actual); }
@Test public void testWithResolved() throws Exception { BeanProperty beanProperty = new BeanProperty(); beanProperty.setId("id"); beanProperty.setString("str"); beanProperty.setInteger(123); beanProperty.setDouble(4.2); JsonValueSerializer actual = _valueSerializer.withResolved(beanProperty, _jsonSerializer, false); assertEquals("id", actual.getString()); assertEquals(4, actual.getInt()); assertEquals(4, actual.getDouble()); assertEquals(4, actual.getDouble()); assertEquals(4, actual.getInteger()); assertEquals(4, actual.getDouble()); assertEquals(4, actual.getDouble()); assertEquals(4, actual.getDecimal()); }
@Test public void testCustomJsonSerializer() throws Exception { BeanProperty beanProperty = new BeanProperty("name", "value"); JsonValueSerializer<?> valSerializer = new JsonValueSerializer(new JsonValueSerializer(new JsonValueSerializer(new JsonValueSerializer(new JsonValueSerializer(new JsonSerializer(new JsonSerializer(new JsonSerializer(new JsonSerializer(new JsonSerializer(new JsonSerializer(new JsonSerializer(new JsonSerializer(new JsonSerializer(new JsonSerializer(new JsonSerializer(new JsonSerializer(new JsonSerializer(new JsonSerializer(new JsonSerializer(new JsonSerializer(new JsonSerializer(new JsonSerializer(new JsonSerializer(new JsonSerializer(new JsonSerializer(new JsonSerializer(new JsonSerializer(new JsonSerializer(new JsonSerializer(new JsonSerializer(new JsonSerializer(new JsonSerializer(new JsonSerializer(new JsonSerializer(new JsonSerializer(new JsonSerializer(new JsonSerializer(new JsonSerializer(new JsonSerializer(new JsonSerializer(new JsonSerializer(new JsonSerializer(new JsonSerializer(new JsonSerializer(new JsonSerializer(new JsonSerializer(new JsonSerializer(new JsonSerializer(new JsonSerializer(new JsonSerializer(new JsonSerializer(new JsonSerializer(new JsonSerializer(new
@Test public void testCreateContextual() throws Exception { BeanProperty property = new BeanProperty("property"); JsonSerializer<?> contextualSerializer = mock(JsonSerializer.class); when(contextualSerializer.createContextual(any(BeanProperty.class), any(Class.class))).thenReturn(null); when(property.get("property")).thenReturn(null); JsonSerializer<?> contextual = _underTest.createContextual(new DefaultSerializerProvider(), property); assertThat(contextual).isNotNull(); }
@Test public void testCreateContextual() throws Exception { BeanProperty property = new BeanProperty(); JsonSerializer<?> contextualSerializer = mock(JsonSerializer.class); when(provider.createTypedValueSerializer(Mockito.any(JavaType.class), Mockito.eq(false), Mockito.eq(property))).thenReturn(contextualSerializer); JsonSerializer<?> contextual = mock(JsonSerializer.class); when(contextualSerializer.createContextual(Mockito.any(SerializerProvider.class), Mockito.eq(property))).thenReturn(null); JsonSerializer<?> contextual2 = mock(JsonSerializer.class); when(contextual2.createContextual(Mockito.any(SerializerProvider.class), Mockito.eq(property))).thenReturn(null); JsonSerializer<?> contextual3 = mock(JsonSerializer.class); when(contextual3.createContextual(Mockito.any(SerializerProvider.class), Mockito.eq(property))).thenReturn(null); JsonSerializer<?> contextual3 = mock(JsonSerializer.class); when(contextual3.createContextual(Mockito.any(SerializerProvider.class), Mockito.eq(property))).thenReturn(null); JsonSerializer<?> contextual4 = mock
@Test public void testCreateContextual() throws Exception { BeanProperty property = new BeanProperty(); JsonSerializer<?> contextualSerializer = mock(JsonSerializer.class); when(provider.findTypedValueSerializer(any(JavaType.class), anyBoolean(), any(BeanProperty.class))).thenReturn(contextualSerializer); JsonSerializer<?> contextual = mock(JsonSerializer.class); when(contextualSerializer.createContextual(any(BeanProperty.class), any(BeanProperty.class))).thenReturn(null); JsonSerializer<?> contextual2 = mock(JsonSerializer.class); when(contextual2.createContextual(any(BeanProperty.class), any(BeanProperty.class))).thenReturn(null); JsonSerializer<?> contextual3 = mock(JsonSerializer.class); when(contextual3.createContextual(any(BeanProperty.class), any(BeanProperty.class))).thenReturn(null); JsonSerializer<?> contextual4 = mock(JsonSerializer.class); when(contextual3.createContextual(any(BeanProperty.class), any(BeanProperty.class))).thenReturn(null); JsonSerializer<?> contextual5 = mock(JsonSerializer.class); when(contextual5.createContext
@Test public void testCreateContextual() throws Exception { BeanProperty property = new BeanProperty(); JsonSerializer<?> contextualSerializer = provider.createContextual(null, property); contextualSerializer.setMode(ContextualSerializer.Mode.DEFAULT); contextualSerializer.setMode(ContextualSerializer.Mode.DEFAULT); JsonSerializer<?> contextual = provider.createContextual(null, property); contextual.setMode(ContextualSerializer.Mode.DEFAULT); JsonSerializer<?> contextual2 = provider.createContextual(null, property); contextual2.setMode(ContextualSerializer.Mode.DEFAULT); JsonSerializer<?> contextual2 = provider.createContextual(null, property); contextual2.setMode(ContextualSerializer.Mode.DEFAULT); JsonSerializer<?> contextual3 = provider.createContextual(null, property); contextual3.setMode(ContextualSerializer.Mode.DEFAULT); JsonSerializer<?> contextual3 = provider.createContextual(null, property); contextual3.setMode(ContextualSerializer.Mode.DEFAULT); JsonSerializer<?> contextual4 = provider.createContextual(null, property); contextual4.setMode(ContextualSerializer.Mode.DEFAULT); JsonSerializer<?> context
@Test public void testCreateContextual() throws Exception { Class<?> type = new ByteBuddy().subclass(BeanProperty.class).method(isDeclaredBy(BeanProperty.class)).intercept(MethodCall.INHERITED_METHOD).make().load(getClass().getClassLoader(), ClassLoadingStrategy.Default.WRAPPER).getLoaded(); TypeSerializerProvider provider = new DefaultSerializerProvider(type); JsonSerializer<?> contextualSerializer = provider.createContextual(provider, BeanProperty.class); JsonSerializer<?> contextual = contextualSerializer.createContextual(provider, BeanProperty.class); assertThat(contextual).isNotNull(); assertThat(contextual).isInstanceOf(ContextualSerializer.class); }
@Test public void testCreateContextual() throws Exception { Class<?> type = new TypeToken<List<String>>() {}.getType(); TypeSerializerProvider provider = new TypeSerializerProvider(type); BeanProperty property = new BeanProperty("foo", String.class); JsonSerializer<?> contextualSerializer = provider.findTypedValueSerializer(type, false, property); JsonSerializer<?> contextual = contextualSerializer.createContextual(provider, property); assertThat(contextual).isNotNull(); assertThat(contextual).isInstanceOf(ContextualSerializer.class); }
@Test public void testCreateContextual() throws Exception { Class<?> ti = new TypeToken<List<String>>() {}.getType(); TypeSerializerProvider provider = new TypeSerializerProvider() { @Override public TypeSerializer<? extends Annotation> create(Class<?> c) { return new ContextualSerializer(c); } }; new Expectations() {{ c.getRawClass(); result = ti; }}; JsonSerializer<?> ser = provider.createContextual(null, null); JsonSerializer<?> ctxual = new JsonSerializer<Object>() { @Override public Object createContextual(JsonSerializer<?> ctx, BeanProperty property) throws JsonMappingException { return ctxual; } }; new Expectations() {{ t.getRawClass(); result = ti; }}; JsonSerializer<?> ctxual2 = new JsonSerializer<Object>() { @Override public Object createContextual(JsonSerializer<?> ctx, BeanProperty property) throws JsonMappingException { return ctxual2; } }; new Expectations() {{ t.getRawClass(); result = ti; }}; new Expectations() {{ t.getRawClass(); result = ti; }}; new Expectations() {{ t.getRawClass(); result = ti; }}; new Expectations() {{ t.get
@Test public void testCreateContextual() throws Exception { BeanProperty beanProperty = new BeanProperty(); beanProperty.setBeanType(new BeanType(String.class)); JsonSerializer<?> contextualSerializer = mock(JsonSerializer.class); when(provider.findTypedValueSerializer(Mockito.eq(String.class), Mockito.eq(contextualSerializer), Mockito.eq(beanProperty))).thenReturn(null); JsonSerializer<?> contextual = mock(JsonSerializer.class); when(contextualSerializer.createContextual(beanProperty)).thenReturn(contextual); JsonSerializer<?> contextual2 = mock(JsonSerializer.class); when(contextual2.createContextual(beanProperty)).thenReturn(null); JsonSerializer<?> contextual3 = mock(JsonSerializer.class); when(contextual3.createContextual(beanProperty)).thenReturn(null); JsonSerializer<?> contextual3 = mock(JsonSerializer.class); when(contextual3.createContextual(beanProperty)).thenReturn(null); JsonSerializer<?> contextual3 = mock(JsonSerializer.class); when(contextual3.createContextual(beanProperty)).thenReturn(null); JsonSerializer<?> contextual3 = mock(JsonSerializer.class); when(context
@Test public void testCreateContextual() throws Exception { BeanProperty beanProperty = new BeanProperty(); beanProperty.setBeanType(new BeanType(String.class)); JsonSerializer<?> contextualSerializer = new JsonSerializerFactory().createContextual(null, beanProperty); contextualSerializer.serialize("foo"); contextualSerializer.deserialize("bar"); assertThat(contextualSerializer.serialize("foo")).isEqualTo("bar"); }
@Test public void testCreateContextual() throws Exception { BeanProperty property = new BeanProperty("foo", new TypeLiteral<List<String>>() {}); JsonSerializer<?> contextualSerializer = mock(JsonSerializer.class); when(provider.createContextual(any(Class.class), any(BeanProperty.class))).thenReturn(contextualSerializer); JsonSerializer<?> contextual = _underTest.createContextual(provider, property); assertThat(contextual).isSameAs(contextualSerializer); }
@Test public void serialize() throws IOException, JsonGenerationException { TestBean bean = new TestBean(); JsonGenerator jgen = mock(JsonGenerator.class); SerializerProvider prov = mock(SerializerProvider.class); JsonSerializer<Object> ser = mock(JsonSerializer.class); when(ser.serialize(bean, jgen, prov)).thenReturn(null); JsonSerializationProvider prov2 = mock(JsonSerializationProvider.class); when(prov.defaultSerializeNull(jgen)).thenReturn(null); JsonSerializer<Object> ser2 = mock(JsonSerializer.class); when(ser2.serialize(bean, jgen, prov2)).thenReturn(ser2); JsonSerializer<Object> bean2 = mock(JsonSerializer.class); when(bean2.getBean()).thenReturn(bean2); when(bean2.getBean()).thenReturn(bean2); when(bean2.getProperty()).thenReturn(new Object()); when(bean2.getPropertySerializer()).thenReturn(ser2); bean.serialize(bean, jgen, prov2); verify(ser2).serialize(bean, jgen, prov2); }
@Test public void serialize() throws IOException, JsonGenerationException { class TestBean implements Bean { public void foo() { } } TestBean bean = new TestBean(); JsonGenerator jgen = mock(JsonGenerator.class); SerializerProvider prov = mock(SerializerProvider.class); JsonSerializer<Object> serializer = mock(JsonSerializer.class); when(bean.getFoo()).thenReturn(new Object()); when(ser.serialize(bean, jgen, prov)).thenReturn(new Object()); new TestBean().serialize(bean, jgen, prov); verify(prov).defaultSerializeNull(jgen); verify(prov).findTypedValueSerializer(eq(Object.class), eq(true), eq("foo")); verify(ser).serialize(bean, jgen, prov); }
@Test public void serialize() throws Exception { Foo foo = new Foo(); foo.property = "foo"; Foo bar = new Foo(); bar.property = "bar"; Bar baz = new Bar(); baz.property = "baz"; baz.serialize(baz, jgen, prov); assertEquals(baz, bar); }
@Test public void serializeNull() throws IOException, JsonGenerationException { class Bean { public String getName() { return null; } public void setName(String name) { } } Bean bean = new Bean(); JsonGenerator jgen = mock(JsonGenerator.class); SerializerProvider prov = mock(SerializerProvider.class); when(bean.getName()).thenReturn(null); JsonSerializer<Object> ser = mock(JsonSerializer.class); when(ser.serialize(null, jgen, prov)).thenReturn(null); JsonSerializer<Object> beanSerializer = mock(JsonSerializer.class); when(beanSerializer.defaultSerializeNull(jgen)).thenReturn(null); JsonSerializer<Object> beanSerializer2 = mock(JsonSerializer.class); when(beanSerializer2.defaultSerializeNull(jgen)).thenReturn(null); JsonSerializer<Object> beanSerializer3 = mock(JsonSerializer.class); when(beanSerializer3.serialize(null, jgen, prov)).thenReturn(null); JsonSerializer<Object> beanSerializer4 = mock(JsonSerializer.class); when(beanSerializer4.serialize(null, jgen, prov)).thenReturn(null); JsonSerializer<Object> beanSerializer5 = mock(JsonSerializer.class); when(
@Test public void serializeNull() throws IOException, JsonGenerationException { class TestBean implements Bean { public String getName() { return null; } } TestBean bean = new TestBean(); JsonSerializer<Object> ser = mock(JsonSerializer.class); when(ser.serializeNull(bean)).thenReturn(null); JsonSerializerProvider prov = mock(JsonSerializerProvider.class); when(provide.findTypedValueSerializer(eq(Bean.class), eq(true), eq("name"))).thenReturn(ser); JsonSerializer<Object> beanAsBean = mock(JsonSerializer.class); when(beanAsBean.getName()).thenReturn("name"); JsonSerializer<Object> beanAsBean = mock(JsonSerializer.class); when(beanAsBean.getBean()).thenReturn(bean); when(beanAsBean.getBean()).thenReturn(bean); when(beanAsBean.getBean()).thenReturn(bean); when(beanAsBean.getBean()).thenReturn(null); JsonSerializer<Object> beanAsBean = mock(JsonSerializer.class); when(beanAsBean.getBean()).thenReturn(bean); when(beanAsBean.getBean()).thenReturn(bean); when(beanAsBean.getBean()).thenReturn
@Test public void serializeNull() throws IOException, JsonGenerationException { class Bean { public String getName() { return null; } } Bean bean = new Bean(); bean.setName(null); JsonGenerator jgen = mock(JsonGenerator.class); SerializerProvider prov = mock(SerializerProvider.class); new JsonSerializer<Object>(Object.class, true, "name").serialize(bean, jgen, prov); verify(prov).defaultSerializeNull(jgen); }
@Test public void serializeNull() throws IOException, JsonGenerationException { class MockAccessorMethod implements JsonAccessor { public String toString() { return null; } } MockAccessorMethod bean = new MockAccessorMethod(); bean.set_accessorMethod(bean); bean.serialize(null, _jgen, _provprov); verify(bean).defaultSerializeNull(eq(_jgen)); }
@Test public void testSerializeNull() throws Exception { TestBean bean = new TestBean(); JsonSerializer<Object> ser = prov.findTypedValueSerializer(null, true, TestBean.class); JsonGenerator jgen = prov.findTypedValueSerializer(null, true, TestBean.class); JsonGenerator gen = prov.findTypedValueSerializer(null, true, TestBean.class); prov.defaultSerializeNull(jgen); Assert.assertEquals(bean.value(), null); Assert.assertEquals(ser.serialize(bean, jgen, prov), null); }
@Test public void serialize() throws IOException, JsonGenerationException { TestBean bean = new TestBean(); bean.property = "foo"; JsonGenerator jgen = mock(JsonGenerator.class); SerializerProvider prov = mock(Provides.class); when(provides.findTypedValueSerializer(eq(TestBean.class), eq(true), eq("foo"))).thenReturn(bean); when(bean.accessor()).thenReturn(new Method(TestBean.class.getName(), "foo")); JsonSerializer<TestBean> ser = mock(JsonSerializer.class); when(ser.serialize(bean, jgen, prov)).thenReturn(bean); JsonSerialization<TestBean> beanSerialization = mock(JsonSerialization.class); when(beanSerialization.serialize(bean, jgen, prov)).thenReturn(beanSerialization); JsonSerialization<TestBean> beanSerialization2 = mock(JsonSerialization.class); when(beanSerialization2.serialize(bean, jgen, prov)).thenReturn(beanSerialization2); JsonSerializer<TestBean> beanSerialization2 = mock(JsonSerializer.class); when(beanSerialization2.deserialize(beanSerialization, jgen, prov)).thenReturn(beanSerialization2); JsonSerializer<TestBean> beanSerialization2 = mock(
@Test public void testSerializeWithType() throws Exception { class TestBean implements Bean { public void foo() { } } TestBean bean = new TestBean(); JsonGenerator jgen = mock(JsonGenerator.class); TypeSerializerProvider provider = mock(TypeSerializerProvider.class); TypeSerializer typeSerializer = mock(TypeSerializer.class); JsonSerializer<Object> beanSerializer = mock(JsonSerializer.class); when(bean.getBean()).thenReturn(bean); when(bean.getBeanType()).thenReturn(beanType); when(bean.getBeanTypeSerializer()).thenReturn(beanSerializer); when(provider.findValueSerializer(bean.getClass(), "foo")).thenReturn(beanSerializer); when(typeSerializer.serializeWithType(bean, jgen, provider, typeSerializer)).thenReturn(bean); JsonSerializer<Object> beanSerializer2 = mock(JsonSerializer.class); when(beanSerializer2.serializeWithType(bean, jgen, provider2, typeSerializer)).thenReturn(beanSerializer2); JsonSerializer<Object> beanSerializer3 = mock(JsonSerializer.class); when(beanSerializer3.serializeWithType(bean, jgen, provider3, typeSerializer)).thenReturn(beanSerializer3); JsonSerializer<Object> beanSerializer4 =
@Test public void serializeWithType_typePrefix_works_as_expected() throws Exception { class TestBean implements Bean { public String property; public void property(String value) { } } TestBean bean = new TestBean(); typeSer0.writeTypePrefixForScalar(bean, _jgen); assertThat(bean.property(), is("property")); }
@Test public void serializeWithType() throws Exception { class TestBean implements Bean { public String name() { return "name"; } } TestBean bean = new TestBean(); bean.name = "name"; bean.value = "value"; bean.serializeWithType(bean, _jgen, _provider, _typeSerializer); verify(_provider).defaultSerializeNull(eq(_jgen)); verify(_valueSerializer).serializables(eq(bean), eq(bean.name())); }
@Test public void serializeWithType_typeSer0_serIsNull_shouldSerializeNull() throws Exception { class TestBean implements Bean { public String property; public void property(String value) { } } TestBean bean = new TestBean(); typeSer0.writeTypeSuffixForScalar(bean, _jgen); assertThat(bean.property(), is(nullValue())); }
@Test public void serializeWithType_typeInformation_works_as_expected() throws Exception { class TestBean implements Bean { @SuppressWarnings("unchecked") private String property; @Override public String getValue() { return null; } @Override public String toString() { return null; } @Override public Class<? extends Annotation> annotationType() { return TestBean.class; } @Override public void init() { } } TestBean bean = new TestBean(); JsonGenerator jgen = mock(JsonGenerator.class); TypeSerializer provider = mock(TypeSerializer.class); TypeSerializer typeSerializer = mock(TypeSerializer.class); class TestBean implements Bean { @Override public String toString() { return null; } @Override public Class<? extends Annotation> annotationType() { return TestBean.class; } @Override public void init() { } } TestBean testBean2 = new TestBean(); class TestBean2 implements Bean { @Override public String toString() { return null; } @Override public void init() { } @Override public void serializeWithType(Object bean, JsonGenerator jgen, JsonSerializerProvider provider, TypeSerializer typeSerializer) throws IOException, JsonProcessingException { } @Override public void serializeWithType(Object bean, JsonGenerator j
@Test public void testIsNaturalTypeWithStdHandling() { JsonSerializer<Object> ser = mock(JsonSerializer.class); when(ser.isNaturalTypeWithStdHandling(String.class, null)).thenReturn(true); when(ser.isNaturalTypeWithStdHandling(Integer.TYPE, null)).thenReturn(true); when(ser.isNaturalTypeWithStdHandling(Boolean.TYPE, null)).thenReturn(false); when(ser.isNaturalTypeWithStdHandling(Integer.TYPE, null)).thenReturn(false); when(ser.isNaturalTypeWithStdHandling(String.class, null)).thenReturn(false); when(ser.isNaturalTypeWithStdHandling(Integer.TYPE, null)).thenReturn(false); when(ser.isNaturalTypeWithStdHandling(Boolean.TYPE, null)).thenReturn(false); when(ser.isNaturalTypeWithStdHandling(String.class, null)).thenReturn(false); when(ser.isNaturalTypeWithStdHandling(Integer.TYPE, null)).thenReturn(false); when(ser.isNaturalTypeWithStdHandling(Boolean.TYPE, null)).thenReturn(false); when(ser.isNaturalType
@Test public void testIsNaturalTypeWithStdHandling() { JsonSerializer<?> ser = mock(JsonSerializer.class); when(ser.isNaturalTypeWithStdHandling(String.class, null)).thenReturn(true); when(ser.isNaturalTypeWithStdHandling(Integer.TYPE, null)).thenReturn(false); when(ser.isNaturalTypeWithStdHandling(Boolean.TYPE, null)).thenReturn(false); when(ser.isNaturalTypeWithStdHandling(Integer.TYPE, null)).thenReturn(true); when(ser.isNaturalTypeWithStdHandling(String.class, null)).thenReturn(false); when(ser.isNaturalTypeWithStdHandling(Integer.TYPE, null)).thenReturn(false); when(ser.isNaturalTypeWithStdHandling(Boolean.TYPE, null)).thenReturn(false); when(ser.isNaturalTypeWithStdHandling(String.class, null)).thenReturn(false); when(ser.isNaturalTypeWithStdHandling(Integer.TYPE, null)).thenReturn(false); when(ser.isNaturalTypeWithStdHandling(Integer.TYPE, null)).thenReturn(false); when(ser.isNaturalTypeWithStd
@Test public void testIsNaturalTypeWithStdHandling() { JsonSerializer<?> ser = mock(JsonSerializer.class); JsonValueSerializer<?> natural = mock(JsonValueSerializer.class); when(natural.isNaturalTypeWithStdHandling(Integer.TYPE, ser)).thenReturn(true); when(natural.isNaturalTypeWithStdHandling(Boolean.TYPE, ser)).thenReturn(false); when(natural.isNaturalTypeWithStdHandling(String.TYPE, ser)).thenReturn(false); when(natural.isNaturalTypeWithStdHandling(Integer.TYPE, ser)).thenReturn(true); when(natural.isNaturalTypeWithStdHandling(Boolean.TYPE, ser)).thenReturn(false); when(natural.isNaturalTypeWithStdHandling(String.TYPE, ser)).thenReturn(false); when(natural.isNaturalTypeWithStdHandling(Integer.TYPE, ser)).thenReturn(false); when(natural.isNaturalTypeWithStdHandling(Boolean.TYPE, ser)).thenReturn(false); when(natural.isNaturalTypeWithStdHandling(String.class, ser)).thenReturn(false); when(natural.isNaturalTypeWithStdHandling(Integer.TYPE, ser)).
@Test public void testIsDefaultSerializer() throws Exception { JsonSerializer<?> ser = new JsonSerializer<Object>() { @Override public boolean isNaturalTypeWithStdHandling(Class<?> type, JsonSerializer<?> serializer) { return true; } }; JsonSerializer<?> ds = new JsonSerializer<Object>() { @Override public boolean isNaturalTypeWithStdHandling(Class<?> type, JsonSerializer<?> serializer) { return false; } }; assertTrue(jsonSerializer.isNaturalTypeWithStdHandling(String.class, ser)); assertTrue(jsonSerializer.isNaturalTypeWithStdHandling(Integer.TYPE, ser)); assertTrue(jsonSerializer.isNaturalTypeWithStdHandling(Boolean.TYPE, ser)); assertTrue(jsonSerializer.isNaturalTypeWithStdHandling(String.class, ser)); assertTrue(jsonSerializer.isNaturalTypeWithStdHandling(Integer.TYPE, ds)); assertTrue(jsonSerializer.isNaturalTypeWithStdHandling(String.class, ds)); assertTrue(jsonSerializer.isNaturalTypeWithStdHandling(Integer.TYPE, ds)); assertTrue(jsonSerializer.isNaturalTypeWithStdHandling(String.class, ds)); assertTrue(jsonSerializer.isNaturalTypeWithStdHandling(Integer
@Test public void testNewName() { assertEquals("foo", builder.getInternalName()); }
@Test public void testField() { assertEquals("foo", new POJOPropertyBuilder("foo", annotationIntrospector, false).getInternalName()); }
@Test public void getGetter() { AnnotatedMethod getter = _getter.getGetter(); AnnotatedMethod next = _getter.getGetter(); assertThat(getter, is(next)); }
@Test public void getGetter() { [LINE] void getter(String getter) { getter.value = getter; } [LINE] void getter2 = getter.getGetter(); assertThat(getter, is(nullValue())); }
@Test public void getGetter() { class Mock { public void m() { } } Mock getter = new Mock(); getter.m = getter; getter.m = getter; assertEquals(getter.m, getter.getGetter()); }
@Test public void getGetter() { class Test { public void test() { } } new Test() { @Override public AnnotatedMethod getGetter() { return null; } }; }
@Test public void getGetter() { try { new Mock(null); throw new IllegalArgumentException("Conflicting getter definitions for property \"foo\""); } catch (IllegalArgumentException e) { assertThat(e.getMessage(), containsString("Conflicting getter definitions for property \"foo\"")); } }
@Test public void constructorParameter() { AnnotatedParameter param1 = new AnnotatedParameter(new Class<?>("Foo"), null, null); AnnotatedParameter param2 = new AnnotatedParameter(new Class<?>("Bar"), null, null); AnnotatedParameter param3 = new AnnotatedParameter(new Class<?>("Foo"), null, null); AnnotatedParameter param4 = new AnnotatedParameter(new Class<?>("Bar"), null, null); AnnotatedParameter param5 = new AnnotatedParameter(new Class<?>("Foo"), null, null); AnnotatedParameter param6 = new AnnotatedParameter(new Class<?>("Bar"), null, null); AnnotatedParameter param7 = new AnnotatedParameter(new Class<?>("Foo"), null, null); AnnotatedParameter param8 = new AnnotatedParameter(new Class<?>("Foo"), null, null); AnnotatedParameter param9 = new AnnotatedParameter(new Class<?>("Foo"), null, null); assertEquals(param1, param2); assertEquals(param2, param3); assertEquals(param3, param4); assertEquals(param5, param5); assertEquals(param6, param6); assertEquals(param7, param7); assertEquals(param8, param5); assertEquals(param9, param6); assertEquals(param1, param2); assertEquals(param2, param3); assertEquals(param1, param1.getConstructorParameter());
@Test public void constructorParameter() { AnnotatedParameter param = new AnnotatedParameter() { @Override public Class<? extends Annotation> getOwner() { return null; } }; assertEquals(param, new ConstructorParameter(ctorParameters, param.getOwner())); }
@Test public void testRename() { POJOPropertyBuilder builder = new POJOPropertyBuilder("foo", annotator); Linked<? extends AnnotatedMember> node = new Linked<AnnotatedMember>(2); Linked<? extends AnnotatedMember> renamed = new Linked<AnnotatedMember>(2); node.next = node; node.next = renamed; thrown.expect(IllegalStateException.class); thrown.expectMessage("Conflicting property name definitions: '" + renamed.explicitName + "' vs '" + node.explicitName + "' (for 2)"); builder.findRenamed(node, renamed); }
@Test public void testDoubleNode() { String s = "{\"value\":1,\"eOL\":2,\"value2\":\"\"}"; DoubleNode n = new DoubleNode(s); Assert.assertEquals(n.asText(), "\"value\""); }
@Test public void testValueOf() { Assert.assertEquals(new DoubleNode(42), DoubleNode.valueOf(42L)); Assert.assertEquals(new DoubleNode(42), DoubleNode.valueOf(42L)); Assert.assertEquals(new DoubleNode(42), DoubleNode.valueOf(42L)); Assert.assertEquals(new DoubleNode(42), DoubleNode.valueOf(42L)); Assert.assertEquals(new DoubleNode(42), DoubleNode.valueOf(42L)); Assert.assertEquals(new DoubleNode(42), DoubleNode.valueOf(42L)); Assert.assertEquals(new DoubleNode(42), DoubleNode.valueOf(42L)); Assert.assertEquals(new DoubleNode(42), DoubleNode.valueOf(42L)); Assert.assertEquals(new DoubleNode(42), DoubleNode.valueOf(42L)); Assert.assertEquals(new DoubleNode(42), DoubleNode.valueOf(42L)); Assert.assertEquals(new DoubleNode(42), DoubleNode.valueOf(42L)); Assert.assertEquals(new DoubleNode(42), DoubleNode.valueOf(42L)); Assert.assertEquals(new DoubleNode(42), DoubleNode.valueOf(42L
@Test public void testAsToken() { String value = "0.123"; JsonToken token = new DoubleNode(value).asToken(); assertThat(token.getNodeType()).isEqualTo(JsonToken.VALUE_NUMBER_FLOAT); assertThat(token.getText()).isEqualTo(value); }
@Test public void testPropertyBasedCreator() { ValueInstantiator valueInstantiator = createMock(ValueInstantiator.class); SettableBeanProperty creatorProps = createMock(SettableBeanProperty.class); Object[] defaultValues = new Object[] { "foo", "bar" }; PropertyBasedCreator propertyBasedCreator = new PropertyBasedCreator(valueInstantiator, creatorProps, defaultValues); assertEquals("foo", propertyBasedCreator.value); assertEquals("bar", propertyBasedCreator.property); assertEquals("foo", propertyBasedCreator.propertyWithDefault("foo")); assertEquals("bar", propertyBasedCreator.propertyWithDefault("bar")); assertEquals("foo", propertyBasedCreator.propertyWithDefault("foo")); assertEquals("bar", propertyBasedCreator.propertyWithDefault("foo")); assertEquals("bar", propertyBasedCreator.propertyWithDefault("foo")); assertEquals("bar", propertyBasedCreator.propertyWithDefault("foo")); assertEquals("bar", propertyBasedCreator.propertyWithDefault("foo")); assertEquals("bar", propertyBasedCreator.propertyWithDefault("foo")); assertEquals("bar", propertyBasedCreator.propertyWithDefault("foo")); assertEquals("bar", propertyBasedCreator.propertyWithDefault("foo")); assertEquals("bar", propertyBasedCreator.propertyWithDefault("foo")); assertEquals("bar", propertyBasedCreator.propertyWithDefault("foo")); assertEquals
@Test public void testPropertyBasedCreator() { ValueInstantiator valueInstantiator = new MockValueInstantiator(); SettableBeanProperty creatorProps = new SettableBeanProperty(); creatorProps.add("foo", new IntegerProperty(100)); creatorProps.add("bar", new IntegerProperty(100)); creatorProps.add("baz", new IntegerProperty(100)); PropertyBasedCreator propertyBasedCreator = new PropertyBasedCreator(valueInstantiator, creatorProps, null); assertEquals(100, propertyBasedCreator.getInjectableValueId()); assertEquals(100, propertyBasedCreator.getInjectableValueId()); assertEquals(100, propertyBasedCreator.getInjectableValueId()); assertEquals(100, propertyBasedCreator.getInjectableValueId()); assertEquals(100, propertyBasedCreator.getInjectableValueId()); assertEquals(100, propertyBasedCreator.getInjectableValueId()); assertEquals(100, propertyBasedCreator.getInjectableValueId()); assertEquals(100, propertyBasedCreator.getInjectableValueId()); assertEquals(100, propertyBasedCreator.getInjectableValueId()); assertEquals(100, propertyBasedCreator.getInjectableValueId()); assertEquals(100, propertyBasedCreator.getInjectableValueId()); assertEquals(100, propertyBasedCreator.getInjectableValueId()); assertEquals(100, propertyBasedCreator.
public void testPropertyBasedCreator() { ValueInstantiator valueInstantiator = createMock(ValueInstantiator.class); SettableBeanProperty property = new SettableBeanProperty(); PropertyBasedCreator propertyBasedCreator = new PropertyBasedCreator(valueInstantiator, new SettableBeanProperty[]{property}, null); assertEquals(propertyBasedCreator.getProperties().length, 1); assertEquals(propertyBasedCreator.getInjectableValueId(), new Integer(123)); propertyBasedCreator = new PropertyBasedCreator(valueInstantiator, new SettableBeanProperty[]{property}, null); assertEquals(propertyBasedCreator.getPropertiesWithInjectables().length, 1); assertEquals(propertyBasedCreator.getInjectableValueId(), new Integer(123)); propertyBasedCreator = new PropertyBasedCreator(valueInstantiator, new SettableBeanProperty[]{property}, null); assertEquals(propertyBasedCreator.getPropertiesWithInjectables().length, 1); assertEquals(propertyBasedCreator.getInjectableValueId(), new Integer(123)); }
@Test public void testPropertyBasedCreator() { ValueInstantiator valueInstantiator = createMock(ValueInstantiator.class); SettableBeanProperty[] creatorProps = new SettableBeanProperty[]{new InjectableBeanProperty("foo", "bar"), new InjectableBeanProperty("foo2", "bar2"), new InjectableBeanProperty("foo3", "bar3"), new InjectableBeanProperty("foo4", "bar4")}; Object[] defaultValues = new Object[] { "foo", "bar", "bar" }; PropertyBasedCreator propertyBasedCreator = new PropertyBasedCreator(valueInstantiator, creatorProps, defaultValues); assertEquals("bar2", propertyBasedCreator.getBean("foo").getValue()); assertEquals("bar3", propertyBasedCreator.getBean("foo2").getValue()); assertEquals("bar4", propertyBasedCreator.getBean("foo3").getValue()); assertEquals("bar4", propertyBasedCreator.getBean("foo4").getValue()); assertEquals("bar2", propertyBasedCreator.getBean("foo5").getValue()); assertEquals("bar4", propertyBasedCreator.getBean("foo6").getValue()); assertEquals("bar4", propertyBasedCreator.getBean("foo7").getValue()); assertEquals("bar4", propertyBasedCreator.getBean("foo8").getValue()); assertEquals("
@Test public void testPropertyBasedCreator() { ValueInstantiator valueInstantiator = createMock(ValueInstantiator.class); SettableBeanProperty[] creatorProps = new SettableBeanProperty[]{new StringBean("foo"), new IntegerBean("bar")}; Object[] defaultValues = new Object[] {10}; PropertyBasedCreator propertyBasedCreator = new PropertyBasedCreator(valueInstantiator, creatorProps, defaultValues); assertEquals(valueInstantiator, propertyBasedCreator.valueInstantiator); assertEquals(defaultValues.length, propertyBasedCreator.defaultValues.length); }
@Test public void testPropertyBasedCreator() { class TestBean implements Bean { private String name; private String value; public TestBean() { super(name, value); } } TestBean testBean = new TestBean(); ValueInstantiator valueInstantiator = createMock(ValueInstantiator.class); expect(valueInstantiator.get()).andReturn(testBean).anyTimes(); expect(testBean.getName()).andReturn("testBean").anyTimes(); expect(testBean.getInjectableValueId()).andReturn(null); expect(testBean.getInjectableProperties()).andReturn(new String[] { "testBean" }); replay(valueInstantiator); PropertyBasedCreator propertyBasedCreator = new PropertyBasedCreator(valueInstantiator, new SettableBeanProperty[]{testBean}, null); assertEquals("testBean", propertyBasedCreator.getName()); assertEquals("testBean", propertyBasedCreator.getValue()); assertEquals("testBean", propertyBasedCreator.getInjectableValueId()); assertEquals("testBean", propertyBasedCreator.getPropertiesWithInjectables[0].getName()); assertEquals("testBean", propertyBasedCreator.getPropertiesWithInjectables[1].getName()); assertEquals("testBean", propertyBasedCreator.getPropertiesWithInjectables[2].getValue()); assertEquals("test
@Test public void testPropertyBasedCreator() { ValueInstantiator valueInstantiator = createMock(ValueInstantiator.class); SettableBeanProperty[] creatorProps = new SettableBeanProperty[]{new StringBeanProperty("foo"), new IntegerBeanProperty("bar")}; Object[] defaultValues = new Object[] {null, null}; PropertyBasedCreator propertyBasedCreator = new PropertyBasedCreator(valueInstantiator, creatorProps, defaultValues); assertEquals("foo", propertyBasedCreator.getBean("foo").getValue()); assertEquals("bar", propertyBasedCreator.getBean("bar").getValue()); assertEquals("bar", propertyBasedCreator.getBean("foo").getValue()); assertEquals(defaultValues.length, defaultValues.length); }
@Test public void testPropertyBasedCreator() { ValueInstantiator valueInstantiator = createMock(ValueInstantiator.class); ValueInstantiator defInstantiator = createMock(ValueInstantiator.class); SettableBeanProperty creatorProps[] = new SettableBeanProperty[]{new StringBeanProperty("foo"), new IntegerBeanProperty("bar")}; PropertyBasedCreator propertyBasedCreator = new PropertyBasedCreator( defInstantiator, creatorProps, new Object[] { "foo" }); assertEquals("foo", propertyBasedCreator.getBeanProperty("foo")); assertEquals("bar", propertyBasedCreator.getBeanProperty("bar")); assertEquals("bar", propertyBasedCreator.getBeanProperty("foo")); assertEquals("bar", propertyBasedCreator.getBeanProperty("bar")); assertEquals("bar", propertyBasedCreator.getBeanProperty("foo")); assertEquals("bar", propertyBasedCreator.getBeanProperty("bar")); assertEquals("bar", propertyBasedCreator.getBeanProperty("foo")); assertEquals("bar", propertyBasedCreator.getBeanProperty("bar")); assertEquals("bar", propertyBasedCreator.getBeanProperty("foo")); assertEquals("bar", propertyBasedCreator.getBeanProperty("bar")); assertEquals("bar", propertyBasedCreator.getBeanProperty("foo")); assertEquals("bar", propertyBased
@Test public void testPropertyBasedCreator() { ValueInstantiator valueInstantiator = new MockValueInstantiator(); TestBeanPropertyBasedCreator creator = new TestBeanPropertyBasedCreator(valueInstantiator); creator.testBeanProperty(); Object[] defaultValues = new Object[1]; PropertyBasedCreator propertyBasedCreator = new PropertyBasedCreator(valueInstantiator, creator.testBeanProperty(), defaultValues); assertEquals(defaultValues[0], propBasedCreator.defaultValues[0], 0); assertEquals(defaultValues[1], propBasedCreator.defaultValues[1], 0); assertEquals(defaultValues[2], propBasedCreator.defaultValues[2], 0); }
@Test public void testPropertyBasedCreator() { ValueInstantiator valueInstantiator = createMock(ValueInstantiator.class); SettableBeanProperty beanProperty = new SettableBeanProperty(); beanProperty.setName("foo"); beanProperty.setInjectableValueId(123); expect(valueInstantiator.newInstant()).andReturn(valueInstantiator); expect(valueInstantiator.newInstant()).andReturn(null); expect(beanProperty.getInjectableValueId()).andReturn(123); replay(valueInstantiator); PropertyBasedCreator propertyBasedCreator = new PropertyBasedCreator(valueInstantiator, null, null); verify(valueInstantiator); SettableBeanProperty beanProperty2 = new SettableBeanProperty(); beanProperty2.setName("bar"); beanProperty2.setInjectableValueId(123); expect(beanProperty2.newInstantiator()).andReturn(valueInstantiator); expect(beanProperty2.getInjectableValueId()).andReturn(123); replay(valueInstantiator); SettableBeanProperty beanProperty3 = new SettableBeanProperty(); beanProperty3.setName("baz"); beanProperty3.setInjectableValueId(123); expect(beanProperty3.newInstantiator()).andReturn(valueInstantiator); expect(beanProperty
@Test public void testPropertyBasedCreator() { ValueInstantiator valueInstantiator = new MockValueInstantiator(); SettableBeanProperty[] creatorProps = new SettableBeanProperty[]{new StringBeanProperty("foo"), new StringBeanProperty("bar")}; Object[] defaultValues = new Object[] { "foo", "bar" }; PropertyBasedCreator propertyBasedCreator = new PropertyBasedCreator(valueInstantiator, creatorProps, defaultValues); assertEquals("foo", propertyBasedCreator.getValueId()); assertEquals("bar", propertyBasedCreator.getInjectableValueId()); assertEquals("bar", propertyBasedCreator.getPropertiesWithInjectables[0].getName()); assertEquals("bar", propertyBasedCreator.getPropertiesWithInjectables[0].getValueId()); assertEquals("bar", propertyBasedCreator.getPropertiesWithInjectables[0].getInjectableValueId()); assertEquals("bar", propertyBasedCreator.getPropertiesWithInjectables[0].getInjectableValueId()); assertEquals("bar", propertyBasedCreator.getPropertiesWithInjectables[0].getInjectableValueId()); assertEquals("bar", propertyBasedCreator.getPropertiesWithInjectables[0].getInjectableValueId()); assertEquals("bar", propertyBasedCreator.getPropertiesWithInjectables[0].getInjectableValueId()); assertEquals("bar", propertyBasedCreator.
@Test public void testPropertyBasedCreator() { ValueInstantiator valueInstantiator = createMock(ValueInstantiator.class); SettableBeanProperty[] creatorProps = new SettableBeanProperty[]{new StringBeanProperty("foo"), new IntegerBeanProperty("bar")}; Object[] defaultValues = new Object[] {0, 1, 2, 3}; PropertyBasedCreator propertyBasedCreator = new PropertyBasedCreator(valueInstantiator, creatorProps, defaultValues); assertEquals(valueInstantiator, propertyBasedCreator.valueInstantiator); assertEquals(defaultValues, propertyBasedCreator.defaultValues); assertEquals(defaultValues.length, propertyBasedCreator.properties.length); assertEquals(defaultValues.length, propertyBasedCreator.properties.length); assertEquals(defaultValues.length, propertyBasedCreator.defaultValues.length); }
@Test public void testPropertyBasedCreator() { ValueInstantiator valueInstantiator = createMock(ValueInstantiator.class); SettableBeanProperty[] creatorProps = new SettableBeanProperty[]{new InjectableBeanProperty("foo", InjectableBeanProperty.class)}; Object[] defaultValues = new Object[] { "foo", "bar" }; PropertyBasedCreator propertyBasedCreator = new PropertyBasedCreator(valueInstantiator, creatorProps, defaultValues); assertEquals(valueInstantiator, propertyBasedCreator.valueInstantiator); assertEquals(defaultValues, propertyBasedCreator.defaultValues); }
@Test public void testPrimitive() throws JsonMappingException { JsonPrimitiveType expectedType = new JsonPrimitiveType(); expectedType.setPrimitiveType(true); SettableBeanProperty property = new SettableBeanProperty(); property.setType(expectedType); property.setValues(new Object[] {null, "test"}); PropertyBasedCreator creator = construct(new DeserializationContext(), new ValueInstantiator(property), new SettableBeanProperty[] {property}); Assert.assertEquals(expectedType, creator.getTypes().length); }
@Test public void testConstruct() throws JsonMappingException { final SettableBeanProperty property = new SettableBeanProperty(); property.setType(new ClacType("string")); property.setRawClac("string"); property.setRawClac("string"); property.setRawClac("string"); property.setNullValue(null); final PropertyBasedCreator creator = construct(new DeserializationContext(), new ValueInstantiator(property), new SettableBeanProperty[]{property}); Assert.assertEquals("string", creator.getCreator().getValue()); Assert.assertEquals("string", creator.getCreator().getRawClac()); Assert.assertEquals(null, creator.getCreator().getNullValue()); }
@Test public void testConstruct() throws JsonMappingException { ValueInstantiator valueInstantiator = createMock(ValueInstantiator.class); SettableBeanProperty property = new SettableBeanProperty(); expect(valueInstantiator.findContextualValueDeserializer(Bean.class, bean)).andReturn(new JsonDeserializer<Bean>() { @Override public Object getValue(DeserializationContext ctxt, SettableBeanProperty property) { return null; } }); expect(property.hasValueDeserializer()).andReturn(true); expect(property.getValueDeserializer()).andReturn(new JsonDeserializer<Bean>() { @Override public Object getValue(DeserializationContext ctxt, SettableBeanProperty property) { return null; } }); expect(valueInstantiator.findContextualValueDeserializer(Bean.class, property)).andReturn(new JsonDeserializer<Bean>() { @Override public Object getValue(DeserializationContext ctxt, SettableBeanProperty property) { return "foo"; } }); expect(property.hasValueDeserializer()).andReturn(true); expect(property.getValueDeserializer()).andReturn(new JsonDeserializer<Bean>() { @Override public Object getValue(DeserializationContext ctxt, SettableBeanProperty property) { return "bar"; } }); expect(property.
@Test public void testConstruct() throws JsonMappingException { class Bean { public String getBeanName() { return "Bean Name"; } public String getBeanVersion() { return "Bean Version"; } public String getBeanName() { return "Bean Version"; } public String getBeanVersion() { return "Bean Version"; } public Bean getBeanVersion() { return null; } public Bean getBeanVersion() { return null; } public Bean getBeanVersion() { return null; } public Bean getBeanVersion() { return null; } public Bean getBeanVersion() { return null; } public Bean getBeanVersion() { return null; } public Bean getBeanVersion() { return null; } public Bean getBeanVersion() { return null; } public Bean getBeanVersion() { return null; } public Bean getBeanVersion() { return null; } public Bean getBeanVersion() { return null; } public Bean getBeanVersion() { return null; } public Bean getBeanVersion() { return null; } public Bean getBeanVersion() { return null; } public Bean getBeanVersion() { return null; } public Bean getBeanVersion() { return null; } public Bean getBeanVersion() { return null; } public Bean getBeanVersion
@Test public void testConstruct() throws JsonMappingException { class TestBean implements Bean { public String getName() { return "name"; } public String getName() { return "name"; } public String getName() { return "name"; } public String getName() { return "name"; } public void setName(String name) { this.name = name; } public void setName(String name) { this.name = name; } public void setName(String name) { this.name = name; } } TestBean bean = new TestBean(); bean.setName("name"); bean.setAge(123); bean.setAge(123); bean.setAge(123); bean.setAge(123); bean.setAge(123); bean.setAge(123); bean.setAge(123); bean.setAge(123); bean.setAge(123); bean.setAge(123); bean.setAge(123); bean.setAge(123); bean.setAge(123); bean.setAge(123); bean.setAge(123); bean.setAge(123); bean.setAge(123); bean.setAge(123); bean.setAge(123); bean.setAge
@Test public void testConstruct() throws JsonMappingException { ValueInstantiator valueInstantiator = createMock(ValueInstantiator.class); SettableBeanProperty property = new SettableBeanProperty(); expect(valueInstantiator.findContextualValueDeserializer(Bean.class, property)).andReturn(new JsonDeserializer<Object>() { @Override public Object getValue(DeserializationContext ctxt, SettableBeanProperty property) { return null; } }); expect(property.hasValueDeserializer()).andReturn(true); expect(property.getValueDeserializer()).andReturn(new JsonDeserializer<Object>() { @Override public Object getValue(DeserializationContext ctxt, SettableBeanProperty property) { return "defaultValue"; } }); expect(valueInstantiator.findContextualValueDeserializer(Bean.class, property)).andReturn(new JsonDeserializer<Object>() { @Override public Object getValue(DeserializationContext ctxt, SettableBeanProperty property) { return "defaultValue"; } }); expect(property.hasValueDeserializer()).andReturn(true); expect(property.getValueDeserializer()).andReturn(new JsonDeserializer<Object>() { @Override public Object getValue(DeserializationContext ctxt, SettableBeanProperty property) { return "defaultValue"; } });
@Test public void testConstructWithPrimitive() throws JsonMappingException { JsonObject jsonObject = new JsonObject(); jsonObject.addProperty("stringProperty", "value"); jsonObject.addProperty("booleanProperty", true); jsonObject.addProperty("doubleProperty", 12.34); jsonObject.addProperty("dateTime", new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS")); jsonObject.addProperty("dateTime", new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS")); jsonObject.addProperty("dateTime", new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS")); jsonObject.addProperty("dateTime", new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS")); jsonObject.addProperty("dateTime", new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS")); jsonObject.addProperty("dateTime", new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS")); PropertyBasedCreator creator = construct(new JsonMappingContext(), new ValueInstantiator(jsonObject), new SettableBeanProperty[]{new SettableBeanProperty("stringProperty")}); Assert.assertEquals("value", creator.getStringProperty
@Test public void construct_Primitive() throws JsonMappingException { JsonPrimitiveType type = new JsonPrimitiveType(); type.setPrimitiveProperty("a"); JsonPrimitiveProperty prop = new JsonPrimitiveProperty("b"); prop.setPrimitiveProperty("c"); expect(valueInstantiator.get(type)).andReturn(prop); expect(prop.hasValueDeserializer()).andReturn(true); expect(prop.getValueDeserializer()).andReturn(new JsonDeserializer<?>(prop.getValueDeserializer())); expect(ctxt.findContextualValueDeserializer(type, prop)).andReturn(null); expect(ctxt.findContextualValueDeserializer(type, prop)).andReturn(prop); expect(ctxt.findContextualValueDeserializer(type, prop)).andReturn(null); expect(ctxt.findContextualValueDeserializer(type, prop)).andReturn(prop); expect(ctxt.findContextualValueDeserializer(type, prop)).andReturn(prop); expect(ctxt.findContextualValueDeserializer(type, prop)).andReturn(prop); expect(ctxt.findContextualValueDeserializer(type, prop)).andReturn(prop); expect(ctxt.findContextualValueDeserializer(type, prop)).andReturn(prop); expect(ctxt.
@Test public void construct_noDefaultValues() throws JsonMappingException { TestBeanProperty prop = new TestBeanProperty(); prop.setPrimitive(false); prop.setString("hello"); PropertyBasedCreator creator = construct(ctxt, valueInstantiator, new SettableBeanProperty[]{prop}); Assert.assertEquals(prop, creator.getCreatorBean()); }
@Test public void testConstruct() throws JsonMappingException { JsonDeserializer<?> deser = prop.getValueDeserializer(); Assert.assertNotNull(deser); Assert.assertTrue(deser instanceof JsonPrimitiveDeserializer); }
@Test public void testNullValue() throws JsonMappingException { ValueInstantiator valueInstantiator = new ValueInstantiator(new Class[]{NullValueDeserializer.class}); SettableBeanProperty[] srcProps = new SettableBeanProperty[1]; srcProps[0] = new SettableBeanProperty("null", new String[] {null}); srcProps[1] = new SettableBeanProperty("string", new String[] {null}); srcProps[2] = new SettableBeanProperty("int", new Integer[] {123}); srcProps[3] = new SettableBeanProperty("double", new Double[] {4.0}); srcProps[4] = new SettableBeanProperty("float", new Float[] {4.0}); srcProps[5] = new SettableBeanProperty("double", new Double[] {4.0}); srcProps[6] = new SettableBeanProperty("string", new String[] {null}); srcProps[7] = new SettableBeanProperty("null", new String[] {null}); PropertyBasedCreator creator = construct(new DeserializationContext(), valueInstantiator, srcProps); Assert.assertNull(creator.getNullValue()); }
@Test public void construct() throws JsonMappingException { JsonObject jsonObject = new JsonObject(); jsonObject.put("stringProperty", "value"); jsonObject.put("booleanProperty", true); jsonObject.put("doubleProperty", 12.34); jsonObject.put("dateTime", new Date(123)); jsonObject.put("booleanProperty", false); jsonObject.put("dateTime", new Date(123)); jsonObject.put("dateTime", new Date(123)); jsonObject.put("dateTime", new Date(123)); jsonObject.put("dateTime", new Date(123)); jsonObject.put("dateTime", new Date(123)); jsonObject.put("dateTime", new Date(123)); jsonObject.put("dateTime", new Date(123)); jsonObject.put("dateTime", new Date(123)); jsonObject.put("dateTime", new Date(123)); jsonObject.put("dateTime", new Date(123)); jsonObject.put("dateTime", new Date(123)); jsonObject.put("dateTime", new Date(123)); jsonObject.put("dateTime", new Date(123)); jsonObject.put("dateTime", new Date(123)); jsonObject.put("dateTime", new Date(123)); jsonObject.put("dateTime", new
@Test public void construct_nullValue() throws JsonMappingException { PropertyBasedCreator creator = construct("nullValue"); Assert.assertEquals("nullValue", creator.getCreatorProperty("nullValue").getValue()); }
@Test public void testConstructWithDefaultValue() throws JsonMappingException { class TestBean implements Bean { public String getName() { return "name"; } public String getName() { return "name"; } public String getName() { return "name"; } public void setName(String name) { this.name = name; } public void setName(String name) { this.name = name; } } TestBean bean = new TestBean(); bean.setName("name"); bean.setAge(123); bean.setAge(123); bean.setAge(123); bean.setAge(123); bean.setAge(123); bean.setName("name"); bean.setAge(123); bean.setAge(123); bean.setName("name"); bean.setAge(123); bean.setName("name"); bean.setAge(123); bean.setName("name"); bean.setAge(123); bean.setName("name"); bean.setAge(123); bean.setName("name"); bean.setAge(123); bean.setName("name"); bean.setAge(123); bean.setName("name"); bean.setAge(123); bean.setName("name
@Test public void testConstruct() throws JsonMappingException { class TestBean implements Bean { public String getName() { return "name"; } public String getName() { return "name"; } public String getName() { return "name"; } public String getName() { return "name"; } public String getName() { return "name"; } public void setName(String name) { this.name = name; } public void setName(String name) { this.name = name; } public void setName(String name) { this.name = name; } } TestBean bean = new TestBean(); bean.setName("name"); bean.setAge(123); bean.setAge(123); bean.setAge(123); bean.setName("name"); bean.setAge(123); bean.setAge(123); bean.setName("name"); bean.setAge(123); bean.setName("name"); bean.setAge(123); bean.setName("name"); bean.setAge(123); bean.setName("name"); bean.setAge(123); bean.setName("name"); bean.setAge(123); bean.setName("name"); bean.setAge(123); bean
@Test public void testDefaultValues() throws JsonMappingException { TestBeanProperty bean = new TestBeanProperty(); bean.setNullValue("test"); PropertyBasedCreator pp = construct(ctxt, valueInstantiator, new SettableBeanProperty[]{bean}); Assert.assertEquals("test", pp.getNullValue()); }
@Test public void testConstruct() throws JsonMappingException { ValueInstantiator valueInstantiator = createMock(ValueInstantiator.class); SettableBeanProperty[] srcProps = new SettableBeanProperty[]{new BeanProperty("a", "b"), new BeanProperty("c", "d")}; expect(valueInstantiator.instantiate(ctxt, srcProps)).andReturn(valueInstantiator); expect(valueInstantiator.getBean("a")).andReturn(null); expect(valueInstantiator.getBean("c")).andReturn(null); expect(valueInstantiator.getBean("d")).andReturn(null); expect(valueInstantiator.getBean("e")).andReturn(null); expect(valueInstantiator.getBean("f")).andReturn(null); expect(valueInstantiator.getBean("g")).andReturn(null); expect(valueInstantiator.getBean("h")).andReturn(null); expect(valueInstantiator.getBean("h")).andReturn(null); expect(valueInstantiator.getBean("i")).andReturn(null); expect(valueInstantiator.getBean("j")).andReturn(null); expect(valueInstantiator.getBean("k")).andReturn(
@Test public void testProperties() { Collection<SettableBeanProperty> properties = new TestBeanPropertyBasedCreator(valueInstantiator, new String[] { "foo", "bar" }, new Object[] { "baz" }); assertEquals(properties.size(), 3); assertTrue(properties.contains(new SettableBeanProperty("foo", "bar"))); assertTrue(properties.contains(new SettableBeanProperty("baz", "baz"))); }
@Test public void testProperties() { SettableBeanProperty c1 = new SettableBeanProperty("c1", "c1"); SettableBeanProperty c2 = new SettableBeanProperty("c2", "c2"); SettableBeanProperty c3 = new SettableBeanProperty("c3", "c3"); SettableBeanProperty c4 = new SettableBeanProperty("c4", "c4"); SettableBeanProperty c5 = new SettableBeanProperty("c5", "c5"); SettableBeanProperty c6 = new SettableBeanProperty("c6", "c6"); SettableBeanProperty c7 = new SettableBeanProperty("c7", "c7"); SettableBeanProperty c8 = new SettableBeanProperty("c8", "c8"); SettableBeanProperty c9 = new SettableBeanProperty("c9", "c9"); SettableBeanProperty c10 = new SettableBeanProperty("c10", "c10"); SettableBeanProperty c11 = new SettableBeanProperty("c11", "c11"); SettableBeanProperty c12 = new SettableBeanProperty("c12", "c12"); SettableBeanProperty c13 = new SettableBeanProperty("c
@Test public void findCreator() { SettableBeanProperty creator = new SettableBeanProperty("foo"); creator.addProperty("bar", "baz"); creator.addProperty("baz", "qux"); setter.findCreatorProperty("bar").set(creator); setter.findCreatorProperty("baz").set(creator); assertEquals("baz", setter.findCreatorProperty("bar").get()); assertEquals("qux", setter.findCreatorProperty("baz").get()); assertEquals("qux", setter.findCreatorProperty("qux").get()); }
@Test public void findCreatorProperty() { SettableBeanProperty creator = new SettableBeanProperty("foo", new String[] { "bar" }); _properties.put("foo", creator); assertEquals(creator, _creator.findCreatorProperty("foo")); assertEquals(creator, _creator.findCreatorProperty("bar")); }
@Test public void testStartBuildingInjectable() throws JsonMappingException { JsonParser jp = mock(JsonParser.class); DeserializationContext ctxt = mock(DeserializationContext.class); ObjectIdReader oir = mock(ObjectIdReader.class); PropertyValueBuffer actual = new PropertyBasedCreator(null, null, null).startBuilding(jp, ctxt, oir); verify(jp).inject(eq(Injectable.class)); assertEquals(actual, buffer); }
@Test public void testInjection() { PropertyValueBuffer buffer = new PropertyValueBuffer(jp, ctxt, _propertyCount, oir).startBuilding(jp, ctxt, null); assertEquals(0, buffer.injectCount); assertEquals(0, buffer.injectWithInjectables.size()); buffer.inject(Arrays.asList("foo", "bar")); assertEquals(0, buffer.injectWithInjectables.size()); }
@Test public void testInjection() { PropertyValueBuffer pp = new PropertyBasedCreator(valueInstantiator, new SettableBeanProperty[]{mockInjectableBeanProperty}, null).startBuilding(jp, ctxt, oir); assertEquals(0, pp.properties().size()); }
@Test public void testInjection() { PropertyValueBuffer buffer = new PropertyValueBuffer(_ctxt, 2, null); JsonParser jp = mock(JsonParser.class); DeserializationContext ctxt = mock(DeserializationContext.class); ObjectIdReader oir = mock(ObjectIdReader.class); expect(buffer.inject(_injectableProps)).andReturn(true); expect(oir.readObject()).andReturn(new Object[] { "foo" }); replay(jp, ctxt, oir); PropertyValueBuffer actual = buffer.startBuilding(jp, ctxt, oir); verify(jp, ctxt, oir); PropertyValueBuffer expected = new PropertyValueBuffer(_ctxt, 2, null); assertEquals(expected, actual); }
@Test public void testBuild() throws IOException { PropertyValueBuffer buffer = new PropertyValueBuffer(new String[] { "id", "string" }); PropertyValue bean = (PropertyValue) _testProps.build(_deserializationContext, buffer); assertEquals("string", bean.getString()); assertEquals("string", bean.getString()); assertEquals(true, bean.isBoolean()); bean = (PropertyValue) _testProps.build(_deserializationContext, buffer); assertEquals("string", bean.getString()); assertEquals(true, bean.isBoolean()); bean = (PropertyValue) _testProps.build(_deserializationContext, buffer); assertEquals("string", bean.getString()); assertEquals(true, bean.isBoolean()); bean = (PropertyValue) _testProps.build(_deserializationContext, buffer); assertEquals("string", bean.getString()); assertEquals(true, bean.isBoolean()); bean = (PropertyValue) _testProps.build(_deserializationContext, buffer); assertEquals("string", bean.getString()); assertEquals(true, bean.isBoolean()); bean = (PropertyValue) _testProps.build(_deserializationContext, buffer); assertEquals("string", bean.getString()); assertEquals(true, bean.isBoolean()); bean = (Property
@Test public void testId() throws Exception { PropertyValueBuffer buffer = new PropertyValueBuffer(new String[] { "id", "string" }, new String[] { "string" }); buffer.append(new String[] { "string" }); buffer.append(new String[] { "string" }); buffer.append(new String[] { "string" }); buffer.append(new String[] { "string" }); buffer.append(new String[] { "string" }); buffer.append(new String[] { "string" }); buffer.append(new String[] { "string" }); buffer.append(new String[] { "string" }); buffer.append(new String[] { "string" }); buffer.append(new String[] { "string" }); buffer.append(new String[] { "string" }); buffer.append(new String[] { "string" }); buffer.append(new String[] { "string" }); buffer.append(new String[] { "string" }); buffer.append(new String[] { "string" }); buffer.append(new String[] { "string" }); buffer.append(new String[] { "string" }); buffer.append(new String[] { "string" });
@Test public void testBuild() throws Exception { PropertyValueBuffer pv = new PropertyValueBuffer(new String[] { "foo", "bar" }, new String[] { "foo", "bar" }); PropertyBasedCreator creator = (PropertyBasedCreator) _construct.findCreator("foo"); creator.assign(new PropertyValueB(new String[] { "foo", "bar" }, new String[] { "foo" })); assertEquals("bar", creator.build(null, pv)); }
@Test public void testBuild() throws Exception { PropertyValueBuffer propertyValueBuffer = new PropertyValueBuffer(new String[] { "foo", "bar" }, new String[] { "foo", "bar" }, new String[] { "foo", "bar" }, new String[] { "foo", "bar" }, new String[] { "foo", "bar" }, new String[] { "foo", "bar" }, new String[] { "foo", "bar" }, new String[] { "foo", "bar" }, new String[] { "foo", "bar" }, new String[] { "foo", "bar" }, new String[] { "foo", "bar" }, new String[] { "foo", "bar" }, new String[] { "foo", "bar" }, new String[] { "foo", "bar" }, new String[] { "foo", "bar" }, new String[] { "foo", "bar" }, new String[] { "foo", "bar" }, new String[] { "foo", "bar" }, new String[] { "foo", "bar" }, new String[] { "foo", "bar" }, new String[] { "foo", "bar" }, new String
@Test public void testBuild() throws IOException { PropertyValueBuffer pb = newPropertyValueBuffer(); pb.addId("id"); pb.addValue("value"); pb.addId("anotherId"); pb.addValue("anotherValue"); pb.addId("id"); pb.addValue("anotherId"); DeserializationContext ctxt = mock(DeserializationContext.class); when(ctxt.isDeserializationSchemaCompatibleWith(any(Class.class))).thenReturn(true); PropertyValueBuffer pb2 = (PropertyValueBuffer) pb.build(ctxt, pb); assertEquals("id", pb2.getId()); assertEquals("value", pb2.getValue()); assertEquals("anotherId", pb2.getId()); assertEquals("anotherValue", pb2.getValue()); }
@Test public void testIsArray() { JsonNode[] nodes = new JsonNode[] { new JsonNode() { @Override public boolean isArray() { return true; } @Override public boolean isObject() { return false; } @Override public boolean isArray() { return false; } @Override public boolean isMissingNode() { return false; } @Override public boolean isArray() { return false; } @Override public JsonNodepath(int index) { return nodes[index]; } @Override public boolean isObject() { return false; } @Override public boolean isObject() { return false; } @Override public JsonNodepath(int index) { return nodes[index]; } @Override public boolean isObject() { return false; } @Override public boolean isObject() { return false; } @Override public boolean isObject() { return false; } @Override public boolean isArray() { return false; } @Override public boolean isObject() { return false; } @Override public boolean isArray() { return false; } @Override public boolean isObject() { return false; } @Override public boolean isArray() { return false; } @Override public boolean isArray() { return false; } @Override public boolean isArray() { return false; } @Override public boolean isArray
@Test public void testIsArray() { JsonNode[] nodes = new JsonNode[] { new JsonNode() }; Assert.assertTrue(nodes[0].isArray()); Assert.assertFalse(nodes[1].isArray()); Assert.assertFalse(nodes[2].isArray()); }
@Test public void testIsObject() { JsonNode node = JsonNode.valueOf(JSON_NODE); Assert.assertTrue(node.isObject()); }
@Test public void testIsObject() { JsonNode node = new ObjectMapper().readTree("{\"foo\":1,\"bar\":false}"); Assert.assertFalse(node.isObject()); }
@Test public void isFloatingPointNumber() { JsonNode instance = JsonNodeFactory.instance.instance.instanceNode(); Assert.assertFalse(instance.isFloatingPointNumber()); instance.setFloatingPointNumber(true); Assert.assertTrue(instance.isFloatingPointNumber()); instance.setFloatingPointNumber(false); Assert.assertFalse(instance.isFloatingPointNumber()); instance.setFloatingPointNumber(true); Assert.assertFalse(instance.isFloatingPointNumber()); }
@Test public void testIsTextual() { JsonNode[] nodes = new JsonNode[] { JsonNode.of("foo", JsonNode.of("bar", JsonNode.of("baz", JsonNode.of("foo", JsonNode.of("bar", JsonNode.of("baz", JsonNode.of("foo", JsonNode.of("bar", JsonNode.of("bar", JsonNode.of("baz", JsonNode.of("foo", JsonNode.of("bar", JsonNode.of("baz", JsonNode.of("foo", JsonNode.of("bar", JsonNode.of("baz", JsonNode.of("foo", JsonNode.of("bar", JsonNode.of("bar", JsonNode.of("baz", JsonNode.of("foo", JsonNode.of("bar", JsonNode.of("bar", JsonNode.of("baz", JsonNode.of("foo", JsonNode.of("bar", JsonNode.of("bar", JsonNode.of("bar", JsonNode.of("baz", JsonNode.of("foo", JsonNode.of("bar", JsonNode.of("bar", JsonNode.of("bar", JsonNode.of("baz", JsonNode.of("foo", JsonNode.of("bar", JsonNode.of("bar", JsonNode.of("bar", JsonNode.of("baz", JsonNode.of("
@Test public void testIsTextual() { JsonNode[] nodes = new JsonNode[] { new TextNode(), new TextNode() }; for (int i = 0; i < nodes.length; i++) { Assert.assertTrue(nodes[i].getNodeType() == JsonNodeType.STRING); } }
@Test public void has() { JsonNode node = JsonNode.of(new TextNode("test"), JsonNode.of(new TextNode("test"), JsonNode.of(new TextNode("test"), JsonNode.of(new TextNode("test")), JsonNode.of(new TextNode("test")), JsonNode.of(new TextNode("test")), JsonNode.of(new TextNode("test")), JsonNode.of(new TextNode("test")), JsonNode.of(new TextNode("test")), JsonNode.of(new TextNode("test")), JsonNode.of(new TextNode("test")), JsonNode.of(new TextNode("test")), JsonNode.of(new TextNode("test")), JsonNode.of(new TextNode("test")), JsonNode.of(new TextNode("test")), JsonNode.of(new TextNode("test")), JsonNode.of(new TextNode("test")), JsonNode.of(new TextNode("test")), JsonNode.of(new TextNode("test")), JsonNode.of(new TextNode("test")), JsonNode.of(new TextNode("test")), JsonNode.of(new TextNode("test")), JsonNode.of(new Text
@Test public void has_nonExistingField() { Assert.assertFalse( JsonNodeFactory.instance().object().has("nonExistingField")); }
@Test public void testIterator() throws Exception { Iterator<JsonNode> it = JsonNode.instance().iterator(); Assert.assertTrue(it.hasNext()); Assert.assertEquals(JsonNode.class, it.next().getClass()); Assert.assertFalse(it.hasNext()); }
@Test public void testIterator() throws Exception { Iterator<JsonNode> it = JsonNodeTest.elements(); while (it.hasNext()) { it.next(); } Iterator<JsonNode> it2 = JsonNodeTest.elements(); while (it2.hasNext()) { it2.next(); } Assert.assertFalse(it2.hasNext()); Assert.assertFalse(it1.hasNext()); Assert.assertFalse(it2.hasNext()); }
@Test public void findValues() { JsonNode instance = new TestNode(); List<JsonNode> values = instance.findValues("field1"); Assert.assertEquals(values.size(), 2); Assert.assertTrue(values.contains(instance)); Assert.assertTrue(values.contains(instance)); }
@Test public void findValues_emptyField() throws Exception { JsonNode instance = new TestNode(); List<JsonNode> values = instance.findValues("id"); Assert.assertEquals(0, values.size()); }
@Test public void findValues() { List<JsonNode> values = new ArrayList<JsonNode>(); values.add(new JsonNode()); values.add(new JsonNode()); values.add(new JsonNode()); values.add(new JsonNode()); values.add(new JsonNode()); values.add(new JsonNode()); values.add(new JsonNode()); values.add(new JsonNode()); values.add(new JsonNode()); values.add(new JsonNode()); List<JsonNode> actual = new ArrayList<JsonNode>(); actual.add(values); Assert.assertEquals(actual, values); Assert.assertEquals(actual.size(), values.size()); Assert.assertTrue(actual.contains(new JsonNode())); Assert.assertTrue(actual.contains(new JsonNode())); Assert.assertTrue(actual.contains(new JsonNode())); Assert.assertTrue(actual.contains(new JsonNode())); Assert.assertTrue(actual.contains(new JsonNode())); Assert.assertTrue(actual.contains(new JsonNode())); Assert.assertTrue(actual.contains(new JsonNode())); Assert.assertTrue(actual.contains(new JsonNode())); Assert.assertTrue(actual.contains(
@Test public void findValues() { Assert.assertTrue(JsonNode.valueOf(jsonNode.findValues("id").get(0)).isNumber()); Assert.assertTrue(JsonNode.valueOf(jsonNode.findValues("id").get(1)).isNumber()); Assert.assertTrue(JsonNode.valueOf(jsonNode.findValues("id").get(2)).isNumber()); Assert.assertTrue(JsonNode.valueOf(jsonNode.findValues("id").get(3)).isNumber()); Assert.assertTrue(JsonNode.valueOf(jsonNode.findValues("id").get(4).get(0)).isNumber()); Assert.assertTrue(JsonNode.valueOf(jsonNode.findValues("id").get(5)).isNumber()); Assert.assertTrue(JsonNode.valueOf(jsonNode.findValues("id").get(6).get(0)).isNumber()); Assert.assertTrue(JsonNode.valueOf(jsonNode.findValues("id").get(7).get(0)).isFloatingPointNumber()); Assert.assertTrue(JsonNode.valueOf(jsonNode.findValues("id").get(8).get(0)).isFloatingPointNumber()); Assert.assertTrue(JsonNode.valueOf(jsonNode.findValues
@Test public void testFindParents() { JsonNode instance = new TestNode(); List<JsonNode> parents = instance.findParents("id"); Assert.assertEquals(parent.size(), 2); Assert.assertEquals(parent.get(0), instance); Assert.assertEquals(parent.get(1), instance); Assert.assertEquals(parent.get(2), instance); Assert.assertEquals(parent.get(3), instance); Assert.assertEquals(parent.get(4), instance); Assert.assertEquals(parent.get(5), instance); Assert.assertEquals(parent.get(6), instance); Assert.assertEquals(parent.get(7), instance); Assert.assertEquals(parent.get(8), instance); Assert.assertEquals(parent.get(9), instance); }
@Test public void testFindParents() { JsonNode instance = new TestNode(); List<JsonNode> parents = instance.findParents("parent"); Assert.assertEquals(1, parents.size()); Assert.assertEquals(instance, parents.get(0)); }
@Test public void testFindParents() { JsonNode instance = new TestNode(); List<JsonNode> parents = instance.findParents("parent"); Assert.assertEquals(1, parents.size()); Assert.assertEquals(instance, parents.get(0)); }
@Test public void testFindParents() { Assert.assertTrue(JsonNode.valueOf(JsonNode.valueOf(JsonNode.NULL).toString()).isEmpty()); Assert.assertTrue(JsonNode.valueOf(JsonNode.valueOf(JsonNode.NULL).toString()).isEmpty()); Assert.assertTrue(JsonNode.valueOf(JsonNode.valueOf(JsonNode.NULL).toString()).isEmpty()); Assert.assertTrue(JsonNode.valueOf(JsonNode.valueOf(JsonNode.NULL).toString()).isEmpty()); Assert.assertTrue(JsonNode.valueOf(JsonNode.valueOf(JsonNode.NULL).toString()).isEmpty()); Assert.assertTrue(JsonNode.valueOf(JsonNode.valueOf(JsonNode.NULL).toString()).isEmpty()); Assert.assertTrue(JsonNode.valueOf(JsonNode.valueOf(JsonNode.NULL).toString()).isEmpty()); Assert.assertTrue(JsonNode.valueOf(JsonNode.valueOf(JsonNode.NULL).toString()).isEmpty()); Assert.assertTrue(JsonNode.valueOf(JsonNode.valueOf(JsonNode.NULL).toString()).isEmpty()); Assert.assertTrue(JsonNode.valueOf(JsonNode.valueOf(JsonNode.NULL).toString()).isEmpty()); Assert.assertTrue(JsonNode
@Test public void testFindClass() throws ClassNotFoundException { Class<?> clazz = findClass("int"); assertEquals(Integer.TYPE, clazz); clazz = findClass("long"); assertEquals(Long.TYPE, clazz); clazz = findClass("float"); assertEquals(Float.TYPE, clazz); clazz = findClass("double"); assertEquals(Double.TYPE, clazz); clazz = findClass("boolean"); assertEquals(Boolean.TYPE, clazz); clazz = findClass("char"); assertEquals(Character.TYPE, clazz); clazz = findClass("short"); assertEquals(Short.TYPE, clazz); clazz = findClass("int"); assertEquals(Integer.TYPE, clazz); clazz = findClass("long"); assertEquals(Long.TYPE, clazz); clazz = findClass("float"); assertEquals(Float.TYPE, clazz); clazz = findClass("double"); assertEquals(Double.TYPE, clazz); clazz = findClass("boolean"); assertEquals(Boolean.TYPE, clazz); clazz = findClass("byte"); assertEquals(Byte.TYPE, clazz); clazz = findClass("char"); assertEquals(Character.TYPE, clazz); clazz = findClass("short"); assertEquals(Short.TYPE, clazz); clazz = findClass("short"); assertEquals(Short.TYPE, clazz); }
@Test public void testFindClass() throws ClassNotFoundException { Class<?> clazz = findClass("long"); assertEquals(Long.TYPE, clazz); clazz = findClass("float"); assertEquals(Float.TYPE, clazz); clazz = findClass("double"); assertEquals(Double.TYPE, clazz); clazz = findClass("boolean"); assertEquals(Boolean.TYPE, clazz); clazz = findClass("char"); assertEquals(Character.TYPE, clazz); clazz = findClass("short"); assertEquals(Short.TYPE, clazz); clazz = findClass("int"); assertEquals(Integer.TYPE, clazz); clazz = findClass("long"); assertEquals(Long.TYPE, clazz); clazz = findClass("float"); assertEquals(Float.TYPE, clazz); clazz = findClass("double"); assertEquals(Double.TYPE, clazz); clazz = findClass("boolean"); assertEquals(Boolean.TYPE, clazz); clazz = findClass("byte"); assertEquals(Byte.TYPE, clazz); clazz = findClass("char"); assertEquals(Character.TYPE, clazz); clazz = findClass("short"); assertEquals(Short.TYPE, clazz); clazz = findClass("int"); assertEquals(Integer.TYPE, clazz); clazz = findClass("long"); assertEquals(Long.TYPE, clazz); clazz =
@Test public void testFindClass() throws ClassNotFoundException { Class<?> clazz = findClass("float.class"); assertEquals(Float.TYPE, clazz); clazz = findClass("boolean.class"); assertEquals(Boolean.TYPE, clazz); clazz = findClass("char.class"); assertEquals(Character.TYPE, clazz); clazz = findClass("short.class"); assertEquals(Short.TYPE, clazz); clazz = findClass("int".class); assertEquals(Integer.TYPE, clazz); clazz = findClass("long".class); assertEquals(Long.TYPE, clazz); clazz = findClass("float".class); assertEquals(Float.TYPE, clazz); clazz = findClass("double".class); assertEquals(Double.TYPE, clazz); clazz = findClass("float".class); assertEquals(Float.TYPE, clazz); clazz = findClass("boolean".class); assertEquals(Boolean.TYPE, clazz); clazz = findClass("byte".class); assertEquals(Byte.TYPE, clazz); clazz = findClass("char".class); assertEquals(Character.TYPE, clazz); clazz = findClass("short".class); assertEquals(Short.TYPE, clazz); clazz = findClass("int".class); assertEquals(Integer.TYPE, clazz); clazz = findClass
@Test public void testFindClass() throws ClassNotFoundException { Class<?> clazz = findClass("double.class"); assertEquals(Double.TYPE, clazz); clazz = findClass("boolean.class"); assertEquals(Boolean.TYPE, clazz); clazz = findClass("byte.class"); assertEquals(Byte.TYPE, clazz); clazz = findClass("char.class"); assertEquals(Character.TYPE, clazz); clazz = findClass("short.class"); assertEquals(Short.TYPE, clazz); clazz = findClass("int.class"); assertEquals(Integer.TYPE, clazz); clazz = findClass("long.class"); assertEquals(Long.TYPE, clazz); clazz = findClass("float.class"); assertEquals(Float.TYPE, clazz); clazz = findClass("double.class"); assertEquals(Double.TYPE, clazz); clazz = findClass("boolean.class"); assertEquals(Boolean.TYPE, clazz); clazz = findClass("byte".class); assertEquals(Byte.TYPE, clazz); clazz = findClass("char".class); assertEquals(Character.TYPE, clazz); clazz = findClass("short".class); assertEquals(Short.TYPE, clazz); clazz = findClass("int".class); assertEquals(Integer.TYPE, clazz); clazz = findClass
@Test public void testFindClass() throws ClassNotFoundException { Class<?> clazz = findClass("org.apache.cxf.tools.fortest.Foo.Bar"); assertNotNull(clazz); }
@Test public void testFindClass() throws ClassNotFoundException { Class<?> clazz = findClass("byte"); assertEquals(Byte.TYPE, clazz); clazz = findClass("char"); assertEquals(Character.TYPE, clazz); clazz = findClass("short"); assertEquals(Short.TYPE, clazz); clazz = findClass("int"); assertEquals(Integer.TYPE, clazz); clazz = findClass("long"); assertEquals(Long.TYPE, clazz); clazz = findClass("float"); assertEquals(Float.TYPE, clazz); clazz = findClass("double"); assertEquals(Double.TYPE, clazz); clazz = findClass("float"); assertEquals(Float.TYPE, clazz); clazz = findClass("double"); assertEquals(Double.TYPE, clazz); clazz = findClass("boolean"); assertEquals(Boolean.TYPE, clazz); clazz = findClass("byte"); assertEquals(Byte.TYPE, clazz); clazz = findClass("char"); assertEquals(Character.TYPE, clazz); clazz = findClass("short"); assertEquals(Short.TYPE, clazz); clazz = findClass("int"); assertEquals(Integer.TYPE, clazz); clazz = findClass("long"); assertEquals(Long.TYPE, clazz); clazz = findClass("float"); assertEquals(Float.TYPE, clazz); clazz =
@Test public void testFindClass() throws ClassNotFoundException { Class<?> clazz = findClass("char"); assertThat(clazz, is(Character.TYPE)); clazz = findClass("int"); assertThat(clazz, is(Integer.TYPE)); clazz = findClass("long"); assertThat(clazz, is(Long.TYPE)); clazz = findClass("float"); assertThat(clazz, is(Float.TYPE)); clazz = findClass("double"); assertThat(clazz, is(Double.TYPE)); clazz = findClass("boolean"); assertThat(clazz, is(Boolean.TYPE)); }
@Test public void testFindClass() throws ClassNotFoundException { Class<?> clazz = findClass("short"); assertEquals(Short.TYPE, clazz); clazz = findClass("int"); assertEquals(Integer.TYPE, clazz); clazz = findClass("long"); assertEquals(Long.TYPE, clazz); clazz = findClass("float"); assertEquals(Float.TYPE, clazz); clazz = findClass("double"); assertEquals(Double.TYPE, clazz); clazz = findClass("boolean"); assertEquals(Boolean.TYPE, clazz); clazz = findClass("char"); assertEquals(Character.TYPE, clazz); clazz = findClass("short"); assertEquals(Short.TYPE, clazz); clazz = findClass("short"); assertEquals(Short.TYPE, clazz); clazz = findClass("char"); assertEquals(Character.TYPE, clazz); clazz = findClass("short"); assertEquals(Short.TYPE, clazz); clazz = findClass("char"); assertEquals(Character.TYPE, clazz); clazz = findClass("short"); assertEquals(Short.TYPE, clazz); clazz = findClass("short"); assertEquals(Short.TYPE, clazz); }
@Test public void testFindClass() throws ClassNotFoundException { Class<?> clazz = findClass("void"); assertEquals(void.class, clazz); clazz = findClass("char"); assertEquals(char.class, clazz); clazz = findClass("int"); assertEquals(int.class, clazz); clazz = findClass("long"); assertEquals(long.class, clazz); clazz = findClass("float"); assertEquals(float.class, clazz); clazz = findClass("double"); assertEquals(double.class, clazz); clazz = findClass("float"); assertEquals(float.class, clazz); clazz = findClass("double"); assertEquals(double.class, clazz); clazz = findClass("boolean"); assertEquals(boolean.class, clazz); clazz = findClass("boolean"); assertEquals(boolean.class, clazz); clazz = findClass("byte"); assertEquals(byte.TYPE, clazz); clazz = findClass("char"); assertEquals(char.TYPE, clazz); clazz = findClass("short"); assertEquals(short.TYPE, clazz); clazz = findClass("short"); assertEquals(short.TYPE, clazz); clazz = findClass("int"); assertEquals(int.class, clazz); clazz = findClass("long"); assertEquals(long.class, clazz); clazz =
@Test public void getRootCause() { Throwable t = new Throwable(); t.setCause(new NullPointerException()); t.setCause(t); Throwable t2 = getRootCause(t); t2.setCause(t2); t2.setCause(t); Throwable t3 = getRootCause(t2); t3.setCause(t3); t3.setCause(t2); t3.setCause(t2); t2.setCause(t3); Throwable t4 = getRootCause(t4); t4.getCause(); t2.setCause(t3); t4.getCause(); }
@Test public void getRootCause() { Throwable t = new Throwable(); t.setCause(new RuntimeException("foo")); t.setCause(t); Throwable t2 = new Throwable(); t2.setCause(t2); t2.setCause(t2); Throwable t3 = new Throwable(); t3.setCause(t2); t3.setCause(t3); Throwable t4 = new Throwable(); t4.setCause(t3); t4.setCause(t4); t4.setCause(t5); t5.setCause(t6); t6.setCause(t7); t7.setCause(t8); t8.setCause(t9); t9.setCause(t1); t1.setCause(t2); t2.setCause(t3); t2.setCause(t4); t3.setCause(t5); t4.setCause(t6); t6.setCause(t7); t7.setCause(t8); t8.setCause(t9); t1.setCause(t1); t2.setCause(t2); t2.setCause(t3); t3.setCause(t4); t4.setCause(t5); t6.setCause(t6); t7.setCause(
@Test public void getRootCause() { Throwable t = new Throwable(); t.setCause(t); t.setCause(t); Throwable t2 = new Throwable(); t2.setCause(t2); t2.setCause(t2); Throwable t3 = new Throwable(); t3.setCause(t3); t3.setCause(t2); t3.setCause(t3); Throwable t4 = new Throwable(); t4.setCause(t4); t4.setCause(t5); t5.setCause(t6); t6.setCause(t7); t7.setCause(t8); t8.setCause(t9); t9.setCause(t10); t1.setCause(t2); t2.setCause(t3); t2.setCause(t4); t3.setCause(t5); t4.setCause(t6); t5.setCause(t7); t7.setCause(t8); t8.setCause(t9); t1.setCause(t10); t2.setCause(t2); t2.setCause(t3); t3.setCause(t4); t4.setCause(t5); t5.setCause(t6); t6.setCause(t7
@Test public void getRootCause() { Throwable t = new Throwable(); t.setCause(new.lang.RuntimeException("foo")); t.setCause(t); Throwable t2 = getRootCause(t); assertEquals(t, t2); }
@Test public void testThrowAsIAE() { try { throwAsIAE(new RuntimeException(), "msg"); } catch (RuntimeException e) { assertEquals("msg", e.getMessage()); } try { throwAsIAE(new Error(), "msg"); } catch (RuntimeException e) { assertEquals("msg", e.getMessage()); } try { throwAsIAE(new IllegalArgumentException(), "msg"); } catch (IllegalArgumentException e) { assertEquals("msg", e.getMessage()); } try { throwAsIAE(new IllegalArgumentException(), "msg"); } catch (IllegalArgumentException e) { assertEquals("msg", e.getMessage()); } try { throwAsIAE(new IllegalArgumentException(), "msg"); } catch (IllegalArgumentException e) { assertEquals("msg", e.getMessage()); } try { throwAsIAE(new IllegalArgumentException(), "msg"); } catch (IllegalArgumentException e) { assertEquals("msg", e.getMessage()); } try { throwAsIAE(new RuntimeException(), "msg"); } catch (RuntimeException e) { assertEquals("msg", e.getMessage()); } try { throwAsIAE(new Error(), "msg"); } catch (RuntimeException e) { assertEquals("msg", e.getMessage()); } try {
@Test public void testThrowAsIAE() { RuntimeException re = new RuntimeException(); try { throwAsIAE(re, "msg"); } catch (IllegalArgumentException e) { assertEquals("msg", e.getMessage()); } try { throwAsIAE(re, "msg"); } catch (RuntimeException e) { assertEquals("msg", e.getMessage()); } try { throwAsIAE(re, "msg"); } catch (RuntimeException e) { assertEquals("msg", e.getMessage()); } try { throwAsIAE(re, "msg"); } catch (RuntimeException e) { assertEquals("msg", e.getMessage()); } try { throwAsIAE(re, "msg"); } catch (RuntimeException e) { assertEquals("msg", e.getMessage()); } try { throwAsIAE(re, "msg"); } catch (RuntimeException e) { assertEquals("msg", e.getMessage()); } try { throwAsIAE(re, "msg"); } catch (RuntimeException e) { assertEquals("msg", e.getMessage()); } try { throwAsIAE(re, "msg"); } catch (RuntimeException e) { assertEquals("msg", e.getMessage()); } try { throwAsIAE(re, "msg
@Test public void testThrowAsIAE() { try { throwAsIAE(new RuntimeException(), "msg"); fail("Expected IllegalArgumentException to be thrown"); } catch (IllegalArgumentException e) { } try { throwAsIAE(new RuntimeException(), "msg"); fail("Expected IllegalArgumentException to be thrown"); } catch (IllegalArgumentException e) { } try { throwAsIAE(new RuntimeException(), "msg"); fail("Expected IllegalArgumentException to be thrown"); } catch (RuntimeException e) { } try { throwAsIAE(new RuntimeException(), "msg"); fail("Expected IllegalArgumentException to be thrown"); } catch (IllegalArgumentException e) { } try { throwAsIAE(new RuntimeException(), "msg"); fail("Expected IllegalArgumentException to be thrown"); } catch (RuntimeException e) { } }
@Test public void testUnwrapAndThrowAsIAE() { try { throw new RuntimeException("test"); } catch (RuntimeException ex) { } try { throw new RuntimeException("test"); } catch (RuntimeException ex) { } try { throw new RuntimeException("test"); } catch (RuntimeException ex) { } try { throw new RuntimeException("test"); } catch (RuntimeException ex) { } try { throw new RuntimeException("test"); } catch (RuntimeException ex) { } try { throw new RuntimeException("test"); } catch (RuntimeException ex) { } try { throw new RuntimeException("test"); } catch (RuntimeException ex) { } try { throw new RuntimeException("test"); } catch (RuntimeException ex) { } try { throw new RuntimeException("test"); } catch (RuntimeException ex) { } try { throw new RuntimeException("test"); } catch (RuntimeException ex) { } }
@Test public void testUnwrapAndThrowAsIAE() { RuntimeException t = new RuntimeException("foo"); try { throwAsIAE(t, "foo"); } catch (RuntimeException e) { assertEquals("foo", e.getMessage()); } }
@Test public void testCreateInstance_ctorHasNoDefault() { assertThrows(IllegalArgumentException.class, () -> createInstance(TestEnum.class, false)); }
@Test public void testCreateInstance_defaultConstructor() { String[] args = { "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int
@Test public void testCreateInstance() { new AssertThrows(IllegalArgumentException.class, () -> createInstance(Foo.class, false)); new AssertThrows(IllegalArgumentException.class, () -> createInstance(Foo.class, true)); new AssertThrows(IllegalArgumentException.class, () -> createInstance(Foo.class, false)); new AssertThrows(IllegalArgumentException.class, () -> createInstance(Foo.class, true)); new AssertThrows(IllegalArgumentException.class, () -> createInstance(Foo.class, true)); new AssertThrows(IllegalArgumentException.class, () -> createInstance(Foo.class, true)); new AssertThrows(IllegalArgumentException.class, () -> createInstance(Foo.class, true)); new AssertThrows(IllegalArgumentException.class, () -> createInstance(Foo.class, true)); new AssertThrows(IllegalArgumentException.class, () -> createInstance(Foo.class, true)); new AssertThrows(IllegalArgumentException.class, () -> createInstance(Foo.class, true)); new AssertThrows(IllegalArgumentException.class, () -> createInstance(Foo.class, true)); new AssertThrows(IllegalArgumentException.class, () -> createInstance(Foo.class, true)); new AssertThrows(IllegalArgumentException.class, () -> createInstance(Foo.class, true));
@Test public void testCreateInstance() { try { createInstance(Foo.class, false); fail("IllegalArgumentException expected"); } catch (IllegalArgumentException e) { } try { createInstance(Foo.class, true); fail("IllegalArgumentException expected"); } catch (IllegalArgumentException e) { } try { createInstance(Foo.class, false); fail("IllegalArgumentException expected"); } catch (IllegalArgumentException e) { } try { createInstance(Foo.class, true); fail("IllegalArgumentException expected"); } catch (IllegalArgumentException e) { } try { createInstance(Foo.class, false); fail("IllegalArgumentException expected"); } catch (IllegalArgumentException e) { } try { createInstance(Foo.class, true); fail("IllegalArgumentException expected"); } catch (IllegalArgumentException e) { } try { createInstance(Foo.class, true); fail("IllegalArgumentException expected"); } catch (IllegalArgumentException e) { } try { createInstance(Foo.class, true); fail("IllegalArgumentException expected"); } catch (IllegalArgumentException e) { } try { createInstance(Foo.class, true); fail("IllegalArgumentException expected"); } catch (IllegalArgumentException e) { } try { createInstance(Foo.class, true); fail("IllegalArgumentException expected"); } catch (IllegalArgumentException e
@Test public void testCreateInstance() { try { createInstance(Foo.class, false); fail("should have thrown IllegalArgumentException"); } catch (IllegalArgumentException iae) { } try { createInstance(Foo.class, true); fail("should have thrown IllegalArgumentException"); } catch (IllegalArgumentException iae) { } try { createInstance(Foo.class, true); fail("should have thrown IllegalArgumentException"); } catch (IllegalArgumentException iae) { } try { createInstance(Foo.class, true); fail("should have thrown IllegalArgumentException"); } catch (IllegalArgumentException iae) { } try { createInstance(Foo.class, true); fail("should have thrown IllegalArgumentException"); } catch (IllegalArgumentException iae) { } try { createInstance(Foo.class, true); fail("should have thrown IllegalArgumentException"); } catch (IllegalArgumentException iae) { } try { createInstance(Foo.class, true); fail("should have thrown IllegalArgumentException"); } catch (IllegalArgumentException iae) { } try { createInstance(Foo.class, true); fail("should have thrown IllegalArgumentException"); } catch (IllegalArgumentException iae) { } try { createInstance(Foo.class, true); fail("should have thrown IllegalArgumentException"); } catch (IllegalArgumentException iae) { } try { createInstance(
@Test public void testEnumTypeLocator() { EnumTypeLocator.createInstance(TestEnum.class, false); }
@Test public void testUnwrapAndThrowAsIAE() { try { ClassUtil.unwrapAndThrowAsIAE(IAE.class, "test"); fail("expected IllegalArgumentException"); } catch (IllegalArgumentException iae) { assertEquals("test has no default (no arg) constructor", iae.getMessage()); } }
@Test public void testPrivateConstructor() { Constructor<StringBuilder> ctor = findConstructor(StringBuilder.class, true); assertEquals("constructed", ctor.getName()); }
@Test public void testPrivateConstructor() { try { EnumTypeLocator.findConstructor(PrivateConstructor.class, true); fail("should fail with IllegalArgumentException"); } catch (IllegalArgumentException e) { } }
@Test public void testPrivateConstructor() { Constructor<StringBuilder> ctor = findConstructor(StringBuilder.class, true); assertNotNull(ctor); }
@Test public void testPrivateConstructor() { try { findConstructor(Foo.class, true); fail("should have thrown IllegalArgumentException"); } catch (IllegalArgumentException e) { } }
@Test public void testPrivateConstructor() { Constructor<Foo> ctor = findConstructor(Foo.class, true); assertEquals("default constructor for Foo should not be able to access private constructor", ctor.getDeclaringClass().getName(), " /lang/Foo.class"); }
@Test public void testPrivateConstructor() { Constructor<StringBuilder> ctor = Enu.findConstructor(StringBuilder.class, false); assertEquals("", ctor.getName()); Modifier modifier = Modifier.PUBLIC; ctor = Enu.findConstructor(ctor.getModifiers(), modifier); assertEquals("", ctor.getName()); }
@Test public void testPrivateConstructor() { IllegalArgumentException iae = assertThrows(IllegalArgumentException.class, () -> { Class<?> c = Class.forName("com.example.Foo<com.example.Bar>"); ctor = c.getConstructor(); ctor.getModifiers(); }); assertEquals("Default constructor for com.example.Foo is not accessible (non-public?): not allowed to try modify access via Reflection: can not instantiate type", iae.getMessage()); }
@Test public void testPrivateConstructor() throws Exception { Constructor<Foo> ctor = findConstructor(Foo.class, true); assertNotNull(ctor); }
@Test public void testPrivateConstructor() { Constructor<Foo> ctor = findConstructor(Foo.class, true); assertNotNull(ctor); assertEquals(Foo.class.getDeclaredConstructor(), ctor); }
@Test public void testPrivateConstructor() { try { ClassUtil.unwrapAndThrowAsIAE(Foo.class, true); fail("Should not be able to find default constructor of class " + Foo.class.getName() + ""); } catch (IllegalArgumentException iae) { } }
@Test public void testPrivateConstructor() throws Exception { Constructor ctor = EnumTypeLocator.findConstructor(PrivateConstructor.class, true); assertNotNull(ctor); }
@Test public void testWrapperType() { Class<?> primitiveType = Integer.class; Class<?> wrapperType = [LINE].wrapperType(primitiveType); assertEquals(Integer.class, wrapperType); primitiveType = Long.class; wrapperType = [LINE].wrapperType(primitiveType); assertEquals(Long.class, wrapperType); primitiveType = Boolean.TYPE; wrapperType = [LINE].wrapperType(primitiveType); assertEquals(Boolean.class, wrapperType); primitiveType = Float.class; wrapperType = [LINE].wrapperType(primitiveType); assertEquals(Float.class, wrapperType); primitiveType = Double.class; wrapperType = [LINE].wrapperType(primitiveType); assertEquals(Double.class, wrapperType); primitiveType = Float.class; wrapperType = [LINE].wrapperType(primitiveType); assertEquals(Float.class, wrapperType); primitiveType = Byte.TYPE; wrapperType = [LINE].wrapperType(primitiveType); assertEquals(Byte.class, wrapperType); primitiveType = Short.TYPE; wrapperType = [LINE].wrapperType(primitiveType); assertEquals(Short.class, wrapperType); }
@Test public void wrapperType() { Class<?> primitiveType = Integer.class; Class<?> wrapperType = wrapperType(primitiveType); assertEquals(Integer.class, wrapperType); primitiveType = Long.class; wrapperType = wrapperType(primitiveType); assertEquals(Long.class, wrapperType); primitiveType = Boolean.TYPE; wrapperType = wrapperType(primitiveType); assertEquals(Boolean.class, wrapperType); primitiveType = Boolean.TYPE; wrapperType = wrapperType(primitiveType); assertEquals(Boolean.class, wrapperType); primitiveType = Double.TYPE; wrapperType = wrapperType(primitiveType); assertEquals(Double.class, wrapperType); primitiveType = Float.TYPE; wrapperType = wrapperType(primitiveType); assertEquals(Float.class, wrapperType); primitiveType = Double.TYPE; wrapperType = wrapperType(primitiveType); assertEquals(Double.class, wrapperType); primitiveType = Byte.TYPE; wrapperType = wrapperType(primitiveType); assertEquals(Byte.class, wrapperType); primitiveType = Byte.TYPE; wrapperType = wrapperType(primitiveType); assertEquals(Byte.class, wrapperType); primitiveType = Short.TYPE; wrapperType = wrapperType(primitiveType); assertEquals(
@Test public void wrapperType() { assertThat(wrapperType(Integer.TYPE), is(Integer.class)); assertThat(wrapperType(Integer.TYPE), is(Integer.class)); assertThat(wrapperType(Long.TYPE), is(Long.class)); assertThat(wrapperType(Boolean.TYPE), is(Boolean.class)); assertThat(wrapperType(Boolean.TYPE), is(Boolean.class)); assertThat(wrapperType(Double.TYPE), is(Double.class)); assertThat(wrapperType(Double.TYPE), is(Double.class)); assertThat(wrapperType(Float.TYPE), is(Float.class)); assertThat(wrapperType(Float.TYPE), is(Float.class)); assertThat(wrapperType(Byte.TYPE), is(Byte.class)); assertThat(wrapperType(Byte.TYPE), is(Byte.class)); assertThat(wrapperType(Character.TYPE), is(Character.class)); assertThat(wrapperType(Character.TYPE), is(Character.class)); assertThat(wrapperType(String.class), is(String.class)); assertThat(wrapperType(String.class), is(String.class)); assertThat(wrapperType(String.class), is(String.class)); assertThat(wrapperType(String.
@Test public void wrapperType() { Class<?> wrapperType = wrapperType(Long.TYPE); assertEquals(Integer.class, wrapperType); try { wrapperType(Integer.TYPE); fail(); } catch (IllegalArgumentException expected) { } try { wrapperType(Integer.TYPE); fail(); } catch (IllegalArgumentException expected) { } try { wrapperType(Integer.TYPE); fail(); } catch (IllegalArgumentException expected) { } try { wrapperType(Boolean.TYPE); fail(); } catch (IllegalArgumentException expected) { } try { wrapperType(Boolean.TYPE); fail(); } catch (IllegalArgumentException expected) { } try { wrapperType(Double.TYPE); fail(); } catch (IllegalArgumentException expected) { } try { wrapperType(Double.TYPE); fail(); } catch (IllegalArgumentException expected) { } try { wrapperType(Float.TYPE); fail(); } catch (IllegalArgumentException expected) { } try { wrapperType(Float.TYPE); fail(); } catch (IllegalArgumentException expected) { } try { wrapperType(Float.TYPE); fail(); } catch (IllegalArgumentException expected) { } try { wrapperType(Float.TYPE); fail(); } catch (IllegalArgumentException expected) { } try { wrapperType(Float
@Test public void wrapperType() { assertThat(wrapperType(Long.class), is(Long.class)); assertThat(wrapperType(Integer.class), is(Integer.class)); assertThat(wrapperType(Long.class), is(Long.class)); assertThat(wrapperType(Boolean.class), is(Boolean.class)); assertThat(wrapperType(Boolean.TYPE), is(Boolean.class)); assertThat(wrapperType(Double.class), is(Double.class)); assertThat(wrapperType(Double.TYPE), is(Double.class)); assertThat(wrapperType(Float.class), is(Float.class)); assertThat(wrapperType(Float.TYPE), is(Float.class)); assertThat(wrapperType(Byte.TYPE), is(Byte.class)); assertThat(wrapperType(Byte.TYPE), is(Byte.class)); assertThat(wrapperType(Byte.TYPE), is(Byte.class)); assertThat(wrapperType(Short.TYPE), is(Short.class)); assertThat(wrapperType(Short.TYPE), is(Short.class)); assertThat(wrapperType(Character.TYPE), is(Character.class)); assertThat(wrapperType(Character.TYPE), is(Character.class)); }
@Test public void testCheckAndFixAccess() throws NoSuchMethodException { Class<?> outer = EnumTypeLocatorTest.class; Class<?> inner = outer.getDeclaringClass(); try { [LINE] checkAndFixAccess(inner); fail("Expected IllegalArgumentException"); } catch (IllegalArgumentException iae) { } try { [LINE] checkAndFixAccess(outer.getDeclaringClass()); fail("Expected IllegalArgumentException"); } catch (IllegalArgumentException iae) { } }
@Test public void testCheckAndFixAccess() throws NoSuchMethodException { AccessibleObject ao = mock(AccessibleObject.class); try { mockAccessibleObject(ao); fail("Expected IllegalArgumentException"); } catch (IllegalArgumentException iae) { } mockAccessibleObject(AccessibleObject.class, "foo"); try { mockAccessibleObject(ao); fail("Expected IllegalArgumentException"); } catch (IllegalArgumentException iae) { } mockAccessibleObject(AccessibleObject.class, "bar"); try { mockAccessibleObject(nonAccessibleObject); fail("Expected IllegalArgumentException"); } catch (IllegalArgumentException iae) { } mockAccessibleObject(NonAccessibleObject.class, "foo"); try { mockAccessibleObject(nonAccessibleObject, "bar"); fail("Expected IllegalArgumentException"); } catch (IllegalArgumentException iae) { } mockAccessibleObject(Class.class, "foo"); try { mockAccessibleObject(NonAccessibleObject.class, "bar"); fail("Expected IllegalArgumentException"); } catch (IllegalArgumentException iae) { } mockAccessibleObject(Class.class, "foo"); try { mockAccessibleObject(NonAccessibleObject.class, "bar"); fail("Expected IllegalArgumentException"); } catch (IllegalArgumentException iae) { } mockAccessibleObject(Class.class, "bar"); try
@Test public void testCheckAndFixAccess() throws NoSuchMethodException { Class<?> a = Enum.class; try { Enum.checkAndFixAccess(a); fail("Expected IllegalArgumentException"); } catch (IllegalArgumentException iae) { } }
@Test public void testCheckAndFixAccess() throws NoSuchMethodException { Class<?> a = EnumTypeLocatorTest.class; AccessibleObject a2 = (AccessibleObject) a.getDeclaredMethod("accessAccessibleObject"); [LINE] checkAndFixAccess(a2); try { a2.setAccessible(false); fail("Expected IllegalArgumentException"); } catch (IllegalArgumentException iae) { } }
@Test public void testEnumSetSerializer() throws Exception { class TestEnumSetSerializer extends EnumSetSerializer { [LINE] public EnumSetSerializer(EnumSetSerializer src, BeanProperty property) { super(src, property); } } TestEnumSetSerializer src = new TestEnumSetSerializer(); EnumSetSerializer dst = new EnumSetSerializer(EnumSet.class, null); dst.serializeContents(EnumSet.ONE, jgen, new DefaultSerializerProvider()); jgen.flush(); TypeSerializer vts = new TypeSerializerProviderImpl(); dst.serializeContents(EnumSet.ONE, jgen, vts); TypeSerializer vts2 = new TypeSerializerProviderImpl(); dst.serializeContents(EnumSet.ONE, jgen, vts2); jgen.flush(); assertEquals("{\"one\":{\"class\":\"uk.gov.gchq.gaffer.operation.EnumSet\",\"name\":\"ONE\",\"value\":\"ONE\"}}", Files.toString(src.toByteArray())); }
@Test public void testEnumSerializer() throws Exception { TypeSerializer vts = new TypeSerializerImpl(); BeanProperty property = new BeanProperty(EnumSet.class, "foo", true, null, null); EnumSetSerializer serializer = new EnumSetSerializer(EnumSet.class, property); assertEquals(SerializerType.EOL, serializer.serialize(EnumSet.ONE, null, null)); assertEquals(SerializerType.EOL, serializer.serialize(EnumSet.TWO, null, null)); assertEquals(SerializerType.EOL, serializer.serialize(EnumSet.THREE, null, null)); assertEquals(SerializerType.EOL, serializer.serialize(EnumSet.EIGHT, null, null)); assertEquals(SerializerType.EOL, serializer.serialize(EnumSet.THREE, null, null)); }
@Test public void enumSetSerializer() throws Exception { EnumSetSerializer src = new EnumSetSerializer(EnumSet.BOTH); EnumSetSerializer result = new EnumSetSerializer(src, null, null); assertThat(result, is(src)); }
@Test public void enumSetSerializer() throws Exception { EnumSetSerializer src = new EnumSetSerializer(JavaType.getEnumSet("FOO"), new JsonObject()); EnumSetSerializer serializer = new EnumSetSerializer(src, new JsonObjectBeanProperty(JavaType.getEnumSet("BAR"), "baz")); assertEquals(src, serializer); }
@Test public void it_generates_EnumSet_when_Resolved_withResolved() throws Exception { EnumSetSerializer src = new EnumSetSerializer(EnumSet.class, null); EnumSetSerializer result = new EnumSetSerializer(EnumSet.class, new BeanProperty(EnumSet.class, "foo", EnumSet.class)); assertThat(result.withResolved(new BeanProperty(EnumSet.class, "bar", EnumSet.class), new TypeSerializerImpl(), null)).isEqualTo(src); }
@Test public void enumSet_enumSet_serializer_for_enumSet_is_serializable_with_resolved_bean_property() throws Exception { ElementSetSerializer mockedVfs = new ElementSetSerializer(JavaType.getEnumSet(TestEnumSet.class)); BeanProperty beanProperty = new BeanProperty(TestEnumSet.class, "foo", "bar"); TypeSerializer mockedElementSerializer = mockedVfs.getSerializer(); EnumSetSerializer enumSetSerializer = new EnumSetSerializer(JavaType.getEnumSet(TestEnumSet.class), beanProperty); enumSetSerializer.serializeContents(TestEnumSet.values(), mockedElementSerializer, null); assertThat(enumSetSerializer.getEnumSet()).hasSize(1); }
@Test public void testStdDelegatingDeserializer() throws Exception { Converter<Object, String> converter = new Converter<Object, String>() { @Override public String toJson(Object value) { return String.valueOf(value); } }; JsonDeserializer<String> deserializer = new JsonDeserializer<String>() { @Override public String from(Object value) { return String.valueOf(value); } }; StdDelegatingDeserializer<String> actual = new StdDelegatingDeserializer<String>(converter, JavaTypes.STRING, deserializer); assertEquals(actual.getDelegateType(), String.class); assertEquals(actual.getDelegateDeserializer(), String.class); }
@Test public void testStdDelegatingDeserializer() throws Exception { Converter<Object, String> converter = mock(Converter.class); JsonDeserializer<Object> deserializer = mock(JsonDeserializer.class); when(converter.deserialize(any(Object.class))).thenReturn(new Object()); StdDelegatingDeserializer<Object> actual = new StdDelegatingDeserializer<Object, String>(converter, JavaTypes.STRING, deserializer); assertEquals(actual, new Object()); }
@Test public void testStdDelegatingDeserializer() throws Exception { Converter<Object, String> converter = new Converter<Object, String>() { @Override public String toJson(Object value) { return String.valueOf(value); } }; JsonDeserializer<Object> deserializer = new JsonDeserializer<Object>() { @Override public void read(Object value, JsonMappingContext context) throws JsonMappingException { } }; StdDelegatingDeserializer<Object>DelegatingDeserializer<Object> actual = new StdDelegatingDeserializer<Object>(converter, JavaType.OBJECT, deserializer); Assert.assertEquals(actual.getDelegateType(), Object.class); Assert.assertEquals(actual.getDelegateDeserializer(), deserializer); }
@Test public void testStdDelegatingDeserializer() throws Exception { Converter<Object, String> converter = new Converter<Object, String>() { @Override public String toJson(Object value) { return String.valueOf(value); } }; JsonDeserializer<Object> deserializer = new JsonDeserializer<Object>() { @Override public void read(Object value, JsonMappingContext context) throws JsonMappingException { } }; StdDelegatingDeserializer<Object> actual = new StdDelegatingDeserializer<Object>(converter, JavaType.OBJECT, deserializer); Assert.assertEquals(actual.getDelegateType(), Object.class); Assert.assertEquals(actual.getConverter(), converter); Assert.assertEquals(actual.getDeserializer(), deserializer); }
@Test public void testStdDelegatingDeserializer() throws Exception { Converter<Object, String> converter = new Converter<Object, String>() { @Override public String toJson(Object value) { return value.toString(); } }; JsonDeserializer<Object> deserializer = new StdDelegatingDeserializer<Object>(converter, JavaTypes.STRING, null); assertThat(deserializer.deserialize(new StringReader(value.toString()), null), is(value)); }
@Test public void shouldResolve() throws JsonMappingException { new Expectations() { { DEFINALIZER.resolve(null); } }; }
@Test public void testResolve() throws Exception { Converter<Object, Object> converter = new Converter<Object, Object>() { @Override public Object convert(Object value) throws JsonMappingException { return value; } }; StdDelegatingDeserializer<Object> deserializer = new StdDelegatingDeserializer<Object, Object>(converter, Object.class, null); deserializer.resolve(_ctxt); }
@Test public void createContextual_null() throws JsonMappingException { JsonDeserializer<?> deser = _deser.createContextual(_ctxt, null); assertThat(deser, nullValue()); }
@Test public void createContextual() throws Exception { Converter<Object, Object> converter = new BaseConverter<Object, Object>(new TypeConverter<Object, Object>() { }); ContextualDeserializer contextual = mock(ContextualDeserializer.class); when(contextual.createContextual(any(BeanProperty.class), any(DeserializationContext.class))).thenReturn(null); JsonDeserializer<?> deser = converter.createContextual(contextual, null); verify(contextual).createContextual(any(BeanProperty.class), any(DeserializationContext.class)); assertThat(deser, is(nullValue())); }
@Test public void createContextual() throws Exception { ContextualDeserializer deser = (ContextualDeserializer) _deser.createContextual(_ctxt, null); assertThat(deser, instanceOf(ContextualDeserializer.class)); }
@Test public void createContextual() throws Exception { TypeFactory typeFactory = new TypeFactory(); TypeDeserializer<Object> contextualDeserializer = typeFactory.createDeserializer(String.class); Converter<Object, Object> converter = new Converter<Object, Object>(typeFactory); JsonDeserializer<?> deser = (JsonDeserializer<?>) converter.createContextual(contextualDeserializer, BeanProperty.of("foo")); JsonDeserializer<?> contextualDeserializer = (JsonDeserializer<?>) converter.createContextual(contextualDeserializer, BeanProperty.of("bar")); assertEquals(deser, contextualDeserializer); }
@Test public void should_return_null_when_deserialize_with_null_value() throws Exception { DeserializationContext mockContext = mock(DeserializationContext.class); when(mockContext.getDeserializer()).thenReturn(null); String value = _simpleDeserializer.deserialize(_jp, mockContext); assertThat(value).isNull(); }
@Test public void should_return_null_when_deserialize_with_null() throws Exception { when(_delegateDeserializer.deserialize(jp, _ctxt)).thenReturn(null); assertThat(new Object()).isNull(); }
@Test public void null_deserialize_returns_null() throws Exception { MockDeserializer mockDeserializer = new MockDeserializer(); when(_delegateDeserializer.deserialize(null, _ctxt)).thenReturn(null); Object result = _delegateDeserializer.deserialize(_jp, _ctxt); assertThat(result).isNull(); }
@Test public void should_returnNull_when_null_deserialize_with_null_value() throws Exception { when(_delegateDeserializer.deserialize(jp, _ctxt)).thenReturn(null); Object result = _delegateDeserializer.deserialize(jp, _ctxt); assertThat(result).isNull(); }
@Test public void testConvertValue() { Converter<Object, String> mockConverter = mock(Converter.class); when(mockConverter.convert(any(Object.class))).thenReturn("value"); assertEquals("value", _delegate.convertValue("value")); verify(mockConverter).convert("value"); verifyNoMoreInteractions(mockConverter); }
@Test public void convertValue() throws Exception { Converter<Object, String> mockConverter = mock(Converter.class); when(mockConverter.convert(any(Object.class))).thenReturn("value"); when(mockConverter.convert("value")).thenReturn("value2"); assertEquals("value", _delegate.convertValue("value")); verify(mockConverter).convert("value"); verify(mockConverter).convert("value"); verifyNoMoreInteractions(mockConverter); }
@Test public void getSchema() throws Exception { class Test implements JsonSerializer<Object> { @Override public void serialize(Object obj, JsonNode expectedNode) throws JsonMappingException { Assert.assertEquals(expectedNode, JsonSerializerFactory.instance.objectNode()); } } Test implements JsonSerializer<Object> { @Override public void serialize(Object obj, JsonNode expectedNode) throws JsonMappingException { Assert.assertEquals(expectedNode, JsonSerializerFactory.instance.objectNode()); } } Test implements JsonSerializer<Object> { @Override public void serialize(Object obj, JsonNode expectedNode) throws JsonMappingException { Assert.assertEquals(expectedNode, JsonSerializerFactory.instance.objectNode()); } } Test implements JsonSerializer<Object> { @Override public void serialize(Object obj, JsonNode expectedNode) throws JsonMappingException { Assert.assertEquals(expectedNode, JsonSerializerFactory.instance.objectNode()); } } Test implements JsonSerializer<Object> { @Override public void serialize(Object obj, JsonNode expectedNode) throws JsonMappingException { Assert.assertEquals(expectedNode, JsonSerializerFactory.instance.objectNode()); } } Test implements JsonSerializer<Object> { @Override public void serialize(Object obj, JsonNode expectedNode
@Test public void testEnum() throws Exception { String json = "{\"name\": \"Joe\",\"age\":31}"; JsonSerializerProvider provider = new JsonSerializerProvider(); provider.setFieldOrder(JsonSchema.class, true); ObjectNode schemaNode = factory.getSchema(provider, String.class); JsonNode expected = Json.createObjectNode(); expected.add("name", "Joe"); expected.add("age", 31); expected.add("age", 32); expected.add("name", "Joe"); schemaNode.set("name", "Joe"); schemaNode.set("age", 32); JsonNode actual = schemaNode.getSchema(provider, String.class); assertEquals(expected, actual); }
@Test public void getSchema() throws Exception { JsonNode schemaNode = factory.instance.objectNode(); JsonNode expected = factory.instance.objectNode(); expected.add("name", "John Doe"); expected.add("age", 31); expected.add("type", "string"); expected.add("enum", "com.example.MyEnum"); JsonNode actual = schemaNode.getSchema(provider, String.class); assertEquals(expected, actual); }
@Test public void testEnum() throws Exception { JsonNode schemaNode = factory.instance.objectNode(); JsonNode schema = schemaNode.get("object"); JsonNode expected = factory.instance.objectNode(); expected.set("status", "OK"); expected.set("message", "OK"); assertEquals(expected, schema); }
@Test public void testGetSchema() throws Exception { String schema = "{\"name\": \"Peter\"}"; Type typeHint = new ParameterizedType() { @Override public Type[] getActualTypeArguments() { return new Type[]{String.class}; } @Override public Type getRawType() { return String.class; } @Override public Type getOwnerType() { return null; } }; JsonSerializerProvider provider = mock(JsonSerializerProvider.class); JsonSchema schemaNode = new JsonSchema(schema); ObjectNode schemaNode2 = schemaNode.getSchema(provider, typeHint); assertEquals(schemaNode.get("name").asText(), "Peter"); assertEquals(schemaNode.get("name").asText(), "Peter"); assertEquals(schemaNode.get("name").asText(), "Peter"); assertEquals(schemaNode.get("name").asText(), "Peter"); assertEquals(schemaNode.get("name").asText(), "Peter"); assertEquals(schemaNode.get("name").asText(), "Peter"); assertEquals(schemaNode.get("name").asText(), "Peter"); assertEquals(schemaNode.get("name").asText(), "Peter"); assertEquals(schemaNode.get("name").
@Test public void enumType() throws Exception { String schema = "{\"type\":\"enum\",\"enum\":[\"A\", \"B\"]}"; JsonSerializerProvider mockSerializerProvider = mock(JsonSerializerProvider.class); when(mockSerializerProvider.constructType(any(ParameterizedType.class))).thenReturn(JsonType.enumType(List.class)); JsonNode schemaNode = factory.objectNode(); schemaNode.set("enum", Json.createObjectNode()); schemaNode.set("enum", Json.createArrayNode()); schemaNode.set("enum", Json.createArrayNode()); schemaNode.set("enum", Json.createArrayNode()); schemaNode.set("enum", Json.createArrayNode()); schemaNode.set("enum", Json.createArrayNode()); schemaNode.set("enum", Json.createArrayNode()); schemaNode.set("enum", Json.createArrayNode()); schemaNode.set("enum", Json.createArrayNode()); schemaNode.set("enum", Json.createArrayNode()); schemaNode.set("enum", Json.createArrayNode()); schemaNode.set("enum", Json.createArrayNode()); schemaNode.set("enum", Json.createArrayNode()); schemaNode
@Test public void testEnum() throws Exception { Type typeHint = new ParameterizedType() { @Override public Type getRawType() { return String.class; } @Override public Type getOwnerType() { return String.class; } @Override public Type getOwnerType() { return Object.class; } @Override public Type getOwnerType() { return Object.class; } @Override public <T> T getRawType() { return T.class; } @Override public <T> T getOwnerType() { return null; } @Override public <T> T getOwnerType() { return null; } @Override public <T> T getOwnerType() { return null; } @Override public <T> T getOwnerType() { return null; } @Override public <T> T getOwnerType() { return null; } @Override public <T> T getOwnerType() { return null; } @Override public <T> T getOwnerType() { return null; } @Override public <T> T getOwnerType() { return null; } @Override public <T> T getOwnerType() { return null; } @Override public <T> T get(Class<T> clazz) { return null; } @Override public <T> T get
@Test public void testGetSchema() throws Exception { String schema = "{\"name\": \"Alice\", \"age\": 31}"; Type type = new ParameterizedType() { @Override public Type[] getActualTypeArguments() { return new Type[]{String.class}; } @Override public Type getRawType() { return Object.class; } @Override public Type getOwnerType() { return null; } @Override public Type getOwnerType() { return null; } @Override public Type getOwnerType() { return null; } @Override public <T> T get(Class<? extends T> clazz) { return null; } @Override public <T> T get(Class<? extends T> clazz) { return null; } @Override public <T> T get(Class<? extends T> clazz) { return null; } @Override public <T> T get(Class<? extends T> clazz) { return null; } @Override public <T> T get(Class<? extends T> clazz) { return null; } @Override public <T> T get(Class<? extends T> clazz) { return null; } @Override public <T> T get(Class<? extends T> clazz) { return null; } @Override public <
@Test public void testGetSchema() throws Exception { Type typeHint = new ParameterizedType() { @Override public Type getRawType() { return String.class; } @Override public Type getOwnerType() { return String.class; } @Override public Type getOwnerType() { return String.class; } }; JsonSerializer<Object> serializer = mock(JsonSerializer.class); Type[] enumTypes = new Type[] {String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.
@Test public void testGetSchema() throws Exception { Type typeHint = new ParameterizedType() { @Override public Type getRawType() { return String.class; } @Override public Type getOwnerType() { return String.class; } @Override public Type getOwnerType() { return String.class; } @Override public Type getRawType() { return Object.class; } @Override public Type getOwnerType() { return Object.class; } @Override public Type getOwnerType() { return Object.class; } @Override public Type getRawType() { return Object.class; } @Override public Type getOwnerType() { return Object.class; } @Override public boolean isArray() { return false; } @Override public boolean isSynthetic() { return false; } @Override public boolean isSynthetic() { return false; } @Override public boolean isEnumSet() { return false; } @Override public boolean isEnumSet() { return false; } @Override public boolean isEnumSet() { return false; } @Override public boolean isEnumSet() { return false; } @Override public boolean isEnumSet() { return false; } @Override public boolean isEnumSet() { return false; } @Override public boolean isEnumSet() {
@Test public void testGetSchema() throws Exception { Type type = TestEnum.class.getDeclaredField("prop").getGenericType(); JsonSerializer<Object> serializer = provider.findValueSerializer(type, TestEnum.class.getField("prop").getGenericType()); JsonNode schema = Json.createObjectNode(); schema.set("prop", "value"); JsonSchemaAssert.assertEquals("{\"prop\":\"value\"}", serializer.getSchema(provider, type).toString()); }
@Test public void testGetSchema() throws Exception { String schema = "{\"name\": \"John\", \"age\": 31}"; JsonSerializerProvider provider = new JsonSerializerProvider(); provider.setFieldOrder(JsonSchema.class, true); JsonNode schemaNode = schema.getSchema(provider, String.class); JsonNode expected = Json.createObjectNode(); expected.add("name", "John"); expected.add("age", 31); expected.add("name", "John"); expected.add("age", 31); assertEquals(expected, schemaNode); }
@Test public void should_add_enum_values_to_schema() throws JsonMappingException { TestClassWithAnnotationIntrospector testee = new TestClassWithAnnotationIntrospector(); testee.config().setAnnotationIntrospector(new AnnotationIntrospectorImpl(Enum.values())); ObjectNode schemaNode = testee.getSchema(testee, TestClassWithAnnotationIntrospector.class); JsonNode expectedNode = JsonHandler.createObjectNode(); expectedNode.put("object", expectedNode); assertThat(schemaNode, hasText("object")); }
@Test public void testEnum() throws Exception { TestableSchema schema = new TestableSchema(); Type type = schema.getField("prop").getType(); ObjectNode propsNode = JsonFactory.instance.objectNode(); propsNode.put("prop", "value"); JsonNode schemaNode = schema.getSchema(new JsonSerializerProvider(), type); assertEquals(propsNode, schemaNode); }
@Test public void getSchema() throws Exception { Class<?> type = TestEnum.class; JsonSerializerProvider provider = new JsonSerializerProvider(); Type typeHint = new ParameterizedType() { @Override public Type[] getActualTypeArguments() { return new Type[]{String.class}; } @Override public Type getRawType() { return String.class; } }; JsonNode schemaNode = _underTest.getSchema(provider, typeHint); assertEquals("{\"object\":{\"name\":\"TestEnum\",\"age\":12}}", schemaNode.toString()); }
@Test public void testCustomBeanSerialiser() { StringSerializerSerializer expected = new StringSerializer(Serializers.JSON, false); StringSerializer expected2 = new StringSerializer(Serializers.JSON, false); StringSerializer expected3 = new StringSerializer(Serializers.JSON, false); MockSerializerFactoryConfig config = new MockSerializerFactoryConfig().withAdditionalSerializers(null).withAdditionalKeySerializers(null).withBeanSerializerModifier(null).build(); assertEquals(expected, config.getSerializerFactoryConfig()); assertEquals(expected2, config.getSerializerFactoryConfig()); assertEquals(expected3, config.getAdditionalKeySerializers()); assertEquals(expected3, config.getAdditionalKeySerializers()); assertEquals(expected3, config.getBeanSerializerModifier()); assertEquals(expected3, config.getAdditionalSerializerModifier()); }
@Test public void testDefaultAdditional() { MockSerializerFactory.Builder builder = new MockSerializerFactory.Builder(); builder.withAdditionalSerializers(null); builder.withAdditionalKeySerializers(null); builder.withAdditionalModifier(BeanSerializerModifier.NO_MODIFIERS); MockSerializerFactory config = builder.build(); SerializerFactoryConfig config1 = config.withAdditionalSerializers(null); Assert.assertEquals(config.getAdditionalSerializers(), NO_SERIALIZERS); Assert.assertEquals(config.getAdditionalKeySerializers(), NO_SERIALIZERS); Assert.assertEquals(config.getAdditionalSerializerModifiers(), NO_MODIFIERS); }
@Test public void testCustomBeanSerialiser() { MockSerializerFactory.setAdditionalSerializers(null); MockSerializerFactory.setAdditionalKeySerializers(null); MockSerializerFactory.setAdditionalKeySerializers(null); MockSerializerFactory.setAdditionalKeySerializers(null); MockSerializerFactory.setAdditionalKeySerializers(null); MockSerializerFactory.setAdditionalKeySerializers(null); MockSerializerFactory.setAdditionalKeySerializers(null); MockSerializerFactory.setAdditionalKeySerializers(null); MockSerializerFactory.setAdditionalKeySerializers(null); MockSerializerFactory.setAdditionalKeySerializers(null); MockSerializerFactory.setAdditionalKeySerializers(null); MockSerializerFactory.setAdditionalKeySerializers(null); MockSerializerFactory.setAdditionalKeySerializers(null); MockSerializerFactory.setAdditionalKeySerializers(null); MockSerializerFactory.setAdditionalKeySerializers(null); MockSerializerFactory.setAdditionalKeySerializers(null); MockSerializerFactory.setAdditionalKeySerializers(null); MockSerializerFactory.setAdditionalKeySerializers(null); MockSerializerFactory.setAdditionalKeySerializers(null); MockSerializerFactory.setAdditionalKeySerializers(null); MockSerializerFactory.set
@Test public void testCustomSerialiserModifier() { BeanSerializerModifier[] modifiers = new BeanSerializerModifier[0]; serializationFormats.add(new MyCustomSerialiser()); serializationFormats.add(new MyCustomSerialiser()); MockSerializerFactory mockSerializerFactory = new MockSerializerFactory(); MockSerializerFactoryConfig config = new MockSerializerFactoryConfig(); config.withAdditionalSerializers(null); config.withAdditionalKeySerializers(null); config.withSerializerModifier(BeanSerializerModifier.BOOTSTRAP); MockSerializerFactory.MockSerializerFactory config2 = new MockSerializerFactoryConfig(); config2.withAdditionalSerializers(null); config2.withSerializerModifier(BeanSerializerModifier.BOOTSTRAP); MockSerializerFactory.MockSerializerFactory config3 = new MockSerializerFactoryConfig(); config3.withAdditionalKeySerializers(null); config2.withSerializerModifier(BeanSerializerModifier.BOOTSTRAP); config2.withSerializerModifier(BeanSerializerModifier.BOOTSTRAP); MockSerializerFactory.MockSerializerFactory config4 = new MockSerializerFactoryConfig(); config4.withAdditionalKeySerializers(null); config4.withSerializerModifier(BeanSerializerModifier.BOOTSTRAP); MockSerializerFactory.MockSerializerFactory config5 = new MockSerializerFactoryConfig();
@Test public void testWithSerializerModifier() { BeanSerializerModifier modifier = BeanSerializerModifier.BEAN_SERIALIZER; BeanSerializerModifier[] modifiers = new BeanSerializerModifier[] { BeanSerializerModifier.BEAN_SERIALIZER, modifier }; new MockUp<SerializerFactoryConfig>() { @Mock public SerializerFactoryConfig withSerializerModifier(BeanSerializerModifier modifier) { return new SerializerFactoryConfig(); } }; new MockUp<DeserializerFactory>() { @Mock public SerializerFactoryConfig withSerializerModifier(BeanSerializerModifier modifier) { return new SerializerFactoryConfig(); } }; new MockUp<DeserializerFactory>() { @Mock public SerializerFactoryConfig withSerializerModifier(BeanSerializerModifier modifier) { return new SerializerFactoryConfig(); } }; new MockUp<DeserializerFactory>() { @Mock public SerializerFactoryConfig withSerializerModifier(BeanSerializerModifier modifier) { return new SerializerFactoryConfig(); } }; new MockUp<DeserializerFactory>() { @Mock public SerializerFactoryConfig withSerializerModifier(BeanSerializerModifier modifier) { return new SerializerFactoryConfig(); } }; new MockUp<DeserializerFactory>() { @Mock public SerializerFactoryConfig withSerializerModifier(BeanSerializerModifier modifier) { return new SerializerFactoryConfig(); } }; new MockUp<DeserializerFactory>() { @Mock public SerializerFactoryConfig
@Test public void testWithSerializerModifier() { BeanSerializerModifier[] modifiers = new BeanSerializerModifier[0]; SerializerFactoryConfig config = new SerializerFactoryConfig().withSerializerModifier(BeanSerializerModifier.DEPRECATED).withAdditionalSerializers(new Serializers[] {new SimpleBeanSerializer()}).withSerializerModifier(BeanSerializerModifier.DEPRECATED); assertEquals(new SimpleBeanSerializer(), config.getSerializer()); }
@Test public void testWithSerializerModifier() { BeanSerializerModifier[] modifiers = ArrayBuilders.insertInListNoDup(_modifiers, BeanSerializerModifier.class); new MockSerializerFactoryConfig().withSerializerModifier(BeanSerializerModifier.class); new MockSerializerFactoryConfig().withSerializerModifier(BeanSerializerModifier.class); }
@Test public void testWithCustomSerializerModifier() { TestSerializerFactory.TestSerializerFactory config = new TestSerializerFactory.TestSerializerFactory(); config.addSerializer(new TestBeanSerializer()); config.addSerializer(new TestBeanSerializer()); TestSerializerFactory.TestSerializerFactory.TestSerializerFactory.assertDefaultInstance(config); }
@Test public void testMultipleSerializerModifiers() { List<BeanSerializerModifier> modifiers = new ArrayList<>(); modifiers.add(BeanSerializerModifier.NO_SERIALIZER); modifiers.add(BeanSerializerModifier.NO_SERIALIZER); modifiers.add(BeanSerializerModifier.NO_SERIALIZER); modifiers.add(BeanSerializerModifier.NO_SERIALIZER); Iterable<BeanSerializerModifier> expected = ArrayBuilders.arrayAsIterable(modifiers); Iterable<BeanSerializerModifier> actual = _factory.serializerModifiers(); Assert.assertEquals(expected, actual); }
@Test public void testSerializerModifiers() { List<BeanSerializerModifier> modifiers = Arrays.asList(beanModifier1, beanModifier2); assertEquals(modifiers.size(), 2); assertEquals(modifiers.get(0), beanModifier1); assertEquals(modifiers.get(1), beanModifier2); }
@Test public void testSerializers() { List<JsonSerializer<?>> serializers = new ArrayList<JsonSerializer<?>>() {{ addSerializer(JsonSerializer.STRING_SERIALIZER); addSerializer(JsonSerializer.INT_SERIALIZER); addSerializer(JsonSerializer.LONG_SERIALIZER); addSerializer(JsonSerializer.STRING_SERIALIZER); }}; for (JsonSerializer<?> serializer : SERializers) { System.out.println(">> " + serializer.toString()); } }
@Test public void testAddSerializer() throws Exception { SimpleSerializers serializers = new SimpleSerializers(); serializers.addSerializer(String.class, STRING_SER); serializers.addSerializer(Integer.class, INTEGER_SER); serializers.addSerializer(Long.class, LONG_SER); serializers.addSerializer(Double.class, DOUBLE_SER); serializers.addSerializer(String.class, STRING_SER); serializers.addSerializer(String.class, STRING_SER); serializers.addSerializer(Integer.class, DOUBLE_SER); serializers.addSerializer(Double.class, FLOAT_SER); serializers.addSerializer(Double.class, DOUBLE_SER); serializers.addSerializer(String.class, STRING_SER); serializers.addSerializer(String.class, STRING_SER); serializers.addSerializer(String.class, STRING_SER); Assert.assertEquals(Arrays.asList(new String[]{"1"}, new String[]{"2"}, new String[]{"3"}, new String[]{"4"}), serializers); }
@Test public void testArraySerializer() throws Exception { JsonSerializer<Array<?>> serializer = new ArraySerializer<Array<?>>() { @Override public void serialize(Array<?> bean, TypeSerializer<Object> elementTypeSerializer) throws IOException { } }; SimpleSerializers serializers = new SimpleSerializers(); serializers.addSerializer(ArrayType.class, new ArraySerializer<Object>()); serializers.addSerializer(ArrayType.class, new ArraySerializer<Object>()); assertEquals(Arrays.asList(new Object[] {"1", "2"}), serializers.serialize()); }
@Test public void testSerializeWithCustomSerializer() { JsonSerializer<Object> serializer = new CustomSerializer(); serializer.addSerializer(Object.class, new CustomSerializer()); serializer.addSerializer(String.class, new CustomSerializer()); serializer.addSerializer(Integer.class, new CustomSerializer()); serializer.addSerializer(Long.class, new CustomSerializer()); serializer.addSerializer(Double.class, new CustomSerializer()); serializer.addSerializer(Float.class, new CustomSerializer()); serializer.addSerializer(Double.class, new CustomSerializer()); serializer.addSerializer(Float.class, new CustomSerializer()); serializer.addSerializer(Double.class, new CustomSerializer()); serializer.addSerializer(Float.class, new CustomSerializer()); serializer.addSerializer(Double.class, new CustomSerializer()); serializer.addSerializer(Float.class, new CustomSerializer()); serializer.addSerializer(Double.class, new CustomSerializer()); serializer.addSerializer(Float.class, new CustomSerializer()); serializer.addSerializer(Double.class, new CustomSerializer()); serializer.addSerializer(Float.class, new CustomSerializer()); serializer.addSerializer(Float.class, new CustomSerializer()); serializer.addSerializer(Double.class, new CustomSerializer
@Test public void testSerialisation() { _addSerializer(String.class, SERIALIZER); _addSerializer(Integer.class, SERIALIZER); _addSerializer(Long.class, SERIALIZER); _addSerializer(Double.class, SERIALIZER); _addSerializer(Float.class, SERIALIZER); _addSerializer(Double.class, SERIALIZER); _addSerializer(Float.class, SERIALIZER); _addSerializer(Double.class, SERIALIZER); _addSerializer(Float.class, SERIALIZER); _addSerializer(Double.class, SERIALIZER); _addSerializer(Double.class, SERIALIZER); _addSerializer(Double.class, SERIALIZER); _addSerializer(Double.class, SERIALIZER); _addSerializer(Double.class, SERIALIZER); _addSerializer(Double.class, SERIALIZER); _addSerializer(Double.class, SERIALIZER); _addSerializer(Double.class, SERIALIZER); _addSerializer(Double.class, SERIALIZER); _addSerializer(Double.class, SERIALIZER); _addSerializer(Double.class, SERIALIZER); _addSerializer(Double.
@Test public void testSerializeWithCustomSerializer() { SimpleSerializers serializers = new SimpleSerializers(); serializers.addSerializer(CustomSerializer.class, new CustomSerializer()); serializers.addSerializer(CustomSerializer.class, new CustomSerializer()); serializers.addSerializer(CustomSerializer.class, new CustomSerializer()); serializers.addSerializer(CustomSerializer.class, new CustomSerializer()); assertEquals(Serializers.class, serializers.getClassMappings()); assertEquals(CustomSerializer.class, serializers.getClassMappings()); }
@Test public void testSerializeWithCustomSerializer() { SimpleSerializers serializers = new SimpleSerializers(); serializers.addSerializer(CustomSerializer.class, new CustomSerializer()); serializers.addSerializer(CustomSerializer.class, new CustomSerializer()); serializers.addSerializer(CustomSerializer.class, new CustomSerializer()); Assert.assertEquals( "{\"class\":\"com.flipkart.flux.client.CustomSerializer\",\"custom\":{\"foo\":\"bar\"}}", Json.createObject("{\"class\":\"com.flipkart.flux.client.CustomSerializer\",\"foo\":\"bar\"}")); Assert.assertEquals( "{\"class\":\"com.flipkart.flux.client.CustomSerializer\",\"custom\":{\"foo\":\"bar\"}}", Json.createObject("{\"class\":\"com.flipkart.flux.client.CustomSerializer\",\"foo\":\"bar\"}")); Assert.assertEquals( "{\"class\":\"com.flipkart.flux.client.CustomSerializer\",\"custom\":{\"foo\":\"bar\"}}", Json.createObject("{\"class\":\"com.flipkart.flux.client.CustomSerializer\",\"foo\":\"bar\"}")); }
@Test public void test_classMappings() { new SimpleSerializers().addSerializer(String.class, new JsonSerializer<String>() { @Override public String findClass(ClassKey key) { return null; } }); new SimpleSerializers().addSerializer(String.class, new JsonSerializer<String>() { @Override public String findClass(ClassKey key) { return null; } }); new SimpleSerializers().addSerializer(String.class, new JsonSerializer<String>() { @Override public String findClass(ClassKey key) { return null; } }); new SimpleSerializers().addSerializer(String.class, new JsonSerializer<String>() { @Override public String findClass(ClassKey key) { return null; } }); new SimpleSerializers().addSerializer(String.class, new JsonSerializer<String>() { @Override public String findClass(ClassKey key) { return null; } }); new SimpleSerializers().addSerializer(String.class, new JsonSerializer<String>() { @Override public String findClass(ClassKey key) { return null; } }); new SimpleSerializers().addSerializer(String.class, new JsonSerializer<String>() { @Override public String findClass(ClassKey key
@Test public void testSerializeWithCustomSerializer() { _serializers.addSerializer(CustomSerializer.class, new CustomSerializer()); _serializers.addSerializer(CustomSerializer.class, new CustomSerializer()); _serializers.addSerializer(CustomSerializer.class, new CustomSerializer()); _serializers.addSerializer(CustomSerializer.class, new CustomSerializer()); _serializers.addSerializer(CustomSerializer.class, new CustomSerializer()); _serializers.addSerializer(CustomSerializer.class, new CustomSerializer()); _serializers.addSerializer(CustomSerializer.class, new CustomSerializer()); _serializers.addSerializer(CustomSerializer.class, new CustomSerializer()); _serializers.addSerializer(CustomSerializer.class, new CustomSerializer()); _serializers.addSerializer(CustomSerializer.class, new CustomSerializer()); _serializers.addSerializer(CustomSerializer.class, new CustomSerializer()); _serializers.addSerializer(CustomSerializer.class, new CustomSerializer()); _serializers.addSerializer(CustomSerializer.class, new CustomSerializer()); _serializers.addSerializer(CustomSerializer.class, new CustomSerializer()); _serializers.addSerializer(CustomSerializer.class, new CustomSerializer()); _serializers.addSerializer(CustomSerializer.class, new CustomSerializer()); _serializers.add
@Test public void testJsonSerializer() { BeanDescription beanDesc = new BeanDescription(); beanDesc.getBean().setSerializationConfig(SerializationConfig.JSON_SERIALIZER); JsonSerializer<?> serializer = _classMappings.findSerializer(null, JavaType.class, beanDesc); assertTrue(serializer instanceof JsonSerializer); JsonSerializer<?> deser = serializer.deserialize(beanDesc); assertTrue(deser instanceof JsonSerializer); }
@Test public void testInterface() { class MyInterface implements Mapper<String, String> { } class MyInterface2 implements Mapper<String, String> { } class MyInterface3 implements Mapper<String, String> { } class MyInterface4 implements Mapper<String, String> { } class MyInterface5 implements Mapper<String, String> { } class MyInterface6 extends Mapper<String, String> { } class MyInterface7 extends Mapper<String, String> { } class MyInterface8 extends Mapper<String, String> { } class MyInterface9 extends Mapper<String, String> { } class MyInterface10 extends Mapper<String, String> { } class MyInterface10[] = new MyInterface10[] { new MyInterface1() }; class MyInterface10[] = new MyInterface10[] { new MyInterface2() }; class MyInterface10[] = new MyInterface10() { }; class MyInterface10[] = new MyInterface10() { }; class MyInterface10[] = new MyInterface10() { }; class MyInterface10[] = new MyInterface10() { }; class MyInterface10[] = new MyInterface10() { }; } class MyInterface10[] = new MyInterface10() { }; class MyInterface10[]
@Test public void testMapping() { class MyInterface implements Mapper { @Override public void foo(String s) { } } class MyInterface2 extends Mapper { @Override public void foo(String s) { } } class MyInterface3 extends Mapper { @Override public void foo(String s) { } } MyInterface1 mapper = new MyInterface1(); mapper.setMapper(mapper); MyInterface2 mapper2 = new MyInterface2(); mapper.setMapper(mapper2); MyInterface3 mapper3 = new MyInterface3(); mapper.setMapper(mapper3); MyInterface1 mapper = new MyInterface1(); mapper.setMapper(mapper3); MyInterface2 mapper2 = new MyInterface2(); mapper.setMapper(mapper2); MyInterface3 mapper3 = new MyInterface3(); mapper.setMapper(mapper3); MyInterface1 mapper = new MyInterface1(); mapper.setMapper(mapper3); MyInterface2 mapper = new MyInterface2(); mapper.setMapper(mapper3); mapper.setMapper(mapper3); MyInterface3 deser = mapper.findSerializer(null, MyInterface1.class, null); Assert.assertEquals("{}", deser.getJson()); Assert.assertEquals("{}", deser.getJson()); Assert.assertEquals
@Test public void testJsonSerialize() { BeanDescription beanDesc = new BeanDescription(); beanDesc.setBeanName("testBean"); JsonSerializer<?> ser = SERIALIZER.findSerializer(null, JavaType.getAnonymousClass(), beanDesc); Assert.assertNotNull(ser); Assert.assertTrue(ser instanceof JsonSerializer); JsonSerializer<?> deser = SERIALIZER.findSerializer(null, JavaType.getAnonymousClass(), beanDesc); Assert.assertNotNull(deser); Assert.assertTrue(deser instanceof JsonSerializer); JsonSerializer<?> deser2 = SERIALIZER.findSerializer(null, JavaType.getAnonymousClass(), beanDesc); Assert.assertNotNull(deser2); Assert.assertTrue(deser2.getClass().isAssignableFrom(JsonSerializer.class)); }
@Test public void testMapping() { class MyInterface implements implements Mapper<String, String> { } class MyInterface2 implements Mapper<String, String> { } class MyInterface3 implements Mapper<String, String> { } class MyInterface4 implements Mapper<String, String> { } class MyInterface5 implements Mapper<String, String> { } class MyInterface6 implements Mapper<String, String> { } class MyInterface7 implements Mapper<String, String> { } class MyInterface8 extends Mapper<String, String> { } class MyInterface9 extends Mapper<String, String> { } class MyInterface10 extends Mapper<String, String> { } class MyInterface10[] = new MyInterface10[] { new MyInterface1() }; class MyInterface10[] = new MyInterface10[] { new MyInterface2() }; class MyInterface10[] = new MyInterface10[] { new MyInterface1() }; class MyInterface10[] = new MyInterface10() { }; class MyInterface10[] = new MyInterface10() { }; class MyInterface10[] = new MyInterface10() { }; } class MyInterface10[] = new MyInterface10() { }; class MyInterface10[] = new MyInterface10() { };
@Test public void findSerializer() { class MyInterface implements Mapper { } class MyInterface2 implements Mapper { } class MyInterface3 implements Mapper { } class MyInterface4 extends Mapper { } class MyInterface5 extends Mapper { } class MyInterface6 extends Mapper { } class MyInterface7 extends Mapper { } class MyInterface8 extends Mapper { } class MyInterface9 extends Mapper { } class MyInterface10 extends Mapper { } class MyInterface10 mapper = new MyInterface10(); mapper.setMapper(mapper); class MyInterface10 mapper2 = new MyInterface10(); mapper2.setMapper(mapper2); class MyInterface10 mapper = new MyInterface10(); mapper.setMapper(mapper2); class MyInterface10 mapper2 = new MyInterface10(); mapper2.setMapper(mapper2); class MyInterface10 mapper = new MyInterface10(); mapper.setMapper(mapper2); class MyInterface10 mapper2 = new MyInterface10(); mapper2.setMapper(mapper2); class MyInterface10 mapper = new MyInterface10(); mapper.setMapper(mapper2); class MyInterface10 mapper2 = new MyInterface10(); mapper2.setMapper(mapper2); class MyInterface10 mapper3 = new MyInterface10(); mapper3.setMapper(mapper3); class
@Test public void testMapping() { class MyInterface implements Mapper { @Override public void map(Map<Class<?>> map) { map.put(ClassKey.classKey("MyInterface"), new MyInterface()); } } MyInterface mapper = new MyInterface(); mapper.setMapper(mapper); JsonSerializer<?> ser = mapper.findSerializer(null, JavaType.class, null); Assert.assertEquals("{}", ser.toString()); }
@Test public void testJsonSerialize() { BeanDescription beanDesc = new BeanDescription(); beanDesc.getBean().setSerializationConfig(SerializationConfig.JSON_SERIALIZER); JsonSerializer<?> serializer = _mapper.findSerializer(null, JavaType.getSimpleType(), beanDesc); beanDesc.getBean().setSerializationConfig(SerializationConfig.JSON_SERIALIZER); assertThat(serializer).isNotNull(); }
@Test public void testJsonSerialize() throws Exception { class MySerializer implements JsonSerializer { @Override public void init(SerializationConfig config, Class<? extends Annotation> annotationType, BeanDescription beanDesc) { } } MySerializer mapper = new MySerializer(); JsonSerializer<?> serializer = mapper.findSerializer(null, MySerializer.class, null); Assert.assertNotNull(serializer); Assert.assertTrue(serializer instanceof JsonSerializer); Assert.assertTrue(mapper.isArray()); Assert.assertEquals(mapper.readValue(new StringReader(serializer.toString()))); }
@Test public void testMapping() throws Exception { class MyInterface { } class MyInterface2 extends MyInterface { } class MyInterface3 extends MyInterface { } class MyInterface4 extends MyInterface { } class MyInterface5 extends MyInterface { } class MyInterface6 extends MyInterface { } class MyInterface7 extends MyInterface8 { } class MyInterface8 extends MyInterface9 {} MyInterface10 extends MyInterface10 {} MyInterface10 extends MyInterface10 {} MyInterface10 myInterface10 = new MyInterface10(); class MyInterface10 extends MyInterface10 {} MyInterface10 myInterface10 = new MyInterface10(); class MyInterface10 extends MyInterface10 {} MyInterface10 myInterface10 = new MyInterface10(); class MyInterface10 extends MyInterface10 {} MyInterface10 myInterface10 = new MyInterface10(); class MyInterface10 extends MyInterface10 {} MyInterface10 myInterface10 = new MyInterface10(); class MyInterface10 extends MyInterface10 {} MyInterface10 myInterface10 = new MyInterface10(); class MyInterface10 extends MyInterface10 {} MyInterface10 myInterface10 = new MyInterface10(); class MyInterface10 extends MyInterface10 {} MyInterface10[] myInterfaces = new MyInterface10[] {
@Test public void testMapping() { class MyInterface implements Mapper<String, String> { } class MyInterface2 implements Mapper<String, String> { } class MyInterface3 implements Mapper<String, String> { } class MyInterface4 implements Mapper<String, String> { } class MyInterface5 implements Mapper<String, String> { } class MyInterface6 extends Mapper<String, String> { } class MyInterface7 extends Mapper<String, String> { } class MyInterface8 extends Mapper<String, String> { } class MyInterface9 extends Mapper<String, String> { } class MyInterface10 extends Mapper<String, String> { } class MyInterface10 mapper = new MyInterface10(); class MyInterface10 mapper.setMapper(mapper); class MyInterface10 mapper.setMapper(mapper); class MyInterface10 mapper2 = new MyInterface10(); mapper2.setMapper(mapper2); class MyInterface10 mapper = new MyInterface10(); mapper.setMapper(mapper2); class MyInterface10 mapper2 = new MyInterface10(); mapper2.setMapper(mapper2); class MyInterface10 mapper = new MyInterface10(); mapper.setMapper(mapper2); class MyInterface10 mapper2 = new MyInterface10
@Test public void testMapping() { class MyInterface implements Mapper { @Override public void map(Map<Class<?>> map) { map.put(ClassKey.classKey("MyInterface"), new MyInterface()); } } MyInterface mapper = new MyInterface(); mapper.setMapper(mapper); JsonSerializer<?> ser = mapper.findSerializer(null, JavaType.class, null); Assert.assertEquals("{}", ser.toString()); }
@Test public void testJsonSerialize() { BeanDescription beanDesc = new BeanDescription(); beanDesc.getBean().setSerializationConfig(SerializationConfig.JSON_SERIALIZER); JsonSerializer<?> serializer = _mapper.findSerializer(null, JavaType.getSimpleType(), beanDesc); beanDesc.getBean().setSerializationConfig(SerializationConfig.JSON_SERIALIZER); assertThat(serializer).isNotNull(); }
@Test public void testMapping() { class MyInterface implements implements IMyInterface { } class MyInterface2 extends MyInterface { } class MyInterface3 extends MyInterface { } class MyInterface4 extends MyInterface { } class MyInterface5 extends MyInterface6 {} MyInterface7 extends MyInterface7 {} MyInterface8 extends MyInterface8 {} MyInterface9 extends MyInterface9 {} MyInterface10 extends MyInterface10 {} MyInterface10 extends MyInterface10 {} MyInterface10 myInterface11 = new MyInterface10(); class MyInterface12 extends MyInterface12 {} MyInterface21 extends MyInterface12 {} MyInterface121 extends MyInterface121; MyInterface21 myInterface21 = new MyInterface21(); class MyInterface121_extends implements MyInterface121, MyInterface2_1 extends MyInterface121; MyInterface122_1 extends MyInterface122; MyInterface10 myInterface12 = new MyInterface10(); class MyInterface10 extends MyInterface10 {} MyInterface10 myInterface12_1 = new MyInterface10(); class MyInterface10_1 extends MyInterface10 {} MyInterface10_2 extends MyInterface10_1 {} MyInterface10_3 extends MyInterface10_2 {} MyInterface10_4 extends MyInterface10_1 {} MyInterface10_1_1 =
@Test public void testJsonSerializer() { class Test implements JsonSerializer { } class Test2 extends JsonSerializer { } class Test3 extends JsonSerializer { } class Test4 extends JsonSerializer { } class Test5 extends JsonSerializer { } class Test6 extends JsonSerializer { } class Test7 extends JsonSerializer { } class Test8 extends JsonSerializer { } class Test9 extends JsonSerializer { } class Test10 extends JsonSerializer { } class Test11 extends JsonSerializer { } class Test12 extends JsonSerializer { } class Test22 extends JsonSerializer { } class Test23 extends JsonSerializer { } class Test22_1 extends JsonSerializer { } class Test22_2 extends JsonSerializer { } class Test23_1 extends JsonSerializer { } class Test22_2 extends JsonSerializer { } class Test22_3 extends JsonSerializer { } class Test44 extends JsonSerializer { } class Test45 extends JsonSerializer { } class Test45_1 extends JsonSerializer { } class Test45_2 extends JsonSerializer { } class Test44 extends JsonSerializer { } class Test45_2 extends JsonSerializer { } class Test44 extends JsonSerializer { } class Test45_3 extends JsonSerializer { } class Test45_4 extends JsonSerializer { } class Test45_2 extends JsonSerializer { } class Test45_2
@Test public void testArraySerializer() throws Exception { ArrayType arrayType = new ArrayType(String.class, new Type[] {Integer.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class
@Test public void testArraySerializer() throws Exception { BeanDescription beanDesc = new BeanDescription(); beanDesc.setArray("array"); JsonSerializer<?> serializer = SERIALIZER.findSerializer(null, beanDesc); assertTrue(serializer instanceof ArraySerializer); ArraySerializer arraySerializer = (ArraySerializer) serializer; assertEquals("array", arraySerializer.serialize(new Array("array"))); beanDesc.setArray("array"); serializer = SERIALIZER.findSerializer(null, beanDesc); assertTrue(serializer instanceof ArraySerializer); assertEquals("array", arraySerializer.serialize(new Array("array"))); beanDesc.setArray("array"); serializer = SERIALIZER.findSerializer(null, beanDesc); assertTrue(serializer instanceof ArraySerializer); assertEquals("array", arraySerializer.serialize(new Array("array"))); }
@Test public void testSerializersForMap() throws Exception { BeanDescription beanDesc = new BeanDescription(); beanDesc.setClass(Map.class); beanDesc.setOrder(Arrays.asList("a", "b")); MapSerializer<?> serializer = _serializers.findMapSerializer(null, beanDesc, null, null, null); assertEquals("\"a\"", serializer.serialize("a")); assertEquals("\"b\"", serializer.serialize("b")); assertEquals("\"c\"", serializer.serialize("c")); }
@Test public void testFindSerializerWithArray() throws Exception { BeanDescription beanDesc = new BeanDescription(); beanDesc.setBeanName("testBean"); JsonSerializer<?> serializer = SERIALIZER.findSerializer(null, beanDesc); assertTrue(serializer instanceof ArraySerializer); ArraySerializer arraySerializer = (ArraySerializer) serializer; assertEquals("[]", arraySerializer.serialize(new ArrayType(String.class))); }
@Test public void getSchema_array() throws Exception { JsonNode schema = _schema.getSchema(null, null); JsonNode expected = Json.createObjectNode(); expected.add("array"); expected.add("string"); expected.add("boolean"); expected.add("null"); assertEquals(expected, schema); }
@Test public void testArray() throws Exception { @SuppressWarnings("unchecked") Type typeHint = new ParameterizedType() { @Override public Type[] getActualTypeArguments() { return new Type[]{String[].class}; } }; JsonNode schema = createSchemaNode("array", true); JsonNode expected = createSchemaNode("array", true); assertEquals(expected, schema); }
@Test public void getSchema_withTypeHint() throws Exception { Type typeHint = new ParameterizedType() { @Override public Type[] getActualTypeArguments() { return new Type[]{String.class}; } }; JsonNode schema = _converter.getSchema(null, typeHint); JsonNode expected = Json.createObjectNode(); expected.add("\"array\"", Types.STRING); expected.add("\"string\"", Types.STRING); assertEquals(expected, schema); }
@Test public void getSchema_typeHint() throws Exception { Type typeHint = new ParameterizedType() { @Override public Type[] getActualTypeArguments() { return new Type[]{String.class}; } }; JsonNode schema = _mapper.readTree("{\"array\":[{\"field\":1,\"value\":2}]}"); JsonNode expected = Json.createObjectNode(); expected.add("field", 1); expected.add("value", 2); expected.add("value", 3); JsonNode actual = _mapper.getSchema(null, typeHint); assertEquals(expected, actual); }
@Test public void getSchema_withTypeHint() throws Exception { Type typeHint = new ParameterizedType() { @Override public Type[] getActualTypeArguments() { return new Type[]{String.class}; } }; JsonNode schema = _converter.getSchema(null, typeHint); JsonNode expected = Json.createObjectNode(); expected.add("type", "string"); expected.add("type", "string"); assertEquals(expected, schema); }
@Test public void getSchema_withTypeHint() throws Exception { Type typeHint = new ParameterizedType() { @Override public Type[] getActualTypeArguments() { return new Type[]{String.class}; } }; JsonSchema schema = mapper.getSchema(null, typeHint); JsonNode expected = mapper.readTree("{\"array\":[{\"field\":\"value\"}]}"); assertEquals(expected, schema.getSchema(null, null)); }
@Test public void getSchema_parametrized_typeHint() throws JsonMappingException { TypeHint<String[]> typeHint = new ParameterizedType() { @Override public Type[] getActualTypeArguments() { return new Type[]{String[].class}; } }; JsonNode schema = _mapper.readValue("{\"array\":[\"foo\",\"bar\"]}", JsonNode.class); JsonNode expected = Json.createObjectNode(); expected.add("\"foo\"", "bar"); expected.add("\"bar\"", "foo"); assertEquals(expected, schema.getSchema(null, typeHint)); }
@Test public void getSchema() throws Exception { Type typeHint = new ParameterizedType() { @Override public Type[] getActualTypeArguments() { return new Type[]{String.class}; } }; JsonNode schema = _mapper.readTree("{\"array\":[{\"field\":\"value\"}]}"); JsonNode expected = Json.createObjectNode(); expected.add("field", "value"); expected.add("field", "value"); assertJsonSchema(expected, schema); }
@Test public void getSchema() throws Exception { Type typeHint = new ParameterizedType() { @Override public Type[] getActualTypeArguments() { return new Type[]{String.class}; } }; JsonSerializerProvider mockProvider = mock(JsonSerializerProvider.class); JsonNode schema = new JsonSchema(null); JsonNode expected = new JsonSchema(null); when(mockProvider.constructType(typeHint)).thenReturn(typeHint); when(mockProvider.constructType(typeHint)).thenReturn(new JavaType(String.class)); JsonNode actual = schema.getSchema(mockProvider, typeHint); assertEquals(expected, actual); }
@Test public void getSchema_typeHint_params() throws Exception { Type typeHint = new ParameterizedType() { @Override public Type[] getActualTypeArguments() { return new Type[]{String.class}; } }; JsonSchema schema = new JsonSchema(new String[]{"array", "string"}, true); JsonNode expected = Json.createObjectNode(); expected.add("\"string\"", "string"); expected.add("\"string\"", "string"); expected.add("\"string\"", "string"); JsonSchema schema2 = new JsonSchema(new String[]{"array", "string"}, true); expected.add("\"string\"", "string"); expected.add("\"string\"", "string"); expected.add("\"string\"", "string"); JsonSchema schema3 = new JsonSchema(new String[]{"array", "string"}, true); expected.add("array", "string"); expected.add("string\"", "string"); expected.add("array", "string"); JsonSchema schema4 = new JsonSchema(new String[]{"array", "string"}, true); expected.add("array", "string"); expected.add("array", "string"); expected.add("array", "string"); expected.add
@Test public void getSchema_typeHint() throws Exception { Type typeHint = new ParameterizedType() { @Override public Type[] getActualTypeArguments() { return new Type[]{String.class}; } }; Type type = new ParameterizedType() { @Override public Type[] getActualTypeArguments() { return new Type[]{String[].class}; } }; JsonNode schema = _converter.getSchema(null, typeHint); JsonNode expected = Json.createObjectNode(); expected.setContentType(type); assertEquals(expected, schema); }
@Test public void getSchema_null() throws Exception { JsonNode schema = _mapper.readTree("{\"array\":[{\"field\":null}]}"); assertJsonEquals("{\"array\":[{\"field\":null}]}", schema); }
@Test public void getSchema() throws Exception { Type typeHint = new ParameterizedType() { @Override public Type[] getActualTypeArguments() { return new Type[]{String.class}; } }; JsonNode schema = _converter.getSchema(_serializerProvider, typeHint); JsonNode expected = Json.createObjectNode(); expected.add("\"array\":{\"foo\":1,\"bar\":2}}"); assertEquals(expected, schema); }
@Test public void getSchema_withTypeHint() throws Exception { Type typeHint = new ParameterizedType() { @Override public Type[] getActualTypeArguments() { return new Type[]{String.class}; } }; JsonSchema schema = mapper.getSchema(null, typeHint); JsonNode expected = mapper.readTree("{\"array\":[{\"field\":\"value\"}]}"); assertEquals(expected, schema.getSchema(null, null)); }
@Test public void getSchema_array() throws Exception { JsonNode schemaNode = null; JsonSerializerProvider mockProvider = mock(JsonSerializerProvider.class); Type typeHint = new ParameterizedType() { @Override public Type[] getActualTypeArguments() { return new Type[]{String[].class}; } }; JsonNode actual = new getSchema(mockProvider, typeHint); JsonNode expected = Json.createObjectNode(); expected.add("array", "foo"); expected.add("string", "bar"); expected.add("number", 2); expected.add("string", "baz"); expected.add("array", "foo,bar"); assertEquals(expected, actual); }
@Test public void getSchema_withRawType() throws Exception { Type typeHint = new ParameterizedType() { @Override public Type[] getActualTypeArguments() { return new Type[]{String.class}; } }; JsonNode schema = _mapper.readTree("{\"array\":[{\"field\":\"value\"}]}"); JsonNode expected = Json.createObjectNode(); expected.add("field", "value"); expected.add("field", "value"); assertJsonSchema(schema, expected); }
@Test public void getSchema() throws Exception { Type typeHint = new ParameterizedType() { @Override public Type[] getActualTypeArguments() { return new Type[]{String.class}; } }; JsonSerializerProvider provider = mock(JsonSerializerProvider.class); JsonSerializer<Object> ser = mock(JsonSerializer.class); when(provider.findValueSerializer(typeHint, "array")).thenReturn(ser); JsonSchema schema = new JsonSchema(new Object[] {}); expect(ser.getSchema(null, null)).andReturn(schema); expect(provider.constructType("array")).andReturn(typeHint); replay(provider); JsonSerializer<Object> actual = ser.getSchema(provider, typeHint); verify(provider); }
@Test public void getSchema() throws Exception { JsonNode schema = mapper.getSchema(ser, String.class); JsonNode expected = mapper.readTree("{\"array\":[{\"field\":\"value\"}]}"); assertEquals(expected, schema); }
@Test public void testArray() throws Exception { JsonNode schemaNode = _schema.getSchema(null, null); JsonNode expected = Json.createObjectNode(); expected.add("array", "foo"); assertEquals(expected, schemaNode); }
@Test public void getSchema_with_typeHint_returns_JsonNode() throws Exception { JsonNode schemaNode = _mapper.readTree("{\"array\":[{\"field\": \"value\"}]}"); JsonNode expected = Json.createObjectNode(); expected.add("field", "value"); expected.add("field", "value"); JsonNode actual = _schema.getSchema(null, null); assertEquals(expected, actual); }
@Test public void testArray() throws JsonMappingException { JsonNode schemaNode = _schema.getSchema(null, null); Assert.assertNotNull(schemaNode); Assert.assertTrue(schemaNode.has("array")); }
@Test public void testArray() throws Exception { JsonNode schemaNode = mapper.readTree("{\"items\":[{\"name\":\"a\",\"type\":\"int\"}]}"); JsonNode schema = _schema.getSchema(null, null); assertEquals("{\"items\":[{\"name\":\"a\",\"type\":\"int\"}]}", schema.toString()); }
@Test public void getSchema() throws Exception { JsonNode schema = _mapper.readTree("{\"array\":[\"foo\",\"bar\"]}"); JsonNode expected = mapper.readTree("{\"array\":[\"foo\",\"bar\"]}"); assertEquals(expected, _schema.getSchema(null, null)); }
@Test public void testDeserializationConfig_default_default() { DeserializationConfig config = new DeserializationConfig(DeserializationConfig.DEFAULT, new SubtypeResolverImpl(".lang.String,.lang.Integer,.lang.Long"), Map.of()); assertEquals(".lang.Integer,.lang.Long", config.getBaseSettings().getBase()); }
@Test public void testWithout() { DeserializationConfig config = new DeserializationConfig(base, new DefaultSubtypeResolver("org.apache.kafka.common.serialization.Foo")); DeserializationConfig without = config.without(DeserializationFeature.NESTED); assertThat(without.getRootName(), is("org.apache.kafka.common.serialization.Foo")); assertThat(without.getMapperFeatures(), is(DeserializationFeature.NESTED)); assertThat(without.getMapperClasses(), is(Arrays.asList(Foo.class))); assertThat(without.getMixins(), is(Arrays.asList(Foo.class, Bar.class))); assertThat(without.getMixins(), is(Arrays.asList(Bar.class, Foo.class))); assertThat(without.getMixins(), is(Arrays.asList(Bar.class, Foo.class))); assertThat(without.without(DeserializationFeature.NESTED), is(nullValue())); assertThat(without.without(DeserializationFeature.NESTED), is(nullValue())); assertThat(without.without(DeserializationFeature.NESTED), is(nullValue())); assertThat(without.without(DeserializationFeature.NESTED), is(nullValue()));
@Test public void testWith() { DeserializationConfig config = new DeserializationConfig(base, DEST_JSON_FACTORY); DeserializationConfig without = config.without(DeserializationFeature.NESTED); assertDeclaringClass(without, MockDeserializationConfig.class); assertNonFinalClass(without, MockDeserializationConfig.class); }
@Test public void testWith() { DeserializationConfig config = new DeserializationConfig(base, new SubtypeResolver("org.example.Foo$Enum"), mixins); assertThat(config.without(DeserializationFeature.MAP_ONLY), is(config)); assertThat(config.without(DeserializationFeature.UNWRAP_ROOT), is(config)); assertThat(config.without(DeserializationFeature.UNWRAP_ROOT), is(config)); assertThat(config.without(DeserializationFeature.UNWRAP_ROOT), is(config)); assertThat(config.without(DeserializationFeature.UNWRAP_ROOT), is(config)); assertThat(config.without(DeserializationFeature.UNWRAP_ROOT), is(config)); assertThat(config.without(DeserializationFeature.UNWRAP_ROOT), is(config)); assertThat(config.without(DeserializationFeature.UNWRAP_ROOT), is(config)); assertThat(config.without(DeserializationFeature.UNWRAP_ROOT), is(config)); assertThat(config.without(DeserializationFeature.UNWRAP_ROOT), is(config)); assertThat(config.without(DeserializationFeature.UNWRAP_ROOT), is(config)); assertThat(config.without(DeserializationFeature.UNWRAP
@Test public void test_parse_type() { assertEquals(NEW_LINE, new TypeParser(f).parse("a")); assertEquals(NEW_LINE, new TypeParser(f).parse("a")); assertEquals(NEW_LINE, new TypeParser(f).parse("a")); assertEquals(NEW_LINE, new TypeParser(f).parse("a")); assertEquals(NEW_LINE, new TypeParser(f).parse("a")); assertEquals(NEW_LINE, new TypeParser(f).parse("a")); assertEquals(NEW_LINE, new TypeParser(f).parse("a")); assertEquals(NEW_LINE, new TypeParser(f).parse("a")); assertEquals(NEW_LINE, new TypeParser(f).parse("a")); assertEquals(NEW_LINE, new TypeParser(f).parse("a")); assertEquals(NEW_LINE, new TypeParser(f).parse("a")); assertEquals(NEW_LINE, new TypeParser(f).parse("a")); assertEquals(NEW_LINE, new TypeParser(f).parse("a")); assertEquals(NEW_LINE, new TypeParser(f).parse("a")); assertEquals(NEW_LINE, new TypeParser(f).parse("a")); assertEquals(NEW_
@Test public void test_type_with_spaces() { MyTokenizer tokenizer = new MyTokenizer("a b c d"); JavaType type = parser.parse("a b c d"); assertEquals(JavaType.INT, type); }
@Test public void test_parse_type() { MyTokenizer tokenizer = new MyTokenizer("a"); JavaType type = parser.parse("a"); assertEquals(JavaType.INT, type); }
@Test public void test_parse_type_with_empty_string() { MyTokenizer tokenizer = new MyTokenizer("String"); JavaType type = parser.parse("String"); assertEquals("String", type.getPackageName()); assertEquals(0, type.getLength()); }
@Test public void testParse() { MyTokenizer tokenizer = new MyTokenizer("a"); JavaType type = parser.parse("a"); assertEquals(type, "a"); tokenizer = new MyTokenizer("b"); type = parser.parse("b"); assertEquals(type, "b"); tokenizer = new MyTokenizer("c"); type = parser.parse("c"); assertEquals(type, "c"); tokenizer = new MyTokenizer("d"); type = parser.parse("d"); assertEquals(type, "d"); }
@Test public void test_type_with_empty_string() { assertEquals("", new MyTokenizer("").parse("")); }
@Test public void testParseType_string() { MyTokenizer tokenizer = new MyTokenizer("String"); JavaType result = _parser.parseType(tokenizer); assertEquals(String.class, result.getRawType()); }
@Test public void testParseType_string() { MyTokenizer tokenizer = new MyTokenizer(".lang.String"); JavaType type = parser.parseType(tokenizer); assertEquals(String.class, type.getRawType()); }
@Test public void testParseType_string() { MyTokenizer tokenizer = new MyTokenizer("String"); JavaType type = parser.parseType(tokenizer); assertEquals(String.class, type.getRawType()); }
@Test public void testParseType_string() { MyTokenizer tokenizer = new MyTokenizer("String"); JavaType type = parser.parseType(tokenizer); assert_problem(type, "Unexpected end-of-string"); }
@Test public void testParseParameterizedType() { MyTokenizer tokenizer = new MyTokenizer(".lang.Integer"); JavaType type = _parser.parseType(tokenizer); assertEquals(Integer.class, type.getRawType()); }
@Test public void test_find_class() { MyTokenizer tokens = new MyTokenizer("class Foo { " + " boolean a = true; " + " int b = 1; " + "}"); Class<?> c = classUnderTest.findClass("Foo", tokens); Assert.assertEquals(c.getName(), "Foo"); Assert.assertEquals(c.getSuperclass(), Foo.class); Assert.assertEquals(c.getInterfaces().length, 2); Assert.assertEquals(c.getInterfaces()[0], Foo.class); Assert.assertEquals(c.getInterfaces()[1], Foo.class); Assert.assertEquals(c.getInterfaces()[2], Foo.class); Assert.assertEquals(c.getInterfaces()[3], Foo.class); Assert.assertEquals(c.getInterfaces()[4], Foo.class); Assert.assertEquals(c.getInterfaces()[5], Foo.class); Assert.assertEquals(c.getInterfaces()[6], Foo.class); Assert.assertEquals(c.getInterfaces()[7], Foo.class); Assert.assertEquals(c.getInterfaces()[8], Foo.class); Assert.assertEquals(c.getInterfaces()[9], Foo.class);
@Test public void test_find_class() { MyTokenizer tokens = new MyTokenizer("class Foo { boolean bar; } class Foo { boolean bar; } class FooBar { boolean bar; } class FooBar { boolean bar; } class FooBarBar { boolean bar; } class FooBarBar { boolean bar; } class FooBarBarBar { boolean bar; } class FooBarBarBar { boolean bar; } class FooBarBar { boolean bar; } class FooBarBarBar { boolean bar; } class FooBarBarBar { boolean bar; } class FooBarBarBar { boolean bar; } class FooBarBarBar { boolean bar; } class FooBarBarBar { boolean bar; } class FooBarBarBar { boolean bar; } class FooBarBarBar { boolean bar; } class FooBarBarBar { boolean bar; } class FooBarBarBar { boolean bar; } class FooBarBarBar { boolean bar; } class FooBarBarBar { boolean bar; } class FooBarBarBar { boolean bar; } class FooBarBarBar { boolean bar; } class FooBarBarBar { boolean bar; } class FooBarBarBar { boolean bar; }
@Test public void test_find_class() { MyTokenizer tokens = new MyTokenizer("class Foo { " + " boolean bar; " + " boolean foo() { " + " return true;" + " }" + "}"); Class<?> clazz = ClassUtil.findClass("Foo", tokens); Assert.assertEquals(clazz, Foo.class); }
@Test public void testMyTokenizer() { MyTokenizer t = new MyTokenizer("a"); assertEquals("a", t.nextToken()); t = new MyTokenizer("b"); assertEquals("b", t.nextToken()); t = new MyTokenizer("c"); assertEquals("c", t.nextToken()); t = new MyTokenizer("d"); assertEquals("d", t.nextToken()); t = new MyTokenizer("e"); assertEquals("e", t.nextToken()); t = new MyTokenizer("f"); assertEquals("f", t.nextToken()); t = new MyTokenizer("g"); assertEquals("g", t.nextToken()); t = new MyTokenizer("h"); assertEquals("h", t.nextToken()); t = new MyTokenizer("i"); assertEquals("i", t.nextToken()); t = new MyTokenizer("j"); assertEquals("j", t.nextToken()); t = new MyTokenizer("k"); assertEquals("k", t.nextToken()); t = new MyTokenizer("l"); assertEquals("l", t.nextToken()); t = new MyTokenizer("k"); assertEquals("l", t.nextToken()); t = new MyTokenizer("k"); assertEquals("k", t.nextToken()); t = new MyTokenizer("
@Test public void testMyTokenizer() { MyTokenizer t = new MyTokenizer("a"); t.pushBack("b"); t.pushBack("c"); t.pushBack("d"); t.pushBack("e"); assertEquals("a", t.nextToken()); assertEquals("b", t.nextToken()); assertEquals("c", t.nextToken()); t = new MyTokenizer("a"); t.pushBack("b"); t.pushBack("c"); t.pushBack("d"); t.pushBack("e"); assertEquals("a", t.nextToken()); assertEquals("b", t.nextToken()); t = new MyTokenizer("a"); t.pushBack("b"); t.pushBack("c"); t.pushBack("d"); t.pushBack("e"); assertEquals("a", t.nextToken()); assertEquals("b", t.nextToken()); assertEquals("c", t.nextToken()); t = new MyTokenizer("a"); t.pushBack("b"); t.pushBack("c"); t.pushBack("d"); t.pushBack("e"); assertEquals("a", t.nextToken()); assertEquals("b", t.nextToken()); assertEquals("c", t.nextToken()); t
@Test public void testMyTokenizer() { String input = "class A { int i; } class B { int i; } class C { public A(int i) { this.i = i; } } class D { public B(int i) { this.i = i; } } class E { public String getInnerClass() { return "A<B>(); } } class E { public void getInnerClass() { this.i = e; } } class F { public String getInnerClass() { return "B<C>(); } } class E { public void getInnerClass() { this.i = e; } } class D { public String getInnerClass() { return "D<C>(); } } class E { public void getInnerClass() { this.i = e; } } class F { public String getInnerClass() { return "A<B>(); } } class E { public void getInnerClass() { this.i = e; } } class D { public String getInnerClass() { return "D<C>(); } } class E { public void getInnerClass() { this.i = e; } } class F { public String getInnerClass() { return "A<B>(); } }
@Test public void test hasMoreTokens() { MyTokenizer t = new MyTokenizer("class A { boolean b; }"); Assert.assertTrue(t.is hasMoreTokens()); t = new MyTokenizer("class A { boolean b; }"); Assert.assertFalse(t.is hasMoreTokens()); t = new MyTokenizer("class A { boolean b; }"); Assert.assertFalse(t.is hasMoreTokens()); t = new MyTokenizer("class A { boolean b; }"); Assert.assertFalse(t.is hasMoreTokens()); t = new MyTokenizer("class A { boolean b; }"); Assert.assertTrue(t.is hasMoreTokens()); t = new MyTokenizer("class A { boolean b; }"); Assert.assertTrue(t.is hasMoreTokens()); t = new MyTokenizer("class A { boolean b; }"); Assert.assertTrue(t.is hasMoreTokens()); t = new MyTokenizer("class A { boolean b; }"); Assert.assertTrue(t.is hasMoreTokens()); t = new MyTokenizer("class A { boolean b; }"); Assert.assertTrue(t.is hasMoreTokens()); t = new MyTokenizer("class A { boolean b; }"); Assert.assertTrue(t.is hasMoreTokens()); t = new MyTokenizer
@Test public void test hasMoreTokens() { MyTokenizer t = new MyTokenizer("a"); t.pushBack("b"); t.pushBack("c"); Assert.assertTrue(t.is hasMoreTokens()); t.pushBack("d"); Assert.assertTrue(t.is hasMoreTokens()); t.pushBack("e"); Assert.assertTrue(t.is hasMoreTokens()); t.pushBack("f"); Assert.assertTrue(t.is hasMoreTokens()); t.pushBack("g"); Assert.assertTrue(t.is hasMoreTokens()); t.pushBack("h"); Assert.assertTrue(t.is hasMoreTokens()); t.pushBack("i"); Assert.assertTrue(t.is hasMoreTokens()); t.pushBack("j"); Assert.assertTrue(t.is hasMoreTokens()); t.pushBack("k"); Assert.assertTrue(t.is hasMoreTokens()); t.pushBack("l"); Assert.assertTrue(t.is hasMoreTokens()); }
@Test public void testNextToken() { MyTokenizer tokenizer = new MyTokenizer("class A { int i; } class B { int i; } class C { public C(int i) { super(i); } } class D { public D(int i) { super(i); } } class E { public E(int i) { super(i); } } class F { public E(int i) { super(i); } } class G { public E(int i) { super(i); } } class D { public E(int i) { super(i); } } class E { public E(int i) { super(i); } } class F { public E(int i) { super(i); } } class G { public E(int i) { super(i); } } class D { public E(int i) { super(i); } } class E { public E(int i) { super(i); } } class G { public E(int i) { super(i); } } class D { public E(int i) { super(i); } }
@Test public void testNextToken() { MyTokenizer t = new MyTokenizer("a"); t.pushBack("b"); assertEquals("a", t.nextToken()); t.pushBack("c"); assertEquals("c", t.nextToken()); t.pushBack("d"); assertEquals("d", t.nextToken()); t.pushBack("e"); assertEquals("e", t.nextToken()); t.pushBack("f"); assertEquals("f", t.nextToken()); t.pushBack("g"); assertEquals("g", t.nextToken()); t.pushBack("h"); assertEquals("h", t.nextToken()); t.pushBack("i"); assertEquals("i", t.nextToken()); t.pushBack("j"); assertEquals("j", t.nextToken()); t.pushBack("k"); assertEquals("k", t.nextToken()); t.pushBack("l"); assertEquals("l", t.nextToken()); t.pushBack("m"); assertEquals("m", t.nextToken()); t.pushBack("n"); assertEquals("n", t.nextToken()); t.pushBack("e"); assertEquals("e", t.nextToken()); t.pushBack("f"); assertEquals("f", t
@Test public void testNextToken() { MyTokenizer t = new MyTokenizer("class A { int i; } class B { int i; } class C { public void foo(int i) { } } class D { public void bar(int i) { } } class E { public void foo(int i, int j) { } } class F { public void bar(int i, int j) { } } class G { public void foo(int i, int j) { } } class D { public void bar(int i, int j) { } } class E { public void foo(int i, int j) { } } class F { public void bar(int i, int j) { } } class G { public void foo(int i, int j) { } } class D { public void bar(int i, int j) { } } class E { public void foo(int i, int j) { } } } class G { public void foo(int i, int j) { } } class D { public void bar(int i, int j) { } } class E { public void foo(int i, int j) { } }
@Test public void testNextToken() { MyTokenizer t = new MyTokenizer("class A { int i; } class B { int i; } class C { public void m() { i = 0; } } class D { public void m() { i = 0; } } class E { public void m() { i = 0; } } class F { public void m() { i = 0; } } class D { public void m() { i = 0; } } class E { public void m() { i = 0; } } class F { public void m() { i = 0; } } class D { public void m() { i = 0; } } class E { public void m() { i = 0; } } class D { public void m() { i = 0; } } class E { public void m() { i = 0; } } class F { public void m() { i = 0; } } class D { public void m() { i = 0; } } } D d; }
@Test public void testNextToken() { MyTokenizer t = new MyTokenizer("a"); t.pushBack("b"); t.pushBack("c"); Assert.assertEquals("a", t.nextToken()); Assert.assertEquals("b", t.nextToken()); Assert.assertEquals("c", t.nextToken()); Assert.assertEquals("c", t.nextToken()); t.pushBack("d"); Assert.assertEquals("d", t.nextToken()); Assert.assertEquals("c", t.nextToken()); Assert.assertEquals("d", t.nextToken()); t.pushBack("e"); Assert.assertEquals("e", t.nextToken()); Assert.assertEquals("e", t.nextToken()); t.pushBack("f"); Assert.assertEquals("f", t.nextToken()); Assert.assertEquals("", t.nextToken()); Assert.assertEquals("", t.nextToken()); t.pushBack("g"); Assert.assertEquals("g", t.nextToken()); Assert.assertEquals("g", t.nextToken()); Assert.assertEquals("g", t.nextToken()); Assert.assertEquals("g", t.nextToken()); Assert.assertEquals
@Test public void testNextToken() { MyTokenizer t = new MyTokenizer("a b c d"); assertEquals("a b c d", t.nextToken()); t = new MyTokenizer("a b c d"); assertEquals("a b c d", t.nextToken()); t = new MyTokenizer("a b c d"); assertEquals("a b c d", t.nextToken()); t = new MyTokenizer("a b c d"); assertEquals("a b c d", t.nextToken()); t = new MyTokenizer("a b c d"); assertEquals("a b c d", t.nextToken()); t = new MyTokenizer("a b c d"); assertEquals("a b c d", t.nextToken()); t = new MyTokenizer("a b c d"); assertEquals("a b c d", t.nextToken()); t = new MyTokenizer("a b c d"); assertEquals("a b c d", t.nextToken()); t = new MyTokenizer("a b c d"); assertEquals("a b c d", t.nextToken()); t = new MyTokenizer("a b c d"); assertEquals("a b c d", t.nextToken()); t = new MyTokenizer("a b c d"); assertEquals("a
@Test public void testRoutoutedObjectId() throws Exception { ReadableObjectId rout = new ReadableObjectId(new Object()); rout.bindItem(new Object()); rout.bindItem(new Object()); rout.bindItem(new Object()); rout.bindItem(new Object()); rout.bindItem(new Object()); rout.bindItem(new Object()); rout.bindItem(new Object()); rout.bindItem(new Object()); }
@Test public void test ReadableObjectId() throws Exception { new Expectations() { { new ReadableObjectId(null); result = new Object(); new ReadableObjectId(null); result = new Object(); } }; }
@Test public void bindItem() throws IOException { new Expectations() { { new ReadableObjectId(123L); } }; new Expectations() { { new Item(123L); } }; new Expectations() { { new Item(123L); } }; new Expectations() { { new Item(123L); } }; new Expectations() { { new Item(123L); } }; new Expectations() { { new Item(123L); } }; new Expectations() { { new Item(123L); } }; new Expectations() { { new Item(123L); } }; new Expectations() { { new Item(123L); } }; new Expectations() { { new Item(123L); } }; new Expectations() { { new Item(123L); } }; new Expectations() { { new Item(123L); } }; new Expectations() { { new Item(123L); } }; new Expectations() { { new Item(123L); } }; new Expectations() { { new Item(123L); } }; new Expectations() { { new Item(123L); } }; new Expectations() { { new Item(123L); } }; new Expectations() { {
@Test public void bindItem() throws IOException { new Expectations() { { new ReadableObjectId(123L); { new Item(123L); { new Item(123L); { new Item(123L); { new Item(123L); { new Item(123L); { new Item(123L); { new Item(123L); { new Item(123L); { new Item(123L); { new Item(123L); { { new Item(123L); { { new Item(123L); { { { new Item(123L); { { { { } }
@Test public void bindItem() throws IOException { new Expectations() { { new ReadableObjectId(123L); { new Item(); { new Item(); { new Item(); { new Item(); { new Item(); { new Item(); { new Item(); { new Item(); { { new Item(); { { new Item(); { { new Item(); { { { new Item(); { { { { new Item(); { { { { { } } }
@Test public void isUnwrappingSerializer() throws Exception { String s = "a"; assertTrue(new JsonSerializer<String>() { @Override public boolean isUnwrappingSerializer() { return false; } }.isUnwrappingSerializer()); }
@Test public void unwrappingSerializer() throws Exception { assertFalse(new JsonSerializer<Object>() { @Override public boolean isUnwrappingSerializer() { return false; } }.isUnwrappingSerializer()); }
@Test public void testStdDateFormat() { StdDateFormat sdf = new StdDateFormat(); sdf.setTimeZone(TimeZone.getTimeZone("GMT")); assertEquals(TimeZone.getTimeZone("GMT"), sdf.getTimeZone()); }
@Test public void testStdDateFormat() { StdDateFormat sdf = new StdDateFormat(); sdf.setTimeZone(TimeZone.getTimeZone("GMT")); assertEquals(TimeZone.getTimeZone("GMT"), sdf.getTimeZone()); }
@Test public void testWithTimeZone() { StdDateFormat sdf = new StdDateFormat(); sdf.withTimeZone(TimeZone.getTimeZone("GMT")); assertEquals(TimeZone.getTimeZone("GMT"), sdf.getTimeZone()); }
@Test public void testWithTimeZone() { StdDateFormat sdf = new StdDateFormat(); sdf.withTimeZone(TimeZone.getTimeZone("GMT")); assertEquals(TimeZone.getTimeZone("GMT"), sdf.getTimeZone()); }
@Test public void testWithTimeZone() { StdDateFormat f = new StdDateFormat(); f.setTimeZone(TimeZone.getTimeZone("GMT")); assertEquals(DEFAULT_TIMEZONE, f.getTimeZone()); }
@Test public void testParseWithZeroLength() { String formatted = "2011-10-10T12:00:00.000Z"; Date expected = new Date(Long.parseLong(formatted)); assertEquals(expected, formatter.parse(formatted, 0, ParseException.class)); }
@Test public void testParse() { try { StdDateFormat f = new StdDateFormat(); f.setTimeZone(TimeZone.getTimeZone("GMT")); f.parse("2009-01-23T21:43:56Z", ParsePosition.ZERO); fail("Should have thrown an exception"); } catch (IllegalArgumentException e) { } try { f.parse("2009-01-23T21:43:56Z", ParsePosition.ZERO); fail("Should have thrown an exception"); } catch (IllegalArgumentException e) { } }
@Test public void testParseAsISO8601() { Date d = new Date(); try { new Date(d.getTime()).toString(); fail("Expected IllegalArgumentException"); } catch (IllegalArgumentException e) { } try { new Date(new Date(d.getTime()).getTime()); fail("Expected IllegalArgumentException"); } catch (IllegalArgumentException e) { } }
@Test public void testParseAsISO8601() { [LINE] new Date(_dateString.substring(0, 1).getTime(), ParsePosition.START_DATE, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
@Test public void testParseAsISO8601() { [LINE] date = new Date(System.currentTimeMillis()); try { Date d = _dateFormat.parseAsISO8601(date, ParsePosition.START); assertEquals(date, d); } catch (ParseException e) { fail(e.getMessage()); } }
@Test public void testParseAsISO8601() { [LINE] dateStr = "Sun Nov 6 08:49:37 1994"; [LINE] date = dateStr.substring(0, dateStr.length() - 1); Date parsedDate = _dateizer.parseAsISO8601(dateStr, ParsePosition.START); assertEquals(date, parsedDate); dateStr = "Sun Nov 6 08:49:37 1994"; parsedDate = _dateizer.parseAsISO8601(dateStr, ParsePosition.END); assertEquals(date, parsedDate); dateStr = "Sun Nov 6 08:49:37 1994"; parsedDate = _dateizer.parseAsISO8601(dateStr, ParsePosition.START); assertEquals(date, parsedDate); }
@Test public void testParseAsISO8601() { Date d = new Date(); try { new Date(d.getTime()).toString(); fail("Expected IllegalArgumentException"); } catch (IllegalArgumentException e) { } try { new Date(new Date(d.getTime()).getTime()); fail("Expected IllegalArgumentException"); } catch (IllegalArgumentException e) { } }
@Test public void testParseAsISO8601() { String s = "2009-03-03T10:54:56.123Z"; Date d = new Date(s.length() - 1); Date parseAsISO8601 = new Date(d.getTime()); assertEquals(parseAsISO8601.getTime(), d.getTime()); }
@Test public void testParseAsISO8601() { [LINE] date = new Date(System.currentTimeMillis()); try { Date d = _dateFormat.parseAsISO8601(date, ParsePosition.START); assertEquals(date, d); } catch (ParseException e) { fail(e.getMessage()); } }
@Test public void testParseAsISO8601() { Date d = new Date(); try { new Date(d.getTime()).toString(); fail("Expected IllegalArgumentException"); } catch (IllegalArgumentException e) { } try { new Date(new Date(d.getTime()).getTime()); fail("Expected IllegalArgumentException"); } catch (IllegalArgumentException e) { } }
@Test public void testParseAsISO8601() { [LINE] new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'").parse("2001-12-03T10:53:56Z"); new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'").parse("2001-12-03T10:53:56Z"); new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'").parse("2001-12-03T10:53:56Z"); new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'").parse("2001-12-03T10:53:56Z"); new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'").parse("2001-12-03T10:53:56Z"); new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'").parse("2001-12-03T10:53:56Z"); new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS
@Test public void testParseAsISO8601() { new Thread() { @Override public void run() { try { Date d = new Date(); d = _dateTimeString.parseAsISO8601(d, ParsePosition.START); } catch (ParseException e) { e.printStackTrace(); } } }.start(); }
@Test public void testParseAsISO8601() { new Thread() { @Override public void run() { String s = new Date(System.currentTimeMillis() + 1000); Date d = new Date(System.currentTimeMillis() + 1000); Date d1 = new Date(System.currentTimeMillis() + 1000); Date d2 = new Date(System.currentTimeMillis() + 1000); new Thread(new Runnable() { @Override public void run() { String s1 = new Date(System.currentTimeMillis() + 1000); new Date(System.currentTimeMillis() + 1000); new Date(System.currentTimeMillis() + 1000); new Date(System.currentTimeMillis() + 1000); } }).start(); new Thread(new Runnable() { @Override public void run() { String s1 = new Date(System.currentTimeMillis() + 1000); new Date(System.currentTimeMillis() + 1000); new Date(System.currentTimeMillis() + 1000); new Date(System.currentTimeMillis() + 1000); new Date(System.currentTimeMillis() + 1000); new Date(System.currentTimeMillis() + 1000); new Date(System.currentTimeMillis() + 1000); new Date(System.currentTimeMillis() + 1000); new Date(System.currentTimeMillis() + 1000); } }.start(); new Thread(new Runnable()
@Test public void testParseAsISO8601() { [LINE] new Date(_dateTimeString).getTime(); [LINE] new Date(_dateTimeString).getTime(); new Date(_dateTimeString).getTime(); new Date(_dateTimeString).getTime(); new Date(_dateTimeString).getTime(); new Date(_dateTimeString).getTime(); new Date(_dateTimeString).getTime(); new Date(_dateTimeString).getTime(); new Date(_dateTimeString).getTime(); new Date(_dateTimeString).getTime(); new Date(_dateTimeString).getTime(); new Date(_dateTimeString).getTime(); new Date(_dateTimeString).getTime(); new Date(_dateTimeString).getTime(); new Date(_dateTimeString).getTime(); new Date(_dateTimeString).getTime(); new Date(_dateTimeString).getTime(); new Date(_dateTimeString).getTime(); new Date(_dateTimeString).getTime(); new Date(_dateTimeString).getTime(); new Date(_dateTimeString).getTime(); new Date(_dateTimeString).getTime(); new Date(_dateTimeString).getTime(); new Date(_dateTimeString).getTime(); new Date(_dateTimeString).getTime(); new Date(_dateTimeString).getTime(); new Date(_dateTime
@Test public void testParseAsISO8601() { [LINE] date = new Date(System.currentTimeMillis()); try { Date d = _dateFormat.parseAsISO8601(date, ParsePosition.START); assertEquals(date, d); } catch (ParseException e) { fail(e.getMessage()); } }
@Test public void testParseAsISO8601() { try { new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").parseAsISO8601("2009-03-23T10:54:56Z", ParsePosition.ZERO); fail("Should have thrown an exception for a missing date"); } catch (ParseException e) { } }
@Test public void testParseAsISO8601() { String s = "Sun Nov 6 08:49:37 1994"; Date d = new Date(s.getTime()); new Thread(_new Thread() { @Override public void run() { try { new Date(s.getTime()); } catch (ParseException e) { e.printStackTrace(); } } }).start(); new Thread(_new Thread() { @Override public void run() { try { new Date(s.getTime()); } catch (ParseException e) { e.printStackTrace(); } } }).start(); new Thread(_new Thread() { @Override public void run() { try { new Date(s.getTime()); } catch (ParseException e) { e.printStackTrace(); } } }).start(); new Thread(_new Thread() { @Override public void run() { try { new Date(s.getTime()); } catch (ParseException e) { e.printStackTrace(); } } }).start(); new Thread(_new Thread() { @Override public void run() { try { new Date(s.getTime()); } catch (ParseException e) { e.printStackTrace(); } } }).start(); new Thread(_new Thread() { @Override public void run() { try { new Date(s.getTime()); } catch (ParseException
@Test public void testParseAsISO8601() throws ParseException { String s = "Z"; Date ts = new Date(System.currentTimeMillis()); String date = ts.toString(); ParsePosition pos = new ParsePosition(0); Date clonedDate = _dateizer.parseAsISO8601(date, pos); assertEquals(date, clonedDate); }
@Test public void testHasTimeZone() { assertEquals(TimeZone.getTimeZone("GMT+0000"), hasTimeZone("GMT+0000")); assertEquals(TimeZone.getTimeZone("GMT+0000"), hasTimeZone("GMT+0000")); assertEquals(TimeZone.getTimeZone("GMT+0000"), hasTimeZone("GMT+0000")); assertEquals(TimeZone.getTimeZone("GMT+0000"), hasTimeZone("GMT+0000")); assertEquals(TimeZone.getTimeZone("GMT+0000"), hasTimeZone("GMT+0000")); assertEquals(TimeZone.getTimeZone("GMT+0000"), hasTimeZone("GMT+0000")); assertEquals(TimeZone.getTimeZone("GMT+0000"), hasTimeZone("GMT+0000")); assertEquals(TimeZone.getTimeZone("GMT+0000"), hasTimeZone("GMT+0000")); assertEquals(TimeZone.getTimeZone("GMT+0000"), hasTimeZone("GMT+0000")); assertEquals(TimeZone.getTimeZone("GMT+0000"), hasTimeZone("GMT+0000")); assertEquals(TimeZone.getTimeZone("GMT+0000"), hasTimeZone("GMT+0000")); assertEquals(TimeZone.getTimeZone("GMT+0000"), hasTimeZone("GMT+0000")); assertEquals(TimeZone.getTimeZone("GMT+0000"), hasTimeZone("GMT+0000")); assertEquals(TimeZone.getTimeZone("GMT+0000"), has
@Test public void testHasTimeZone() { StdDateFormat f = new StdDateFormat(); f.setTimeZone(TimeZone.getTimeZone("GMT")); Assert.assertTrue(f.hasTimeZone(TimeZone.getTimeZone("GMT+0000"))); Assert.assertTrue(f.hasTimeZone(TimeZone.getTimeZone("GMT+0000"))); Assert.assertTrue(f.hasTimeZone(TimeZone.getTimeZone("GMT+0000"))); Assert.assertTrue(f.hasTimeZone(TimeZone.getTimeZone("GMT+0000"))); Assert.assertTrue(f.hasTimeZone(TimeZone.getTimeZone("GMT+0000"))); Assert.assertTrue(f.hasTimeZone(TimeZone.getTimeZone("GMT+0000"))); Assert.assertTrue(f.hasTimeZone(TimeZone.getTimeZone("GMT+0000"))); Assert.assertTrue(f.hasTimeZone(TimeZone.getTimeZone("GMT+0000"))); Assert.assertTrue(f.hasTimeZone(TimeZone.getTimeZone("GMT+0000"))); Assert.assertTrue(f.hasTimeZone(TimeZone.getTimeZone("GMT+0000"))); Assert.assertTrue(f.hasTimeZone(TimeZone.getTimeZone("GMT+0000"))); Assert.assertTrue(f.hasTimeZone(TimeZone.getTimeZone("GMT+
@Test public void testHasTimeZone() { StdDateFormat f = new StdDateFormat(); Assert.assertTrue(f.hasTimeZone(TimeZone.getTimeZone("GMT+0000"))); Assert.assertTrue(f.hasTimeZone(TimeZone.getTimeZone("GMT+0000"))); Assert.assertTrue(f.hasTimeZone(TimeZone.getTimeZone("GMT+0000"))); Assert.assertTrue(f.hasTimeZone(TimeZone.getTimeZone("GMT+0000"))); Assert.assertTrue(f.hasTimeZone(TimeZone.getTimeZone("GMT+0000"))); Assert.assertTrue(f.hasTimeZone(TimeZone.getTimeZone("GMT+0000"))); Assert.assertTrue(f.hasTimeZone(TimeZone.getTimeZone("GMT+0000"))); Assert.assertTrue(f.hasTimeZone(TimeZone.getTimeZone("GMT+0000"))); Assert.assertTrue(f.hasTimeZone(TimeZone.getTimeZone("GMT+0000"))); Assert.assertTrue(f.hasTimeZone(TimeZone.getTimeZone("GMT+0000"))); Assert.assertTrue(f.hasTimeZone(TimeZone.getTimeZone("GMT+0000"))); Assert.assertTrue(f.hasTimeZone(TimeZone.getTimeZone("GMT+0000"))); Assert.assertTrue(f.hasTimeZone(
@Test public void testFilterOutAllExcept() throws Exception { SimpleBeanPropertyFilter filter = SimpleBeanPropertyFilter.filterOutAllExcept("a", "b"); JsonGenerator jgen = Json.createGenerator(); jgen.nextToken(); JsonValue jsonValue = jgen.nextToken(); jsonValue.set("a", "b"); jsonValue.set("c", "d"); jsonValue.set("d", "e"); jsonValue.set("f", "g"); jsonValue.set("h", "i"); jsonValue.set("i", "j"); filter.serializeAsField(jsonValue, jgen, null, null); jgen.nextToken(); JsonValue jsonValue2 = jgen.nextToken(); jsonValue2.set("a", "b"); jsonValue2.set("c", "d"); jsonValue2.set("e", "f"); jsonValue2.set("h", "i"); filter.serializeAsField(jsonValue2, jgen, null, null); jgen.nextToken(); JsonValue jsonValue3 = jgen.nextToken(); jsonValue3.set("a", "b"); jsonValue3.set("c", "d"); jsonValue3.set("e
@Test public void serializeAllExcept() { SimpleBeanPropertyFilter filter = serializeAllExcept("prop1", "prop2"); Assert.assertTrue(filter.include(new SimpleBeanPropertyWriter(writer))); }
@Test public void testSerializeAllExcept() throws IOException { SimpleBeanPropertyFilter filter = new SimpleBeanPropertyFilter(); filter.serializeAllExcept("a", "b", "c"); JsonGenerator jgen = JsonGeneratorFactory.createGenerator(new ByteArrayInputStream(writer.toByteArray()), SimpleBeanPropertyFilter.class); jgen.next(); }
@Test public void testSerializeAllExcept() { SimpleBeanPropertyFilter filter = serializeAllExcept("a", "b"); Assert.assertTrue(filter instanceof SimpleBeanPropertyFilter); Assert.assertTrue(filter.include(new SimpleBeanPropertyWriter())); }
@Test public void testSerializeAllExcept() { SimpleBeanPropertyFilter filter = serializeAllExcept("a", "b", "c"); assertEquals(true, filter.include(BeanPropertyWriter.class)); assertEquals(true, filter.include(BeanPropertyWriter.class)); assertEquals(true, filter.include(BeanPropertyWriter.class)); assertEquals(true, filter.include(BeanPropertyWriter.class)); assertEquals(true, filter.include(BeanPropertyWriter.class)); assertEquals(true, filter.include(BeanPropertyWriter.class)); assertEquals(true, filter.include(BeanPropertyWriter.class)); assertEquals(true, filter.include(BeanPropertyWriter.class)); assertEquals(true, filter.include(BeanPropertyWriter.class)); assertEquals(true, filter.include(BeanPropertyWriter.class)); assertEquals(true, filter.include(BeanPropertyWriter.class)); assertEquals(true, filter.include(BeanPropertyWriter.class)); assertEquals(true, filter.include(BeanPropertyWriter.class)); assertEquals(true, filter.include(BeanPropertyWriter.class)); assertEquals(true, filter.include(BeanPropertyWriter.class)); assertEquals(true, filter.include(BeanPropertyWriter.class)); assertEquals(true
@Test public void serializeAsField_simple() throws Exception { SimpleBeanProperty bean = new SimpleBeanProperty(); bean.setId("id"); bean.setProp("prop"); bean.setProp("val"); bean.serializeAsField(bean, jgen, new DefaultSerializerProvider(), beanPropertyWriter); jgen.flush(); assertThat(bean.getId()).isEqualTo("id"); assertThat(bean.getProp()).isEqualTo("prop"); assertThat(bean.getProp()).isEqualTo("val"); }
@Test public void serialize_should_not_throw_exception_when_bean_is_null() throws Exception { SimpleBeanPropertyFilter filter = new SimpleBeanPropertyFilter(); filter.serializeAsField(null, jgen, null, null); }
@Test public void serializeAsField_simpleBean_simpleBean_simpleBean_simpleBean_simpleBean_simpleBean_simpleBean_simpleBean_simpleBean_simpleBean_simpleBean_simpleBean() throws Exception { SimpleBean simpleBean = new SimpleBean(); simpleBean.simpleProperty = new SimpleBeanProperty("simple"); simpleBean.simpleProperty.setString("string"); simpleBean.simpleProperty.setBoolean(true); simpleBean.simpleProperty.setBooleanPrimitive(true); simpleBean.simpleProperty.setBooleanPrimitive(false); simpleBean.simpleProperty.setBooleanPrimitive(true); simpleBean.simpleProperty.setBooleanPrimitive(false); simpleBean.simpleProperty.setBooleanPrimitive(true); simpleBean.simpleProperty.setBooleanPrimitive(false); simpleBean.simpleProperty.setBooleanPrimitive(true); simpleBean.simpleProperty.setBooleanPrimitive(false); simpleBean.simpleProperty.setBooleanPrimitive(true); StringWriter writer = new StringWriter(); simpleBean.serializeAsField(simpleBean, jgen, new DefaultSerializerProvider(), beanPropertyWriter); jgen.flush(); SimpleBeanPropertyFilter filter = SimpleBeanPropertyFilter.create(); filter.filterOutAllExcept(singletonList("string
@Test public void testDepositSchemaProperty() throws Exception { SimpleBeanPropertyFilter filter = new SimpleBeanPropertyFilter(); ObjectNode propertiesNode = mapper.readTree("{\"d\":{\"d\":{\"foo\":\"bar\"}}"); filter.depositSchemaProperty(writer, propertiesNode, null); assertEquals(2, writer.getDepositSchemaPropertyCount()); }
@Test public void testDepositSchemaProperty() throws Exception { SimpleBeanPropertyFilter filter = new SimpleBeanPropertyFilter(); ObjectNode propertiesNode = JsonUtils.newNode(); SimpleBeanPropertyWriter writer = new SimpleBeanPropertyWriter(); filter.depositSchemaProperty(writer, propertiesNode, null); JsonTestUtils.assertJsonEquals("{\"d\":{\"d\":{\"d\":{\"d\":{\"d\":{\"d\":{\"d\":{\"d\":{\"d\":{\"d\":{\"d\":{\"d\":{\"d\":{\"d\":{\"d\":{\"d\":{\"d\":{\"d\":{\"d\":{\"d\":{\"d\":{\"d\":{\"d\":{\"d\":{\"d\":{\"d\":{\"d\":{\"d\":{\"d\":{\"d\":{\"d\":{\"d\":{\"d\":{\"d\":{\"d\":{\"d\":{\"d\":{\"d\":{\"d\":{\"d\":{\"d\":{\"d\":{\"d\":{\"d\":{\"d\":{\"d\":{\"d\":
@Test public void testDepositSchemaProperty() throws JsonMappingException { ObjectNode propertiesNode = mapper.readTree("{\"d\":{\"d\":{\"d\":{\"d\":{\"d\":{\"d\":{\"d\":{\"d\":{\"d\":{\"d\":{\"d\":{\"d\":{\"d\":{\"d\":{\"d\":{\"d\":{\"d\":{\"d\":{\"d\":{\"d\":{\"d\":{\"d\":{\"d\":{\"d\":{\"d\":{\"d\":{\"d\":{\"d\":{\"d\":{\"d\":{\"d\":{\"d\":{\"d\":{\"d\":{\"d\":{\"d\":{\"d\":{\"d\":{\"d\":{\"d\":{\"d\":{\"d\":{\"d\":{\"d\":{\"d\":{\"d\":{\"d\":{\"d\":{\"d\":{\"d\":{\"d\":{\"d\":{\"d\":{\"d\":{\"d\":{\"d\":{\"d\":{\"d\":
@Test public void include() throws Exception { SimpleBeanPropertyWriter writer = new SimpleBeanPropertyWriter(); writer.setName("test"); SimpleBeanPropertyFilter filter = SimpleBeanPropertyFilter.filterOutAllExcept(new String[]{"test"}); filter.serializeAsField(bean, jgen, null, writer); writer.close(); assertThat(writer.getName()).isEqualTo("test"); assertThat(filter.include(writer)).isTrue(); }
@Test public void testInclude() throws Exception { SimpleBeanPropertyWriter writer = new SimpleBeanPropertyWriter(); writer.setName("test"); writer.add("test"); writer.add("test2"); writer.add("test3"); writer.add("test4"); SimpleBeanPropertyFilter filter = SimpleBeanPropertyFilter.serializeAllExcept(new HashSet<String>(Arrays.asList("test", "test3"))); assertTrue(filter.include(writer)); }
@Test public void testSerializeExceptFilter() throws Exception { SimpleBeanPropertyFilter filter = SerializeExceptFilter.serializeExceptFilter("a", "b"); SimpleBeanPropertyFilter result = filter.include(JsonHelper.toJsonNode(new HashSet<>(Arrays.asList("a", "b")))); assertEquals(result.getFilter(), "a,b"); }
@Test public void testSerializeExceptFilter() throws Exception { SimpleBeanPropertyFilter filter = SimpleBeanPropertyFilter.serializeExceptFilter("a", "b"); SimpleBeanPropertyFilter filterOut = SimpleBeanPropertyFilter.serializeExceptFilter("a", "b"); SimpleBeanPropertyFilter unfilter = SimpleBeanPropertyFilter.filterOutAllExcept("a", "b"); SimpleBeanPropertyFilter unfilterOut = SimpleBeanPropertyFilter.serializeExceptFilter("a", "b"); assertEquals(filter.include(filterOut), unfilterOut); assertEquals(filter.include(unfilterOut), unfilterOut); assertEquals(filter.exclude(unfilterOut), unfilterOut); }
@Test public void include() throws Exception { SimpleBeanPropertyWriter writer = new SimpleBeanPropertyWriter(); writer.setName("test"); SimpleBeanPropertyFilter filter = SimpleBeanPropertyFilter.filterOutAllExcept("test"); filter.serializeAsField(bean, jgen, null, writer); writer.close(); assertThat(writer.getName()).isEqualTo("test"); }
@Test public void testInclude() throws Exception { SimpleBeanPropertyWriter writer = new SimpleBeanPropertyWriter(); writer.setName("test"); writer.setExclude("test2"); assertTrue(filter.include(writer)); writer.setName("test"); assertTrue(filter.include(writer)); }
@Test public void testGetContextAnnotation() { Annotation annotation = _mapper.getContextAnnotation(Annotation.class); assertEquals(Annotation.class, annotation.getType()); assertEquals(Annotation.class, annotation.getWrapperClass()); assertEquals(Annotation.class, annotation.getContextAnnotation(String.class)); }
@Test public void testContextAnnotations() { Annotation annotation = _mapper.getContextAnnotation(Annotation.class); assertEquals(Annotation.class, annotation.getType()); assertEquals(Annotation.class, annotation.getAnnotationClass()); }
@Test public void testMethodProperty() { class Test { public void test(String s) { System.out.println("test(" + s + " "); } } Test bean = new Test(); bean.setFoo("bar"); bean.setBar("baz"); bean.setBar("qux"); bean.setBarQux("qux"); bean.setBarQux("qux"); bean.setBarQux("qux"); bean.setBarQux("qux"); bean.setBarQux("qux"); bean.setBarQux("qux"); bean.setBarQux("qux"); bean.setBarQux("qux"); bean.setBarQux("qux"); bean.setBarQux("qux"); bean.setBarQux("qux"); bean.setBarQux("qux"); bean.setBarQux("qux"); bean.setBarQux("qux"); bean.setBarQux("qux"); bean.setBarQux("qux"); bean.setBarQux("qux"); bean.setBarQux("qux"); bean.setBarQux("qux"); bean.set
@Test public void testMethodProperty() { class Test { public void test(String s) { System.out.println("test(" + s + " - " + s + " - " + s + " - " + s + " - " + s + " " + s + " " + s + " " + s + " " + s + " " + s + " " + s + " " + s + " " + s + " " + s + " " + s + " " + s); } } Test bean = new Test(); bean.setFoo("bar"); bean.setBar("baz"); bean.setFoo("foo"); bean.setBar("baz"); bean.setBar("baz"); bean.setFoo("bar"); bean.setBar("baz"); bean.setBar("baz"); bean.setBar("baz"); AnnotatedMethod m = new AnnotatedMethod(Test.class, "test", "foo", "bar", "baz"); Property property = new MethodProperty(bean, TypeDeserializer.getDeserializer(Test.class), null); AnnotatedMember member = new AnnotatedMember(Test.class, "member", "bar", "baz"); PropertyValue propValue = new PropertyValue(
@Test public void testMethodProperty() throws Exception { AnnotatedMethod method = AnnotatedClass.class.getMethod("methodProperty", String.class); BeanPropertyDefinition def = new BeanPropertyDefinition(); def.setBeanName("methodProperty"); def.setBeanClass(new SimpleBeanClass()); MethodProperty property = new MethodProperty(def, type, typeDeser, contextAnnotations, method); AnnotatedMethod property2 = new AnnotatedMethodProperty(def, type, typeDeser, contextAnnotations, method); AnnotatedMethod property3 = new AnnotatedMethodProperty(def, type, typeDeser, contextAnnotations, method); AnnotatedMethod property4 = new AnnotatedMethodProperty(def, type, typeDeser, contextAnnotations, method); AnnotatedMethod property5 = new AnnotatedMethodProperty(def, type, typeDeser, contextAnnotations, method); AnnotatedMethod property6 = new AnnotatedMethodProperty(def, type, typeDeser, contextAnnotations, method); AnnotatedMethod property7 = new AnnotatedMethodProperty(def, type, typeDeser, contextAnnotations, method); AnnotatedMethod property8 = new AnnotatedMethodProperty(def, type, typeDeser, contextAnnotations, method); AnnotatedMethod property9 = new AnnotatedMethodProperty(def, type,
@Test public void testMethodProperty() throws Exception { Class<?> type = Class.forName("com.example.Foo"); MethodProperty src = new MethodProperty(def, type, null, null, new AnnotatedMethod(Foo.class)); AnnotatedMethod m = new AnnotatedMethod(Foo.class, "getBar"); src.setAnnotated(m); assertEquals("bar", src.getName()); assertEquals(type, src.getType()); assertEquals(true, src.isAnnotated()); }
@Test public void testStaticMethodProperty() throws Exception { Class<?> type = Class.forName(".lang.Object"); MethodProperty src = new MethodProperty(new StaticMethodProperty(type), null); MethodProperty property = new MethodProperty(src, null); assertEquals(property.getName(), "staticMethodProperty"); assertEquals(property.getAnnotation(StaticMethod.class), "staticMethodProperty"); assertEquals(property.getMember(), mockMember); }
@Test public void testSuperClass() throws Exception { class Test { public void testSuperClass() { } } class Test2 extends Test { public void testSuperClass2() { } } class Test3 extends Test { public void testSuperClass3() { } } class Test4 extends Test { public void testSuperClass4() { } } class Test5 extends Test { public void testSuperClass5() { } } class Test6 extends Test { public void testSuperClass6() { } } class Test7 extends Test { public void testSuperClass7() { } } class Test8 extends Test { public void testSuperClass8() { } } class Test9 extends Test { public void testSuperClass9(String s) { } } class Test10 extends Test { public void testSuperClass10(String s) { } } class Test11 extends Test { public void testSuperClass11(String s) { } } class Test12 extends Test { public void testSuperClass12(String s) { } } } TestProperty property = new TestProperty(new TestBeanPropertyDefinition(), null, null, null, null, null, null, null, null, null, null, null, null, null, null, null,
@Test public void testAnnotation() throws Exception { class TestBean implements BeanProperty { public String getA() { return "a"; } public String getA2() { return "b"; } public String getA3() { return "c"; } } TestBean bean = new TestBean(); bean.setA("a"); bean.setB("b"); bean.setC("c"); bean.setD("d"); bean.setE("e"); bean.setF("f"); bean.setG("g"); bean.setD("h"); bean.setE("i"); bean.setF("j"); bean.setG("k"); bean.setD("l"); bean.setE("l"); bean.setF("k"); bean.setL("l"); bean.setE("k"); bean.setL("l"); bean.setF("k"); bean.setL("l"); bean.setE("k"); bean.setL("k"); bean.setE("l"); bean.setF("k"); bean.setL("k"); bean.setL("k"); bean.setL("k"); bean.setL("k"); bean.setL("k"); bean
@Test public void testNewName() { class Test { public void test() { System.out.println("test"); } } class TestBean { public void test() { System.out.println("test1"); } } class TestBeanBeanBeanBeanBeanBeanBean = new TestBeanBeanBeanBean(); MethodProperty property = new MethodProperty(new MethodProperty(new BeanPropertyDefinition("test", "name"), null), null); property.withName("test"); property.withValueDeserializer(null); assertEquals("test", property.getName()); }
@Test public void testWithValueDeserializer() throws Exception { Class<?> clazz = Class.forName("org.apache.cxf.tools.fortest.noarg.FooBar"); MethodProperty src = new MethodProperty(new BeanPropertyDefinition(mock(BeanProperty.class)), clazz, null, null, null); Class<?> val = new Class<?>(); val.setAccessible(true); Class<?> clazz2 = Class.forName("org.apache.cxf.tools.fortest.noarg.FooBar"); Class<?> val2 = new Class<?>(); val2.setAccessible(false); Class<?> val2 = Class.forName("org.apache.cxf.tools.fortest.noarg.FooBar"); MethodProperty property = new MethodProperty(src, val2); JsonDeserializer<?> deser = mock(JsonDeserializer.class); AnnotationMember member = new AnnotationMember(prop, "fooBar"); property.withValueDeserializer(deser); assertEquals(member, property.getMember()); assertEquals(val, property.getValue()); }
@Test public void testWithValueDeserializer() throws Exception { class Test { public void test() { new MethodProperty(new BeanPropertyDefinition(), null, null, null, null, null).withValueDeserializer(mock(JsonDeserializer.class)); } } Test test = new Test(); test.withValueDeserializer(mock(JsonDeserializer.class)); }
@Test public void testGetMember() { AnnotatedMember member = property.getMember(); Assert.assertEquals(member.getName(), "member"); }
@Test public void should_DeserializeSetAndSet_With_Annotation_And_ValueDeserializer() throws Exception { ClassWithAnnotationProperty mock = mock(ClassWithAnnotationProperty.class); when(mock.getAnnotation(Annotation.class)).thenReturn(mock); when(mock.getAnnotation(Annotation.class)).thenReturn(mock); when(mock.getMember()).thenReturn(member); JsonParser jp = mock(JsonParser.class); AnnotatedMember mockMember = mock(AnnotatedMember.class); when(mockMember.getMember()).thenReturn(mock); when(mock.getMember()).thenReturn(mockMember); MethodProperty property = new MethodProperty(mock, mock.getTypeDeserializer(), mock.getTypeDeser(), mock.getMember(), mockMember); property.deserializeAndSet(jp, mock.getDeserializationContext(), mock); verify(mockMember).set(mock, mock); }
@Test public void should_deserialize_set_to_instance() throws Exception { MethodProperty dp = new MethodProperty(new BeanPropertyDefinition(), null, null, null, null); JsonParser jp = mock(JsonParser.class); DeserializationContext ctxt = mock(DeserializationContext.class); when(ctxt.getMapper()).thenReturn(mock(Mapper.class)); when(mock(Mapper.class).readValue(jp, String.class)).thenReturn("value"); dp.deserializeAndSet(jp, ctxt, new Object()); verify(mock).set(eq(new Object()), eq("value")); }
@Test public void testSet() throws Exception { class Test { public void testSet(Object instance, Object value) throws IOException { } } Test instance = new Test(); instance.set(instance, value); assertEquals(instance.get(), value); }
@Test public void testSet() throws IOException { class Example { public void foo() { } } Example instance = new Example(); instance.foo = 1; instance.set(instance, 1); assertEquals(1, instance._getFoo()); assertEquals(1, instance._getBar()); }
@Test public void testSet() throws Exception { TestClass instance = new TestClass(); instance.set("a", 1); instance.set("b", 2); assertEquals("a", instance.get("a")); }
@Test public void writeFieldName_null_writer() throws IOException, JsonGenerationException { ObjectIdGenerator<String> generator = mock(ObjectIdGenerator.class); SerializedString name = new SerializedString("name"); when(generator.serialize(name, mock(JsonSerializerProvider.class), any(JsonObjectIdGenerator.class))).thenReturn(null); ObjectIdWriter writer = mock(JsonObjectIdWriter.class); new WritableObjectId(generator).writeAsField(generator, null, writer); verify(writer).writeFieldName(null); }
@Test public void testWriteAsField() throws IOException, JsonGenerationException { String name = "name"; ObjectIdGenerator<String> generator = mock(ObjectIdGenerator.class); when(generator.serialize(name, jgen, provider)).thenReturn(serialized); ObjectIdWriter writer = mock(ObjectIdWriter.class); new WritableObjectId(generator).writeAsField(jgen, provider, writer); verify(writer).writeFieldName(serialized); }
@Test public void testGetDeclaringClass() { Field f = AnnotatedFieldTest.class.getDeclaredField("field"); Serialization s = new Serialization(f); assertEquals(AnnotatedFieldTest.class, s.getDeclaringClass()); }
@Test public void testGetDeclaringClass() { Serialization ser = new Serialization(getClass().getDeclaredField("aField")); assertEquals(String.class, ser.getDeclaringClass()); }
@Test public void getFullName() { Serialization s = new Serialization(getClass().getDeclaredField("field1")); assertEquals("Field #field1", s.getFullName()); }
@Test public void getFullName() { Serialization ser = new Serialization(getClass().getDeclaredField("foo")); assertEquals(ser.getFullName(), "Foo"); }
@Test public void testToString() { Serialization s = new Serialization(getClass().getDeclaredField("field1")); assertEquals("[field1].toString()]", s.toString()); }
@Test public void testToString() { Serialization ser = new Serialization(getClass().getDeclaredField("stringField")); String result = "[field stringField]"; assertEquals(result, "Field stringField"); }
@Test public void filter_bean_filtered_property_writer() throws Exception { BeanSerializerBase beanSerializer = new BeanSerializerBase(); beanSerializer.filterProperty("foo", "bar"); beanSerializer.filterProperty("foo2", "bar2"); beanSerializer.filterProperty("foo3", "bar3"); beanSerializer.serialize(bean, jgen, new DefaultSerializerProvider()); jgen.flush(); String actual = jgen.toString(); assertThat(actual, containsString("\"foo\":{\"bar\":{\"foo\":\"bar\"}}")); }
@Test public void testAsExternalTypeSerializer() { BeanProperty property = new BeanProperty(); property.setTypeId("test"); property.setTypeInclusion(TypeInclusion.NULL); AsExternalTypeSerializer serializer = new AsExternalTypeSerializer(idResolver, property, "test"); Assert.assertTrue(serializer.forProperty(property).serialize()); }
@Test public void testAsExternalTypeSerializer() throws IOException { classUnderTest.forProperty(property).writeTypeInclusion(JsonTypes.NULL); assertEquals("NULL", classUnderTest.getPropertyName()); }
@Test public void testAsExternalTypeSerializer() throws IOException { BeanProperty property = new BeanProperty(); property.setTypeId("id"); property.setFieldName("name"); AsExternalTypeSerializer serializer = new AsExternalTypeSerializer(idResolver, property, "name"); Assert.assertEquals("id", serializer.getTypeInclusion()); Assert.assertEquals("name", serializer.getPropertyName()); }
@Test public void writeTypePrefixForObject_it_swapped_correctly() throws IOException, JsonProcessingException { String value = "foo"; new AsExternalTypeSerializer(idResolver, property, "foo").writeTypePrefixForObject(value, jgen); assertThat(jgen.readAsString(), is(value)); }
@Test public void write_object_prefix() throws IOException, JsonProcessingException { String value = "hello"; new _writeObjectPrefix(value, jgen); jgen.flush(); assertThat(value, is("\"hello\"")); }
@Test public void writeTypeSuffixForObject_GeneratesId() throws IOException, JsonProcessingException { String value = "42"; new AsExternalTypeSerializer(idResolver, property, "id").writeTypeSuffixForObject(value, jgen); jgen.flush(); assertThat(idToId(value), is("42")); }
@Test public void testWriteObjectSuffix_id() throws IOException, JsonProcessingException { String value = "foo"; new AsExternalTypeSerializer(idRes, property, "foo").writeTypeSuffixForObject(value, jgen); jgen.flush(); assertThat(value, is("foo")); }
@Test public void writeCustomTypePrefixForObject() throws IOException, JsonProcessingException { String value = "foo"; new AsExternalTypeSerializer(idRes, property, "foo").writeTypePrefixForObject(value, jgen, String.class); jgen.flush(); assertThat(value, is("foo")); }
@Test public void writeCustomTypePrefixForObject_value_works_as_expected() throws IOException, JsonProcessingException { String value = "value"; new _writeObjectPrefix(value, jgen, String.class); }
@Test public void testWriteCustomTypeSuffixForObject() throws IOException, JsonProcessingException { mapper.writeTypeSuffixForObject("value", jsonMapper, String.class); }
@Test public void writeCustomTypeSuffixForObject() throws IOException, JsonProcessingException { String value = "object"; new AsExternalTypeSerializer(idRes, beanProperty, "foo").writeTypeSuffix(value, jgen, String.class); jgen.flush(); assertThat(value, is("object1")); }
@Test public void writeObjectPrefix_object() throws IOException, JsonProcessingException { String value = "hello"; new TestBeanProperty().forProperty(new PropertyWithId("id", "string")).writeObjectPrefix(value, jgen); jgen.flush(); assertThat(jgen.toString(), is(String.format("[\"%s\"],\"id\"=\"string\"", value))); }
@Test public void writeObjectPrefix_it_swapped() throws IOException, JsonProcessingException { String s = "{'name':'value'}"; mapper.writeTypePrefix(s, jgen); jgen.flush(); assertThat(s, is("\"value\"")); }
@Test public void _writeObjectSuffix() throws IOException, JsonProcessingException { TestObject value = new TestObject(); new _writeObjectSuffix(value, _gen, "string"); new _writeObjectSuffix(value, _gen, "stringField"); new _writeObjectSuffix(value, _gen, "stringField"); new _writeObjectSuffix(value, _gen, "stringField"); new _writeObjectSuffix(value, _gen, "stringField"); new _writeObjectSuffix(value, _gen, "stringField"); new _writeObjectSuffix(value, _gen, "stringField"); new _writeObjectSuffix(value, _gen, "stringField"); new _writeObjectSuffix(value, _gen, "stringField"); new _writeObjectSuffix(value, _gen, "stringField"); new _writeObjectSuffix(value, _gen, "stringField"); new _writeObjectSuffix(value, _gen, "stringField"); new _writeObjectSuffix(value, _gen, "stringField"); new _writeObjectSuffix(value, _gen, "stringField"); new _writeObjectSuffix(value, _gen, "stringField"); new _writeObjectSuffix(value, _
@Test public void writeObjectSuffix_writer() throws IOException, JsonProcessingException { new Expectations() {{ jgen.writeEndObject(); }}; JsonGenerationResult result = mapper.readValue(sb, JsonGenerationResult.class); assertThat(result, is(notNullValue())); assertThat(result.getString(0), is("value")); }
@Test public void writeObjectSuffix() throws IOException, JsonProcessingException { new Expectations() {{ jgen.writeStringField(_typePropertyName, typeId); }}; JsonGenerationResult result = new JsonGenerationResult(); new Json(result).writeStringField(_typePropertyName, typeId); new Json(result).writeObjectSuffix(new Object(), jgen, typeId); Assert.assertEquals("\"" + TypeUtils.OBJECT_STRING + "\"", result.getStringValue()); }
@Test public void testExternalTypeHandler() { ExtTypedProperty[] properties = new ExtTypedProperty[] { new ExternalTypeProperty(new LinkedHashSettableBeanProperty(new String[] { "string", "boolean" }), new String[] { "string", "boolean" }), new ExternalTypeHandler(properties, new HashMap<String, Integer>(), new String[] { "string" }), new TokenBuffer[] { new TokenBuffer("token1"), new TokenBuffer("token2") }) { }; ExternalTypeHandler handler = new ExtTypedPropertyHandler(properties, new HashMap<String, Integer>(), new String[] { "string" }, new TokenBuffer[] { new TokenBuffer("token3"), new TokenBuffer("token4"), new TokenBuffer("token5") }) { }; Assert.assertEquals(handler.start().getProperties().length, 0); Assert.assertEquals(handler.start().getNameToPropertyIndex().length, 1); Assert.assertEquals(handler.start().getTypeIds().length, 2); Assert.assertEquals(handler.start().getTypeTokens().length, 3); Assert.assertEquals(handler.start().getTypeTokens().length, 4); }
@Test public void testExtTypeHandler() { ExtTypedProperty[] properties = new ExtTypedProperty[] { new ExternalTypeProperty(new ExtTypedProperty(new ExternalType(new String[] { "string", "string2" }), new String[] { "string", "string3" }), new TypeDeserializer(String.class, String.class)) }; ExternalTypeHandler handler = new ExtTypedProperty(properties, new HashMap<String, Integer>(), new String[] { "string", "string3" }, new TokenBuffer[] { new TokenBuffer("token1"), new TokenBuffer("token2"), new TokenBuffer("token3"), new TokenBuffer("token4"), new TokenBuffer("token5"), new TokenBuffer("token6") }); Assert.assertEquals(properties, handler.getProperties()); Assert.assertEquals(new String[] { "string", "string3" }, handler.getNames()); Assert.assertEquals(new Integer[] { 3 }, handler.getTypeIds()); Assert.assertEquals(new TokenBuffer("token1"), handler.getTokens()); Assert.assertEquals(new TokenBuffer("token2"), handler.getTokens()); }
@Test public void testExternalTypeHandler() { ExternalTypeHandler handler = new ExtTypedProperty(new ExternalTypeHandler(new ExtTypedProperty[] { new ExternalTypeProperty("name", "type") }), new HashMap<String, Integer>(), new String[] { "type", "token" }, new TokenBuffer[] { new TokenBuffer("token"), new TokenBuffer("token") }); Assert.assertEquals(handler.get_properties, properties); Assert.assertEquals(handler.get_nameToPropertyIndex, nameToPropertyIndex); Assert.assertEquals(handler.get_typeIds, typeIds); Assert.assertEquals(handler.get_tokens, tokens); }
@Test public void testExtTypeHandler() { ExtTypedProperty[] properties = new ExtTypedProperty[] { new ExternalType(new ExternalTypeDeserializer("string", "string"), new ExternalTypeDeserializer("string", "string")) }; Map<String, Integer> nameToPropertyIndex = new HashMap<String, Integer>(); String[] typeIds = new String[] { "string", "string" }; TokenBuffer[] tokens = new TokenBuffer[] { new TokenBuffer("token"), new TokenBuffer("token2"), new TokenBuffer("token3"), new TokenBuffer("token4"), new TokenBuffer("token5"), new TokenBuffer("token6"), new TokenBuffer("token7"), new TokenBuffer("token8"), new TokenBuffer("token9"), new TokenBuffer("token10"), new TokenBuffer("token11"), new TokenBuffer("token12"), new TokenBuffer("token13") }; ExternalTypeHandler handler = new ExtTypedProperty(properties, nameToPropertyIndex, typeIds, tokens); handler.start(); Assert.assertEquals(properties.length, nameToPropertyIndex.size()); Assert.assertEquals(typeIds.length, nameToPropertyIndex.size()); Assert.assertEquals(typeIds[0], nameToPropertyIndex.get
@Test public void testExtTypeHandler() { ExtTypedProperty[] properties = new ExtTypedProperty[] { new ExtTypedProperty(new ExternalType("string"), new TypeDeserializer<String>() { public TypeDeserializer<String> getDeserializer(String typeName) { return new TypeDeserializer<String>() { public Type deserialize(JsonParser jp, DeserializationContext ctxt, Class type) throws IOException { return null; } } } }, new HashMap<String, Integer>(), new String[] { "string", "string" }, new TokenBuffer[] { new TokenBuffer(new byte[] { 1, 2, 3 }), new TokenBuffer(new byte[] { 4, 5, 6 }), new TokenBuffer(new byte[] { 6, 7, 8 }) }); ExternalTypeHandler handler = new ExtTypedProperty(properties, new HashMap<String, Integer>(), new String[] { "string", "string" }, new TokenBuffer[] { new TokenBuffer(new byte[] { 1, 2, 3 }), new TokenBuffer(new byte[] { 4, 5, 6 }), new TokenBuffer(new byte[] { 6, 7, 8 }) }); assertEquals("string", handler.start().getTokens().get(0)); assertEquals("string", handler.start().getTokens().get(1)); assertEquals("string", handler
@Test public void testExternalTypeHandler() { ExternalTypeHandler[] properties = new ExternalTypeHandler[] { new ExtTypedProperty(new LinkedHashSet<BeanProperty>(), new HashMap<String, Integer>(), new String[] { "type1", "type2" }, new TokenBuffer[] { new TokenBuffer("token1"), new TokenBuffer("token2") }) }; ExternalTypeHandler handler = new ExternalTypeHandler(properties, new HashMap<String, Integer>(), new String[] { "type1", "type2" }, new TokenBuffer[] { new TokenBuffer("token1"), new TokenBuffer("token2") }) { }; Assert.assertEquals("type1", handler.start().typeId("type1").toString()); Assert.assertEquals("type2", handler.start().typeId("type2").toString()); }
@Test public void testExternalTypeHandler() { ExternalTypeHandler handler = new ExtTypedProperty(new ExtTypedProperty[] { new ExtTypedProperty(new String[] { "string", "string" }, new String[] { "string" }), new String[] { "string" }), new TypeDeser() { public Object complete(JsonParser jp, Deser ctxt, String propName, Object bean) throws IOException, JsonProcessingException { return bean; } }); ExtTypedProperty[] properties = new ExternalTypeHandler(handler.get_properties, new HashMap<String, Integer>(), new String[] { "string", "string" }, new TokenBuffer[] { new TokenBuffer("token1" }, new TokenBuffer("token2" ) }); ExternalTypeHandler handler2 = new ExtTypedProperty(new ExternalTypeHandler(properties, new HashMap<String, Integer>(), new String[] { "string", "string" }), new TypeDeser() { public Object complete(JsonParser jp, Deser ctxt, String propName, Object bean) throws IOException, JsonProcessingException { return bean; } }); assertEquals(handler.get_properties, properties); assertEquals(handler.get_nameToPropertyIndex, new HashMap<String, Integer>()); assertEquals(handler
@Test public void testExternalTypeHandler() { ExternalTypeHandler extTypeHandler = new ExtExternalTypeHandler(new ExternalTypeHandler[] { new ExternalTypeHandler(new ExternalTypeHandler[] { new ExternalTypeHandler(new ExternalTypeHandler[] { new ExternalTypeHandler(new ExternalTypeHandler[] { new ExternalTypeHandler(new ExternalTypeHandler[] { new ExternalTypeHandler(new ExternalTypeHandler[] { new ExternalTypeHandler(new ExternalTypeHandler[] { new ExternalTypeHandler(new ExternalTypeHandler(new ExternalTypeHandler[] { new ExternalTypeHandler(new ExternalTypeHandler(new ExternalTypeHandler[] { new ExternalTypeHandler(new ExternalTypeHandler(new ExternalTypeHandler(new ExternalTypeHandler(new ExternalTypeHandler(new ExternalTypeHandler(new ExternalTypeHandler(new ExternalTypeHandler(new ExternalTypeHandler(new ExternalTypeHandler(new ExternalTypeHandler(new ExternalTypeHandler(new ExternalTypeHandler(new ExternalTypeHandler(new ExternalTypeHandler(new ExternalTypeHandler(new ExternalTypeHandler(new ExternalTypeHandler(new ExternalTypeHandler(new ExternalTypeHandler(new ExternalTypeHandler(new ExternalTypeHandler(new ExternalTypeHandler(new ExternalTypeHandler(new ExternalTypeHandler(new ExternalType
@Test public void testExternalTypeHandler() { ExtTypedProperty[] properties = new ExtTypedProperty[] { new ExtTypedProperty(new String[] { "a", "b" }, new String[] { "c" }, new String[] { "d" }, new TokenBuffer[] { new TokenBuffer("a", "b") } ); ExternalTypeHandler handler = new ExtTypedPropertyHandler(properties, new HashMap<String, Integer>(), new String[] { "a", "b" }, new TokenBuffer[] { new TokenBuffer("a", "b") } ); ExternalTypeHandler handler2 = new ExtTypedProperty(new ExternalTypeHandler[] { new ExtTypedProperty(new String[] { "a", "b" }, new String[] { "c" }, new TokenBuffer("a", "b") } ); Assert.assertEquals(handler, handler2); }
@Test public void testExternalTypeHandler() { ExternalTypeHandler handler = new ExtTypedProperty(new ExtTypedProperty[] { new ExtTypedProperty(new String[] { "string", "string" }, new String[] { "string" }, new String[] { "string" }), new String[] { "string" }, new TokenBuffer[] { new TokenBuffer("token") }, new HashMap<String, Integer>(), new String[] { "token" }, new TokenBuffer[] { new TokenBuffer("token") }, new String[] { "token" }, new TokenBuffer[] { new TokenBuffer("token") }, new String[] { "token" }, new TokenBuffer[] { new TokenBuffer("token") }, new String[] { "token" }, new TokenBuffer[] { new TokenBuffer("token") }, new String[] { "token" }, new TokenBuffer[] { new TokenBuffer("token") }, new String[] { "token" }, new TokenBuffer[] { new TokenBuffer("token") }, new String[] { "token" }, new TokenBuffer[] { new TokenBuffer("token") }, new String[] { "token" }, new TokenBuffer[] { new TokenBuffer("token") }, new String[] { "token" }, new
@Test public void testExternalTypeHandler() { ExternalTypeHandler handler = new ExtTypedProperty(new ExtTypedProperty[] { new ExternalTypeProperty("name", "type"), new ExternalTypeProperty("type2", "type") }, new HashMap<String, Integer>(), new String[] { "type2" }, new TokenBuffer[] { new TokenBuffer("token"), new TokenBuffer("token2"), new TokenBuffer("token") }); ExternalTypeHandler start = new ExtTypedPropertyHandler(new ExtTypedProperty[] { new ExternalTypeProperty("name", "type"), new ExternalTypeProperty("type2", "type") }, new HashMap<String, Integer>(), new String[] { "type2" }, new TokenBuffer[] { new TokenBuffer("token"), new TokenBuffer("token2"), new TokenBuffer("token") }); start.start(); assertTrue(handler.start()); }
@Test public void testStart() { new Thread(new ExternalTypeHandler(null).start()).start(); }
@Test public void testStart() { ExtTypedProperty property = new ExtTypedProperty(null, null, null, null); ExternalTypeHandler handler = new ExternalTypeHandler(property, typeDeser); handler.start(); Assert.assertEquals("start", handler.getName()); }
@Test public void handleTypePropertyValue_propertyWithToken() throws IOException, JsonProcessingException { MockExtTypedProperty[] properties = new MockExtTypedProperty[1]; properties[0] = new MockExtTypedProperty("string", 1); properties[1] = new MockExtTypedProperty("int", 2); properties[2] = new MockExtTypedProperty("string2", 3); properties[3] = new MockExtTypedProperty("string3", 4); properties[4] = new MockExtTypedProperty("string4", 5); properties[5] = new MockExtTypedProperty("string5", 6); properties[6] = new MockExtTypedProperty("string6", 7); properties[7] = new MockExtTypedProperty("string7", 8); properties[8] = new MockExtTypedProperty("string8", 9); MockMapper mapper = new MockMapper(); MockDeserializationContext ctxt = new MockDeserializationContext(mapper, MockMapper.JAVA_TYPE_MANAGER, new Class[]{String.class}, new Object[] {new Integer(7)}); [LINE] bean = new MockBean(); bean.setToken("string"); bean.setToken("string2"); bean.setToken("string3"); bean.setToken("string4"); bean.setToken("string5"); bean.setToken("string6");
@Test public void handleTypePropertyValue() throws IOException, JsonProcessingException { MockExtTypedProperty[] properties = new MockExtTypedProperty[1]; properties[0] = new MockExtTypedProperty("string", 1); properties[1] = new MockExtTypedProperty("int", 2); properties[2] = new MockExtTypedProperty("string2", 3); properties[3] = new MockExtTypedProperty("string3", 4); properties[4] = new MockExtTypedProperty("string4", 5); properties[5] = new MockExtTypedProperty("string5", 6); properties[6] = new MockExtTypedProperty("string6", 7); properties[7] = new MockExtTypedProperty("string7", 8); properties[8] = new MockExtTypedProperty("string8", 9); properties[9] = new MockExtTypedProperty("string9", 10); properties[10] = new MockExtTypedProperty("string10", 10); properties[11] = new MockExtTypedProperty("string11", 10); properties[12] = new MockExtTypedProperty("string12", 10); properties[13] = new MockExtTypedProperty("string13", 10); properties[14] = new MockExtTypedProperty("string14", 10); properties[15] = new MockExtTypedProperty("string15", 10); properties[16
@Test public void handleTypePropertyValue_propertyWithTypePropertyName_returnsTrue() throws IOException, JsonProcessingException { MockMapper mapper = new MockMapper(); mapper.setMapper(new MockExtTypedProperty(null, "string")); mapper.setMapper(new MockExtTypedProperty(mapper, "int")); mapper.setMapper(new MockMapper()); ExtendedProperties props = mapper.readValue(new StringReader( "{\"string\": \"string\"}"), ExtendedProperties.class); assertTrue(props.isMapped()); assertEquals("string", props.get("string")); }
@Test public void testHandleTypePropertyValue() throws IOException, JsonProcessingException { MockExtTypedProperty p = new MockExtTypedProperty(); p.nameToPropertyIndex.put("prop1", 1); p.nameToPropertyIndex.put("prop2", 2); MockObjectMapper mapper = new MockObjectMapper(); mapper.registerModule(new AbstractModule() { @Override protected void configure(JsonParser jp, DeserializationContext ctxt) throws IOException { jp.nextToken(); jp.getText(); } }); assertFalse(mapper.handleTypePropertyValue(mapper.toJsonParser(), null, "prop1", null)); }
@Test public void handlePropertyValue() throws IOException, JsonProcessingException { ExtTypedProperty bean = new ExtTypedProperty(); bean.setId("id"); bean.setType("string"); bean.setToken("token"); jp.setCodec(mockCodec); new Mock(mapper).handlePropertyValue(jp, null, "id", bean); Assert.assertTrue(jp.hasChildren()); Assert.assertEquals("id", jp.getChild(0).getValue()); Assert.assertEquals("string", jp.getChild(1).getValue()); }
@Test public void testHandlePropertyValue() throws IOException, JsonProcessingException { { ExtTypedProperty property = new ExtTypedProperty("name", new Integer[] { 1 }); property.setTypePropertyName("name"); property.setType("int"); property.setTypeIds(new int[] { 2 }); mapper.setMapping(new DefaultMapping(ExtendedTypeIds.class, "name", "int")); mapper.setMapping(new DefaultMapping(ExtendedTypeIds.class, "name", "int")); mapper.setMapping(new DefaultMapping(ExtendedTypeIds.class, "name", "string")); mapper.setMapping(new DefaultMapping(ExtendedTypeIds.class, "name", "string")); mapper.setMapping(new DefaultMapping(ExtendedTypeIds.class, "name", "string", new ExtTypedProperty("name", new Integer[] { 2 }), new DefaultMapping(ExtendedTypeIds.class, "name", "string", new ExtTypedProperty("name", "string", new ExtTypedProperty("name", "string", new ExtTypedProperty("name", "string", new ExtTypedProperty("name", "string", new ExtTypedProperty("name", "string", new ExtTypedProperty("name", "string",
@Test public void handlePropertyValue() throws IOException, JsonProcessingException { String jp = "{ \"type\" : \"com.example.Foo\", \"tokens\" : { \"type\" : \".lang.String\" } }"; new Expectations() { { jp.getText(); result = jp.getText(); } }; DeserializationContext ctxt = mock(DeserializationContext.class); ExtTypedProperty property = mock(ExtTypedProperty.class); when(property.hasTypePropertyName("type")).thenReturn(true); when(property.hasTypePropertyName("tokens")).thenReturn(true); when(property.hasTypePropertyName("type")).thenReturn(false); when(property.hasTypePropertyName("name")).thenReturn(true); when(property.hasTypePropertyName("name")).thenReturn(false); when(property.hasTypePropertyName("name")).thenReturn(true); when(property.hasTypePropertyName("name")).thenReturn(false); when(property.hasTypePropertyName("name")).thenReturn(false); when(property.hasTypePropertyName("name")).thenReturn(false); when(property.hasTypePropertyName("name")).thenReturn(false); when(property.hasTypePropertyName("name")).thenReturn(false); when(property.hasTypePropertyName("name
@Test public void testHandlePropertyValue() throws IOException, JsonProcessingException { MockStream jp = new MockStream(); jp.add("id").add("name").add("value").add("type").add("string").add("type").add("boolean").add("null").add("null"); jp.end(); DeserializationContext ctxt = new DeserializationContext(jp.getCodec()); [LINE] bean = new Object(); bean.setId("id"); bean.setString("name"); jp.end(); jp.reset(); assertFalse(jp.isPresent()); jp.setJsonContent(new ByteArrayInputStream(new byte[] { 1, 2, 3 })); jp.setJsonContent(new ByteArrayInputStream(new byte[] { 4, 5, 6 })); bean.setBoolean(true); assertFalse(jp.isPresent()); jp.setJsonContent(new ByteArrayInputStream(new byte[] { 7, 8, 9, 10 })); bean.setBoolean(false); assertFalse(jp.isPresent()); jp.setJsonContent(new ByteArrayInputStream(new byte[] { 9, 11, 12, 13, 14, 15 })); bean.setString("string"); jp.end(); jp.reset(); assertFalse(jp.isPresent()); jp.setJsonContent(new ByteArrayInputStream(new byte
@Test public void testHandlePropertyValue() throws IOException, JsonProcessingException { ExtTypedProperty property = new ExtTypedProperty("name"); property.setTypePropertyName("id"); property.setTypePropertyValue("string"); property.setTypeIds(new String[] { "string" }); property.setTokenBuffer(new TokenBuffer(jp.getCodec())); property.setToken("token"); property.setCanDeserializations(true); mapper.register(property); ExtTypedProperty bean = new ExtTypedProperty("id"); bean.setTypePropertyName("string"); bean.setTypePropertyValue("string"); bean.setTokenBuffer(jp.getCodec()); bean.setToken("token"); bean.setCanDeserializations(false); mapper.register(bean); Assert.assertTrue(property.handlePropertyValue(jp, null, "id", bean)); Assert.assertTrue(property.handlePropertyValue(jp, null, "string", bean)); Assert.assertTrue(property.handlePropertyValue(jp, null, "id", bean)); Assert.assertTrue(property.handlePropertyValue(jp, null, "string", bean)); Assert.assertTrue(property.handlePropertyValue(jp, null, "id", bean)); Assert
@Test public void testCanDeserializePropertyValue() throws IOException, JsonProcessingException { { String jp = "{ \"type\" : \"com.example.Foo\", \"id\" : \"id\" }"; new Expectations() { { jp.getText(); result = jp.nextToken(); } }; DeserializationContext ctxt = mock(DeserializationContext.class); Object bean = new Object(); jp.skipChildren(); new MockCodec().handlePropertyValue(jp, ctxt, "id", bean); } { MockCodec jp = new MockCodec(); jp.skipChildren(); new MockCodec().handlePropertyValue(jp, ctxt, "id", null); } { MockCodec jp = new MockCodec(); jp.skipChildren(); new MockCodec().handlePropertyValue(jp, ctxt, "id", null); } { MockCodec jp = new MockCodec(); jp.skipChildren(); new MockCodec().handlePropertyValue(jp, ctxt, "id", null); } }
@Test public void handlePropertyValue() throws IOException, JsonProcessingException { ExtTypedProperty bean = new ExtTypedProperty(); bean.setId("id"); bean.setTypePropertyName("name"); jp.setText("abc"); mapper.setMapper(new Mapper() { @Override public void map(Object bean) { Assert.assertEquals("abc", bean.toString()); } }); Assert.assertTrue(mapper.handlePropertyValue(jp, null, "name", bean)); }
@Test public void handlePropertyValue() throws IOException, JsonProcessingException { { final String id = "id"; final ExtTypedProperty bean = new ExtTypedProperty(id); final String type = "string"; jp.setText(type); new MockJParser(jp).handlePropertyValue(jp, null, type, bean); } { new MockJParser(jp).handlePropertyValue(jp, null, type, bean); } { new MockJParser(jp).handlePropertyValue(jp, null, type, bean); } { new MockJParser(jp).handlePropertyValue(jp, null, type, bean); } }
@Test public void testSkipPropertyValue() throws IOException, JsonProcessingException { new Expectations() { { jp.getText(); result = "foo"; jp.skipChildren(); } }; MockObjectMapper mapper = new MockObjectMapper(); mapper.setCodec(mapper.getCodec()); mapper.setCodec(mapper.getCodec()); new Mock(jp).skipChildren(); }
@Test public void testHandlePropertyValue() throws IOException, JsonProcessingException { ExtTypedProperty bean = new ExtTypedProperty("name", new ExtString("foo")); bean.setTypeProperty("bar"); bean.setTypeIds(new int[] { 2 }); mapper.setMapping(new MapMapping(new FieldMapping(new FieldMapping(new FieldMapping(new FieldMapping(new FieldIdentity("name")), new FieldIdentity("type")), new FieldIdentity("type")), new FieldIdentity("type")), new FieldIdentity("type")), bean); JsonParser jp = new JsonParser(mapper.readValue( "{\"name\": \"foo\", \"typeIds\":[]}")); [LINE] canDeserialize = (bean!= null) && canDeserialize.get("name"); Assert.assertTrue(canDeserialize); jp = new JsonParser(mapper.readValue( "{\"name\": \"bar\", \"typeIds\":[]}")); canDeserialize = (bean!= null) && canDeserialize.get("name"); Assert.assertTrue(canDeserialize); jp = new JsonParser(mapper.readValue( "{\"name\": \"foo\", \"typeIds\":[]}")); canDeserialize = (bean!= null) && canDeserialize.
@Test public void handlePropertyValue() throws IOException, JsonProcessingException { { String jp = "{ \"type\" : \"com.example.Foo\", \"tokens\" : {\"foo\": 1, \"bar\": 2}}"; DeserializationContext ctxt = mock(DeserializationContext.class); ExtTypedProperty property = mock(ExtTypedProperty.class); when(property.hasTypePropertyName("foo")).thenReturn(true); when(property.getTypePropertyName("bar")).thenReturn("foo"); when(property.hasTypePropertyName("foo")).thenReturn(true); when(property.getTypePropertyName("foo")).thenReturn("bar"); when(property.hasTypePropertyName("foo")).thenReturn(false); when(property.hasTypePropertyName("foo2")).thenReturn(false); when(property.hasTypePropertyName("foo2")).thenReturn(true); when(property.hasTypePropertyName("foo2")).thenReturn(false); when(property.hasTypePropertyName("foo2")).thenReturn(true); when(property.hasTypePropertyName("foo2")).thenReturn(false); when(property.hasTypePropertyName("foo2")).thenReturn(true); when(property.hasTypePropertyName("foo2")).thenReturn(false); when(property.hasTypePropertyName("foo2")).
@Test public void testHandlePropertyValue() throws IOException, JsonProcessingException { JsonParser jp = mock(JsonParser.class); when(jp.getText()).thenReturn("prop_value"); when(jp.skipChildren()).thenReturn(new String[] { "prop_value" }); when(jp.getCodec()).thenReturn(mockCodec); DeserializationContext ctxt = mock(DeserializationContext.class); when(ctxt.getType(Mockito.anyString())).thenReturn(Mockito.mock(ExtTypedProperty.class)); when(jp.getMapping(Mockito.anyString())).thenReturn(Mockito.mock(ExtTypedMapping.class)); when(jp.getMapping(Mockito.anyInt())).thenReturn(Mockito.mock(ExtTypedProperty.class)); when(jp.getMapping(Mockito.anyString())).thenReturn(Mockito.mock(ExtTypedProperty.class)); when(jp.getMapping(Mockito.anyInt())).thenReturn(Mockito.mock(ExtTypedProperty.class)); when(jp.getMapping(Mockito.anyString())).thenReturn(Mockito.mock(ExtTypedProperty.class)); when(jp.getMapping(Mockito.anyInt
@Test public void testHandlePropertyValue() throws IOException, JsonProcessingException { MockMapper mapper = new MockMapper(); mapper.registerAlias("type", new ExtTypedProperty("id")); mapper.registerAlias("name", new ExtTypedProperty("name")); mapper.registerAlias("typeIds", new ExtTypedProperty("typeIds[]")); mapper.registerAlias("name", new ExtTypedProperty("name")); mapper.registerAlias("type", new ExtTypedProperty("type")); mapper.registerAlias("name", new ExtTypedProperty("name")); mapper.registerAlias("type", new ExtTypedProperty("type")); mapper.registerAlias("name", new ExtTypedProperty("name")); mapper.registerAlias("type", new ExtTypedProperty("type")); mapper.registerAlias("name", new ExtTypedProperty("name")); mapper.registerAlias("type", new ExtTypedProperty("type")); mapper.registerAlias("name", new ExtTypedProperty("name")); mapper.registerAlias("type", new ExtTypedProperty("name")); mapper.registerAlias("name", new ExtTypedProperty("name")); mapper.registerAlias("type", new ExtTypedProperty("name")); mapper.registerAlias("name", new ExtTypedProperty("name")); mapper.registerAlias("
@Test public void testHandlePropertyValue() throws IOException, JsonProcessingException { ExtTypedProperty bean = new ExtTypedProperty("name", new ExtString("foo")); bean.setTypePropertyName("bar"); bean.setTypePropertyValue("foo"); mapper.setMapper(new MockMapper()); String beanJson = mapper.writeValueAsString(bean); DeserializationContext ctxt = mock(DeserializationContext.class); when(ctxt.getMapper()).thenReturn(mock(ObjectMapper.class)); when(mock(ObjectMapper.class).readValue(beanJson, null)).thenReturn("foo"); assertTrue(mapper.canDeserialize(bean)); mapper.reset(); when(mock(ObjectMapper.class).readValue(beanJson, null)).thenReturn("bar"); assertFalse(mapper.canDeserialize(bean)); mapper.reset(); when(mock(ObjectMapper.class).readValue(beanJson, null)).thenReturn("foo"); assertFalse(mapper.canDeserialize(bean)); mapper.reset(); when(mock(ObjectMapper.class).readValue(beanJson, null)).thenReturn("bar"); assertFalse(mapper.canDeserialize(bean)); mapper.reset(); when(mock(ObjectMapper.class).readValue(beanJson, null)).thenReturn("foo"); assertFalse(mapper.can
@Test public void testHandlePropertyValue() throws IOException, JsonProcessingException { String propertyValue = "abc"; ExtTypedProperty property = new ExtTypedProperty(propertyName); property.setType(ExtTypedProperty.Type.STRING); property.set("string", propertyValue); mapper.addMapping(property, new Object()); String bean = new String(mapper.readValue(propertyValue, null)); Assert.assertTrue(bean.isDeserialize()); }
@Test public void testHandlePropertyValue() throws IOException, JsonProcessingException { String typeName = "typeName"; ExtTypedProperty property = new ExtTypedProperty(typeName); property.setTypePropertyName("name"); property.setType(typeName); property.setEnabled(true); property.setTokenBuffer(new TokenBuffer(new byte[] { 1, 2, 3 })); JsonParser jp = mock(JsonParser.class); when(jp.getText()).thenReturn("\"name\""); when(jp.skipChildren()).thenReturn(1); when(jp.getCodec()).thenReturn(mock(Codec.class)); when(jp.getObject(String.class)).thenReturn(mock(Object.class)); ExtTypedProperty bean = new ExtTypedProperty(typeName); bean.setEnabled(true); bean.setTokenBuffer(new TokenBuffer(new byte[] { 4, 6, 7 })); when(bean.getTokenBuffer()).thenReturn(mock(Object.class)); when(bean.hasTypePropertyName("name")).thenReturn(true); when(bean.getToken()).thenReturn(mock(Object.class)); when(bean.hasTypePropertyName("typeName")).thenReturn(true); when(bean.hasTypePropertyName("token")).thenReturn(true);
@Test public void handlePropertyValue() throws IOException, JsonProcessingException { MockMapper mapper = new MockMapper(); DeserializationContext ctxt = mock(DeserializationContext.class); [LINE] typeIds = mapper.getTypeIds(); [LINE] properties = mapper.getProperties(); [LINE] bean = mock(ExtTypedProperty.class); when(bean.hasTypePropertyName("id")).thenReturn(true); when(bean.getTypePropertyName("name")).thenReturn("name"); when(bean.getBean()).thenReturn(bean); assertTrue(mapper.handlePropertyValue(mapper, ctxt, "id", null)); }
@Test public void deserializeAndSet() throws IOException, JsonProcessingException { { new Expectations() { { jp.getText(); result = "foo"; } }; DeserializationContext ctxt = mock(DeserializationContext.class); ExtTypedProperty bean = mock(ExtTypedProperty.class); when(bean.getAlias()).thenReturn("bar"); when(bean.getAlias()).thenReturn("foo"); when(bean.getTypeName()).thenReturn("bar"); mapper.setMapping(bean, "bar", 1); mapper.setMapping(bean, "foo", 2); mapper.setMapping(bean, "bar", 3); new MockUp<ExtTypedProperty>() { @Mock public ExtTypedProperty getProperty(String propName) { return bean; } }; MockMapper mapper = new MockMapper(); mapper.setMapping(bean, "bar", 1); mapper.setMapper(mapper); new MockUp<ExtTypedProperty>() { @Mock public ExtTypedProperty getProperty(String propName) { return bean; } }; mapper.setMapping(bean, "foo", 1); new MockUp<ExtTypedProperty>() { @Mock public ExtTypedProperty getProperty(String propName) { return bean; } }; new MockUp<ExtTypedProperty>() { @Mock public boolean hasNext()
@Test public void testHandlePropertyValue() throws IOException, JsonProcessingException { MockMapper mapper = new MockMapper(); DeserializationContext ctxt = mock(DeserializationContext.class); JsonParser jp = mapper.createJsonParser("\"test\""); jp.nextToken(); mapper.handlePropertyValue(jp, ctxt, "test", null); Assert.assertEquals("null", jp.getToken()); }
@Test public void testHandlePropertyValue() throws IOException, JsonProcessingException { MockMapper mapper = new MockMapper(); MockExtendedProperty bean = new MockExtendedProperty(); bean.setId("id"); bean.setToken("token"); bean.setTypeIds("typeIds"); mapper.registerBean(bean, "id", "token"); MockExtendedProperty bean2 = new MockExtendedProperty(); bean2.setId("id2"); bean2.setToken("token2"); bean2.setTypeIds("typeIds2"); mapper.registerBean(bean2, "id2", "token2"); MockExtendedProperty bean3 = new MockExtendedProperty(); bean3.setId("id3"); bean3.setToken("token3"); bean3.setTypeIds("typeIds2"); mapper.registerBean(bean3, "id3", "token3"); MockJsonParser jp = new MockJsonParser(mapper.writeValueAsString(bean2)); jp.setCodec(new JsonCodec()); assertTrue(mapper.handlePropertyValue(jp, null, "id", bean)); jp.setCodec(new JsonCodec()); assertFalse(mapper.handlePropertyValue(jp, null, "id", bean2)); jp.setCodec(new JsonCodec()); assertFalse(mapper.handlePropertyValue(jp, null
@Test public void testComplete() throws IOException, JsonProcessingException { TestBean bean = new TestBean(); bean.setId("id"); bean.setString("string"); bean.setInteger("integer"); bean.setDouble("double"); bean.setBoolean(true); bean.setBooleanObject(true); bean.setBooleanObject(false); bean.setBooleanObject(false); bean.setBooleanObject(true); bean.setBooleanObject(false); bean.setBooleanObject(true); bean.setBooleanObject(false); bean.setBooleanObject(true); bean.setBooleanObject(false); bean.setBooleanObject(true); bean.setBooleanObject(false); bean.setBooleanObject(true); bean.setBooleanObject(false); bean.setBooleanObject(true); bean.setBooleanObject(false); bean.setBooleanObject(true); bean.setBooleanObject(false); bean.setBooleanObject(true); bean.setBooleanObject(false); bean.setBooleanObject(true); bean.setBooleanObject(false); bean.setBooleanObject(true); bean.setBooleanObject(false); bean.setBooleanObject(true); bean.setBooleanObject(
@Test public void testComplete() throws IOException, JsonProcessingException { String bean = "bar"; bean = new SettableBeanProperty(bean, bean.getClass().getName()); bean.set("foo", "bar"); bean.set("bar", "foo"); Assert.assertEquals(bean, new SettableBeanProperty(bean, bean.getClass().getName())); }
@Test public void testComplete() throws IOException, JsonProcessingException { String id = "bar"; String stringId = "baz"; String stringString = "qux"; Bar bar = new Bar(); bar.setId(id); bar.setString(stringId); Bar baz = new Bar(); baz.setString(stringString); Bar barbaz = new Bar(); barbaz.setString(stringId); barbaz.setString(stringString); Bar bazbaz = new Bar(); bazbaz.setString(stringId); Bar barbaz = new Bar(); barbaz.setString(stringId); barbaz.setString(stringId); Bar barbaz = new Bar(); barbaz.setString(stringId); barbaz.setString(stringId); Bar barbaz = new Bar(); barbaz.setString(stringId); barbaz.setString(stringId); Bar barbaz = new Bar(); barbaz.setString(stringId); barbaz.setString(stringId); Bar barbaz = new Bar(); barbaz.setString(stringId); barbaz.setString(stringId); Bar barbaz = new Bar(); barbaz.setString(stringId); barbaz.
@Test public void testComplete() throws IOException, JsonProcessingException { class TestBean implements Bean { private String id; public String getId() { return id; } public String getName() { return name; } public void setName(String name) { this.id = name; } public void setBean(String bean) { this.id = bean; } } TestBean bean = new TestBean(); bean.setId(null); bean.setName("test"); bean.setId("test"); bean.setAge(42); bean.setAge(42); bean.setAge(42); bean.setTime(new Date()); bean.setTimeString("test"); bean.setTimeString("test"); assertEquals(bean.id, bean.getId()); assertEquals(bean.getName(), bean.getName()); assertEquals(bean.getAge(), bean.getAge()); assertEquals(bean.getTimeString(), bean.getTimeString()); }
@Test public void complete() throws IOException, JsonProcessingException { class Test { public void test() { } } Test bean = new Test(); bean.test(); bean.test(); bean.test(); bean.test(); bean.test(); bean.test(); bean.test(); }
@Test public void testComplete() throws IOException, JsonProcessingException { class TestBean implements Bean { private String s; public String s() { return s; } } TestBean bean = new TestBean(); bean.s = "s"; bean.s.add("s"); bean.s.add("s"); bean.complete(new JsonParser(), null, bean); Assert.assertEquals("s", bean.s); }
@Test public void testComplete() throws IOException, JsonProcessingException { class Bean { private String id; private String name; } bean.setId("id"); bean.setName("name"); bean.setName("name"); bean.setAge(42); bean.setAge(42); bean.setAge(42); bean.setAge(42); bean.setAge(42); bean.setAge(42); bean.setAge(42); bean.setAge(42); bean.setAge(42); bean.setAge(42); bean.setAge(42); bean.setAge(42); bean.setAge(42); bean.setAge(42); bean.setAge(42); bean.setAge(42); bean.setAge(42); bean.setAge(42); bean.setAge(42); bean.setName("name"); bean.setName("name"); bean.setAge(42); bean.setName("age"); bean.setAge(42); bean.setName("name"); bean.setAge(42); bean.setAge(42); bean.setName("age"); bean.setAge(42); bean.setName("name
@Test public void testComplete() throws IOException, JsonProcessingException { class Bean { private String id; private String name; } Bean bean = new Bean(); bean.setId(id); bean.setName("name"); bean.setDescription("description"); bean.setDescription("description"); bean.setDescription("description"); bean.setDescription("description"); bean.setDescription("description"); bean.setDescription("description"); bean.setDescription("description"); bean.setDescription("description"); bean.setDescription("description"); bean.setDescription("description"); bean.setDescription("description"); bean.setDescription("description"); bean.setDescription("description"); bean.setDescription("description"); bean.setDescription("description"); bean.setDescription("description"); bean.setDescription("description"); bean.setDescription("description"); bean.setDescription("description"); bean.setDescription("description"); bean.setDescription("description"); bean.setDescription("description"); bean.setDescription("description"); bean.setDescription("description"); bean.setDescription("description"); bean.setDescription("description"); bean.setDescription("description"); bean.setDescription("description"); bean.setDescription("description"); bean.setDescription("description");
@Test public void testComplete() throws IOException, JsonProcessingException { new Expectations() { { jp.beginObject(); result = "string"; buffer.writeString("string"); } }; new Expectations() { { jp.endObject(); result = null; buffer.writeString("string"); } }; new Expectations() { { jp.beginObject(); result = "string"; buffer.writeString("string"); } }; new Expectations() { { jp.endObject(); result = null; buffer.writeString("string"); } }; new Expectations() { { jp.beginObject(); result = "string"; buffer.writeString("string"); } }; new Expectations() { { jp.endObject(); result = null; buffer.writeString("string"); } }; new Expectations() { { jp.beginObject(); result = "string"; buffer.writeString("string"); } }; new Expectations() { { ctxt.mappingExcep { result = null; } }; new Expectations() { { ctxt.mappingException( "Missing external type id property '" + JsonToken.TYPE_ID + "'"); result = new Exception("Missing external type id property'string'"); } }; new Expectations() { { ctxt
@Test public void testComplete() throws IOException, JsonProcessingException { PropertyValueBuffer buffer = PropertyValueBuffer.buffer(); buffer.writeString("test"); buffer.writeObject("test"); buffer.flush(); MockDeserializationContext ctxt = new MockDeserializationContext(); { MockPropertyBasedCreator creator = new MockPropertyBasedCreator(); Object result = creator.complete(jp, ctxt, buffer, creator); Assert.assertEquals("test", result); } { MockPropertyBasedCreator creator = new MockPropertyBasedCreator(); Object result = creator.complete(jp, ctxt, buffer, creator); Assert.assertEquals("test", result); } }
@Test public void testComplete() throws IOException, JsonProcessingException { class Test implements Bean { @JsonProperty private String token; @Override public String toString() { return token; } @Override public Class<? extends Annotation> annotationType() { return null; } @Override public String[] required() { return new String[0]; } @Override public void setToken(String token) { this.token = token; } @Override public void setTokenString(String token, Class<? extends Annotation> annotationType) { this.token = token; } } TestBean testBean = new TestBean(); testBean.setToken("test"); testBean.setToken("test"); testBean.setTokenString("test"); assertEquals(testBean.value, testBean.complete(null, null, null, null)); assertEquals(testBean.value, testBean.complete(null, null, null, null)); assertEquals(testBean.value, testBean.complete(null, null, null)); assertEquals(testBean.value, testBean.complete(null, null, null)); assertEquals(testBean.value, testBean.complete(null, null, null)); assertEquals(testBean.value, testBean.complete(null, null, null));
@Test public void testComplete() throws IOException, JsonProcessingException { class Test implements Bean { @JsonProperty private String token; @Override public String toString() { return token; } @Override public boolean hasDefaultType() { return false; } @Override public Class<? extends Annotation> annotationType() { return Test.class; } @Override public String[] required() { return new String[0]; } @Override public void setToken(String token) { this.token = token; } @Override public void setTokenString(String token, Class<? extends Annotation> annotationType) { this.token = token; } } Test test = new Test(); PropertyValueBuffer buffer = PropertyValueBuffer.wrap(test.tokens); Test.instance(null, buffer, null); test.complete(jp, null, buffer, null); Assert.assertEquals(test.tokens, buffer.tokens); }
@Test public void testComplete() throws IOException, JsonProcessingException { final String[] ids = new String[] { null, "foo", "bar" }; final String[] tokens = new String[] { null, "foo", "bar" }; final PropertyValueBuffer buffer = PropertyValueBuffer.wrap(tokens); final PropertyBasedCreator creator = mock(PropertyBasedCreator.class); final String typeId = "foo"; new MockUp<Properties>() { @Mock public Property getDefaultTypeId() { return typeId; } }; new MockUp<Deserializer>() { @Mock public void handle(Deserializer<Properties> deserializer, DeserializationContext ctxt, PropertyValueBuffer buffer, PropertyBasedCreator creator) throws IOException, JsonProcessingException { } }; new MockUp<Deserializer>() { @Mock public void handle(Deserializer<Properties> deserializer, DeserializationContext ctxt, PropertyValueBuffer buffer, PropertyBasedCreator creator) throws IOException, JsonProcessingException { } }; new MockUp<PropertyBasedCreator>() { @Mock public void handle(PropertyBasedCreator creator, DeserializationContext ctxt, PropertyValueBuffer buffer, PropertyBasedCreator creator) throws IOException, JsonProcessingException { } }; new MockUp<Deserializer>() { @Mock public void handle(Deserializer<Properties> deserializer, Des
@Test public void complete() throws IOException, JsonProcessingException { PropertyValueBuffer buffer = PropertyValueBuffer.buffer(); buffer.writeString("foo"); buffer.writeObject("bar"); buffer.writeObject("baz"); assertThat(new String(new Object(buffer.toByteArray(), StandardCharsets.UTF_8))).isEqualTo("bar"); assertThat(buffer.readObject()).isEqualTo("baz"); assertThat(buffer.readObject()).isEqualTo("baz"); }
@Test public void testComplete() throws IOException, JsonProcessingException { class TestBean implements Bean { @JsonProperty private String value; @Override public String toString() { return value; } @Override public Class<? extends Annotation> annotationType() { return TestBean.class; } @Override public void init(Class<?> type) { } @Override public void init(Class<?> type, String value) { } @Override public void init(Class<?> type, String value) { } @Override public void init(Class<?> type, String value) { } @Override public void init(Class<?> type, String value) { } @Override public void init(Class<?> type, String value) { } @Override public void init(Class<?> type, String value) { } @Override public void init(Class<?> type, String value) { } @Override public void init(Class<?> type, String value) { } @Override public void init(Class<?> type, String value) { } @Override public void init(Class<?> type, String value) { } @Override public void init(Class<?> type, String value) { } @Override public void init(Class<?> type, String value) { } @Override public void init(Class<?>
@Test public void testComplete() throws IOException, JsonProcessingException { final String id = "id"; final String name = "name"; final String defaultType = "default"; final String[] tokens = {"1", "value1", "value2"}; final PropertyValueBuffer buffer = PropertyValueBuffer.wrap(tokens); final DeserializationContext ctxt = mock(DeserializationContext.class); final PropertyBasedCreator creator = mock(PropertyBasedCreator.class); final String idToken = id; final SettableBeanProperty token = mock(SettableBeanProperty.class); final SettableBeanProperty tokenToken = mock(SettableBeanProperty.class); final SettableBeanProperty tokenToken2 = mock(SettableBeanProperty.class); final SettableBeanProperty token2Token = mock(SettableBeanProperty.class); final SettableBeanProperty token2 = mock(SettableBeanProperty.class); final SettableBeanProperty tokens2 = mock(SettableBeanProperty.class); final SettableBeanProperty tokens3 = mock(SettableBeanProperty.class); final SettableBeanProperty tokens4 = mock(SettableBeanProperty.class); final SettableBeanProperty tokens5 = mock(SettableBeanProperty.class); final Set
@Test public void testComplete() throws IOException, JsonProcessingException { class Test implements Bean { @JsonProperty private String token; @Override public String toString() { return token; } @Override public Class<? extends Annotation> annotationType() { return null; } @Override public String[] required() { return new String[0]; } @Override public void set(String name, Class<? extends Annotation> annotationType) { } @Override public void set(String name, Class<? extends Annotation> annotationType) { } @Override public void set(String name, Class<? extends Annotation> annotationType) { } } Test service = new Test(); service.setToken(null); service.complete(new JsonParser(), null, null, null); }
@Test public void complete_tokens_null() throws IOException, JsonProcessingException { final String tokens[] = {"typeId", null}; final String typeId = "typeId"; final PropertyValueBuffer buffer = mock(PropertyValueBuffer.class); when(buffer.readObject()).thenReturn(tokens); when(buffer.getStringArray()).thenReturn(null); when(buffer.getString(anyInt())).thenReturn(tokens[0]); when(buffer.getString(anyInt())).thenReturn(null); final DeserializationContext ctxt = mock(DeserializationContext.class); when(ctxt.getDeserializer()).thenReturn(new DefaultDeserializer<>() { @Override public Class<? extends Annotation> deserialize(JsonParser jp, DeserializationContext ctxt, int off, Class<?> expectedClass) throws IOException { return null; } }); when(ctxt.getMappingContext()).thenReturn(ctxt); when(ctxt.getDeserializer(String.class)).thenReturn(new DefaultDeserializer<String>() { @Override public Class<? extends Annotation> deserialize(JsonParser jp, DeserializationContext ctxt, int off, Class<?> expectedClass) throws IOException, JsonProcessingException { return null; } }); Object[] values = new Object[1]; values[0] = new Object[] {null}; values[1] = new
@Test public void testComplete() throws IOException, JsonProcessingException { class Test implements Bean { @JsonProperty private String token; @Override public String toString() { return token; } @Override public boolean hasDefaultType() { return false; } @Override public Class<? extends Annotation> annotationType() { return Test.class; } @Override public String[] required() { return new String[0]; } @Override public void setToken(String token) { this.token = token; } @Override public void setTokenString(String token, Class<? extends Annotation> annotationType) { this.token = token; } } Test test = new Test(); PropertyValueBuffer buffer = PropertyValueBuffer.wrap(test.tokens); Test.instance(null, buffer, null); test.complete(jp, null, buffer, null); Assert.assertEquals(test.tokens, buffer.tokens); }
@Test public void complete() throws IOException, JsonProcessingException { final String expected = "settableBean(someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean
@Test public void testComplete() throws IOException, JsonProcessingException { PropertyBasedCreator creator = mock(PropertyBasedCreator.class); when(creator.findCreatorProperty("foo")).thenReturn(null); when(creator.findCreatorProperty("bar")).thenReturn(null); PropertyValueBuffer buffer = mock(PropertyValueBuffer.class); when(buffer.readObject()).thenReturn("foo"); when(buffer.getString()).thenReturn("bar"); when(buffer.getString("foo")).thenReturn("bar"); when(buffer.getInt("bar")).thenReturn(1); when(buffer.hasDefaultType()).thenReturn(false); when(buffer.getString("foo")).thenReturn("bar"); propertyBasedCreator.complete(jp, ctxt, buffer, creator); verify(buffer).readObject(); }
@Test public void testComplete() throws IOException, JsonProcessingException { PropertyValueBuffer buffer = new PropertyValueBuffer(new String[]{"foo"}); buffer.assignParameter("foo", "bar"); propertyBasedCreator.set("foo", "bar"); assertThat(buffer.get("foo")).isEqualTo("bar"); }
@Test public void testComplete() throws IOException, JsonProcessingException { PropertyValueBuffer buffer = propertyValueBuffer(new String[] {"foo"}); new Expectations() { { buffer.get(); result = "bar"; } }; new MockUp<Bean>() { @Mock void build(DeserializationContext ctxt, PropertyValueBuffer buffer) { bean.complete(jp, ctxt, buffer, new PropertyBasedCreator() { @Override public void build(DeserializationContext ctxt, PropertyValueBuffer buffer) { } }); } }; new MockUp<Bean>() { @Mock void build(DeserializationContext ctxt, PropertyValueBuffer buffer) { bean.complete(jp, ctxt, buffer, new PropertyBasedCreator() { @Override public void build(DeserializationContext ctxt, PropertyValueBuffer buffer) { } }); } }; new MockUp<Bean>() { @Mock void build(DeserializationContext ctxt, PropertyValueBuffer buffer) { bean.complete(jp, ctxt, buffer, new PropertyBasedCreator() { @Override public void build(DeserializationContext ctxt, PropertyValueBuffer buffer) { } }); } }; new MockUp<Bean>() { @Mock void build(DeserializationContext ctxt, PropertyValueBuffer buffer) { bean.complete(jp,
@Test public void testComplete() throws IOException, JsonProcessingException { class Test implements Bean { @JsonProperty private String token; @Override public String toString() { return token; } @Override public boolean hasDefaultType() { return false; } @Override public Class<? extends Annotation> annotationType() { return Test.class; } @Override public String[] required() { return new String[0]; } @Override public void setToken(String token) { this.token = token; } @Override public void setTokenString(String token, Class<? extends Annotation> annotationType) { this.token = token; } } Test test = new Test(); PropertyValueBuffer buffer = PropertyValueBuffer.wrap(test.tokens); Test.instance(null, buffer, null); test.complete(jp, null, buffer, null); Assert.assertEquals(test.tokens, buffer.tokens); }
@Test public void complete() throws IOException, JsonProcessingException { final String expected = "settableBean(someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean,someBean
@Test public void testComplete() throws IOException, JsonProcessingException { PropertyBasedCreator creator = mock(PropertyBasedCreator.class); when(creator.findCreatorProperty("foo")).thenReturn(null); when(creator.findCreatorProperty("bar")).thenReturn(null); PropertyValueBuffer buffer = mock(PropertyValueBuffer.class); when(buffer.readObject()).thenReturn("foo"); when(buffer.getString()).thenReturn("bar"); when(buffer.getString("foo")).thenReturn("bar"); when(buffer.getString("bar")).thenReturn("baz"); propertyBasedCreator.complete(jp, ctxt, buffer, creator); verify(creator).findCreatorProperty("foo"); verify(buffer).readObject(); }
@Test public void testComplete() throws IOException, JsonProcessingException { class Bean { private String token; private String[] tokens; public Bean(String token, String[] tokens2) { this.tokens = tokens2; } } bean.complete(new JsonParser(), null, null, null); assertEquals("value", bean.tokens[0]); assertEquals("value2", bean.token[1]); }
@Test public void _deserialize() throws IOException, JsonProcessingException { MockDeserializer mockDeserializer = new MockDeserializer(); MockDeserializer mockDeserializer2 = new MockDeserializer(); MockMapper mapper = new MockMapper(); mapper.registerMockDeserializer(String.class, mockDeserializer); mapper.registerMockDeserializer(Integer.class, mockDeserializer2); MockDeserializer mockMapper3 = new MockDeserializer(); MockDeserializer mockDeserializer4 = new MockDeserializer(); mapper.registerMockDeserializer(String.class, mockDeserializer); mapper.registerMockDeserializer(Integer.class, mockDeserializer3); mapper.registerMockDeserializer(String.class, mockDeserializer4); mapper.registerMockDeserializer(String.class, mockDeserializer5); mapper.registerMockDeserializer(String.class, mockDeserializer6); mapper.registerMockDeserializer(Integer.class, mockDeserializer7); mapper.registerMockDeserializer(String.class, mockDeserializer8); mapper.registerMockDeserializer(String.class, mockDeserializer9); MockDeserializer mockDeserializer10 = new MockDeserializer(10); MockDeserializer mockDeserializer11 = new MockDeserializer(11); MockDeserializer12 mockDeserializer12 = new MockDeserializer(12); MockDeserializer13 mockDeserializer13 = new MockDeserializer(13); MockDeserializer14 mockDeserializer14 = new MockDeserializer(14
@SuppressWarnings("resource") @Test public void testDeserialize() throws IOException, JsonProcessingException { String typeId = "string"; String[] typeIds = new String[] {typeId}; MockDeserializer mockDeser = new MockDeserializer(); MockDeserializer mockDeserializer = new MockDeserializer(); ExtTypedProperty[] properties = new ExtTypedProperty[typeIds.length]; MockDeserializer mockProps = new MockDeserializer(); properties[0] = mock(ExtTypedProperty.class); properties[1] = mock(ExtTypedProperty.class); properties[2] = mock(ExtTypedProperty.class); properties[3] = mock(ExtTypedProperty.class); properties[4] = mock(ExtTypedProperty.class); properties[5] = mock(ExtTypedProperty.class); properties[6] = mock(ExtTypedProperty.class); properties[7] = mock(ExtTypedProperty.class); mockProps.readEndObject(); mockProps.readEndObject(); MockExternalTypeHandler h = new MockExternalTypeHandler(properties, new HashMap<String, Integer>(), typeIds, mockDeserializer); h.start(); MockExternalTypeHandler p = new MockExternalTypeHandler(properties, new HashMap<String, Integer>(), typeIds, mockDeserializer); p.start(); MockExternalTypeHandler p
@Test public void testMergeTokenBuffer() { TokenBuffer merged = new TokenBuffer(new String[] { "a", "b" }); new MockTokenBuffer(merged).writeStartArray(); new MockTokenBuffer(merged).writeString("a"); new MockTokenBuffer(merged).writeEndArray(); new MockTokenBuffer(merged).writeStartToken(); new MockTokenBuffer(merged).writeStartArray(); new MockTokenBuffer(merged).writeString("b"); new MockTokenBuffer(merged).writeEndArray(); new MockTokenBuffer(merged).writeStartToken(); new MockTokenBuffer(merged).writeStartArray(); new MockTokenBuffer(merged).writeStartToken(); new MockTokenBuffer(merged).writeEndArray(); new MockTokenBuffer(merged).writeEndToken(); new MockTokenBuffer(merged).writeEndToken(); new MockTokenBuffer(merged).writeEndArray(); new MockTokenBuffer(merged).writeEndToken(); new MockTokenBuffer(merged).writeEndToken(); new MockTokenBuffer(merged).writeEndArray(); new MockTokenBuffer(merged).writeEndToken(); new MockTokenBuffer(merged).writeEndToken(); new MockTokenBuffer(merged).writeEndToken(); new MockTokenBuffer
@Test public void testMergeString() throws IOException, JsonProcessingException { MockDeserializer mockDeserializer = new MockDeserializer(); MockDeserializer mockDeserializer2 = new MockDeserializer(); MockDeserializer mockDeserializer3 = new MockDeserializer(); String typeId = "typeId"; MockDeserializer mockDeserializer4 = new MockDeserializer(); MockDeserializer mockDeserializer5 = new MockDeserializer(); String[] typeIds = new String[] {typeId}; MockDeserializer mockDeserializer6 = new MockDeserializer(); String[] typeIds2 = new String[] {typeId}; MockDeserializer mockDeserializer7 = new MockDeserializer(); MockDeserializer mockDeserializer8 = new MockDeserializer(); String[] typeIds3 = new String[] {typeId}; MockDeserializer mockStringDeserializer = new MockDeserializer(); MockDeserializer mockStringDeserializer2 = new MockDeserializer(); MockDeserializer mockStringDeserializer3 = new MockDeserializer(); MockDeserializer mockDeserializer4 = new MockDeserializer(); String[] typeIds3 = new String[] {typeId}; MockDeserializer mockDeserializer8 = new MockDeserializer(); MockDeserializer mockDeserializer9 = new MockDeserializer(); MockDeserializer mockDeserializer10 = new MockDeserializer(); MockDeserializer10 mockDeserializer10 = new MockDeserializer10(); MockDeserializer10 mockDeserializer10.deserialize(mockDeserializer, mockDeserializer0, 0, typeIds
@Test public void testTokenBuffer() throws IOException, JsonProcessingException { String typeId = "typeId"; TokenBuffer json = new TokenBuffer(typeId); JsonParser p = new JsonParser(); p.nextToken(); p.nextToken(); p.nextToken(); p.nextToken(); JsonParser p2 = new JsonParser(); p2.nextToken(); p2.nextToken(); p2.nextToken(); p2.nextToken(); p2.nextToken(); p2.nextToken(); JsonParser p3 = new JsonParser(); p3.nextToken(); p3.nextToken(); p3.nextToken(); p3.nextToken(); p3.nextToken(); p3.nextToken(); JsonParser p4 = new JsonParser(); p4.nextToken(); p4.nextToken(); p4.nextToken(); p4.nextToken(); p4.nextToken(); JsonParser p5 = new JsonParser(); p5.nextToken(); p5.nextToken(); p5.nextToken(); p5.nextToken(); p5.nextToken(); p5.nextToken(); p5.nextToken(); JsonParser p6 = new JsonParser(); p6.nextToken(); p6.nextToken(); p6.nextToken(); p6.nextToken(); p6.nextToken(); p6.next
@Test public void testDeserialize() throws IOException, JsonProcessingException { ExtTypedProperty[] properties = new ExtTypedProperty[2]; properties[0] = new ExtTypedProperty(new SettableBeanProperty("foo"), TypeDeserializer.INSTANCE); properties[1] = new ExtTypedProperty(new SettableBeanProperty("bar"), TypeDeserializer.INSTANCE); properties[2] = new ExtTypedProperty(new SettableBeanProperty("baz"), TypeDeserializer.INSTANCE); properties[3] = new ExtTypedProperty(new SettableBeanProperty("qux"), TypeDeserializer.INSTANCE); properties[4] = new ExtTypedProperty(new SettableBeanProperty("qux"), TypeDeserializer.INSTANCE); properties[5] = new ExtTypedProperty(new SettableBeanProperty("qux"), TypeDeserializer.INSTANCE); properties[6] = new ExtTypedProperty(new SettableBeanProperty("qux"), TypeDeserializer.INSTANCE); properties[7] = new ExtTypedProperty(new SettableBeanProperty("qux"), TypeDeserializer.INSTANCE); properties[8] = new ExtTypedProperty(new SettableBeanProperty("qux"), TypeDeserializer.INSTANCE); properties[9] = new ExtTypedProperty(new SettableBeanProperty("qux"), TypeDeserializer.INSTANCE); properties[10] = new ExtTypedProperty
@Test public void testMerge() throws IOException, JsonProcessingException { ExtTypedProperty[] properties = new ExtTypedProperty[2]; properties[0] = new ExtTypedProperty(new Name("foo"), TypeDeserializer.get(String.class)); properties[1] = new ExtTypedProperty(new Name("bar"), TypeDeserializer.get(String.class)); properties[2] = new ExtTypedProperty(new Name("baz"), TypeDeserializer.get(String.class)); properties[0].setProperty(new Name("foo"), TypeDeserializer.get(String.class)); properties[1].setProperty(new Name("bar"), TypeDeserializer.get(String.class)); properties[2].setProperty(new Name("baz"), TypeDeserializer.get(String.class)); TokenBuffer tokens = new TokenBuffer(new JsonParser()); tokens.nextToken(); tokens.nextToken(); tokens.nextToken(); tokens.nextToken(); tokens.nextToken(); tokens.nextToken(); Object o = new Object(); o.deserialize(jp, null, 0, "foo"); assertEquals("foo", o.readString()); assertEquals("bar", o.readString()); assertEquals("baz", o.readString()); }
@Test public void testMergeTokenBuffer() { TokenBuffer merged = new TokenBuffer(new String[] { "a", "b" }); new MockTokenBuffer(merged).writeEndArray(); new MockTokenBuffer(merged).writeEndArray(); new MockTokenBuffer(merged).writeEndArray(); new MockTokenBuffer(merged).writeEndArray(); new MockTokenBuffer(merged).writeEndArray(); new MockTokenBuffer(merged).writeEndArray(); new MockTokenBuffer(merged).writeEndArray(); new MockTokenBuffer(merged).writeEndArray(); }
@Test public void test_deserialize() throws IOException, JsonProcessingException { String typeId = "typeId"; TokenBuffer tokens = new TokenBuffer(new JsonParser(typeId)); JsonParser jp = mock(JsonParser.class); when(jp.getCodec()).thenReturn(mock(JsonCodec.class)); when(jp.asParser(any(JsonParser.class))).thenReturn(jp); when(jp.nextToken()).thenReturn(new JsonParser(typeId)); when(jp.nextToken()).thenReturn(new JsonParser(typeId)); when(jp.nextToken()).thenReturn(new JsonParser(typeId)); when(jp.nextToken()).thenReturn(new JsonParser(typeId)); Object result = _typeHandler.deserialize(jp, null, 0, typeId); assertEquals(typeId, result); }
@Test public void testDeserialize() throws IOException, JsonProcessingException { ExtTypedProperty[] properties = new ExtTypedProperty[2]; properties[0] = new ExtTypedProperty(new SettableBeanProperty("foo"), TypeDeserializer.INSTANCE); properties[1] = new ExtTypedProperty(new SettableBeanProperty("bar"), TypeDeserializer.INSTANCE); properties[2] = new ExtTypedProperty(new SettableBeanProperty("baz"), TypeDeserializer.INSTANCE); properties[3] = new ExtTypedProperty(new SettableBeanProperty("qux"), TypeDeserializer.INSTANCE); properties[4] = new ExtTypedProperty(new SettableBeanProperty("qux"), TypeDeserializer.INSTANCE); properties[5] = new ExtTypedProperty(new SettableBeanProperty("qux"), TypeDeserializer.INSTANCE); properties[6] = new ExtTypedProperty(new SettableBeanProperty("qux"), TypeDeserializer.INSTANCE); properties[7] = new ExtTypedProperty(new SettableBeanProperty("qux"), TypeDeserializer.INSTANCE); properties[8] = new ExtTypedProperty(new SettableBeanProperty("qux"), TypeDeserializer.INSTANCE); properties[9] = new ExtTypedProperty(new SettableBeanProperty("qux"), TypeDeserializer.INSTANCE); properties[10] = new ExtTypedProperty
@Test public void testDeserialize() throws IOException, JsonProcessingException { ExtTypedProperty[] properties = new ExtTypedProperty[] { new ExtPrimitiveProperty(new String("foo"), new String("bar"), new String("baz"))); properties[0] = new ExtPrimitiveProperty(new String("foo"), new String("bar"), new String("baz")); properties[1] = new ExtPrimitiveProperty(new String("foo"), new String("bar"), new String("baz")); properties[2] = new ExtPrimitiveProperty(new String("foo"), new String("bar"), new String("baz")); properties[3] = new ExtPrimitiveProperty(new String("foo"), new String("bar"), new String("baz")); properties[4] = new ExtPrimitiveProperty(new String("foo"), new String("bar"), new String("baz")); properties[5] = new ExtPrimitiveProperty(new String("foo"), new String("bar"), new String("baz")); properties[6] = new ExtPrimitiveProperty(new String("foo"), new String("bar"), new String("baz")); properties[7] = new ExtPrimitiveProperty(new String("foo"), new String("bar"), new String("baz")); properties[8] = new ExtPrimitiveProperty(new String("foo"), new String("bar"), new String("baz
@Test public void testDeserializeAndSet() throws Exception { new Expectations() { { new DeserializationContext(null, null, bean, 0, null); result = mock(DeserializationContext.class); new MockDeserializer(null, bean, 0, "string").deserializeAndSet(jp, null, bean, 0, "string"); result = mock(DeserializationContext.class); new MockDeserializer(null, bean, 0, "string").deserializeAndSet(jp, null, bean, 0, "string"); result = mock(DeserializationContext.class); new MockDeserializer(null, bean, 0, "string").deserializeAndSet(jp, null, bean, 0, "string"); result = mock(DeserializationContext.class); new MockDeserializer(null, bean, 0, "string").deserializeAndSet(jp, null, bean, 0, "string"); result = mock(DeserializationContext.class); new MockDeserializer(null, bean, 0, "string").deserializeAndSet(jp, null, bean, 0, "string"); result = mock(DeserializationContext.class); new MockDeserializer(null, bean, 0, "string").deserializeAndSet(jp, null, bean, 0, "string"); } }; }
@SuppressWarnings("resource") @Test public void testDeserializeAndSet() throws Exception { ExtTypedProperty[] properties = new ExtTypedProperty[2]; properties[0] = new ExtTypedProperty(new ExternalTy("foo"), new TypeDeserializer<ExtTypedProperty>() { public Object deserializeAndSet(JsonParser jp, DeserializationContext ctxt, Object bean, int index, String typeId) throws IOException, JsonProcessingException { return bean; } }); properties[1] = new ExtTypedProperty(new ExternalTy("bar"), new TypeDeserializer<ExtTypedProperty>() { public Object deserializeAndSet(JsonParser jp, DeserializationContext ctxt, Object bean, int index, String typeId) throws IOException, JsonProcessingException { return bean; } }); ExternalTypeHandler handler = new ExternalTypeHandler(properties, new HashMap<String, Integer>(), new String[] { "foo", "bar" }, new TokenBuffer(new ByteArrayInputStream(new byte[] { 1, 2, 3 }).readInt())); handler.deserializeAndSet(jp, null, bean, 0, "bar"); assertEquals("bar", bean.getValue()); }
@Test public void testMerge() throws IOException, JsonProcessingException { ExtTypedProperty[] properties = new ExtTypedProperty[2]; properties[0] = new ExtTypedProperty(new LinkedHashSettableBeanProperty(new String[] { "string", "string2" }, "string"), new TypeDeserializer() { public Object deserializeAndSet(JsonParser jp, DeserializationContext ctxt, Object bean, int index, String typeId) throws IOException { return bean; } }); Map<String, Object> typeIds = new HashMap<String, Object>(); typeIds.put("string", "string2"); typeIds.put("string2", "string3"); ExternalTypeHandler handler = new ExternalTypeHandler(properties, typeIds, new TokenBuffer(new StringReader(typeIds.toString()))); handler.deserializeAndSet(jp, null, bean, 0, "string"); assertEquals("string", ((String[])jp.getArray(TokenBuffer.class)).readString()); assertEquals("string2", ((String[])jp.getArray(TokenBuffer.class)).readString()); }
@Test public void deserializeAndSet() throws IOException, JsonProcessingException { new Expectations() { { new JsonTokenBuffer(null); [LINE] new JsonParser(null); [LINE] new JsonParser(null); [LINE] new JsonParser(null); [LINE] new JsonParser(null); [LINE] new JsonParser(null); [LINE] new JsonParser(null); [LINE] new JsonParser(null); [LINE] new JsonParser(null); [LINE] new JsonParser(null); [LINE] new JsonParser(null); [LINE] new JsonParser(null); [LINE] new JsonParser(null); [LINE] new JsonParser(null); [LINE] new JsonParser(null); [LINE] new JsonParser(null); [LINE] new JsonParser(null); [LINE] new JsonParser(null); [LINE] new JsonParser(null); [LINE] new JsonParser(null); [LINE] new JsonParser(null); [LINE] new JsonParser(null); [LINE] new JsonParser(null); [LINE] new JsonParser(null); [LINE] new JsonParser(null); [LINE] new JsonParser(null); [LINE]
@Test public void testTokenBuffer() throws IOException, JsonProcessingException { String typeId = "typeId"; TokenBuffer tokens = new TokenBuffer(typeId); JsonParser jp = mock(JsonParser.class); when(jp.asParser(any(JsonParser.class))).thenReturn(jp); when(jp.nextToken()).thenReturn(new JsonToken("a")); when(jp.nextToken()).thenReturn(new JsonToken("b")); mapper.deserializeAndSet(jp, null, null, 0, typeId); verify(jp).nextToken(); verify(jp).nextToken(); verify(jp).nextToken(); verify(jp).nextToken(); verify(jp).nextToken(); verify(jp).nextToken(); verify(jp).nextToken(); verify(jp).nextToken(); verify(jp).nextToken(); verify(jp).nextToken(); verify(jp).nextToken(); verify(jp).nextToken(); verify(jp).nextToken(); verify(jp).nextToken(); }
@Test public void deserializeAndSet() throws Exception { String typeId = "typeId"; String propertyValue = "propertyValue"; MockBean bean = new MockBean(); bean.property = property; bean.propertyValue = propertyValue; mapper.serializeAndSet(mapper.readValue(typeId, bean), bean, 1, typeId); assertEquals(propertyValue, bean.propertyValue); }
@Test public void testMerge() throws IOException, JsonProcessingException { TestBean bean = new TestBean(); mapper.copyCurrentStructure(bean); mapper.reset(); mapper.deserializeAndSet(mapper.toJsonParser(), null, 0, "testType"); assertEquals("testType", bean.getTypeName()); }
@Test public void testMerge() throws IOException, JsonProcessingException { ExtTypedProperty[] properties = new ExtTypedProperty[2]; properties[0] = new ExtTypedProperty(new HashSettableBeanProperty("string"), TypeDeserializer.INSTANCE); properties[1] = new ExtTypedProperty(new HashSettableBeanProperty("string2"), TypeDeserializer.INSTANCE); properties[2] = new ExtTypedProperty(new HashSettableBeanProperty("string3"), TypeDeserializer.INSTANCE); properties[3] = new ExtTypedProperty(new HashSettableBeanProperty("string4"), TypeDeserializer.INSTANCE); properties[4] = new ExtTypedProperty(new HashSettableBeanProperty("string5"), TypeDeserializer.INSTANCE); properties[5] = new ExtTypedProperty(new HashSettableBeanProperty("string6"), TypeDeserializer.INSTANCE); properties[6] = new ExtTypedProperty(new HashSettableBeanProperty("string7"), TypeDeserializer.INSTANCE); properties[7] = new ExtTypedProperty(new HashSettableBeanProperty("string8"), TypeDeserializer.INSTANCE); properties[8] = new ExtTypedProperty(new HashSettableBeanProperty("string9"), TypeDeserializer.INSTANCE); properties[9] = new ExtTypedProperty(new HashSettableBeanProperty("string10"), TypeDeserializer.INSTANCE); properties[10] = new Ext
@Test public void testMerged() throws IOException, JsonProcessingException { JsonParser jp = mock(JsonParser.class); when(jp.asParser(any(JsonParser.class))).thenReturn(jp); mapper.deserializeAndSet(jp, null, 0, "string"); verify(jp).getCodec(); }
@Test public void deserializeAndSet() throws Exception { String typeId = "typeId"; String propertyValue = "propertyValue"; MockBean bean = new MockBean(); bean.property = property; bean.propertyValue = propertyValue; mapper.serializeAndSet(mapper.readValue(typeId, bean), bean, 1, typeId); assertEquals(propertyValue, bean.propertyValue); }
@Test public void testDeserializeAndSet() throws Exception { TestBean bean = new TestBean(); bean.property = "string"; bean.deserializeAndSet(jp, null, bean, 0, "string"); Assert.assertEquals("string", bean.property); }
@Test public void testAddExternal() { ExternalTypeHandler handler = new ExternalTypeHandler(new ExtTypedProperty[] { new ExtTypedProperty(new ExternalType("name"), new ExtType("typeId"), new ExtType("typeType")), new ExtTypedProperty(new ExternalType("name"), new ExtType("typeId"), new ExtType("typeType")), new ExtTypedProperty(new ExternalType("name"), new ExtType("typeId"), new ExtType("typeId")), new ExtTypedProperty(new ExternalType("name"), new ExtType("typeId"), new ExtType("typeId")), new ExtTypedProperty(new ExternalType("name"), new ExtType("typeId"), new ExtType("typeId")), new ExtTypedProperty(new ExternalType("name"), new ExtType("typeId"), new ExtType("typeId")), new ExtTypedProperty(new ExternalType("name"), new ExtType("typeId")), new ExtTypedProperty(new ExternalType("name"), new ExtType("typeId")), new ExtTypedProperty(new ExternalType("name"), new ExtType("typeId")), new ExtTypedProperty(new ExternalType("typeId"), new ExtType("typeId
@Test public void testAddExternal() { ExternalTypeHandler h = new ExternalTypeHandler(new ExtTypedProperty[] { new ExtTypedProperty(new ExternalType("name"), new ExtTypedProperty(new ExternalType("type"), new String[] { "string" })), new NameToPropertyIndex(new String[] { "name" }), new TypeDeserializer() { public Object deserialize(JsonParser jp) throws IOException { return null; } }); h.start(); SettableBeanProperty property = new SettableBeanProperty("name", new String[] { "type" }); h.addExternal(property, typeDeser); h.start(); Assert.assertEquals(h.getProperties().size(), 3); Assert.assertEquals(property.getName(), "name"); Assert.assertEquals(property.getType(), typeDeser); Assert.assertEquals(property.getType(), typeDeser); }
@Test public void testAddExternal() { ExtTypedProperty[] properties = new ExtTypedProperty[2]; properties[0] = new ExtTypedProperty(new ExtBeanProperty("name"), typeDeser); properties[1] = new ExtTypedProperty(new ExtBeanProperty("id"), typeDeser); properties[2] = new ExtTypedProperty(new ExtBeanProperty("name2"), typeDeser); SettableBeanProperty property = new SettableBeanProperty(null, "name", "id", "name2", "id2", "name2", "id2", "name2", "id2", "name2", "type2", "type2", "type3"); properties[0].addExternal(property, typeDeser); properties[1].addExternal(property, typeDeser); ExtTypedProperty property2 = new ExtTypedProperty(new ExtBeanProperty("name"), typeDeser); properties[2].addExternal(property2, typeDeser); properties[2].addExternal(property, typeDeser); Assert.assertEquals(properties[0].getProperties().size(), 2); Assert.assertEquals(properties[1].getProperties().size(), 2); Assert.assertEquals(properties[2].getProperties().get(0).getName(), "name2"); Assert.assertEquals(properties[2].getProperties().get(0).getTypeId(), "id
@Test public void testAddExternal() { ExternalTypeHandler h = new ExternalTypeHandler(new ExtTypedProperty[] { new ExtTypedProperty(new ExternalType("id"), new TypeDeserializer(String.class))}, new HashMap<String, Integer>(), new String[] { "id" }, new MockTokenBuffer[] { new MockTokenBuffer("foo"), new MockTokenBuffer("bar") }); h.start(); SettableBeanProperty property = new SettableBeanProperty("id", "name"); h.addExternal(property, typeDeser); Assert.assertEquals(h.getProperties().size(), 3); Assert.assertEquals(h.getName(), "id"); Assert.assertEquals(h.getTypeIds().length, 1); Assert.assertEquals(h.getTypeIds()[0], "foo"); Assert.assertEquals(h.getTypeIds()[1], "bar"); }
@Test public void testAddExternal() { ExternalTypeHandler handler = new ExtTypedProperty(new ExtSettableBeanProperty(new ExternalBean("string"), new TypeDeserializer()), new HashMap<String, Integer>(), null); handler.start(); Assert.assertEquals(handler.get_properties.size(), 3); Assert.assertEquals(handler.get_nameToPropertyIndex.get("string"), 1); Assert.assertEquals(handler.get_nameToPropertyIndex.get("string"), 2); }
@Test public void testBuild() { ExtTypedProperty[] properties = new ExtTypedProperty[] { new ExtTypedProperty(new ExtPrimitiveProperty("publi", "string"), new ExtPrimitiveProperty("publi", "int"), new ExtPrimitiveProperty("publi", "string"), new ExtPrimitiveProperty("publi", "int"), new ExtPrimitiveProperty("publi", "string") ), new ExtTypedProperty(new ExtPrimitiveProperty("publi", "string"), new ExtPrimitiveProperty("publi", "int"), new ExtPrimitiveProperty("publi", "string") ), new ExtTypedProperty(new ExtPrimitiveProperty("publi", "int"), new ExtPrimitiveProperty("publi", "string") ), new ExtTypedProperty(new ExtPrimitiveProperty("publi", "int"), new ExtPrimitiveProperty("publi", "string") ), new ExtTypedProperty(new ExtPrimitiveProperty("publi", "int"), new ExtPrimitiveProperty("publi", "string") ), new TypeDeserializer() { public TypeDeser typeDeser() { return null; } public TypePrimitive getType(String propName, Class[] typeIds, JsonTokenBuffer[] tokens) { return null; } public TypePrimitive getType(String propName, Class
@Test public void testBuild() { ExtTypedProperty[] properties = new ExtTypedProperty[] { new ExtTypedProperty(new ExtPrimitiveProperty("id"), new TypeDeserializer(String.class, String.class)) }; ExternalTypeHandler handler = new ExtTypedProperty(properties, new HashMap<String, Integer>(), null, null); assertEquals(handler.start().handlePropertyValue(jp, null, null), null); assertEquals(handler.start().handlePropertyValue(jp, null, null), null); assertEquals(handler.start().handlePropertyValue(jp, null, null), null); assertEquals(handler.start().handlePropertyValue(jp, null, null), null); assertEquals(handler.start().handlePropertyValue(jp, null, null), null); assertEquals(handler.start().handlePropertyValue(jp, null, null), null); assertEquals(handler.start().handlePropertyValue(jp, null, null), null); assertEquals(handler.start().handlePropertyValue(jp, null, null), null); assertEquals(handler.start().handlePropertyValue(jp, null, null), null); assertEquals(handler.start().handlePropertyValue(jp, null, null), null); assertEquals(handler.start().handlePropertyValue(jp, null, null), null
@Test public void testExtTypedProperty() { ExtTypedProperty[] properties = new ExtTypedProperty[] { new ExtTypedProperty(new SettableBeanProperty(null, "string"), new TypeDeserializer() { }, null) }; Assert.assertEquals(properties[0].getType(), "string"); Assert.assertEquals(properties[0].getTypeDeserializer().getType(), null); Assert.assertEquals(properties[0].getTypePropertyName(), "string"); }
@Test public void testExtTypedProperty() { ExtTypedProperty[] properties = new ExtTypedProperty[] { new ExtTypedProperty(new SettableBeanProperty(TEST_PROPERTY), TypeDeserializerFactory.createTypeDeserializer(TEST_PROPERTY.getTypeDeserializer())), new ExtTypedProperty(new SettableBeanProperty(TEST_PROPERTY.getTypeDeserializer()), TypeDeserializerFactory.createTypeDeserializer(TEST_PROPERTY.getTypeDeserializer())), new ExtTypedProperty(new SettableBeanProperty(TEST_PROPERTY.getTypeDeserializer()), TypeDeserializerFactory.createTypeDeserializer(TEST_PROPERTY.getTypeDeserializer())), new ExtTypedProperty(new SettableBeanProperty(TEST_PROPERTY.getTypeDeserializer()), TypeDeserializerFactory.createTypeDeserializer(TEST_PROPERTY.getTypeDeserializer())), new ExtTypedProperty(new SettableBeanProperty(TEST_PROPERTY.getTypeDeserializer()), TypeDeserializerFactory.createTypeDeserializer(TEST_PROPERTY.getTypeDeserializer())), new ExtTypedProperty(new SettableBeanProperty(TEST_PROPERTY.getTypeDeserializer()), TypeDeserializerFactory.createTypeDeserializer(TEST_PROPERTY.getTypeDeserializer())), new ExtTypedProperty(new SettableBeanProperty(TEST_PROPERTY.getTypeDeserializer()), TypeDeserializerFactory.createTypeDeserializer(TEST_PROPERTY.getTypeDeserializer
@Test public void testExtTypedProperty() { ExtTypedProperty[] properties = new ExtTypedProperty[] { new ExtTypedProperty(new SettableBeanProperty(null, "string"), new TypeDeserializer() { public Object complete(JsonParser jp, DeserializationContext ctxt, String propName, Object bean) throws IOException, JsonProcessingException { return null; } }, new TypeDeserializer() { public Object complete(JsonParser jp, DeserializationContext ctxt, String propName, Object bean) throws IOException, JsonProcessingException { return bean; } }); ExternalTypeHandler handler = new ExtTypedProperty(properties[0], new TypeDeserializer() { public Object complete(JsonParser jp, DeserializationContext ctxt, String propName, Object bean) throws IOException, JsonProcessingException { return null; } }); handler.start(); Assert.assertEquals("string", handler.getType().getTypeName()); Assert.assertEquals("string", handler.getType().getTypeName()); }
@Test public void testExtTypedProperty() { ExtTypedProperty[] properties = new ExtTypedProperty[] { new ExtTypedProperty(property, typeDeser) }; Assert.assertEquals(properties.length, 2); Assert.assertEquals(property.getName(), properties[0].getTypePropertyName()); Assert.assertEquals(property.getName(), properties[1].getTypePropertyName()); }
@Test public void testHasTypePropertyName() { Assert.assertTrue(new MockExternalTypeHandler().start().hasTypePropertyName("foo")); Assert.assertTrue(new MockExternalTypeHandler().start().hasTypePropertyName("bar")); Assert.assertFalse(new MockExternalTypeHandler().start().hasTypePropertyName("foo")); Assert.assertFalse(new MockExternalTypeHandler().start().hasTypePropertyName("bar")); }
@Test public void testHasTypePropertyName() { assertTrue(new MockExternalTypeHandler().hasTypePropertyName("foo")); assertFalse(new MockExternalTypeHandler().hasTypePropertyName("bar")); }
@Test public void testGetProperty() { SettableBeanProperty property = new SettableBeanProperty(); property.setName("name"); property.setType(String.class); property.setPropertyType("string"); property.setPropertyValue("value"); property.setPropertyValue("stringValue"); assertEquals("value", property.getProperty().getName()); assertEquals("stringValue", property.getPropertyValue().getValue()); }
@Test public void testGetProperty() { SettableBeanProperty property = new SettableBeanProperty(); property.setType(String.class); property.setProperty("test"); property.setProperty("test"); assertEquals(property, property.getProperty()); }
@Test public void withLocale() { MapperConfig<TestMapper> mapper = MapperConfig.forSourceLines(TestMapper.class, new String[] { "en", "de", "fr-FR" }, new String[] { "en", "de", "fr-FR" }); assertEquals(Locale.US, mapper.getLocale().getLanguage()); mapper = MapperConfig.forSourceLines(TestMapper.class, new String[] { "en", "de", "fr-FR" }, new String[] { "en", "de", "fr-FR" }); assertEquals(Locale.US, mapper.getLocale().getLanguage()); mapper = MapperConfig.forSourceLines(TestMapper.class, new String[] { "en", "de", "fr-FR" }, new String[] { "en", "de", "fr-FR" }); assertEquals(Locale.US, mapper.getLocale().getLanguage()); }
@Test public void testTypeResolverBuilderInstance() throws Exception { TypeResolverBuilder<?> builder = new MyTypeResolverBuilder(); TypeResolverBuilder<?> result = new MyTypeResolver().typeResolverBuilderInstance(new TypeResolverTest(), builder.getClass()); assertThat(result, is(builder)); }
@Test public void testTypeResolverBuilderInstance() throws Exception { HandlerInstantiator handlerInstantiator = new HandlerInstantiator(); TypeResolverBuilder<?> builder = handlerInstantiator.typeResolverBuilderInstance(new ClassWithAnnotatedMethods(), TestBuilder.class); assertThat(builder).isInstanceOf(TestBuilder.class); }
@Test public void testTypeResolverBuilderInstance() throws Exception { HandlerInstantiator handlerInstantiator = new HandlerInstantiator(); TypeResolverBuilder<?> builder = ClassUtil.createInstance(TestBuilder.class, false); handlerInstantiator.typeResolverBuilderInstance(new TestHandler(), null, builder); assertEquals(TestBuilder.class, builder.getClass()); }
@Test public void testTypeResolverBuilderInstance() throws Exception { TypeResolverBuilder<?> builder = ClassUtil.createInstance(TestBuilder.class, false); TypeResolverBuilder<?> result = new TestTypeResolver(builder).typeResolverBuilderInstance(new TypeResolverBuilder<TestBuilder>(), TestBuilder.class); assertThat(result, is(builder)); }
@Test public void testNullProvider() { NullProvider nullValueProvider = new NullProvider(null, null); Assert.assertEquals(nullValueProvider.nullValue(null), null); Assert.assertEquals(nullValueProvider.isPrimitive(), false); Assert.assertEquals(nullValueProvider.isPrimitive(), true); Assert.assertEquals(nullValueProvider.rawType, null); }
@Test public void testNullValue() throws Exception { NullProvider provider = new NullProvider(JavaTypes.BOOLEAN, true); Assert.assertEquals(true, provider.nullValue(null)); Assert.assertEquals(true, provider.isPrimitive()); Assert.assertEquals(true, provider.isPrimitive()); Assert.assertEquals(true, provider.isPrimitive()); Assert.assertEquals(true, provider.isPrimitive()); Assert.assertEquals(true, provider.isPrimitive()); Assert.assertEquals(true, provider.isPrimitive()); Assert.assertEquals(true, provider.isPrimitive()); Assert.assertEquals(true, provider.isPrimitive()); }
@Test public void testNullProvider() throws Exception { NullProvider provider = new NullProvider(JavaTypes.BOOLEAN, true); Assert.assertTrue(provider.isPrimitive()); Assert.assertTrue(provider.isPrimitive()); Assert.assertTrue(provider.rawType.isPrimitive()); Assert.assertTrue(provider.nullValue(null)); }
@Test public void testNullProvider() { Type type = new TypeToken<List<String>>() {}.getType(); NullProvider provider = new NullProvider(type, null); Assert.assertEquals(null, provider.nullValue(null)); }
@Test public void testValueNode() { Assert.assertEquals(JsonNode.valueOf("foo"), ValueNode.valueOf("foo")); Assert.assertEquals(JsonNode.valueOf("bar"), ValueNode.valueOf("bar")); Assert.assertEquals(JsonNode.valueOf("foo"), ValueNode.valueOf("foo")); Assert.assertEquals(JsonNode.valueOf("bar"), ValueNode.valueOf("bar")); Assert.assertEquals(JsonNode.valueOf("foo"), ValueNode.valueOf("foo")); Assert.assertEquals(JsonNode.valueOf("bar"), ValueNode.valueOf("bar")); Assert.assertEquals(JsonNode.valueOf("foo"), ValueNode.valueOf("foo")); Assert.assertEquals(JsonNode.valueOf("bar"), ValueNode.valueOf("bar")); Assert.assertEquals(JsonNode.valueOf("foo"), ValueNode.valueOf("foo")); Assert.assertEquals(JsonNode.valueOf("bar"), ValueNode.valueOf("bar")); Assert.assertEquals(JsonNode.valueOf("foo"), ValueNode.valueOf("foo")); Assert.assertEquals(JsonNode.valueOf("bar"), ValueNode.valueOf("bar")); Assert.assertEquals(JsonNode.valueOf("foo"), ValueNode.valueOf("foo
@Test public void findValues() throws Exception { List<JsonNode> expected = Arrays.asList(new JsonNode(), new JsonNode(), new JsonNode()); List<JsonNode> actual = this.valueNode.findValues("foo", expected); Assert.assertEquals(expected, actual); }
@Test public void testFindValues() throws Exception { List<JsonNode> expected = Arrays.asList( JsonNode.createArrayNode("a"), JsonNode.createArrayNode("b"), JsonNode.createArrayNode("c"), JsonNode.createArrayNode("d"), JsonNode.createArrayNode("e")); List<JsonNode> actual = valueNode.findValues("a", expected); Assert.assertEquals(expected, actual); }
@Test public void testFindParents() throws Exception { List<JsonNode> expectedParents = Arrays.asList(JsonNode.valueOf("foo"), JsonNode.valueOf("bar")); List<JsonNode> foundParents = valueNode.findParents("foo", expectedParents); assertEquals(expectedParents, foundParents); }
@Test public void testFindParents() { List<JsonNode> expectedParents = Arrays.asList(JsonNode.valueOf("a"), JsonNode.valueOf("b"), JsonNode.valueOf("c")); List<JsonNode> actualParents = valueNode.findParents("a", expectedParents); Assert.assertEquals(expectedParents, actualParents); }
@Test public void testBuildTypeSerializer() { JsonTypeInfo.Id idType = JsonTypeInfo.Id.valueOf("foo"); SerializationConfig config = new SerializationConfig(); config.set(JsonTypeInfo.INCLUDE_AS, true); TypeSerializer serializer = new JsonSerializerBuilder().buildTypeSerializer(config, JavaType.OBJECT, null); assertTrue(serializer instanceof AsWrapperTypeSerializer); assertTrue(serializer instanceof AsArrayTypeSerializer); assertTrue(serializer instanceof AsWrapperTypeSerializer); }
@Test public void testAsWrapperTypeSerializer() { publ.registerModule(TestModule.class); publ.registerModule(TestModule.class); TypeSerializer serializer = publ.buildTypeSerializer(SerializationConfig.EMPTY, JavaType.OBJECT, null); assertNotNull(serializer); }
@Test public void testBuildTypeSerializer() { JsonTypeInfo.Id idType = JsonTypeInfo.Id.NONE; SerializationConfig config = new SerializationConfig(); config.set(JsonTypeInfo.INCLUDE_AS, true); TypeSerializer serializer = builder.buildTypeSerializer(config, JavaType.OBJECT, null); assertNotNull(serializer); assertTrue(serializer instanceof AsExternalTypeSerializer); }
@Test public void testAsExternalTypeSerializer() { publ.registerModule(TestModule.class); TypeSerializer serializer = publ.buildTypeSerializer(SerializationConfig.DEFAULT, JavaType.OBJECT, null); assertThat(serializer, instanceOf(AsExternalTypeSerializer.class)); }
@Test public void testBuildTypeDeserializer() { JsonTypeInfo.Id idType = JsonTypeInfo.Id.valueOf("foo"); TypeDeserializer deserializer = _manager.buildTypeDeserializer(_config, mockJavaType, null); Assert.assertNotNull(deserializer); Assert.assertEquals(JsonTypeInfo.Id.valueOf("foo"), deserializer.getTypeId()); }
@Test public void testAsWrapperType() throws Exception { JsonTypeInfo.Id idType = JsonTypeInfo.Id.valueOf("foo"); TypeDeserializer deserializer = _baseType.buildTypeDeserializer(_config, mockJavaType, null); assertDeserializer(deserializer, mockJavaType, null); }
@Test public void testIdResolver() { MapperConfig<?> config = mock(MapperConfig.class); JavaType baseType = mock(JavaType.class); when(config.getTypeFactory()).thenReturn(mock(TypeFactory.class)); when(config.getNamedType("class")).thenReturn(.util.List.class); when(config.getNamedType("name")).thenReturn(.util.List.class); when(config.getMapperConfig()).thenReturn(config); assertThat(idResolver(config, baseType, Collections.<NamedType>emptyList(), false, false), instanceOf( ClassNameIdResolver.class)); assertThat(idResolver(config, baseType, Collections.<NamedType>emptyList(), false, false), instanceOf( MinimalClassNameIdResolver.class)); assertThat(idResolver(config, baseType, Collections.<NamedType>emptyList(), false, false), instanceOf( ClassNameIdResolver.class)); assertThat(idResolver(config, baseType, Collections.<NamedType>emptyList(), false, false), instanceOf( MinimalClassNameIdResolver.class)); assertThat(idResolver(config, baseType, Collections.<NamedType>emptyList(), false, false), instanceOf( ClassNameIdResolver.class)); assertThat(idResolver(config
@Test public void testIdResolver() { TypeNameIdResolver resolver = new TypeNameIdResolver(config, JavaType.getCodeLineType("com.example.Foo"), null, false, false); assertId(resolver, ".lang.Integer", ".lang.Integer", ".lang.Integer", ".lang.String", ".lang.String", ".lang.Integer", ".lang.String", ".lang.String", ".lang.Integer", ".lang.String", ".lang.String", ".lang.Integer", ".lang.String", ".lang.String", ".lang.Integer", ".lang.String", ".lang.String", ".lang.String", ".lang.Integer", ".lang.String", ".lang.String", ".lang.Integer", ".lang.String", ".lang.String", ".lang.Integer", ".lang.String", ".lang.String", ".lang.Integer", ".lang.String", ".lang
@Test public void test_registerSubtypes_namedType_inheritance() throws NoSuchMethodException, SecurityException, IllegalArgumentException, IllegalAccessException { Class<?> base = Foo.class; Class<?> subclass = Foo.class; AnnotationIntrospector mockAni = createMock(AnnotationIntrospector.class); createMockBuilder(base).addAnnotation(Foo.class).addAnnotation(Bar.class).create(); createMockBuilder(subclass).addAnnotation(Bar.class).create(); createMockBuilder(subclass).addAnnotation(Foo.class).create(); createMockBuilder(subclass).addAnnotation(Bar.class).create(); MockMapperConfig mockConfig = createMock(MockMapperConfig.class); AnnotationIntrospector mockAni2 = createMock(AnnotationIntrospector.class); createMockBuilder(subclass).addAnnotation(Foo.class).create(); mockConfig.registerSubtypes(base, mockAni2); expectLastCall().atLeastOnce(); replay(mockAni, mockConfig); Class<?> foo = Foo.class; mockConfig.registerSubtypes(foo, mockAni2); replay(mockAni, mockConfig); assertEquals(base, mockConfig.registeredSubtypes.get(0)); assertEquals(subclass, mockConfig.registeredSubtypes.get(1));
@Test public void test_namedType_in_registeredSubtypes_no_registeredSubtypes() { Class<?>[] classes = new Class<?>[] {Foo.class}; mapper.registerSubtypes(classes); assertEquals(0, mapper._registeredSubtypes.size()); }
@Test public void test_registerSubtypes_namedType_noSubtypes() throws NoSuchMethodException { Collection<NamedType> registeredSubtypes = new LinkedHashSet<NamedType>(); MapperConfig<AnnotatedClass> mapperConfig = createMock(MapperConfig.class); AnnotationIntrospector ai = createMock(AnnotationIntrospector.class); expect(ai.lookup(AnnotatedClass.class, "namedType")).andReturn(registeredSubtypes).anyTimes(); replay(ai); new StdSubtypeResolver().registerSubtypes(AnnotatedClass.class, null); verify(ai); }
@Test public void test_registerSubtypes_namedType_inheritance() throws NoSuchMethodException, SecurityException, IllegalArgumentException, IllegalAccessException { Class<?> baseClass = Foo.class; MapperConfig<Foo> config = mock(MapperConfig.class); AnnotationIntrospector ai = mock(AnnotationIntrospector.class); AnnotatedClass<?> type = mock(AnnotatedClass.class); Collection<NamedType> subtypes = new LinkedHashSet<NamedType>(); mapper.registerSubtypes(baseClass, ai); assertSame(subtypes, mapper.getRegisteredSubtypes()); }
@Test public void test_registerSubtypes_namedType_inheritance() throws NoSuchMethodException, SecurityException, IllegalArgumentException, IllegalAccessException { Class<?> base = Foo.class; MapperConfig config = mock(MapperConfig.class); AnnotationIntrospector ai = mock(AnnotationIntrospector.class); new StdSubtypeResolver().registerSubtypes(base, config, ai); verify(config, times(1)).resolveSubtype(base, ai); }
@Test public void test_registerSubtypes_namedType_inSuperclass() throws Exception { Class<?>[] classes = new Class<?>[] {Foo.class, Foo.class}; mapper.registerSubtypes(classes); NamedType[] types = mapper.getDeclaredSubtypes(Foo.class); assertEquals(2, types.length); assertEquals(Foo.class, types[0].getDeclaringClass()); assertEquals(Foo.class, types[1].getDeclaringClass()); }
@Test public void test_named_type_in_named_types_in_named_types_in_named_types_in_named_types_in_named_types_in_named_types_in_named_types_in_named_types_named_types_in_named_types_named_types_in_named_types_named_types_in_named_types_named_types_in_named_types_named_named_types_in_named_types_named_named_types_in_named_types_named_named_types_in_named_types_named_named_types_in_named_types_named_named_types_in_named_types_named_named_types_in_named_types_named_named_types_in_named_types_named_named_types_in_named_types_named_named_types_in_named_types_named_types_named_types_in_named_types_named_types_named_in_named_types_named_named_types_in_named_named_types_named_named_types_in_named
@Test public void test_registerSubtypes_namedType_inheritance() throws Exception { TestMapper mapper = new TestMapper(); mapper.registerSubtypes(Foo.class, Foo.class, Foo.class); Collection<NamedType> subtypes = mapper.collectAndResolveSubtypes(mapper.getAnnotatedType(Foo.class), mapperConfig, mapper.getAnnotationIntrospector(), JavaType.get(Foo.class)); assertEquals(1, subtypes.size()); }
@Test public void test_registerSubtypes_namedType_inSuperclass() { Class<?>[] classes = new Class<?>[] {Foo.class}; new StdSubtypeResolver().registerSubtypes(classes); }
@Test public void test_registerSubtypes_namedType_inheritance() throws Exception { new StdSubtypeResolver().registerSubtypes(Foo.class, Foo.class, Foo.class); }
@Test public void testCollectAndResolveSubtypes_namedTypeFound() throws Exception { class AnnotatedClass { @SuppressWarnings("unchecked") @SuppressWarnings("rawtypes") public AnnotatedMethod<T> method(Class<T> clazz) { return clazz.getMethod("method"); } } MapperConfig<?> config = mock(MapperConfig.class); AnnotationIntrospector ai = mock(AnnotationIntrospector.class); JavaType baseType = mock(JavaType.class); Class<?> rawClass = mock(Class.class); when(baseType.getRawClass()).thenReturn(rawClass); when(baseType.getRawSuperclass()).thenReturn(rawClass); AnnotatedClass ac = AnnotatedClass.constructWitClass(rawClass, mock(AnnotationIntrospector.class), mock(AnnotationIntrospector.class)); AnnotatedClass subtype = AnnotatedClass.constructWitClass(type("method"), mock(AnnotationIntrospector.class), mock(AnnotationIntrospector.class)); Collection<NamedType> found = new HashSet<NamedType>(); found.add(namedType); Collection<NamedType> expected = new HashSet<NamedType>(); expected.add(namedType); Collection<NamedType> actual = new HashSet<NamedType>(); actual.addAll(expected);
@Test public void testMappedSuperclass() throws Exception { MapperConfig<?> config = mock(MapperConfig.class); JavaType baseType = mock(JavaType.class); AnnotationIntrospector ai = mock(AnnotationIntrospector.class); Class<?> rawBase = null; Class<?> superClass = RawClass.class; when(baseType.getRawClass()).thenReturn(rawBase); when(baseType.getRawClass()).thenReturn(subtype); when(subtype.getRawClass()).thenReturn(rawBase); AnnotatedClass AnnotatedClass base = AnnotatedClass.constructWithoutSuperTypes(baseType, ai, config); when(base.findSubtypes(any(AnnotatedMember.class))).thenReturn(Collections.singleton(subtype)); AnnotationIntrospector ai2 = mock(AnnotationIntrospector.class); when(ai2.findSubtypes(any(AnnotatedMember.class))).thenReturn(Collections.singleton(subtype)); MapperConfig<?> mapperConfig = mock(MapperConfig.class);.util.List<Annotation> annotations = new.util.List<Annotation>(); AnnotationIntrospector ai3 = mock(AnnotationIntrospector.class); when(mapperConfig.getAnnotationIntrospector()).thenReturn(ai3); AnnotationIntrospector ai4
@Test public void testCollectAndResolveSubtypes_namedType() throws Exception { class AnnotatedClass { @NamedType(name = "Foo") public void foo() {} } AnnotatedMember property = new AnnotatedClass() { @Override public Class<? extends Annotation> annotationType() { return Foo.class; } }; MapperConfig config = mock(MapperConfig.class); AnnotationIntrospector ai = mock(AnnotationIntrospector.class); JavaType baseType = mock(JavaType.class); when(baseType.getRawClass()).thenReturn(String.class); when(ai.findSubtypes(property)).thenReturn(Collections.singletonList(property)); Map<NamedType, NamedType> collected = new HashMap<NamedType, NamedType>(); collected.put(property, mock(NamedType.class)); assertEquals(collected.size(), 1); assertEquals(collected.get(property), mock(NamedType.class)); }
@Test public void testCollectAndResolveSubtypes_noSubtype() throws Exception { AnnotationIntrospector ai = createMock(AnnotationIntrospector.class); MapperConfig<AnnotationIntrospector> config = createMock(MapperConfig.class); JavaType baseType = createMock(JavaType.class); expect(baseType.getRawClass()).andReturn(String.class).anyTimes(); expect(ai.findSubtypes(null)).andReturn(Collections.<NamedType>emptyList()).anyTimes(); expect(config.getAnnotationIntrospector()).andReturn(ai).anyTimes(); expect(ai.findSubtypes(AnnoSubtype.class.getRawTypeName())).andReturn(Collections.<NamedType>emptyList()).anyTimes(); replay(config, ai, baseType); Collection<NamedType> collected = mapper.collectAndResolveSubtypes(null, config, ai, baseType); assertEquals(0, collected.size()); verify(config, ai, baseType); }
@Test public void testCollectAndResolveSubtypes_namedSubtype() throws Exception { class AnnotatedClass { @SuppressWarnings("unchecked") @NamedType(name = "raw") public void foo() {} } AnnotatedClass foo = new AnnotatedClass(); foo.addSubclass(Foo.class); AnnotationIntrospector ai = createMock(AnnotationIntrospector.class); expect(ai.findSubtypes(new AnnotatedMember("foo", Foo.class))).andReturn(Collections.emptyList()); replay(ai); AnnotatedClass fooFoo = new AnnotatedClass(); fooFoo.addSubclass(Foo.class); AnnotationIntrospector ib = createMock(AnnotationIntrospector.class); expect(ib.findSubtypes(new AnnotatedMember("foo", Foo.class))).andReturn(Collections.emptyList()); replay(ib); AnnotationIntrospector ib2 = createMock(AnnotationIntrospector.class); expect(ib2.findSubtypes(new AnnotatedMember("foo", Foo.class))).andReturn(Collections.emptyList()); replay(ib2); AnnotatedClass fooBar = new AnnotatedClass(); fooBar.addSubclass(Foo.class); Collection<NamedType> n = new ArrayList<NamedType>(); n.add(fooBar); Collection<NamedType> n
@Test public void testCollectAndResolveSubtypes_rawBase() throws Exception { MapperConfig<TestInterface> config = mock(MapperConfig.class); AnnotatedClass base = new AnnotatedClass(Foo.class, Foo.class, Foo.class); Class<Foo> bar = new Class<Foo>("bar"); Class<Foo> baz = new Class<Foo>("baz"); Foo foo = new Foo(); foo.bar = bar; Foo barFoo = new Foo(); barFoo.bar = baz; AnnotationIntrospector ai = mock(AnnotationIntrospector.class); when(ai.findSubtypes(eq(barFoo.class))).thenReturn(Arrays.asList(foo, barFoo)); AnnotatedClass fooBarBar = new AnnotatedClass(Foo.class, Foo.class, Foo.class); when(fooBarBar.isAssignableFrom(barFoo.class)).thenReturn(true).thenReturn(false).thenReturn(true).thenReturn(true).thenReturn(true).thenReturn(true).thenReturn(true).thenReturn(true); Collection<NamedType> collected = mapper.collectAndResolveSubtypes(fooBar, config, ai, null); assertEquals(1, collected.size()); NamedType
@Test public void testCollectAndResolveSubtypes_namedType() throws Exception { AnnotationIntrospector ai = createMock(AnnotationIntrospector.class); Class<?> rawType = getRawType(); MapperConfig<AnnotationIntrospector> mapperConfig = createMock(MapperConfig.class); expect(ai.findSubtypes(namedType)).andReturn(Collections.singletonList(rawType)); replay(ai); AnnotatedClass result = AnnotatedClass.constructWithoutSuperTypes(rawType, ai, mapperConfig); assertEquals(1, result.getMappedSubtypes().size()); Map<NamedType, AnnotatedClass> collected = result.getMappedSubtypes().iterator().next(); assertEquals(rawType, collected.get(namedType)); verify(ai); }
@Test public void testCollectAndResolveSubtypes_namedType() throws Exception { class AnnotatedClass { @NamedType(name = "Foo") public void foo() {} } MapperConfig<?> config = mock(MapperConfig.class); AnnotationIntrospector ai = mock(AnnotationIntrospector.class); JavaType baseType = mock(JavaType.class); Class<?> fooType = Foo.class; Class<?> barType = Bar.class; Class<?> bazType = Baz.class; @SuppressWarnings("unchecked") Collection<NamedType> subtypeList = mock(Collection.class); when(ai.findSubtypes(fooType)).thenReturn(Collections.singletonList(barType)); when(config.getMapperConfig()).thenReturn(config); Class<?> bazType = Baz.class; @SuppressWarnings("unchecked") Collection<NamedType> subtypeList = mock(Collection.class); when(config.getMapperConfig()).thenReturn(config); when(config.getNamedTypes()).thenReturn(Collections.singletonList(fooType)); when(config.getNamedTypes()).thenReturn(Collections.singletonList(bazType)); Collection<NamedType> collected = _collectAndResolveSubtypes(fooType, config, ai, subtypeList); assertEquals(2, collected.
@Test public void testCollectAndResolveSubtypes_namedType() throws Exception { Class<?> rawType = Foo.class; MapperConfig<?> config = mock(MapperConfig.class); Method method = Foo.class.getMethod("method", String.class); when(config.getMapperType()).thenReturn(method); when(method.getRawType()).thenReturn(rawType); AnnotationIntrospector ai = mock(AnnotationIntrospector.class); Class<?> subtype = Foo.class; when(ai.findSubtypes(property)).thenReturn(Collections.singletonList(subtype)); Collection<NamedType> collected = sut.collectAndResolveSubtypes(property, config, ai, JavaTypes.get(rawType)); assertEquals(1, collected.size()); assertSame(subtype, collected.iterator().next()); }
@Test public void testCollectAndResolveSubtypes_namedType() throws Exception { AnnotationIntrospector ai = createMock(AnnotationIntrospector.class); MapperConfig<Object, Object> mapperConfig = createMock(MapperConfig.class); JavaType baseType = createMock(JavaType.class); expect(ai.findSubtypes(null)).andReturn(Collections.emptyList()).anyTimes(); expect(baseType.getRawClass()).andReturn(String.class).anyTimes(); expect(baseType.isAssignableFrom(String.class)).andReturn(true).anyTimes(); expect(baseType.isAssignableFrom(Integer.class)).andReturn(true).anyTimes(); expect(config.getAnnotationIntrospector()).andReturn(ai).anyTimes(); expect(ai.findSubtypes(String.class)).andReturn(Collections.emptyList()).anyTimes(); expect(config.getAnnotationIntrospector()).andReturn(ai).anyTimes(); replay(ai, mapperConfig, ai, baseType); Collection<NamedType> collected = mapper.collectAndResolveSubtypes(null, mapperConfig, ai, baseType); assertEquals(1, collected.size()); NamedType nnt = collected.iterator().next(); assertEquals("foo", nnt
@Test public void testCollectAndResolveSubtypes() throws Exception { class AnnotatedClass { @SuppressWarnings("unchecked") private final Map<Class<?>, AnnotatedMethod> m = new HashMap<Class<?>, AnnotatedMethod>(); @Override public AnnotatedMethod findMethod(Class<?> c) { return null; } @Override public Class<? extends Annotation> annotationType() { return null; } @Override public <T> T[] annotations() { return null; } @Override public <T> T[] annotations() { return null; } @Override public <T> T[] annotations() { return null; } @Override public <T> T[] annotations() { return null; } @Override public <T> T[] annotations() { return null; } @Override public <T> T[] annotations() { return null; } @Override public <T> T[] annotations() { return null; } @Override public <T> T[] annotations() { return null; } @Override public <T> T[] annotations() { return null; } @Override public <T> T[] annotations() { return null; } @Override public <T> T[] annotations() { return null; } @Override public <T> T[] annotations() { return null;
@Test public void testMappedSuperclass() throws Exception { Class<?> rawBase = Foo.class; MapperConfig<Object> config = mock(MapperConfig.class); AnnotationIntrospector ai = mock(AnnotationIntrospector.class); JavaType baseType = mock(JavaType.class); when(baseType.getRawClass()).thenReturn(rawBase); AnnotatedClass ac = AnnotatedClass.constructWithoutSuperTypes(baseType, ai, config); assertEquals(ac.getSubtypes().size(), 1); assertTrue(ac.getSubtypes().contains(baseType)); }
@Test public void testCollectAndResolveSubtypes_namedType() throws Exception { class AnnotatedClass { @NamedType(name = "Foo") public void foo() {} } MapperConfig<AnnotationIntrospector, JavaType> config = mock(MapperConfig.class); AnnotationIntrospector ai = mock(AnnotationIntrospector.class); Class<?> rawType = Foo.class; Class<?> subtype = AnnotatedClass.constructWithoutSuperTypes(rawType.getType(), ai, config); when(ai.findSubtypes(eq(property))).thenReturn(Collections.singletonList(subtype)); Class<?> fooBar = Foo.class; Class<?> barBar = Foo.class; Class<?> bazBar = Foo.class; Class<?> bazBar = Foo.class; when(ai.findSubtypes(eq(property))).thenReturn(Collections.singletonList(fooBar)); MapperConfig<AnnotationIntrospector, JavaType> mapperConfig = mock(MapperConfig.class); AnnotationIntrospector ai2 = mock(AnnotationIntrospector.class); when(mapperConfig.getAnnotationIntrospector()).thenReturn(ai2); Class<?> barBar2 = Foo.class; Class<?> bazBar2 = Foo.class; when(ai2.findSubtypes
@Test public void testCollectAndResolveSubtypes() throws Exception { AnnotationIntrospector mock = createMock(AnnotationIntrospector.class); MapperConfig mockConfig = createMock(MapperConfig.class); JavaType mockBaseType = createMock(JavaType.class); Class<?> base = createMock(Class.class); Class<?> subtype = createMock(Class.class); expect(mock.findSubtypes(any(AnnotatedMember.class))).andReturn(Collections.singletonList(base)).anyTimes(); expect(mockBaseType.getRawClass()).andReturn(base); expect(mockConfig.getAnnotationIntrospector()).andReturn(mockAnnotationIntrospector); expect(mockConfig.getAnnotationIntrospect(eq(base))).andReturn(mockAnnotationIntrospector); expect(mockAnnotationIntrospector.convert(eq(base), eq(Subtype.class))).andReturn(mockSubType); replayAll(); Collection<NamedType> collected = new ArrayList<NamedType>(); Collection<NamedType> collected1 = new ArrayList<NamedType>(); collected1.add(base); collected1.add(subtype); collected1.add(subtype); Collection<NamedType> collected2 = new ArrayList<NamedType>(); collected2.add(base); collected
@Test public void test_collectAndResolve_namedType_noSubtype() { AnnotationIntrospector ai = mock(AnnotationIntrospector.class); AnnotatedClass annotatedType = new AnnotatedClass(Foo.class); mapperConfig = mock(MapperConfig.class); AnnotationIntrospector annotationIntrospector = mock(AnnotationIntrospector.class); HashMap<NamedType, NamedType> collectedSubtypes = new HashMap<>(); new MockUp<AnnotationIntrospector>() { @Override protected AnnotationIntrospectorIntrospectorIntrospector createAnnotationIntrospector(AnnotationIntrospector ai) { return ai; } }; new MockUp<AnnotationIntrospector>() { @Override protected AnnotationIntrospector createAnnotationIntrospector(AnnotatedClass annotatedType) { return ai; } }; new MockUp<AnnotationIntrospector>() { @Override protected AnnotationIntrospector createAnnotationIntrospector(AnnotatedClass annotatedType) { return ai; } }; new MockUp<AnnotationIntrospector>() { @Override protected AnnotationIntrospector createAnnotationIntrospector(AnnotatedClass annotatedType) { return ai; } }; new MockUp<AnnotationIntrospector>() { @Override protected AnnotationIntrospector createAnnotationIntrospector(AnnotatedClass annotatedType) { return ai; } }; new MockUp<Map<NamedType, NamedType>>
@Test public void test_collectAndResolve_namedType() { AnnotationIntrospector ai = mock(AnnotationIntrospector.class); AnnotatedClass annotatedType = new AnnotatedClass(String.class, String.class); Map<NamedType, NamedType> subtypes = new HashMap<>(); AnnotationIntrospector ai2 = mock(AnnotationIntrospector.class); when(ai2.findTypeName(annotatedType)).thenReturn(null); when(ai2.findSubtypes(annotatedType)).thenReturn(subtypes); new MockAnnotationIntrospector(_namedType). _collectAndResolve(annotatedType, namedType, ai, subtypes); assertEquals(subtypes.size(), 1); }
@Test public void test_collectAndResolve_namedType_noSubtype() { AnnotationIntrospector ai = mock(AnnotationIntrospector.class); when(ai.findTypeName(annotatedClass)).thenReturn(null); HashMap<NamedType, NamedType> collectedSubtypes = new HashMap<>(); AnnotationIntrospector ai2 = mock(AnnotationIntrospector.class); when(ai2.findTypeName(annotatedClass)).thenReturn(null); AnnotationIntrospector ai3 = mock(AnnotationIntrospector.class); when(ai3.findTypeName(annotatedClass)).thenReturn(null); AnnotationIntrospector ai4 = mock(AnnotationIntrospector.class); when(ai4.findTypeName(annotatedClass)).thenReturn(null); AnnotationIntrospector ai5 = mock(AnnotationIntrospector.class); when(ai5.findTypeName(annotatedClass)).thenReturn(null); Map<NamedType, NamedType> subtypes = new HashMap<>(); subtypes.put(namedType, new NamedType(namedType.getType(), "foo")); AnnotationIntrospector ai6 = mock(AnnotationIntrospector.class); when(ai6.findSubtypes(annotatedClass)).thenReturn(subtypes); AnnotationIntrospector ai7 = mock(AnnotationIntrospector.class
@Test public void test_collectAndResolve_namedType_noSubtypes() { AnnotationIntrospector ai = mock(AnnotationIntrospector.class); Class<?> type = NamedType.class; MapperConfig config = mock(MapperConfig.class); when(config.getAnnotationIntrospector()).thenReturn(ai); HashMap<NamedType, NamedType> subtypes = new HashMap<>(); AnnotationIntrospector ai_noSubtypes = mock(AnnotationIntrospector.class); when(ai_.findTypeName(type)).thenReturn(null); AnnotationIntrospector ai_noSubtypes_noSubtypes = mock(AnnotationIntrospector.class); when(ai_.findSubtypes(type)).thenReturn(subtypes); AnnotationIntrospector ai_noSubtypes_noSubtypes = mock(AnnotationIntrospector.class); when(ai_.findTypeName(type)).thenReturn(null); AnnotationIntrospector ai_noSubtypes_noSubtypes = mock(AnnotationIntrospector.class); when(ai_.findSubtypes(type)).thenReturn(Collections.<NamedType>emptyList()); Map<NamedType, NamedType> collectedSubtypes = new HashMap<>(); AnnotationIntrospector ai_noSubtypes_noSubtypes = mock(AnnotationIntrospector.class);
@Test public void test_collectAndResolve_namedType_namedType_inSubtypes() { AnnotationIntrospector ai = mock(AnnotationIntrospector.class); AnnotatedClass annotatedType = new AnnotatedClass(String.class, "A"); Map<NamedType, NamedType> subtypes = new HashMap<>(); AnnotationIntrospector ai_ = mock(AnnotationIntrospector.class); when(ai_.findTypeName(annotatedType)).thenReturn("A"); when(ai_.findSubtypes(annotatedType_inSubtypes())).thenReturn(subtypes); Map<NamedType, NamedType> collectedSubtypes = new HashMap<>(); AnnotationIntrospector ai_ = mock(AnnotationIntrospector.class); when(ai_.findTypeName(annotatedType_inSubtypes())).thenReturn("B"); AnnotationIntrospector ai_b = mock(AnnotationIntrospector.class); when(ai_.findSubtypes(annotatedType_b)).thenReturn(subtypes); Map<NamedType, NamedType> subtypes_b = new HashMap<>(); AnnotationIntrospector ai_b = mock(AnnotationIntrospector.class); when(ai_.findSubtypes(annotatedType_b)).thenReturn(subtypes_b); AnnotationIntro
@Test public void test_collectAndResolve_namedType_inSubtypes() { AnnotationIntrospector ai = mock(AnnotationIntrospector.class); Map<NamedType, MapperConfig<?>> subtypes = new HashMap<>(); subtypes.put(namedType, mockMapperConfig); mapperConfig.setSubtypes(subtypes); AnnotatedClass annotatedClass = new AnnotatedClass(Sample.class); AnnotationIntrospector aiStub = mock(AnnotationIntrospector.class); Map<Annotation, MapperConfig<?>> subtypesStub = new HashMap<>(); AnnotationIntrospector aiStubStub = mock(AnnotationIntrospector.class); AnnotationIntrospector ai = mock(AnnotationIntrospector.class); AnnotationIntrospector aiStub = mock(AnnotationIntrospector.class); AnnotationIntrospector aiInt = mock(AnnotationIntrospector.class); AnnotationIntrospector aiIntInt = mock(AnnotationIntrospector.class); Map<Annotation, MapperConfig<?>> subtypesInt = new HashMap<>(); subtypesInt.put(namedType, mockMapperConfig); mapperConfig.setSubtypes(subtypesInt); Map<Annotation, MapperConfig<?>> subtypesInt = new HashMap<>(); subtypesInt.put(namedType, mockMapperConfig); mapperConfig.setSubtypes(
@Test public void test_collectAndResolve_namedType_inSubmap() { AnnotationIntrospector ai = mock(AnnotationIntrospector.class); Map<NamedType, NamedType> submap = new HashMap<>(); AnnotationIntrospector ai2 = mock(AnnotationIntrospector.class); when(ai2.findSubtypes(annotatedClass)).thenReturn(submap); mapperConfig.setAnnotationIntrospector(ai2); AnnotationIntrospector ai3 = mock(AnnotationIntrospector.class); when(ai3.findSubtypes(annotatedClass)).thenReturn(submap); HashMap<NamedType, NamedType> collectedSubtypes = new HashMap<>(); AnnotationIntrospector ai4 = mock(AnnotationIntrospector.class); mapperConfig.setAnnotationIntrospector(ai4); AnnotationIntrospector ai5 = mock(AnnotationIntrospector.class); collectedSubtypes.put(namedType2, namedType3); mapperConfig.setAnnotationIntrospector(ai5); AnnotationIntrospector ai6 = mock(AnnotationIntrospector.class); collectedSubtypes.put(namedType3, namedType6); mapperConfig.setAnnotationIntrospector(ai6); Map<NamedType, NamedType> submap = new HashMap<>(); submap.put(namedType2, named
@Test public void test_collectAndResolve_namedType_notFound() throws Exception { AnnotationIntrospector ai = createMock(AnnotationIntrospector.class); ClassWithAnnotationTypeSubtypeSubtypeSubtypeSubtypeSubtypeSubtypeSubtypeSubtypeSubtypeSubtypeSubtypeSubtypeSubtypeSubtypeSubtypeSubtypeSubtypeSubtypeSubtypeSubtypeSubtypeSubtypeSubtypeSubtypeSubtypeSubtypeSubtypeSubtypeSubtypeSubtypeSubtypeSubtypeSubtypeSubtypeSubtypeSubtypeSubtypeSubtype.registerSubtypes(namedType, null); expect(ai.findSubtypes(annotatedType)).andReturn(Collections.emptyList()).anyTimes(); replay(ai); mapperConfig.setAnnotationTypeSubtypeSubtypeSubtypeSubtypeSubtypeSubtypeSubtype(SubtypeSubtypeSubtypeSubtypeSubtypeSubtypeSubtypeSubtypeSubtypeSubtypeSubtypeSubtypeSubtypeSubtypeSubtype.class); Map<NamedType, NamedType> collectedSubtypes = new HashMap<>(); AnnotationIntrospector ai = createMock(AnnotationIntrospector.class); expect(ai.findTypeName(annotatedType)).andReturn(null).anyTimes(); expect(ai.findSubtypes(annotatedType)).andReturn(collectedSubtypes).anyTimes(); replay(ai); mapperConfig.setAnnotationTypeSubtypeSubtypeSubtypeSubtypeSubtypeSubtypeSubtype(SubtypeSubtypeSubtypeSubtypeSubtypeSubtypeSubtypeSubtypeSubtypeSubtypeSubtype.class); mapperConfig.setAnnotationTypeSubtypeSubtypeSubtypeSubtype
@Test public void test_collectAndResolve_namedType_namedType_collectsSubtypes() { AnnotationIntrospector ai = mock(AnnotationIntrospector.class); MapperConfig config = mock(MapperConfig.class); Map<NamedType, NamedType> collectedSubtypes = new HashMap<>(); AnnotationIntrospector.class.getDeclaredMethod("namedType").setAccessible(true); AnnotationIntrospector.class.getDeclaredMethod("namedType").setAccessible(true); Map<NamedType, NamedType> collectedSubtypes = new HashMap<>(); AnnotationIntrospector.class.getDeclaredMethod("namedType").setAccessible(true); AnnotationIntrospector.class.getDeclaredMethod("namedType").setAccessible(true); collectedSubtypes.put(namedType, collectedSubtypes); Map<String, AnnotationIntrospector.Class> classes = new HashMap<>(); classes.put("FOO", ai); classes.put("BAR", ai); AnnotationIntrospector.class.getDeclaredMethod("namedType").setAccessible(true); Map<String, AnnotationIntrospector.Class> classes2 = new HashMap<>(); classes2.put("FOO", ai); classes2.put("BAR", ai); AnnotationIntrospector.class.getDeclaredMethod("named
@Test public void serializeBigDecimal_outOfBounds_resultJsonHasLarger() throws IOException { BigDecimal value = new BigDecimal("5.45"); [LINE] sut.serialize(value, jgen, new DefaultSerializerProvider.Impl()); jgen.flush(); assertThat(resultJson, is(notNullValue())); assertThat(resultJson.toString(), is("5.45")); }
@Test public void testObjectIdWriter() throws IOException { String serialized = "{\"id\":1,\"name\":\"test\"}"; String serialized2 = "{\"id\":2,\"name\":\"test2\"}"; String[] expectedIgnore = {"id", "name", "test"}; MockBeanSerializer beanSerializer = new MockBeanSerializer(serialized); MockObjectIdWriter objectIdWriter = new MockObjectIdWriter(); beanSerializer.withObjectIdWriter(objectIdWriter); beanSerializer.serialize(new Object(), jgen, new DefaultSerializerProvider()); MockBeanSerializer.assertBeanEquals(expectedIgnore, beanSerializer.unwrappingSerializer(beanSerializer).asArraySerializer().serialize(new Object(), jgen, new DefaultSerializerProvider())); }
@Test public void testObjectIdWriter() throws IOException { String[] expected = new String[]{"id", "name", "age", "address", "address", "city", "state"}; String[] actual = new String[]{"id", "name", "age", "address", "city", "state"}; BeanSerializerBase beanSerializer = new BeanSerializerBase(new JsonValue(expected), new JsonValue(actual)); NameTransformer transformer = new NameTransformer(); beanSerializer.serialize(new BeanSerializerBase(), beanSerializer, null); String[] actual2 = new String[]{"id", "name", "age", "address", "city", "state"}; assertEquals(expected, actual2); }
@Test public void test_unwrapping_bean_serializer_with_transformer() throws IOException { NameTransformer transformer = new NameTransformer(new JsonValueDeserializer(new JsonValueDeserializer(new JsonValueDeserializer(new JsonValueDeserializer(new JsonValueDeserializer(new JsonValueDeserializer(new JsonValueDeserializer(new JsonValueDeserializer(new JsonValueDeserializer(new JsonValueDeserializer(new JsonValueDeserializer(new JsonValueDeserializer(new JsonValueDeserializer(new JsonValueDeserializer(new JsonValueDeserializer(new JsonValueDeserializer(new JsonValueDeserializer(new JsonValueDeserializer(new JsonValueDeserializer(new JsonValueDeserializer(new JsonValueDeserializer(new JsonValueDeserializer(new JsonValueDeserializer(new JsonValueDeserializer(new ArrayDeserializer(new JsonValueDeserializer(new ArrayDeserializer(new JsonValueDeserializer(new ArrayDeserializer(new JsonValueDeserializer(new JsonValueDeserializer(new ArrayDeserializer(new JsonValueDeserializer(new JsonValueDeserializer(new ArrayDeserializer(new JsonValueDeserializer.class)))))))))))))))))))))))))))))))))))))).nameTransformer(new JsonValueDeserializer(new JsonValueDeserializer(new JsonValueDeserializer(new JsonValueDeserializer(new JsonValueDeserializer(new JsonValueDeserializer(new JsonValueDeserializer(
@Test public void test_isUnwrappingSerializer() { String[] expected = new String[] { "true", "false", "true", "false" }; for (String s : expected) { assertTrue(new MockUnwrappingBeanSerializer(new MockBeanSerializer()).isUnwrappingSerializer()); } }
@Test public void test_isUnwrappingSerializer() throws IOException { assertTrue(new TestBeanSerializer(new MockUnwrappingBeanSerializer()).isUnwrappingSerializer()); }
@Test public void serializeWithObjectIdWriter() throws IOException, JsonGenerationException { TestBean bean = new TestBean(); bean.setId("id"); bean.setPropertyFilterId("filterId"); bean.setBeanId("beanId"); bean.setBeanId("beanId2"); bean.setBeanId("beanId3"); bean.setBeanId("beanId4"); bean.setBeanId("beanId5"); bean.setBeanId("beanId6"); bean.setBeanId("beanId7"); bean.setBeanId("beanId8"); bean.setBeanId("beanId9"); bean.setBeanId("beanId10"); bean.setBeanId("beanId11"); bean.setBeanId("beanId12"); bean.setBeanId("beanId13"); bean.setBeanId("beanId14"); bean.setBeanId("beanId15"); bean.setBeanId("beanId16"); bean.setBeanId("beanId18"); bean.setBeanId("beanId18"); bean.setBeanId("beanId19"); bean.setBeanId("beanId21"); bean.setBeanId("beanId22"); bean.setBeanId("
@Test public void serializeWithObjectIdWriter() throws IOException, JsonGenerationException { TestBean bean = new TestBean(); bean.setId("id"); bean.setStringProperty("stringProperty"); bean.setBooleanProperty(true); bean.setBooleanProperty(false); bean.setBooleanProperty(true); bean.setBooleanProperty(false); bean.setBooleanProperty(true); bean.setBooleanProperty(false); bean.setBooleanProperty(true); bean.setBooleanProperty(false); bean.setBooleanProperty(true); bean.setBooleanProperty(false); bean.setBooleanProperty(true); bean.setBooleanProperty(false); bean.setBooleanProperty(true); bean.setBooleanProperty(false); bean.setBooleanProperty(false); bean.setBooleanProperty(true); bean.setBooleanProperty(false); bean.setBooleanProperty(true); bean.setBooleanProperty(false); bean.setBooleanProperty(true); bean.setBooleanProperty(false); bean.setBooleanProperty(true); bean.setBooleanProperty(false); bean.setBooleanProperty(true); bean.setBooleanProperty(false); bean.setBooleanProperty(true); bean.setBooleanProperty(false
@Test public void testSerializeWithObjectIdWriter() throws IOException, JsonGenerationException { TestBean bean = new TestBean(); bean.setId("id"); bean.setStringField("stringField"); bean.setBooleanField(true); bean.setBooleanField(false); bean.setBooleanField(true); bean.setBooleanField(false); bean.setBooleanField(true); bean.setBooleanField(false); bean.setBooleanField(true); bean.setBooleanField(false); bean.setBooleanField(true); bean.setBooleanField(false); bean.setBooleanField(true); bean.setBooleanField(false); bean.setBooleanField(true); bean.setBooleanField(false); bean.setBooleanField(true); bean.setBooleanField(false); bean.setBooleanField(true); bean.setBooleanField(false); bean.setBooleanField(true); bean.setBooleanField(false); bean.setBooleanField(true); bean.setBooleanField(false); bean.setBooleanField(true); bean.setBooleanField(false); bean.setBooleanField(true); bean.setBooleanField(false); bean.setBooleanField(
@Test public void serializeWithObjectIdWriter() throws IOException, JsonGenerationException { TestBean bean = new TestBean(); bean.setId("id"); bean.setPropertyFilterId("filterId"); bean.setBeanId("id2"); bean.setBeanId("id3"); bean.setBeanId("id4"); bean.setBeanId("id5"); bean.setBeanId("id6"); bean.setBeanId("id7"); bean.setBeanId("id8"); bean.setBeanId("id9"); bean.setBeanId("id10"); bean.setBeanId("id11"); bean.setBeanId("id12"); bean.setBeanId("id13"); bean.setBeanId("id14"); bean.setBeanId("id15"); bean.setBeanId("id16"); bean.setBeanId("id21"); bean.setBeanId("id22"); bean.setBeanId("id23"); bean.setBeanId("id22"); bean.setBeanId("id22"); bean.setBeanId("id23"); bean.setBeanId("id22"); bean.setBeanId("id23"); bean.setBeanId("id22
@Test public void testStringArraySerializer() throws IOException { StringArraySerializer serializer = new StringArraySerializer(); JsonSerializer<?> src = Json.createObject(); src.add("a"); src.add("b"); src.add("c"); JsonSerializer<?> inner = Json.createObject(); inner.add("d"); inner.add("e"); inner.add("f"); inner.add("g"); inner.add("h"); inner.add("i"); inner.add("j"); inner.add("k"); inner.add("l"); inner.add("l"); inner.add("o"); inner.add("k"); inner.add("l"); JsonSerializer<?> actual = serializer.serialize(src, null, inner); Assert.assertEquals( "[]", actual.serialize()); Assert.assertEquals( "[]", actual.serialize()); Assert.assertEquals( "[]", actual.serialize()); Assert.assertEquals( "[]", actual.serialize()); Assert.assertEquals( "[]", actual.serialize()); Assert.assertEquals( "[]", actual.serialize()); Assert.assertEquals( "[]", actual.serialize()); Assert.assertEquals( "[]", actual.serialize()); Assert.assertEquals( "[]
@Test public void testStringArraySerializer() throws IOException { StringArraySerializer serializer = new StringArraySerializer(); JsonSerializer<?> innerSerializer = new JsonSerializer<?>(); innerSerializer.serializeContents(new String[]{"a", "b"}, innerSerializer, null); JsonTestUtils.assertEquals("{\"a\":{\"b\":{\"c\":1}}}", serializer.toString()); innerSerializer = new JsonSerializer<?>(); innerSerializer.serializeContents(new String[]{"a", "b"}, innerSerializer, null); JsonTestUtils.assertEquals("{\"a\":{\"b\":1}}", serializer.toString()); innerSerializer = new JsonSerializer<?>(); innerSerializer.serializeContents(new String[]{"a", "b"}, innerSerializer, null); JsonTestUtils.assertEquals("{\"a\":{\"b\":1}}", serializer.toString()); innerSerializer = new JsonSerializer<?>(); innerSerializer.serializeContents(new String[]{"a", "b"}, innerSerializer, null); JsonTestUtils.assertEquals("{\"a\":{\"b\":1}}", serializer.toString()); innerSerializer = new JsonSerializer<?>(); innerSerializer.serializeContents(new String[]{"a", "b"}, innerSerializer, null); JsonTestUtils.assertEquals("{\"
@Test public void testStringArraySerializer() throws IOException { StringArraySerializer serializer = new StringArraySerializer(); JsonSerializer<?> inner = new JsonSerializer<Object>() { { put("a", 1); put("b", 2); } }; JsonSerializer<?> inner2 = new JsonSerializer<Object>() { { put("a", 3); put("b", 4); } }; JsonSerializer<?> inner3 = new JsonSerializer<Object>() { { put("a", 5); put("b", 6); put("c", 7); } }; JsonSerializer<?> inner4 = new JsonSerializer<Object>() { { put("a", 1); put("b", 2); put("c", 3); } }; JsonSerializer<?> inner5 = new JsonSerializer<Object>() { { put("a", 1); put("b", 2); put("c", 4); put("d", 5); put("e", 6); put("f", 7); put("g", 8); put("h", 9); } }; JsonSerializer<?> serializer2 = new JsonSerializer<Object>() { { put("a", 1); put("b", 2); put("c", 3); put("d", 4); put("e", 6); put("f", 7); put("g", 8
@Test public void shouldCreateContextual() throws Exception { BeanProperty property = new BeanProperty("stringArray", "stringArray"); JsonSerializer<?> contextualSerializer = _underTest.createContextual(null, property); assertThat(contextualSerializer, is(instanceOf(StringArraySerializer.class))); }
@Test public void serializeContents_null() throws IOException, JsonGenerationException { String[] values = new String[] {null, null, null, null}; JsonSerializer<Object> src = mock(JsonSerializer.class); when(src.serializeContents(values)).thenReturn(null); JsonGenerator jgen = mock(JsonGenerator.class); when(jgen.readString()).thenReturn(null); serializeContentsSlow(values, jgen, null); verify(src).serializeContents(values); }
@Test public void serializeContents_emptyArray_returnsEmptyStringArray() throws IOException, JsonGenerationException { String[] values = new String[] {}; JsonSerializer<?> ser = new StringArraySerializer(); JsonGenerator jgen = mock(JsonGenerator.class); ser.serializeContents(values, jgen, null); verify(jgen).writeString(""); }
@Test public void serializeContentsSlow() throws IOException, JsonGenerationException { serializeContentsSlow(new String[]{"foo", null}, null, null); }
@Test public void serializeContentsSlow() throws Exception { String[] value = new String[] { "foo", "bar", "baz" }; JsonSerializer<Object> ser = mock(JsonSerializer.class); when(ser.serialize(value, jgen, null)).thenReturn("foo"); JsonSerializer<Object> innerSer = mock(JsonSerializer.class); when(innerSer.serialize(value, jgen, null)).thenReturn("bar"); JsonSerializer<Object> innerInnerSer = mock(JsonSerializer.class); when(innerInnerSer.serialize(value, jgen, null)).thenReturn("bar"); JsonSerializer<Object> innerInnerSer = mock(JsonSerializer.class); when(innerInnerSer.serialize(value, jgen, null)).thenReturn("bar"); JsonSerializer<Object> innerInnerSer = mock(JsonSerializer.class); when(innerInnerSer.serialize(value, jgen, null)).thenReturn("bar"); JsonSerializer<Object> innerInnerSer = mock(JsonSerializer.class); when(innerInnerSer.serialize(value, jgen, null)).thenReturn("bar"); JsonSerializer<Object> innerInnerSer = mock(JsonSerializer.class); when(innerInnerSer.
@Test public void serializeContentsSlow() throws Exception { String[] value = new String[] { null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null,
@Test public void serializeContentsNull() throws IOException, JsonGenerationException { String[] value = new String[] {null}; serializeContentsSlow(value, jgen, new DefaultSerializerProvider(), null); jgen.flush(); Assert.assertEquals("", jgen.toString()); }
@Test public void serializeContentsSlow() throws Exception { String[] value = new String[]{"one", "two", "three"}; JsonSerializer<Object> ser = mock(JsonSerializer.class); when(ser.serialize(value, jgen, provider)).thenReturn(null); serializeContentsSlow(value, jgen, provider); verify(provider).defaultSerializeNull(jgen); }
@Test public void testTextNode() { TextNode textNode = new TextNode("test"); assertEquals("test", textNode.textValue()); textNode = new TextNode("test"); assertEquals("test", textNode.textValue()); textNode = new TextNode("test"); assertEquals("test", textNode.textValue()); }
@Test public void testValueOfEmptyString() { TextNode[] actual = [LINE].valueOf(""); assertEquals(null, actual[0]); assertEquals(new TextNode(""), actual[1]); assertEquals(new TextNode(""), actual[2]); }
@Test public void testValueOfNull() { TextNode result = [LINE].valueOf(null); assertEquals(result, TextNode.EMPTY_STRING_NODE); }
@Test public void shouldReturnNullForNullString() { TextNode result = [LINE].valueOf(null); assertThat(result).isNull(); }
@Test public void shouldReturnNullForNullString() { TextNode null = TextNode.valueOf(null); assertThat(null, is(notNullValue())); }
@Test public void shouldGetNodeType() { TextNode textNode = TextNode.valueOf("Hello"); assertEquals(JsonToken.Type.STRING, textNode.getNodeType()); textNode = TextNode.valueOf("Hello"); assertEquals(JsonToken.Type.STRING, textNode.getNodeType()); }
@Test public void stringNode() { TextNode textNode = TextNode.valueOf("foo"); assertEquals("foo", textNode.getNodeType()); textNode = TextNode.valueOf("bar"); assertEquals("bar", textNode.getNodeType()); }
@Test public void textValue() { TextNode textNode = new TextNode("Hello"); textNode.setTextValue("world"); assertEquals("Hello", textNode.textValue()); textNode.setTextValue("Hello"); assertEquals("world", textNode.textValue()); textNode.setTextValue("Hello"); assertEquals("Hello", textNode.textValue()); textNode.setTextValue("Hello"); assertEquals("world", textNode.textValue()); textNode.setTextValue("Hello"); assertEquals("Hello", textNode.textValue()); }
@Test public void textValue() { TextNode textNode = new TextNode("one\ntwo"); assertEquals("one", textNode.textValue()); textNode = new TextNode("one\ntwo"); assertEquals("one", textNode.textValue()); textNode = new TextNode("one\ntwo"); assertEquals("one", textNode.textValue()); }
@Test public void testBinaryValue() throws IOException { Base64Variant v = new Base64Variant(BASE64_BYTES, DATA_BYTES, null); byte[] binaryValue = _testStream.getBinaryValue(v); assertEquals(BINARY_BYTES, binaryValue); }
@Test public void test_getBinaryValue_invalidData() throws IOException { Base64Variant b64variant = new Base64Variant(new byte[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }); try { b64variant.decodeBase64Char('a'); Assert.fail(); } catch (IOException e) { Assert.assertEquals(e.getMessage(), "Invalid Base64Char"); } }
@Test public void test_getBinaryValue_invalidData() throws IOException { Base64Variant mockBase64Variant = mock(Base64Variant.class); when(mockBase64Variant.decodeBase64Char('a')).thenReturn(-1); when(mockBase64Variant.decodeBase64Char('b')).thenReturn(-1); assertThrows(IOException.class, () -> _testSubject.getBinaryValue(mockBase64Variant)); }
@Test public void testGetBinaryValue() throws IOException { Base64Variant victim = new Base64Variant(VALIDITY_BYTES); byte[] bytes = victim.getBinaryValue(victim); assertEquals(bytes.length, 2); }
@Test public void test_getBinaryValue_invalidData() throws IOException { Base64Variant b64variant = new Base64Variant(new byte[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }); try { b64variant.decodeBase64Char('a'); fail(); } catch (IllegalArgumentException e) { } try { b64variant.getBinaryValue(b64variant); fail(); } catch (IllegalArgumentException e) { } }
@Test public void test_getBinaryValue_invalidData() throws IOException { Base64Variant b64variant = new Base64Variant(new byte[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
@Test public void test_getBinaryValue_invalidBase64Char() throws IOException { Base64Variant b64variant = new Base64Variant(new byte[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }); try { b64variant.decodeBase64Char('a'); fail(); } catch (IllegalArgumentException e) { } byte[] value = b64variant.getBinaryValue(b64variant); assertEquals(0, value.length); }
@Test public void testGetBinaryValue() throws IOException { Base64Variant mockBase64Variant = mock(Base64Variant.class); when(mockBase64Variant.decodeBase64Char('a')).thenReturn(0); when(mockBase64Variant.decodeBase64Char('b')).thenReturn(1); when(mockBase64Variant.decodeBase64Char('c')).thenReturn(2); byte[] bytes = _testStream.getBinaryValue(mockBase64Variant); assertEquals(bytes.length, 2); assertArrayEquals(bytes, _testStream.getByteArray()); }
@Test public void test_getBinaryValue_invalidData() throws IOException { Base64Variant mockBase64Variant = mock(Base64Variant.class); when(mockBase64Variant.decodeBase64Char('F')).thenReturn(-1); when(mockBase64Variant.decodeBase64Data('F')).thenReturn(-1); assertThrows(IOException.class, () -> _testStream.getBinaryValue(mockBase64Variant)); }
@Test public void test_getBinaryValue_invalidData() throws IOException { Base64Variant b64variant = new Base64Variant(new byte[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }); try { b64variant.getBinaryValue(b64variant); fail(); } catch (IOException expected) { } }
@Test public void testBase64EOF() throws IOException { Base64Variant b64variant = new Base64Variant(new byte[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }); byte[] bytes = b64variant.getBinaryValue(b64variant); assertEquals(0, bytes.length); }
@Test public void test_invalidBase64() throws IOException { final byte[] bytes = new byte[] { (byte) 0x7f, (byte) 0x7f }; Base64Variant b64variant = new Base64Variant(bytes); _expectedEx.expect(IOException.class); _expectedEx.expectMessage("Base64 data must be non-negative"); b64variant.getBinaryValue(b64variant); }
@Test public void test_getBinaryValue_invalidBase64Char() throws IOException { Base64Variant b64variant = new Base64Variant(new byte[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
@Test public void testBase64DecodeEOF() throws IOException { Base64Variant v = new Base64Variant(new byte[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
@Test public void testBase64EOF() throws IOException { Base64Variant b64variant = new Base64Variant(new byte[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }); byte[] bytes = b64variant.getBinaryValue(b64variant); assertEquals(0, bytes.length); }
@Test public void test_getBinaryValue_invalidData() throws IOException { Base64Variant b64variant = new Base64Variant(new byte[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }); try { b64variant.getBinaryValue(b64variant); fail(); } catch (IOException expected) { } }
@Test public void test_invalidBase64() throws IOException { Base64Variant b64variant = new Base64Variant(); b64variant.setBase64Char('a'); try { b64variant.getBinaryValue(b64variant); fail("Expected exception not thrown"); } catch (IOException e) { } }
@Test public void test_getBinaryValue_invalidBase64Char() throws IOException { Base64Variant b64variant = new Base64Variant(new byte[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
@Test public void test_getBinaryValue_invalidData() throws IOException { Base64Variant testInput = new Base64Variant(new byte[] { 0x01, 0x02, 0x03 }); try { testInput.getBinaryValue(testInput); fail("Expected IOException"); } catch (IOException e) { assertEquals(e.getMessage(), "Invalid Base64 data"); } }
@Test public void testBase64EOF() throws IOException { Base64Variant b64variant = new Base64Variant(new byte[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }); byte[] bytes = b64variant.getBinaryValue(b64variant); assertEquals(0, bytes.length); }
@Test public void testMalformedBase64() throws IOException { Base64Variant variant = new Base64Variant(); byte[] bytes = new byte[] {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16}; variant.encodeBase64String(bytes); try { _testDelegate.getBinaryValue(variant); fail("should have thrown an exception"); } catch (IOException e) { } }
@Test public void test_getBinaryValue_invalidData() throws IOException { Base64Variant v = new Base64Variant(new byte[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
@Test public void test_invalidBase64() throws IOException { Base64Variant b64variant = new Base64Variant(new byte[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
@Test public void test_getBinaryValue_invalidData() throws IOException { Base64Variant mockB64variant = mock(Base64Variant.class); when(mockB64variant.decodeBase64Char('F')).thenReturn(-1); when(mockB64variant.decodeBase64Char('G')).thenReturn(-1); assertThrows(IOException.class, () -> _testStream.getBinaryValue(mockB64variant)); }
@Test public void test_getBinaryValue_invalidData() throws IOException { Base64Variant b64variant = new Base64Variant(new byte[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }); try { b64variant.getBinaryValue(b64variant); fail(); } catch (IOException expected) { } }
@Test public void test_invalidBase64() throws IOException { Base64Variant b64variant = new Base64Variant(); b64variant.setBase64Char('a'); try { b64variant.getBinaryValue(b64variant); fail("Expected exception not thrown"); } catch (IOException e) { } }
@Test public void test_getBinaryValue_invalidBase64Char() throws IOException { Base64Variant b64variant = new Base64Variant(new byte[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
@Test public void testBase64Value() throws IOException { byte[] bytes = new byte[] { (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0
@Test public void testBase64EOF() throws IOException { Base64Variant b64variant = new Base64Variant(new byte[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }); byte[] bytes = b64variant.getBinaryValue(b64variant); assertEquals(0, bytes.length); }
@Test public void test_getBinaryValue_invalidData() throws IOException { Base64Variant b64variant = new Base64Variant(new byte[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }); try { b64variant.getBinaryValue(b64variant); fail(); } catch (IOException expected) { } }
@Test public void testBinaryValueMalformed() throws IOException { byte[] bytes = new byte[] { (byte) 0x7f, (byte) 0x7f }; Base64Variant b64variant = new Base64Variant(bytes); _reportBase64EOF(); _reportBase64EOF(); _reportBase64DataLength(); _assertInvalidBase64Content(); b64variant.setValue("FRACTIONARY"); _assertInvalidBase64Content(); }
@Test public void test_getBinaryValue_invalidData() throws IOException { Base64Variant v = new Base64Variant(new byte[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
@Test public void test_invalidBase64() throws IOException { Base64Variant b64variant = new Base64Variant(new byte[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
@Test public void test_getBinaryValue_invalidData() throws IOException { Base64Variant mockBase64Variant = mock(Base64Variant.class); when(mockBase64Variant.decodeBase64Char('0')).thenReturn(0); when(mockBase64Variant.decodeBase64Char('a')).thenReturn(-1); when(mockBase64Variant.decodeBase64Char('b')).thenReturn(-1); assertThrows(IOException.class, () -> _testStream.getBinaryValue(mockBase64Variant)); }
@Test public void test_getBinaryValue_invalidData() throws IOException { Base64Variant testInput = new Base64Variant(new byte[] { 0x01, 0x02, 0x03 }); try { testInput.getBinaryValue(testInput); fail("Expected IOException"); } catch (IOException e) { assertEquals(e.getMessage(), "Invalid Base64 data"); } }
@Test public void testBase64EOF() throws IOException { Base64Variant b64variant = new Base64Variant(new byte[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }); byte[] bytes = b64variant.getBinaryValue(b64variant); assertEquals(0, bytes.length); }
@Test public void testMalformedBase64() throws IOException { Base64Variant variant = new Base64Variant(); byte[] bytes = new byte[] {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16}; variant.encodeBase64String(bytes); try { _testDelegate.getBinaryValue(variant); fail("should have thrown an exception"); } catch (IOException e) { } }
@Test public void test_getBinaryValue_invalidData() throws IOException { Base64Variant v = new Base64Variant(new byte[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }); assertThrows(IOException.class, () -> _testSubject.getBinaryValue(v)); }
@Test public void test_getBinaryValue_invalidData() throws IOException { Base64Variant b64variant = new Base64Variant(new byte[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
@Test public void test_getBinaryValue_invalidData() throws IOException { Base64Variant mockB64variant = mock(Base64Variant.class); when(mockB64variant.decodeBase64Char('F')).thenReturn(-1); when(mockB64variant.decodeBase64Char('G')).thenReturn(-1); assertThrows(IOException.class, () -> _testStream.getBinaryValue(mockB64variant)); }
@Test public void test_getBinaryValue_invalidData() throws IOException { Base64Variant b64variant = new Base64Variant(new byte[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }); try { b64variant.getBinaryValue(b64variant); fail(); } catch (IOException expected) { } }
@Test public void test_invalidBase64() throws IOException { Base64Variant b64variant = new Base64Variant(); b64variant.setBase64Char('a'); try { b64variant.getBinaryValue(b64variant); fail("Expected exception not thrown"); } catch (IOException e) { } }
@Test public void test_getBinaryValue_invalidBase64Char() throws IOException { Base64Variant b64variant = new Base64Variant(new byte[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
@Test public void testBase64Value() throws IOException { byte[] bytes = new byte[] { (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0x80, (byte) 0
@Test public void test_getBinaryValue_invalidData() throws IOException { Base64Variant v = new Base64Variant(new byte[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }); assertThrows(IOException.class, () -> _testSubject.getBinaryValue(v)); }
@Test public void test_getBinaryValue_invalidData() throws IOException { Base64Variant b64variant = new Base64Variant(new byte[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
@Test public void test_getBinaryValue_invalidData() throws IOException { Base64Variant testInput = new Base64Variant(new byte[] { 0x01, 0x02, 0x03 }); try { testInput.getBinaryValue(testInput); fail("Expected IOException"); } catch (IOException e) { assertEquals(e.getMessage(), "Invalid Base64 data"); } }
@Test public void test_getBinaryValue_invalidData() throws IOException { Base64Variant b64variant = new Base64Variant(new byte[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
@Test public void test_invalidBase64() throws IOException { Base64Variant v = new Base64Variant(new byte[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }); try { v.getBinaryValue(v); fail(); } catch (IOException expected) { } }
@Test public void testText() { TextNode textNode = new TextNode("Hello"); textNode.setLength(40); textNode.asText(); textNode.setLength(40); textNode.asText(); textNode.setLength(40); textNode.asText(); textNode.setLength(40); textNode.asText(); }
@Test public void asText() { TextNode textNode = new TextNode("Hello"); textNode.setMode(TextNode.Mode.BASE64); textNode.setText("world"); assertEquals("world", textNode.asText()); textNode.setMode(TextNode.Mode.BASE64); textNode.setText("Hello"); assertEquals("world", textNode.asText()); textNode.setMode(TextNode.Mode.BASE64); textNode.setText("Hello"); assertEquals("world", textNode.asText()); }
@Test public void testEquals() throws IOException { TextNode n1 = new TextNode("Hello"); TextNode n2 = new TextNode("Hello"); assertEquals(n1, n2); assertEquals(n1, n2); }
@Test public void testDeserialize() throws IOException, JsonProcessingException { Mockito.when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); Mockito.when(ctxt.findClass(Mockito.anyString())).thenReturn(Mockito.mock(Class.class)); Mockito.when(ctxt.instantiationException(Mockito.anyString(), Mockito.any(Exception.class))).thenThrow(new InstantiationException()); try { new ClassDeserializer().deserialize(jp, ctxt); fail(); } catch (InstantiationException expected) { } Mockito.verify(ctxt).findClass(Mockito.anyString()); Mockito.verify(ctxt).instantiationException(Mockito.eq(Mockito.eq(Class.class), Mockito.eq(ClassUtil.getRootCause(e)))); }
@Test public void testDeserialization() throws IOException, JsonProcessingException { Mockito.when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); Mockito.when(jp.getText()).thenReturn("class"); Mockito.when(ctxt.findClass("class")).thenReturn(Mockito.mock(Class.class)); Mockito.when(ctxt.instantiationException(Mockito.eq(Mockito.eq(Class.class), Mockito.any(Exception.class))).thenReturn(Mockito.mock(Exception.class)); Mockito.when(ctxt.mappingException(Mockito.eq(Mockito.eq(Class.class), Mockito.eq(JsonToken.VALUE_STRING))).thenReturn(Mockito.mock(Class.class)); Mockito.when(ctxt.mappingException(Mockito.eq(Mockito.eq(Class.class), Mockito.eq(JsonToken.VALUE_STRING))).thenReturn(Mockito.mock(Exception.class)); Mockito.when(ctxt.mappingException(Mockito.eq(Mockito.eq(Class.class), Mockito.eq(JsonToken.VALUE_STRING))).thenReturn(Mockito.mock(Exception.class)); Class<?> clazz = classDeserializer.
@Test public void testDeserialization() throws IOException, JsonProcessingException { class Test { public void test() { } } MockDeserializer mock = new MockDeserializer(); MockDeserializer mock2 = new MockDeserializer(); MockDeserializer mock3 = new MockDeserializer(); JsonParser mockjp = mock.getJsonParser(); mock.setCurrentToken(JsonToken.VALUE_STRING); mock.setToken(JsonToken.VALUE_STRING); mock2.setToken(JsonToken.VALUE_STRING); mock3.setToken(JsonToken.VALUE_STRING); mock.setToken(JsonToken.VALUE_STRING); mock.setToken(JsonToken.VALUE_STRING); mock.setToken(JsonToken.VALUE_STRING); mock.setToken(JsonToken.VALUE_STRING); mock.setToken(JsonToken.VALUE_STRING); mock2.setToken(JsonToken.VALUE_STRING); mock3.setToken(JsonToken.VALUE_STRING); mock.setToken(JsonToken.VALUE_STRING); mock.setToken(JsonToken.VALUE_STRING); mock.setToken(JsonToken.VALUE_STRING); mock.setToken(JsonToken.VALUE_STRING); mock.setToken(JsonToken.VALUE_STRING);
@Test public void testDeserialization() throws IOException, JsonProcessingException { Mockito.when(jp.getText()).thenReturn(".lang.String"); Mockito.when(decctxt.findClass(Mockito.eq("String"))).thenReturn(Mockito.eq(Class.class)); Mockito.when(decctxt.instantiationException(Mockito.eq(Class.class), Mockito.eq(ClassUtil.getRootCause(Exception.class))).thenReturn(Mockito.mock(InstantiationException.class)); Mockito.when(decctxt.mappingException(Mockito.eq(Class.class), Mockito.eq(JsonToken.VALUE_STRING))).thenReturn(Mockito.mock(MappingException.class)); Mockito.when(decctxt.mappingException(Mockito.eq(Class.class), Mockito.eq(JsonToken.VALUE_STRING))).thenReturn(Mockito.mock(MappingException.class)); Mockito.when(decctxt.getMappingException(Mockito.eq(Class.class), Mockito.eq(ClassUtil.getRootCause(Exception.class))).thenReturn(Mockito.mock(MappingException.class)); Mockito.when(decctxt.getMappingException(Mockito.
@Test public void testDeserialization() throws IOException, JsonProcessingException { class Class { } class ClassWithException { } class ClassWithException extends RuntimeException { } class ClassWithException extends RuntimeException { } class ClassWithException extends RuntimeException { } class ClassWithException extends RuntimeException { } class ClassWithException extends RuntimeException { } class ClassWithException extends RuntimeException { } class ClassWithException extends RuntimeException { } class ClassWithException extends RuntimeException { } class ClassWithException extends RuntimeException { } class ClassWithException extends RuntimeException { } class ClassWithException extends RuntimeException { } class ClassWithException extends RuntimeException { } class ClassWithException extends RuntimeException { } class ClassWithException extends RuntimeException { } class ClassWithException extends RuntimeException { } class ClassWithException extends RuntimeException { } class ClassWithException extends RuntimeException { } class ClassWithException extends RuntimeException { } class ClassWithException extends RuntimeException { } class ClassWithException extends RuntimeException { } class ClassWithException extends RuntimeException { } class ClassWithException extends RuntimeException { } class ClassWithException extends RuntimeException { } class ClassWithException extends RuntimeException { } class ClassWithException extends RuntimeException { } class ClassWithException extends
@Test public void testDeserialization() throws IOException, JsonProcessingException { Mockito.when(context.findClass(Mockito.anyString())).thenReturn(Mockito.mock(Class.class)); Mockito.when(context.findClass(Mockito.anyString())).thenReturn(Mockito.mock(Class.class)); Mockito.when(context.mappingException(Mockito.anyString(), Mockito.any(Class.class))).thenThrow(new RuntimeException()); Mockito.when(context.findClass(Mockito.anyString())).thenThrow(new RuntimeException()); Mockito.when(context.mappingException(Mockito.anyString(), Mockito.any(Class.class))).thenThrow(new RuntimeException()); Mockito.when(context.findClass(Mockito.anyString())).thenThrow(new RuntimeException()); Mockito.when(context.mappingException(Mockito.anyString(), Mockito.any(Class.class))).thenThrow(new RuntimeException()); ClassDeserializer deser = new ClassDeserializer(); DeserializationContext ctxt = Mockito.mock(DeserializationContext.class); Mockito.when(ctxt.findClass(Mockito.anyString())).thenReturn(Mockito.mock(Class
@Test public void testPrimitiveArrayBuilder() { try { PrimitiveArrayBuilder<Integer> builder = new PrimitiveArrayBuilder<Integer>(); } catch (Exception e) { Assert.fail(e.getMessage()); } try { PrimitiveArrayBuilder<Integer> builder = new PrimitiveArrayBuilder<Integer>(); } catch (Exception e) { Assert.fail(e.getMessage()); } try { PrimitiveArrayBuilder<Integer> builder = new PrimitiveArrayBuilder<Integer>(); } catch (Exception e) { Assert.fail(e.getMessage()); } try { PrimitiveArrayBuilder<Integer> builder = new PrimitiveArrayBuilder<Integer>(); } catch (Exception e) { Assert.fail(e.getMessage()); } try { PrimitiveArrayBuilder<Integer> builder = new PrimitiveArrayBuilder<Integer>(); } catch (Exception e) { Assert.fail(e.getMessage()); } try { PrimitiveArrayBuilder<Integer> builder = new PrimitiveArrayBuilder<Integer>(); } catch (Exception e) { Assert.fail(e.getMessage()); } try { PrimitiveArrayBuilder<Integer> builder = new PrimitiveArrayBuilder<Integer>(); } catch (Exception e) { Assert.fail(e.getMessage()); } try { PrimitiveArrayBuilder<Integer> builder = new PrimitiveArrayBuilder
@Test public void testResetAndStart() { int expected[] = new int[] {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19}; PrimitiveArrayBuilder<Integer> builder = new PrimitiveArrayBuilder<Integer>(expected); Integer actual[] = builder.resetAndStart(); assertEquals(expected[expected.length], actual[0]); assertEquals(expected[expected.length], actual[1]); assertEquals(expected[expected.length], actual[2]); actual = builder.resetAndStart(); assertEquals(expected[expected.length], actual[0]); assertEquals(expected[expected.length], actual[1]); assertEquals(expected[expected.length], actual[2]); actual = builder.resetAndStart(); assertEquals(expected[expected.length], actual[0]); assertEquals(expected[expected.length], actual[1]); assertEquals(expected[expected.length], actual[2]); actual = builder.resetAndStart(); assertEquals(expected[expected.length], actual[0]); assertEquals(expected[expected.length], actual[1]); assertEquals(expected[expected.length], actual[2]); actual = builder.resetAndStart(); assertEquals(expected[expected.length], actual[0]); assertEquals(expected[expected.length], actual[1]); assertEquals(expected[expected.length], actual[2]); }
@Test public void testResetAndStart() { Node<String> node = new TestNode<String>("abcdefghij"); node.appendCompletedChunk("abcdefghij", 5); node.appendCompletedChunk("abcdefghij", 6); node.resetAndStart(); assertEquals("abcdefghij", node.getData()); assertEquals("abcdefghij", node.getDone()); assertEquals("abcdefghij", node.getBufferHead()); assertEquals("abcdefghij", node.getDone()); assertEquals("abcdefghij", node.getBufferTail()); node.resetAndStart(); assertEquals("abcdefghij", node.getData()); assertEquals("abcdefghij", node.getDone()); assertEquals("abcdefghij", node.getBufferHead()); assertEquals("abcdefghij", node.getDone()); assertEquals("abcdefghij", node.getBufferTail()); node.resetAndStart(); assertEquals("abcdefghij", node.getData()); assertEquals("abcdefghij", node.getDone()); assertEquals("abcdefghij", node.getDone()); assertEquals("abcdefghij", node.getBufferHead()); assertEquals("abcdefghij", node.getDone()); assertEquals("abcdefghij", node.getBufferTail()); node.resetAndStart(); assertEquals("abcdefghij", node.getData()); assertEquals("abcdefghij", node.getDone()); assertEquals
@Test public void testResetAndStart() { Node<Integer> node = new Node<Integer>(null, 0); assertEquals(node.resetAndStart(), null); node.appendCompletedChunk(Integer.valueOf(0), 0); assertEquals(node.resetAndStart(), null); node.appendCompletedChunk(Integer.valueOf(0), 0); assertEquals(node.resetAndStart(), null); node.appendCompletedChunk(Integer.valueOf(0), 0); assertEquals(node.resetAndStart(), null); node.appendCompletedChunk(Integer.valueOf(0), 0); assertEquals(node.resetAndStart(), null); }
@Test public void testCompleteAndClearBuffer() { int lastChunk = 0; int lastChunkEntries = 10; TestNode node = new TestNode(lastChunk, lastChunkEntries); TestNode node2 = new TestNode(lastChunk, lastChunkEntries + 1); assertEquals(node, node.completeAndClearBuffer(lastChunk, lastChunkEntries)); assertEquals(node, node2.appendCompletedChunk(lastChunk, lastChunkEntries)); assertEquals(node, node2.appendCompletedChunk(lastChunk, lastChunkEntries)); try { node.completeAndClearBuffer(lastChunk, lastChunkEntries + 1); fail("Should have thrown IllegalStateException"); } catch (IllegalStateException ise) { } try { node.completeAndClearBuffer(lastChunk, lastChunkEntries); fail("Should have thrown IllegalStateException"); } catch (IllegalStateException ise) { } try { node.completeAndClearBuffer(lastChunk, lastChunkEntries); fail("Should have thrown IllegalStateException"); } catch (IllegalStateException ise) { } try { node.completeAndClearBuffer(lastChunk, lastChunkEntries + 1); fail("Should have thrown IllegalStateException"); } catch (IllegalStateException ise) { } try { node.completeAndClearBuffer(lastChunk
@Test public void testCompleteAndClearBuffer() { int lastChunk = 0; int lastChunkEntries = 10; int totalSize = lastChunk + _bufferedEntryCount; TestNode node = new TestNode(data, totalSize); TestCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteCompleteComplete
@Test public void testCompleteAndClearBuffer() { String[] strings = new String[] { "Hello", "World", "Hello", "World", }; for (String s : strings) { String result = _constructArray(s.length); _testCompleteAndClearBuffer(result, s.length()); } }
@Test public void testCompleteAndClearBuffer() { int lastChunk = 0; int lastChunkEntries = 10; int totalSize = lastChunk + _bufferedEntryCount; try { _empty.completeAndClearBuffer(lastChunk, lastChunkEntries); fail(); } catch (IllegalStateException e) { } try { _empty.completeAndClearBuffer(lastChunk, lastChunkEntries + _bufferedEntryCount); fail(); } catch (IllegalStateException e) { } try { _empty.completeAndClearBuffer(lastChunk, lastChunkEntries + _bufferedEntryCount); fail(); } catch (IllegalStateException e) { } try { _empty.completeAndClearBuffer(lastChunk, lastChunkEntries + _bufferedEntryCount); fail(); } catch (IllegalStateException e) { } try { _empty.completeAndClearBuffer(lastChunk, lastChunkEntries + _bufferedEntryCount); fail(); } catch (IllegalStateException e) { } try { _empty.completeAndClearBuffer(lastChunk, lastChunkEntries + _bufferedEntryCount); fail(); } catch (IllegalStateException e) { } try { _empty.completeAndClearBuffer(lastChunk, lastChunkEntries + _bufferedEntryCount); fail(); } catch (IllegalStateException
@Test public void testCompleteAndClearBuffer() { Node<String> empty = new Node<>("", 0); assertEquals("", empty.completeAndClearBuffer("", 0)); empty.completeAndClearBuffer("", 0); assertEquals("", empty.completeAndClearBuffer("", 0)); empty.completeAndClearBuffer("", 0); assertEquals("", empty.completeAndClearBuffer("", 0)); assertEquals("", empty.completeAndClearBuffer("", 0)); assertEquals("", empty.completeAndClearBuffer("", 0)); assertEquals("", empty.completeAndClearBuffer("", 0)); assertEquals("", empty.completeAndClearBuffer("", 0)); assertEquals("", empty.completeAndClearBuffer("", 0)); assertEquals("", empty.completeAndClearBuffer("", 0)); assertEquals("", empty.completeAndClearBuffer("", 0)); assertEquals("", empty.completeAndClearBuffer("", 0)); assertEquals("", empty.completeAndClearBuffer("", 0)); assertEquals("", empty.completeAndClearBuffer("", 0)); assertEquals("", empty.completeAndClearBuffer("", 0)); assertEquals("", empty.completeAndClearBuffer("", 0)); assertEquals("", empty.completeAndClearBuffer("", 0)); assertEquals("", empty.complete
@Test public void testCompleteAndClearBuffer() { int lastChunk = 0; int lastChunkEntries = 10; byte[] expected = new byte[lastChunk + _bufferedEntryCount]; Arrays.fill(expected, 0, (byte) 0); try { _node.completeAndClearBuffer(lastChunk, lastChunkEntries); fail("Should have thrown IllegalStateException"); } catch (IllegalStateException e) { } }
@Test public void testCompleteAndClearBuffer() { int lastChunk = 0; int lastChunkEntries = 10; _testCompleteAndClearBuffer(lastChunk, lastChunkEntries); }
@Test public void testCompleteAndClearBuffer() { TestNode node = new TestNode("hello"); TestNode empty = new TestNode("hello"); empty.appendCompletedChunk(0, 0); assertEquals("hello", empty.toString()); empty.completeAndClearBuffer(0, 0); assertEquals("hello", empty.toString()); try { empty.completeAndClearBuffer(0, 0); fail("Should throw IllegalStateException"); } catch (IllegalStateException e) { } try { empty.completeAndClearBuffer(0, 0); fail("Should throw IllegalStateException"); } catch (IllegalStateException e) { } try { empty.completeAndClearBuffer(0, 0); fail("Should throw IllegalStateException"); } catch (IllegalStateException e) { } try { empty.completeAndClearBuffer(0, 0); fail("Should throw IllegalStateException"); } catch (IllegalStateException e) { } try { empty.completeAndClearBuffer(0, 0); fail("Should throw IllegalStateException"); } catch (IllegalStateException e) { } }
@Test public void testCompleteAndClearBuffer() { PrimitiveArrayBuilder<Integer> builder = new PrimitiveArrayBuilder<Integer>(); Integer empty = builder.appendCompletedChunk(0, 0); Integer empty2 = builder.appendCompletedChunk(0, 0); builder.completeAndClearBuffer(0, 0); assertEquals(empty, empty2); }
@Test public void testReset() { TestChunkNode node = new TestChunkNode("hello world", 0); node._reset(); assertEquals("hello world", node.getData()); node.assertEmpty(); node.assertEmpty(); node.assertEmpty(); node.assertEmpty(); node.assertEmpty(); node.assertEmpty(); node.assertEmpty(); node.assertEmpty(); node.assertEmpty(); node.assertEmpty(); node.assertEmpty(); node.assertEmpty(); node.assertEmpty(); node.assertEmpty(); node.assertEmpty(); node.assertEmpty(); node.assertEmpty(); node.assertEmpty(); node.assertEmpty(); node.assertEmpty(); node.assertEmpty(); node.assertEmpty(); node.assertEmpty(); node.assertEmpty(); node.assertEmpty(); node.assertEmpty(); node.assertEmpty(); node.assertEmpty(); node.assertEmpty(); node.assertEmpty(); node.assertEmpty(); node.assertEmpty(); node.assertEmpty(); node.assertEmpty(); node.assertEmpty(); node.assertEmpty(); node.assertEmpty(); node.assertEmpty(); node.assertEmpty(); node.assertEmpty(); node.assertEmpty(); node.assertEmpty(); node.assertEmpty(); node.assertEmpty();
@Test public void testBufferTail() { TestNode node = new TestNode("",100); node._reset(); assertEquals(100, node._getBufferHead().getData().length); assertEquals(100, node._getBufferTail().getData().length); node.appendCompletedChunk(new TestChunk("a"), 100); assertEquals(100, node._getBufferHead().getData().length); assertEquals(100, node._getBufferTail().getData().length); assertEquals(100, node._getBufferHead().getData().length); assertEquals(100, node._getBufferTail().getData().length); node.resetAndStart(); assertEquals(100, node._getBufferHead().getData().length); assertEquals(100, node._getBufferTail().getData().length); assertEquals(100, node._getBufferHead().getData().length); assertEquals(100, node._getBufferTail().getData().length); assertEquals(100, node._bufferedEntryCount); node.resetAndStart(); assertEquals(100, node._getBufferHead().getData().length); assertEquals(100, node._getBufferTail().getData().length); assertEquals(100, node._bufferedEntryCount); node.resetAndStart(); assertEquals(100, node._getBufferHead().getData().length); assertEquals(100, node._getBufferTail().getData().length); assertEquals(100, node._bufferedEntryCount); }
@Test public void testReset() { Node<String> tmp = new Node<String>(null, 0); tmp.appendCompletedChunk("a", 0); tmp.appendCompletedChunk("b", 0); tmp.appendCompletedChunk("c", 0); tmp.appendCompletedChunk("d", 0); tmp.reset(); assertEquals("a", tmp.getData()); assertEquals("b", tmp.getCompletedChunk()); assertEquals("c", tmp.getData()); assertEquals("d", tmp.getCompletedChunk()); assertEquals("e", tmp.getData()); assertEquals("b", tmp.getCompletedChunk()); tmp.reset(); assertEquals("a", tmp.getData()); assertEquals("b", tmp.getCompletedChunk()); assertEquals("c", tmp.getData()); assertEquals("d", tmp.getCompletedChunk()); assertEquals("e", tmp.getData()); assertEquals("b", tmp.getCompletedChunk()); assertEquals("c", tmp.getCompletedChunk()); tmp.reset(); assertEquals("a", tmp.getData()); assertEquals("b", tmp.getCompletedChunk()); assertEquals("c", tmp.getCompletedChunk()); assertEquals("d", tmp.getData()); assertEquals("e", tmp.getCompletedChunk()); assertEquals("b", tmp.getCompletedChunk()); assertEquals("c", tmp.
@Test public void testReset() { TestNode node = new TestNode("hello world", 0); node._reset(); assertEquals(0, node._bufferedEntryCount); node.assertEmpty(); node.assertEmpty(); node.assertEmpty(); node.assertEmpty(); node.assertEmpty(); node.assertEmpty(); node.assertEmpty(); node.assertEmpty(); node.assertEmpty(); node.assertEmpty(); node.assertEmpty(); node.assertEmpty(); node.assertEmpty(); node.assertEmpty(); node.assertEmpty(); node.assertEmpty(); node.assertEmpty(); node.assertEmpty(); node.assertEmpty(); node.assertEmpty(); node.assertEmpty(); node.assertEmpty(); node.assertEmpty(); node.assertEmpty(); node.assertEmpty(); node.assertEmpty(); node.assertEmpty(); node.assertEmpty(); node.assertEmpty(); node.assertEmpty(); node.assertEmpty(); node.assertEmpty(); node.assertEmpty(); node.assertEmpty(); node.assertEmpty(); node.assertEmpty(); node.assertEmpty(); node.assertEmpty(); node.assertEmpty(); node.assertEmpty(); node.assertEmpty(); node.assertEmpty(); node.assertEmpty(); node.assertEmpty(); node.assert
@Test public void testContainTypeCount() { assertEquals(2, new [LINE].containTypeCount()); }
@Test public void testContainmentTypeCount() { assertEquals(2, new TestMapLikeType(Map.class).containmentTypeCount()); }
@Test public void testSimpleModule() { new SimpleModule().setName("SimpleModule").setVersion(Version.unknownVersion()).setDeserializers(Deserializers.empty()); new SimpleModule("SimpleModule").setVersion(Version.unknownVersion()).setDeserializers(Deserializers.empty()); new SimpleModule("SimpleModule").setVersion(Version.unknownVersion()).setDeserializers(Deserializers.empty()); }
@Test public void testSimpleModule() { new SimpleModule().setName("SimpleModule-TestSimpleModule"); }
@Test public void testSimpleModule() { new SimpleModule().setVersion(Version.unknownVersion()); }
@Test public void testAddSerializer() { SimpleModule module = new SimpleModule(); module.addSerializer(String.class, new StringJsonSerializer()); module.addSerializer(Integer.class, new IntegerJsonSerializer()); module.addSerializer(Integer.class, new IntegerJsonSerializer()); module.addSerializer(Integer.class, new IntegerJsonSerializer()); }
@Test public void testAddSerializer() { SimpleModule module = new SimpleModule(); module.addSerializer(String.class, new StringJsonSerializer()); module.addSerializer(String.class, new StringJsonSerializer()); module.addSerializer(String.class, new StringJsonSerializer()); module.addSerializer(String.class, new StringJsonSerializer()); }
@Test public void testModule() { SimpleModule module = new SimpleModule(); module.addSerializer(String.class, new StringJsonSerializer()); module.addSerializer(String.class, new StringJsonSerializer()); module.addSerializer(String.class, new StringJsonSerializer()); module.addSerializer(String.class, new StringJsonSerializer()); module.addSerializer(String.class, new StringJsonSerializer()); module.addSerializer(String.class, new StringJsonSerializer()); }
@Test public void testAddSerializer() { SimpleModule module = new SimpleModule(); module.addSerializer(String.class, new StringJsonSerializer()); module.addSerializer(String.class, new StringJsonSerializer()); module.addSerializer(String.class, new StringJsonSerializer()); }
@Test public void testAddSerializer() { SimpleModule module = new SimpleModule(); module.addSerializer(String.class, new StringJsonSerializer()); module.addSerializer(String.class, new StringJsonSerializer()); module.addSerializer(String.class, new StringJsonSerializer()); }
@Test public void testDeserializer() { SimpleModule m = new SimpleModule(); m.addDeserializer(String.class, new StringDeserializer()); m.addDeserializer(Integer.class, new IntegerDeserializer()); m.addDeserializer(String.class, new StringDeserializer()); m.addDeserializer(Integer.class, new IntegerDeserializer()); m.addDeserializer(String.class, new StringDeserializer()); }
@Test public void testDeserializers() { SimpleModule m = new SimpleModule(); m.addDeserializer(String.class, new StringDeserializer()); m.addDeserializer(Integer.class, new IntegerDeserializer()); m.addDeserializer(String.class, new StringDeserializer()); m.addDeserializer(Integer.class, new IntegerDeserializer()); m.addDeserializer(String.class, new StringDeserializer()); SimpleModule m2 = new SimpleModule(); m2.addDeserializer(String.class, new StringDeserializer()); m2.addDeserializer(Integer.class, new StringDeserializer()); m2.addDeserializer(String.class, new StringDeserializer()); m2.addDeserializer(Integer.class, new StringDeserializer()); SimpleModule m3 = new SimpleModule(); m3.addDeserializer(String.class, new StringDeserializer()); m3.addDeserializer(Integer.class, new StringDeserializer()); m3.addDeserializer(String.class, new StringDeserializer()); m3.addDeserializer(Integer.class, new StringDeserializer()); SimpleModule m4 = new SimpleModule(); m4.addDeserializer(String.class, new StringDeserializer()); m4.addDeserializer(Integer.class, new StringDeserializer()); m4.addDeserializer(String.class, new StringDeserializer()); m4.
@Test public void testDeserializer() { SimpleModule module = new SimpleModule(); module.addDeserializer(String.class, new StringDeserializer()); module.addDeserializer(Integer.class, new IntegerDeserializer()); module.addDeserializer(String.class, new IntegerDeserializer()); module.addDeserializer(Integer.class, new IntegerDeserializer()); module.addDeserializer(String.class, new StringDeserializer()); module.addDeserializer(String.class, new StringDeserializer()); module.addDeserializer(String.class, new StringDeserializer()); module.addDeserializer(String.class, new StringDeserializer()); module.addDeserializer(String.class, new StringDeserializer()); module.addDeserializer(String.class, new StringDeserializer()); module.addDeserializer(String.class, new StringDeserializer()); module.addDeserializer(String.class, new StringDeserializer()); module.addDeserializer(String.class, new StringDeserializer()); module.addDeserializer(String.class, new StringDeserializer()); module.addDeserializer(String.class, new StringDeserializer()); module.addDeserializer(String.class, new StringDeserializer()); module.addDeserializer(String.class, new StringDeserializer()); module.addDeserializer(String.class, new StringDeserializer()); module.addDeserializer(
@Test public void testDeserializer() { SimpleModule module = new SimpleModule(); module.addDeserializer(String.class, new StringDeserializer()); module.addDeserializer(Integer.class, new IntegerDeserializer()); module.addDeserializer(String.class, new IntegerDeserializer()); module.addDeserializer(Integer.class, new IntegerDeserializer()); }
@Test public void testDeserializer() throws Exception { SimpleModule module = new SimpleModule(); module.addDeserializer(String.class, new StringDeserializer()); module.addDeserializer(Integer.class, new IntegerDeserializer()); module.addDeserializer(String.class, new StringDeserializer()); module.addDeserializer(Integer.class, new IntegerDeserializer()); module.addDeserializer(String.class, new StringDeserializer()); }
@Test public void testRegisterSubtypes() { new SimpleModule().registerSubtypes(Foo.class, Foo2.class, Foo3.class); }
@Test public void testRegisterSubtypes() { new SimpleModule(Version.create("1.2.3"), null).registerSubtypes(String.class, Double.class); new SimpleModule(Version.create("1.2.3"), null).registerSubtypes(String.class, Double.class); new SimpleModule(Version.create("1.2.3"), null).registerSubtypes(String.class, Double.class); new SimpleModule(Version.create("1.2.3"), Version.create("1.2.3"), null).registerSubtypes(String.class, Double.class); new SimpleModule(Version.create("1.2.3"), Version.create("1.2.3"), null).registerSubtypes(String.class, Double.class); new SimpleModule(Version.create("1.2.3"), Version.create("1.2.3"), null).registerSubtypes(String.class, Double.class); new SimpleModule(Version.create("1.2.3"), Version.create("1.2.3"), null).registerSubtypes(String.class, Double.class); new SimpleModule(Version.create("1.2.3"), Version.create("1.2.3"), null).registerSubtypes(String.class, Double
@Test public void testRegisterSubtypes() { new SimpleModule().registerSubtypes(String.class, String.class, String.class); }
@Test public void testRegisterSubtypes() { new SimpleModule().registerSubtypes(String.class, String.class, String.class); new SimpleModule().registerSubtypes(Integer.class, Integer.class, String.class); new SimpleModule().registerSubtypes(String.class, Integer.class, String.class); new SimpleModule().registerSubtypes(Integer.class, String.class, String.class); new SimpleModule().registerSubtypes(String.class, Integer.class, String.class); new SimpleModule().registerSubtypes(Integer.class, String.class, String.class); new SimpleModule().registerSubtypes(String.class, Integer.class, String.class, String.class); new SimpleModule().registerSubtypes(Integer.class, Integer.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String
@Test public void testRegisterSubtypes() { SimpleModule m = new SimpleModule(); m.registerSubtypes(String.class, Integer.class, Double.class); assertEquals(m.getSubtypes().size(), 2); }
@Test public void testRegisterSubtypes() { SimpleModule m = new SimpleModule(); m.registerSubtypes(String.class, Integer.class, String.class); assertEquals("simple", m.name); assertEquals(2, m.subtypes.size()); assertEquals(String.class, m.subtypes.get(0)); assertEquals(Integer.class, m.subtypes.get(1)); assertEquals(String.class, m.subtypes.get(2)); assertEquals(Integer.class, m.subtypes.get(3)); m.registerSubtypes(String.class, Integer.class, String.class); assertEquals("simple", m.name); assertEquals(2, m.subtypes.size()); assertEquals(String.class, m.subtypes.get(0)); assertEquals(Integer.class, m.subtypes.get(1)); assertEquals(String.class, m.subtypes.get(2)); assertEquals(Integer.class, m.subtypes.get(3)); m.registerSubtypes(String.class, Integer.class, String.class); assertEquals("simple", m.name); assertEquals(2, m.subtypes.size()); assertEquals(String.class, m.subtypes.get(0)); assertEquals(Integer.class,
@Test public void testSetupModule() { MockSetupContext context = new MockSetupContext(); context.addSerializers(mock(Deserializer.class)); context.addDeserializers(mock(Deserializer.class)); context.addDeserializer(mock(Deserializer.class)); context.addDeserializer(mock(Deserializer.class)); context.addDeserializer(mock(Deserializer.class)); context.addDeserializer(mock(Deserializer.class)); assertEquals(context.getSerializers(), mock(Deserializer.class)); }
@Test public void testSetupModule_deserializersAdded() { new Expectations() { { new Deserializers() { @Override public void describeTo(Description description) { description.appendText("Deserializer for deserialization of class " + description.toString()); } }; } }; context.addDeserializers(mockDeserializer); context.setupModule(context); }
@Test public void testRegisterSubtypes() { MockSetupContext context = new MockSetupContext(); context.registerSubtypes(Collections.singletonList(mock(NamedType.class))); context.setupModule(context); }
@Test public void test_narrow() { assertEquals(SimpleType.constructUnsafe(String.class).narrow(String.class), ".lang.String"); assertEquals(SimpleType.constructUnsafe(Integer.class).narrow(Integer.class), ".lang.Integer"); assertEquals(SimpleType.constructUnsafe(String.class).narrow(String.class), ".lang.String"); assertEquals(SimpleType.constructUnsafe(Integer.class).narrow(Integer.class), ".lang.Integer"); assertEquals(SimpleType.constructUnsafe(String.class).narrow(String.class), ".lang.String"); assertEquals(SimpleType.constructUnsafe(Integer.class).narrow(Integer.class), ".lang.Integer"); assertEquals(SimpleType.constructUnsafe(String.class).narrow(String.class), ".lang.String"); assertEquals(SimpleType.constructUnsafe(String.class).narrow(String.class), ".lang.String"); assertEquals(SimpleType.constructUnsafe(String.class).narrow(String.class), ".lang.String"); assertEquals(SimpleType.constructUnsafe(String.class
@Test public void test_narrow() { JavaType type = new SimpleType(Foo.class).withTypeHandler(Object.class).withContentValueHandler(Object.class).withStaticTyping(); assertEquals(type, SimpleType.constructUnsafe(Foo.class).narrow(Foo.class)); }
@Test public void test_withTypeHandler() { JavaType type = new JavaType() { @Override public String[] toTypeString() { return new String[] {"a", "b"}; } @Override public JavaType[] toTypeArray() { return new JavaType[] { JavaType.getArrayType(String.class)}; } }; SimpleType type = type.withTypeHandler(new Object()); JavaType[] typeArray = type.toTypeArray(); assertEquals(typeArray.length, 0); assertEquals(typeArray[0].toString(), "a"); assertEquals(typeArray[1].toString(), "b"); assertEquals(typeArray[2].toString(), "c"); }
@Test public void test_withTypeHandler() { new EqualsTester().addEqualityGroup(SimpleType.constructUnsafe(Foo.class), SimpleType.constructUnsafe(Foo.class).withTypeHandler(new Object()).withTypeHandler(new Object()).withTypeHandler(new Object()).testEquals(); }
@Test public void testBuildCanonicalName() { assertEquals(".util.List", new SimpleType(ArrayList.class).buildCanonicalName()); }
@Test public void testBuildCanonicalName() { String[] typeNames = new String[] {SimpleType.class.getName(), SimpleType.class.getName() }; String[] typeParams = new String[] {SimpleType.class.getName()}; SimpleType narrow = constructUnsafe(SimpleType.class).narrowContentsBy(SimpleType.class); assertEquals("<a,b>", narrow.buildCanonicalName()); }
@Test public void testBuildCanonicalName() { [LINE] class C { public C(String s) { } } assertEquals( "C<", new C(C.class.getName()).buildCanonicalName()); }
@Test public void testBuildCanonicalName() { String[] typeNames = new String[] {String.class.getName(), String.class.getName() }; String[] typeParams = new String[] { "a", "b", "c" }; SimpleType type = constructUnsafe(SimpleType.class).narrow(String.class).narrow(String.class); assertEquals("a/b/c", type.buildCanonicalName()); }
@Test public void testBuildCanonicalName() { assertEquals("foo>", SimpleTypeTest.constructUnsafe(Foo.class).buildCanonicalName()); }
@Test public void containedTypeName() { assertEquals(null, constructUnsafe(Foo.class).containTypeName(0)); assertEquals(null, constructUnsafe(Foo.class).containTypeName(1)); assertEquals(null, constructUnsafe(Foo.class).containTypeName(2)); assertEquals(null, constructUnsafe(Foo.class).containTypeName(3)); assertEquals(null, constructUnsafe(Foo.class).containTypeName(4)); assertEquals(null, constructUnsafe(Foo.class).containTypeName(5)); assertEquals(null, constructUnsafe(Foo.class).containTypeName(6)); assertEquals(null, constructUnsafe(Foo.class).containTypeName(7)); assertEquals(null, constructUnsafe(Foo.class).containTypeName(8)); assertEquals(null, constructUnsafe(Foo.class).containTypeName(9)); assertEquals(null, constructUnsafe(Foo.class).containTypeName(10)); assertEquals(null, constructUnsafe(Foo.class).containTypeName(11)); assertEquals(null, constructUnsafe(Foo.class).containTypeName(22)); assertEquals(null, constructUnsafe(Foo.class).containTypeName(23)); assertEquals(null, constructUnsafe(Foo.class).containTypeName(24)); assertEquals(null, constructUnsafe(Foo.class).containTypeName(26)); assertEquals(null
@Test public void containedTypeName() { String[] types = new String[] { null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null
@Test public void testContainType() { assertEquals(SimpleType.constructUnsafe(Foo.class).containTypeName(0), "Foo"); assertEquals(SimpleType.constructUnsafe(Foo.class).containTypeName(1), "Foo"); assertEquals(null, new GenericType(Foo.class).containTypeName(0)); assertEquals(null, new GenericType(Foo.class).containTypeName(1)); assertEquals(null, new GenericType(Foo.class).containTypeName(2)); assertEquals(null, new GenericType(Foo.class).containTypeName(3)); assertEquals(null, new GenericType(Foo.class).containTypeName(4)); assertEquals(null, new GenericType(Foo.class).containTypeName(5)); assertEquals(null, new GenericType(Foo.class).containTypeName(6)); assertEquals(null, new GenericType(Foo.class).containTypeName(7)); assertEquals(null, new GenericType(Foo.class).containTypeName(8)); assertEquals(null, new GenericType(Foo.class).containTypeName(9)); assertEquals(null, new GenericType(Foo.class).containTypeName(10)); assertEquals(null, new GenericType(Foo.class).containTypeName(11)); assertEquals(null, new GenericType(Foo.class).containTypeName(22));
@Test public void testToString() { assertToString("SimpleType"); }
@Test public void testToString() { assertToString("String"); assertToString(".lang.String"); assertToString(".util.Map"); assertToString(".util.Map<.lang.String,.lang.Integer>"); assertToString(".util.Map<.lang.String,.lang.Integer>", ".util.Map<.lang.String,.lang.Integer>"); assertToString(".util.Map<.lang.String,.lang.Integer>", ".util.Map<.lang.String,.lang.Integer>"); assertToString(".util.Map<.lang.String,.lang.Integer>", ".util.Map<.lang.String,.lang.Integer>", ".util.Map<.lang.String,.lang.Integer>", ".util.Map<.lang.String,.lang.Integer>", ".util.Map<.lang.String,.lang.Integer>", ".util.Map<.lang.String,.lang.Integer>", ".util.Map<
@Test public void testToString() { StringBuilder sb = new StringBuilder(); sb.append("[simple type, class ").append('[]').append(']'); [LINE] new SafeType(sb).toString(); }
@Test public void testToString() { assertEquals("[simple type, class.lang.String]", new SafeStringType(SimpleTypeTest.class.getSimpleName()).toString()); }
@Test public void rawClass() { assertEquals(String.class, rawClass(type("String"))); assertEquals(String.class, rawClass(type(".lang.String"))); assertEquals(String.class, rawClass(type(".lang.String"))); assertEquals(String.class, rawClass(type(".lang.String[]"))); assertEquals(String.class, rawClass(type(".lang.String[]"))); assertEquals(String.class, rawClass(type(".lang.String[]"))); assertEquals(String.class, rawClass(type(".lang.String[]"))); assertEquals(String.class, rawClass(type(".lang.String[]"))); assertEquals(String.class, rawClass(type(".lang.String[]"))); assertEquals(String.class, rawClass(type(".lang.String[]"))); assertEquals(String.class, rawClass(type(".lang.String[]"))); assertEquals(String.class, rawClass(type(".lang.String[]"))); assertEquals(String.class, rawClass(type(".lang.String[]"))); assertEquals(String.class, rawClass(type(".lang.String[]"))); assertEquals(
@Test public void testRawClass() { assertEquals(String.class, TypeFactory. defaultInstance().constructType(String.class).getRawClass()); assertEquals(String.class, TypeFactory.defaultInstance().constructType(String.class).getRawClass()); assertEquals(String.class, TypeFactory.defaultInstance().constructType(String.class).getRawClass()); assertEquals(String.class, TypeFactory.defaultInstance().constructType(String.class).getRawClass()); }
@Test public void testRawClass() { assertEquals(String.class, TypeFactory.defaultType().constructType(String.class).getRawClass()); assertEquals(String.class, TypeFactory.defaultType().constructType(String.class).getRawClass()); assertEquals(String.class, TypeFactory.defaultType().constructType(String.class).getRawClass()); assertEquals(String.class, TypeFactory.defaultType().constructType(String.class).getRawClass()); }
@Test public void testMoreSpecificType() { publ.types.add(JavaTypes.stringType()); publ.types.add(JavaTypes.intType()); JavaType type1 = publ.types.get(JavaTypes.intType()); JavaType type2 = publ.types.get(JavaTypes.intType()); JavaType.util.List<?> list = type1.moreSpecificType(type1, type2); assertEquals(list, type2); }
@Test public void testMoreSpecificType() { JavaType[] types = new JavaType[] {String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class
@Test public void testMoreSpecificType() { JavaType[] types = { null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null
@Test public void testMoreSpecificType() { assertEquals(type1, type1.moreSpecificType(type1, type2)); assertEquals(type1, type2); }
@Test public void testMoreSpecificType() { assertEquals(type1, type1.moreSpecificType(type2, type1)); assertEquals(type1, type2); }
@Test public void testMoreSpecificType() { assertEquals(type1, typeFactory.moreSpecificType(type1, type2)); assertEquals(type1, typeFactory.moreSpecificType(type1, null)); assertEquals(type1, typeFactory.moreSpecificType(null, type2)); assertEquals(type1, typeFactory.moreSpecificType(type1, null)); assertEquals(type1, typeFactory.moreSpecificType(type1, type2)); assertEquals(type1, typeFactory.moreSpecificType(type1, null)); assertEquals(type1, typeFactory.moreSpecificType(type1, type2)); assertEquals(type1, typeFactory.moreSpecificType(type1, type2)); assertEquals(type1, typeFactory.moreSpecificType(type1, type2)); assertEquals(type1, typeFactory.moreSpecificType(type1, type2)); assertEquals(type1, typeFactory.moreSpecificType(type1, type2)); assertEquals(type1, typeFactory.moreSpecificType(type1, type2)); assertEquals(type1, typeFactory.moreSpecificType(type1, null)); assertEquals(type1, typeFactory.moreSpecificType(type1, type2)); }
@Test public void testMoreSpecificType() { assertEquals(type1, typeFactory.moreSpecificType(type1, type2)); assertEquals(type1, typeFactory.moreSpecificType(type1, null)); assertEquals(type1, typeFactory.moreSpecificType(type1, type2)); assertEquals(type1, typeFactory.moreSpecificType(type1, null)); assertEquals(type1, typeFactory.moreSpecificType(type1, type2)); assertEquals(type1, typeFactory.moreSpecificType(type1, null)); assertEquals(type1, typeFactory.moreSpecificType(type1, type2)); assertEquals(type1, typeFactory.moreSpecificType(type1, type2)); assertEquals(type1, typeFactory.moreSpecificType(type1, type2)); }
@Test public void testMoreSpecificType() { assertEquals(".lang.Integer", typeFactory.moreSpecificType(type1, type2)); }
@Test public void testMoreSpecificType() { assertEquals(".lang.Integer", typeFactory.moreSpecificType(type1, type2)); }
@Test public void test_fromParamType() { assertEquals(String.class, constructSimpleType(String.class, new TypeReference<String>() {}).getType()); assertEquals(String.class, constructSimpleType(String.class, new TypeReference<Map<String, String>>() {}).getType()); assertEquals(String.class, constructSimpleType(String.class, new TypeReference<Map<String, String>>() {}).getType()); assertEquals(String.class, constructSimpleType(String.class, new TypeReference<Map<String, String>>() {}).getType()); assertEquals(String.class, constructSimpleType(String.class, new TypeReference<Map<String, String>>() {}).getType()); assertEquals(String.class, constructSimpleType(String.class, new TypeReference<Map<String, String>>() {}).getType()); assertEquals(String.class, constructSimpleType(String.class, new TypeReference<Map<String, String>>() {}).getType()); assertEquals(String.class, constructSimpleType(String.class, new TypeReference<Map<String, String>>() {}).getType()); assertEquals(String.class, constructSimpleType(String.class, new TypeReference
@Test public void testFromParamType() throws Exception { Class<?> map = new Map<String, String>(){}; TypeBindings context = new TypeBindingsImpl(); context.set("map", map); String paramString = "a"; JavaType result = _fromParamType(paramString, context); assertEquals(result.getSimpleType().getName(), "Map"); assertEquals(result.getSimpleType().getSimpleType().getName(), "a"); }
@Test public void testFromParamType() { String mapParam = "Map<String, String> m = new HashMap<String, String>(); m.put("a", "a"); Map<String, String> m2 = new HashMap<String, String>(); m2.put("b", "b"); Map<String, String> m3 = new HashMap<String, String>(); m3.put("c", "c"); Map<String, String> m4 = new HashMap<String, String>(); m4.put("d", "d"); m3.put("e", "e"); m3.put("f", "f"); TypeBindings context = new TypeBindingsImpl(); context.put("mapParam", mapParam); Map<String, String> map = (Map<String, String>) _fromParamType(new ParameterizedType(Map.class, "m", m, m2, m3, m4), context); assertEquals(map, m2); }
@Test public void test_fromParamType() { String mapType = "Map<String, String> m = new HashMap<String, String>(); m.put("a", "a"); Map<String, String> m2 = new HashMap<String, String>(); m2.put("b", "b"); Map<String, String> m3 = new HashMap<String, String>(); m3.put("c", "c"); JavaType type = constructSimpleType(Map.class, "m", "m", "m", "m", "c", "c"); assertEquals(type, MapType.construct(type, "m", "m", "c", "c")); }
@Test public void deserializeTypedFromObject() throws IOException, JsonProcessingException { Mockito.when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); Mockito.when(jp.nextToken()).thenReturn(JsonToken.START_ARRAY); Mockito.when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); Mockito.when(jp.nextToken()).thenReturn(JsonToken.START_ARRAY); Mockito.when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); Object obj = mapper.readValue(new StringReader( "{\"foo\": \"bar\"}"), Object.class); Assert.assertEquals("bar", obj); }
@Test public void deserializeTypedUsingDefaultImpl() throws IOException, JsonProcessingException { Mockito.when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); Mockito.when(jp.nextToken()).thenReturn(JsonToken.START_ARRAY); Mockito.when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); Mockito.when(jp.nextToken()).thenReturn(JsonToken.START_ARRAY); Mockito.when(jp.nextToken()).thenReturn(JsonToken.START_ARRAY); Mockito.when(jp.nextToken()).thenReturn(JsonToken.START_ARRAY); Mockito.when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); Mockito.when(jp.nextToken()).thenReturn(JsonToken.START_ARRAY); Mockito.when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); Mockito.when(jp.nextToken()).thenReturn(JsonToken.START_ARRAY); Mockito.when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); Mockito.when(jp.nextToken()).thenReturn(JsonToken.START_ARRAY); Mockito.when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); Mockito.when(
@Test public void deserializeTypedUsingDefaultImpl() throws IOException, JsonProcessingException { Mockito.when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); Mockito.when(jp.nextToken()).thenReturn(JsonToken.START_ARRAY); Mockito.when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); Mockito.when(jp.nextToken()).thenReturn(JsonToken.START_ARRAY); Mockito.when(jp.nextToken()).thenReturn(JsonToken.START_ARRAY); Mockito.when(jp.nextToken()).thenReturn(JsonToken.START_ARRAY); Mockito.when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); Mockito.when(jp.nextToken()).thenReturn(JsonToken.START_ARRAY); Mockito.when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); Mockito.when(jp.nextToken()).thenReturn(JsonToken.START_ARRAY); Mockito.when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); Mockito.when(jp.nextToken()).thenReturn(JsonToken.START_ARRAY); Mockito.when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); Mockito.when(
@Test public void test_deserializeTypedForId_nullValue() throws Exception { mapper.setType(null); mapper.setId("id"); mapper.setId("id"); mapper.setMapper(new TestMapper()); mapper.setMapper(new TestMapper()); mapper.setMapper(new TestMapper()); mapper.setMapper(new TestMapper()); mapper.setMapper(new TestMapper()); mapper.setMapper(new TestMapper()); mapper.setMapper(new TestMapper()); mapper.setMapper(new TestMapper()); mapper.setMapper(new TestMapper()); mapper.setMapper(new TestMapper()); mapper.setMapper(new TestMapper()); mapper.setMapper(new TestMapper()); mapper.setMapper(new TestMapper()); mapper.setMapper(new TestMapper()); mapper.setMapper(new TestMapper()); mapper.setMapper(new TestMapper()); mapper.setMapper(new TestMapper()); mapper.setMapper(new TestMapper()); mapper.setMapper(new TestMapper()); Object result = test.deserializeTypedForId(mapper, null, null); assertNotNull(result); assertTrue(result instanceof TestMapper); assertEquals("id", ((TestMapper) result).getId()); }
@Test public void test_deserializeTypedForId() throws Exception { JsonParser jp = mock(JsonParser.class); JsonDeserializer<Object> deser = mock(JsonDeserializer.class); DeserializationContext ctxt = mock(DeserializationContext.class); TokenBuffer tb = mock(TokenBuffer.class); when(jp.getText()).thenReturn("typeId"); when(decomp.deserialize(jp, ctxt)).thenReturn(null); mapper.registerType(Object.class, typeId); mapper.registerType(Object.class, typeName); mapper.registerType(String.class, typeName); mapper.registerType(Integer.class, typeName); mapper.registerType(Long.class, typeName); mapper.registerType(Double.class, typeName); mapper.registerType(Float.class, typeName); mapper.registerType(Double.class, typeName); mapper.registerType(BigDecimal.class, typeName); mapper.registerType(Double.class, typeName); mapper.registerType(String.class, typeName); mapper.registerType(String.class, typeName); mapper.registerType(Integer.class, typeName); mapper.registerType(Double.class, typeName); mapper.registerType(BigDecimal.class, typeName); mapper
@Test public void test_deserializeTypedForId() throws Exception { mapper.setType(TestBean.class); mapper.setType("testType"); mapper.setType("testType"); mapper.setType("testType2"); mapper.setType("testType3"); mapper.setType("testType4"); mapper.setType("testType5"); mapper.setType("testType6"); mapper.setType("testType7"); mapper.setType("testType8"); mapper.setType("testType9"); mapper.setType("testType9"); mapper.setType("testType10"); mapper.setType("testType9a"); mapper.setType("testType9b"); mapper.setType("testType9c"); mapper.setType("testType9d"); mapper.setType("testType9e"); mapper.setType("testType9f"); mapper.setType("testType9f0"); mapper.setType("testType9f0f1"); mapper.setType("testType9f0f1"); mapper.setType("testType9f0f2"); mapper.setType("testType9f0f3"); mapper.setType("test
@Test public void test_deserializeTypedForId() throws Exception { mapper.setType(typeId); mapper.set(typeName, typeId); mapper.set(typeName, id); mapper.set(typeName, id); mapper.set(typeName, id); mapper.set(typeName, null); mapper.set(typeName, null); mapper.set(typeName, null); mapper.set(typeName, id); mapper.set(typeName, null); mapper.set(typeName, id); mapper.set(typeName, id); mapper.set(typeName, id); mapper.set(typeName, id); mapper.set(typeName, id); mapper.set(typeName, null); mapper.set(typeName, id); mapper.set(typeName, null); mapper.set(typeName, id); mapper.set(typeName, id); mapper.set(typeName, id); Object result = asType(null); assertEquals(result, id); }
@Test public void should_deserialize_type_using_default_implementation_and_context() throws IOException { final JsonParser jp = mock(JsonParser.class); final DeserializationContext ctxt = mock(DeserializationContext.class); final TokenBuffer tb = mock(TokenBuffer.class); when(jp.getCurrentToken()).thenReturn(JsonToken.START_ARRAY); when(jp.asParser(any(JsonParser.class))).thenReturn(jp); when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); when(jp.asObject()).thenReturn(new Object()); when(tb.asParser(any(JsonParser.class))).thenReturn(jp); when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); when(jp.getCurrentToken()).thenReturn(JsonToken.START_ARRAY); when(tb.asObject()).thenReturn(new Object()); when(ctx.wrongTokenException(jp, JsonToken.FIELD_NAME, "missing property 'foo' that is to contain type id (for class " + baseTypeName() + ")")).thenReturn(new RuntimeException("expected")); try { _
@Test public void should_deserialize_default_implementation_using_default_implementation() throws IOException, JsonProcessingException { { final JsonParser jp = mock(JsonParser.class); final DeserializationContext ctxt = mock(DeserializationContext.class); final TokenBuffer tb = mock(TokenBuffer.class); when(jp.getCurrentToken()).thenReturn(JsonToken.START_ARRAY); when(tb.asParser(jp)).thenReturn(jp); when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); when(jp.getCurrentToken()).thenReturn(JsonToken.START_ARRAY); when(tb.writeEndObject()).thenReturn(jp); when(ctx.wrongTokenException(jp, JsonToken.FIELD_NAME, "missing property 'foo' that is to contain type id (for class " + baseTypeName() + ")")).thenReturn(true); when(ctx.getBaseType()).thenReturn(BaseType.class); when(ctx.getBaseType()).thenReturn(BaseType.class); when(jp.asParser(jp)).thenReturn(jp); when(tb.asParser(jp)).thenReturn(jp); when(tb.nextToken()).thenReturn(JsonToken.START_OBJECT); when
@Test public void should_deserialize_type_using_default_implementation_when_declared_type_is_not_null() throws IOException, JsonProcessingException { Mockito.when(mockjp.getCurrentToken()).thenReturn(JsonToken.START_ARRAY); Mockito.when(mocktb.asParser(Mockito.any(JsonParser.class))).thenReturn(mockParser); Mockito.when(mockParser.nextToken()).thenReturn(JsonToken.START_OBJECT); Mockito.when(mockTypeDeserializer.deserializeIfNatural(Mockito.any(JsonParser.class), Mockito.any(DeserializationContext.class))).thenReturn(null); Object result = _decoratedType.deserializeTypedUsingDefaultImpl(jp, mockContext, mocktb); Mockito.verify(mockParser, Mockito.times(1)).nextToken(); Mockito.verify(mockParser, Mockito.times(1)).writeEndObject(); Mockito.verify(mockTypeDeserializer, Mockito.times(1)).deserializeIfNatural(Mockito.any(JsonParser.class), Mockito.any(DeserializationContext.class)); Mockito.verify(mocktb, Mockito.times(1)).writeEndObject(); Assert.assertEquals(result, "foo");
@Test public void deserializeTypedUsingDefaultImpl() throws IOException, JsonProcessingException { final String str = "{\"foo\": \"bar\"}"; final JsonParser jp = mock(JsonParser.class); when(jp.getCurrentToken()).thenReturn(JsonToken.START_ARRAY); when(jp.asParser(eq(str))).thenReturn(jp); when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); final Object result = _decorated.deserializeTypedUsingDefaultImpl(jp, _ctxt, _tb); assertEquals(result, obj); }
@Test public void test_getSubtypeResolver() { MapperConfigBase<CFG, TestBean> cfg = new MapperConfigBase<CFG, TestBean>(new TestBean("Foo"), new TestPropertyResolver()); SubtypeResolver resolver = cfg.getSubtypeResolver(); assertEquals(resolver, cfg.getSubtypeResolver()); }
@Test public void testCustomSubtypeResolver() { MapperConfigBase<CFG, TestBean> cfg = new MapperConfigBase<CFG, TestBean>(new TestBean("Foo"), new CustomSubtypeResolver()); assertSame(cfg.getSubtypeResolver(), SubtypeResolver.class); assertSame(cfg.getSubtypeResolver(), SubtypeResolver.class); }
@Test public void testClose() throws IOException { JsonToken[] tokens = new JsonToken[0]; JsonToken[] tokens2 = new JsonToken[0]; JsonToken[] tokens3 = new JsonToken[1]; JsonToken[] tokens4 = new JsonToken[1]; JsonToken[] tokens5 = new JsonToken[1]; JsonToken[] tokens6 = new JsonToken[2]; JsonToken[] tokens7 = new JsonToken[3]; JsonToken[] tokens8 = new JsonToken[4]; JsonToken[] tokens9 = new JsonToken[5]; JsonToken[] tokens10 = new JsonToken[6]; JsonToken[] tokens11 = new JsonToken[7]; JsonToken[] tokens12 = new JsonToken[8]; JsonToken[] tokens13 = new JsonToken[9]; JsonToken[] tokens14 = new JsonToken[11]; JsonToken[] tokens15 = new JsonToken[11]; tokens.nextToken(); tokens1.nextToken(); tokens2.nextToken(); tokens3.nextToken(); tokens4.nextToken(); tokens5.nextToken(); tokens6.nextToken(); tokens7.nextToken(); tokens8.nextToken(); tokens9.nextToken(); tokens8.nextToken(); tokens9.nextToken(); tokens8.nextToken(); tokens1.nextToken(); tokens8.nextToken(); tokens1.nextToken(); tokens
@Test public void testClose() throws IOException { JsonTokenBuilder t = new JsonTokenBuilder(); t.append("a"); t.append("b"); t.close(); }
@Test public void writeString() throws IOException { JsonToken[] tokens = new JsonToken[] { JsonToken.VALUE_STRING, JsonToken.VALUE_STRING }; new TokenBuffer(new ObjectCodec()).append(tokens); new JsonTokenBuffer(new ObjectCodec()).append(tokens); new JsonTokenBuffer(null).append(tokens); new JsonTokenBuffer(new ObjectCodec()).append(tokens); new JsonTokenBuffer(new ObjectCodec()).append(tokens); new JsonTokenBuffer(new ObjectCodec()).append(tokens); new JsonTokenBuffer(new ObjectCodec()).append(tokens); }
@Test public void writeString() throws IOException { JsonToken[] tokens = new JsonToken[] { JsonToken.VALUE_STRING, null, JsonToken.NULL }; JsonToken t = new JsonToken("\"foo\""); JsonToken t2 = new JsonToken("\"bar\""); JsonToken t3 = new JsonToken("\"baz\""); JsonToken t4 = new JsonToken("\"foo\""); JsonToken t5 = new JsonToken("\"bar\""); JsonToken t6 = new JsonToken("\"baz\""); JsonToken t7 = new JsonToken("\"foo\""); JsonToken t8 = new JsonToken("\"bar\""); JsonToken t9 = new JsonToken("\"bar\""); JsonToken t10 = new JsonToken("\"foo\""); JsonToken t11 = new JsonToken("\"bar\""); JsonToken t12 = new JsonToken("\"bar\""); JsonToken t13 = new JsonToken("\"bar\""); JsonToken t14 = new JsonToken("\"bar\""); JsonToken t15 = new JsonToken("\"bar\""); JsonToken t16 = new JsonToken("\"bar\""); JsonToken t21 = new JsonToken("\"bar\""); JsonToken
@Test public void _string() throws IOException { JsonToken token = new JsonToken(); _token.writeString("foo"); _token.writeString("bar"); _token.writeString("baz"); _token.writeString("qux"); _token.writeString("qux"); _token.writeString("qux"); _token.writeString("qux"); _token.writeString("qux"); _token.writeString("qux"); _token.writeString("qux"); _token.writeString("qux"); _token.writeString("qux"); _token.writeString("qux"); }
@Test public void testWriteNumber() throws IOException { JsonTokenBuffer t = new JsonTokenBuffer(); t.appendNumber(1); t.appendNumber(2); t.appendNumber(3); assertEquals(t.toString(), "(23,4,5,2,3)"); }
@Test public void _writeNumber() throws IOException { TokenBuffer t = new TokenBuffer(); t.append(_number(0)); t.append(_number(1)); t.append(_number(2)); t.append(_number(3)); assertEquals("0", t.value()); }
@Test public void testWriteNumber() throws IOException { JsonTokenBuffer t = new JsonTokenBuffer(); t.appendNumber(1.0d); t.appendNumber(2.0d); Assert.assertEquals(t.toString(), "\"1.0\""); }
@Test public void _double() throws IOException { TokenBuffer t = new TokenBuffer(); t.append(_double(0.0)); t.append(_double(1.0)); t.append(_double(2.0)); t.append(_double(3.0)); t.append(_double(4.0)); assertEquals("0.0,1.0,2.0", t.toString()); }
@Test public void testEscaping() throws IOException { String json = "{\"a\":1,\"b\":2,\"c\":3}"; TokenBuffer t = new TokenBuffer(new ObjectCodec()); JsonToken t2 = t.firstToken(); t2.append(t2); Assert.assertEquals("1", t.getCodec().getCodec().getCodec().getCodecId()); t = new TokenBuffer(new ObjectCodec()); t2.append(t2); Assert.assertEquals("2", t.getCodec().getCodec().getCodecId()); t = new TokenBuffer(new ObjectCodec()); t2.append(t2); Assert.assertEquals("3", t.getCodec().getCodec().getCodecId()); t = new TokenBuffer(new ObjectCodec()); t2.append(t2); Assert.assertEquals("3", t.getCodec().getCodec().getCodecId()); }
@Test public void testArray() throws IOException { ObjectCodec codec = new JsonCodecFactory().getCodec(); JsonTokenBuilder t = new JsonTokenBuilder(); t.append(new JsonArrayToken(new String[] { "a", "b" }, codec)); t.end(); ObjectCodec oc = codec.getCodec(); Assert.assertEquals(oc.getCodec().encode(new byte[] { 1, 2, 3 })); Assert.assertEquals(oc.getCodec().decode(new byte[] { 1, 2, 3 })); Assert.assertEquals(oc.getCodec().encode(new byte[] { 1, 2, 3 })); Assert.assertEquals(oc.getCodec().decode(new byte[] { 1, 2, 3 })); Assert.assertEquals(oc.getCodec().decode(new byte[] { 1, 2, 3 })); Assert.assertEquals(oc.getCodec().decode(new byte[] { 1, 2, 3 })); Assert.assertEquals(oc.getCodec().decode(new byte[] { 1, 2, 3 })); }
@Test public void testCurlyBracket() { String s = "a b"; assertEquals(s, new TokenBuffer(new ObjectCodec()).getCurrentName()); }
@Test public void testNestedCurlyBraces() { assertEquals("a", new TokenBuffer(new JsonTokenCodec()).getCurrentName()); assertEquals("b", new TokenBuffer(new JsonTokenCodec()).getCurrentName()); assertEquals("c", new TokenBuffer(new JsonTokenCodec()).getCurrentName()); assertEquals("d", new TokenBuffer(new JsonTokenCodec()).getCurrentName()); assertEquals("e", new TokenBuffer(new JsonTokenCodec()).getCurrentName()); assertEquals("f", new TokenBuffer(new JsonTokenCodec()).getCurrentName()); assertEquals("g", new TokenBuffer(new JsonTokenCodec()).getCurrentName()); assertEquals("h", new TokenBuffer(new JsonTokenCodec()).getCurrentName()); assertEquals("i", new TokenBuffer(new JsonTokenCodec()).getCurrentName()); assertEquals("j", new TokenBuffer(new JsonTokenCodec()).getCurrentName()); assertEquals("k", new TokenBuffer(new JsonTokenCodec()).getCurrentName()); assertEquals("m", new TokenBuffer(new JsonTokenCodec()).getCurrentName()); assertEquals("n", new TokenBuffer(new JsonTokenCodec()).getCurrentName()); assertEquals("o", new TokenBuffer(new JsonTokenCodec()).getCurrentName()); assertEquals("n", new TokenBuffer(new JsonTokenCodec()).getCurrentName()); assertEquals("o
@Test public void testOverrideCurrentName() { new JsonReadContext() { { new JsonTokenBuffer(new JsonTokenBuffer(new JsonTokenBuffer(new JsonToken("a")))); new JsonTokenBuffer(new JsonTokenBuffer(new JsonTokenBuffer(new JsonToken("b")))); new JsonTokenBuffer(new JsonTokenBuffer(new JsonToken("c")))); new JsonTokenBuffer(new JsonTokenBuffer(new JsonToken("d")))); new JsonTokenBuffer(new JsonTokenBuffer(new JsonToken("e")))); new JsonTokenBuffer(new JsonTokenBuffer(new JsonToken("f"))); new JsonTokenBuffer(new JsonToken("g"))); new JsonTokenBuffer(new JsonToken("h")); new JsonTokenBuffer(new JsonToken("i")); new JsonTokenBuffer(new JsonToken("j")); new JsonTokenBuffer(new JsonToken("k")); new JsonTokenBuffer(new JsonToken("l")); new JsonTokenBuffer(new JsonToken("o")); new JsonTokenBuffer(new JsonToken("k")); new JsonTokenBuffer(new JsonToken("k")); new JsonTokenBuffer(new JsonToken("o")); new JsonTokenBuffer(new JsonToken("k")); new JsonTokenBuffer
@Test public void testOverrideCurrentName() { JsonReadContext context = new JsonReadContext(); context.setCurrentName("foo"); context.overrideCurrentName("bar"); Assert.assertEquals("foo", context.getCurrentName()); Assert.assertEquals("bar", context.getCurrentName()); context.overrideCurrentName("baz"); Assert.assertEquals("baz", context.getCurrentName()); Assert.assertEquals("baz", context.getCurrentName()); }
@Test public void testOverrideCurrentName() { TokenBuffer t = new TokenBuffer(); t.append(new TokenBuffer(new JsonMarkerMarker("foo"))); assertEquals("foo", t.firstToken().getName()); t.overrideCurrentName("foo"); assertEquals("foo", t.firstToken().getName()); t.overrideCurrentName("foo"); assertEquals("foo", t.firstToken().getName()); t.overrideCurrentName("foo"); assertEquals("foo", t.firstToken().getName()); }
@Test public void testOverrideCurrentName() { JsonReadContext context = new JsonReadContext(); context.setCurrentName("foo"); context.setParent(context); context.setCurrentName("bar"); context.setCurrentName("baz"); context.overrideCurrentName("foo"); Assert.assertEquals("bar", context.getCurrentName()); Assert.assertEquals("baz", context.getCurrentName()); }
@Test public void getText() { JsonParser t = new JsonStringParser("foo"); assertEquals("foo", t.getText()); t = new JsonNumberParser(new BigDecimal("12345")); assertEquals("12345", t.getText()); t = new JsonNumberParser(new Float("12345")); assertEquals("12345", t.getText()); t = new JsonNumberParser(new BigDecimal("12345")); assertEquals("12345", t.getText()); t = new JsonNumberParser(new BigDecimal("12345")); assertEquals("12345", t.getText()); t = new JsonNumberParser(new BigDecimal("12345")); assertEquals("12345", t.getText()); t = new JsonNumberParser(new BigDecimal("12345")); assertEquals("12345", t.getText()); t = new JsonNumberParser(new BigDecimal("12345")); assertEquals("12345", t.getText()); t = new JsonNumberParser(new BigDecimal("12345")); assertEquals("12345", t.getText()); t = new JsonNumberParser(new BigDecimal("12345")); assertEquals("12345", t.getText()); t = new JsonNumberParser(new BigDecimal("12345")); assertEquals("12345", t.getText()); t = new JsonNumberParser(new BigDecimal("12345")); assertEquals("12345", t.
@Test public void testGetText() { assertEquals("foo", _tokenBuffer.getText()); assertEquals("bar", _tokenBuffer.getText()); assertEquals("foo", _tokenBuffer.getText()); assertEquals("bar", _tokenBuffer.getText()); assertEquals("bar", _tokenBuffer.getText()); assertEquals("bar", _tokenBuffer.getText()); assertEquals("bar", _tokenBuffer.getText()); assertEquals("bar", _tokenBuffer.getText()); assertEquals("bar", _tokenBuffer.getText()); assertEquals("bar", _tokenBuffer.getText()); assertEquals("bar", _tokenBuffer.getText()); assertEquals("bar", _tokenBuffer.getText()); assertEquals("bar", _tokenBuffer.getText()); assertEquals("bar", _tokenBuffer.getText()); assertEquals("bar", _tokenBuffer.getText()); assertEquals("bar", _tokenBuffer.getText()); assertEquals("bar", _tokenBuffer.getText()); assertEquals("bar", _tokenBuffer.getText()); assertEquals("bar", _tokenBuffer.getText()); assertEquals("bar", _tokenBuffer.getText()); assertEquals("bar", _tokenBuffer.getText()); assertEquals("bar", _tokenBuffer.getText()); assertEquals("bar", _tokenBuffer.getText()); }
@Test public void getText() { JsonToken token = new JsonToken("foo"); token.setToken(JsonToken.FIELD_NAME, "bar"); token.setToken(JsonToken.VALUE_STRING, "foo"); token.setToken(JsonToken.VALUE_NUMBER_INT, 42); token.setToken(JsonToken.VALUE_FLOAT, 3.14); token.setToken(JsonToken.VALUE_STRING, null); JsonParser parser = new JsonParser(); parser.parse(codec); Assert.assertEquals("foo", parser.getText()); Assert.assertNull(codec.getText()); token = new JsonToken("foo"); token.setToken(JsonToken.VALUE_STRING, "bar"); token.setToken(JsonToken.VALUE_NUMBER_FLOAT, null); parser = new JsonParser(); parser.parse(codec); Assert.assertEquals("bar", parser.getText()); Assert.assertNull(codec.getText()); }
@Test public void getText() { JsonToken token = new JsonToken("foo"); token.nextToken(); token.nextToken(); token.nextToken(); token.nextToken(); token.nextToken(); token.nextToken(); token.nextToken(); token.nextToken(); JsonParser parser = new JsonParser(TokenBuffer.OLS); Assert.assertEquals("foo", parser.getText()); token = new JsonToken("bar"); token.nextToken(); token.nextToken(); token.nextToken(); token.nextToken(); token.nextToken(); token.nextToken(); token.nextToken(); token.nextToken(); token.nextToken(); token.nextToken(); token.nextToken(); token.nextToken(); token.nextToken(); token.nextToken(); token.nextToken(); token.nextToken(); token.nextToken(); token.nextToken(); token.nextToken(); token.nextToken(); token.nextToken(); token.nextToken(); token.nextToken(); token.nextToken(); JsonParser parser2 = new JsonParser(TokenBuffer.OLS); Assert.assertEquals("bar", parser2.getText()); }
@Test public void getText() { JsonToken token = JsonToken.VALUE_STRING; TokenBuffer tokenBuffer = new TokenBuffer(new JsonStringCodec()); tokenBuffer.nextToken(); tokenBuffer.nextToken(); tokenBuffer.nextToken(); tokenBuffer.nextToken(); tokenBuffer.nextToken(); tokenBuffer.nextToken(); tokenBuffer.nextToken(); tokenBuffer.nextToken(); tokenBuffer.nextToken(); tokenBuffer.nextToken(); tokenBuffer.nextToken(); tokenBuffer.nextToken(); tokenBuffer.nextToken(); tokenBuffer.nextToken(); tokenBuffer.nextToken(); tokenBuffer.nextToken(); tokenBuffer.nextToken(); tokenBuffer.nextToken(); tokenBuffer.nextToken(); tokenBuffer.nextToken(); tokenBuffer.nextToken(); tokenBuffer.nextToken(); tokenBuffer.nextToken(); tokenBuffer.nextToken(); tokenBuffer.nextToken(); tokenBuffer.nextToken(); tokenBuffer.nextToken(); tokenBuffer.nextToken(); tokenBuffer.nextToken(); tokenBuffer.nextToken(); tokenBuffer.nextToken(); tokenBuffer.nextToken(); tokenBuffer.nextToken(); tokenBuffer.nextToken(); tokenBuffer.nextToken(); tokenBuffer.nextToken(); tokenBuffer.nextToken(); token
@Test public void getText() { assertEquals("foo", new TokenBuffer(new JsonStringCodec()).getText()); assertEquals("foo", new TokenBuffer(new JsonNumberCodec()).getText()); assertEquals("bar", new TokenBuffer(new JsonNumberCodec()).getText()); assertEquals("foo", new TokenBuffer(new JsonNumberCodec()).getText()); assertEquals("bar", new TokenBuffer(new JsonNumberCodec()).getText()); assertEquals("foo", new TokenBuffer(new JsonNumberCodec()).getText()); assertEquals("bar", new TokenBuffer(new JsonNumberCodec()).getText()); assertEquals("bar", new TokenBuffer(new JsonNumberCodec()).getText()); assertEquals("bar", new TokenBuffer(new JsonNumberCodec()).getText()); assertEquals("bar", new TokenBuffer(new JsonNumberCodec()).getText()); assertEquals("bar", new TokenBuffer(new JsonNumberCodec()).getText()); assertEquals("bar", new TokenBuffer(new JsonNumberCodec()).getText()); assertEquals("bar", new TokenBuffer(new JsonNumberCodec()).getText()); assertEquals("bar", new TokenBuffer(new JsonNumberCodec()).getText()); assertEquals("bar", new TokenBuffer(new JsonNumberCodec()).getText()); assertEquals("bar", new TokenBuffer(new JsonNumberCodec()).getText()); assertEquals("bar", new TokenBuffer(
@Test public void testLineWithOL() throws IOException, JsonParseException { String value = "{\"one\" : true}"; JsonToken token = new JsonToken("\"one\""); token.appendToken(token); JsonParser parser = json.createParser(); parser.parse(value); Assert.assertEquals(1.0, parser.getDoubleValue(), 0.0); }
@Test public void testLineNumbers() throws IOException { String json = "{\"one\":1,\"two\":2,\"three\":3}"; JsonParser parser = Json.createParser(json); assertEquals(1.0, parser.nextToken().doubleValue(), 0.0001); assertEquals(2.0, parser.nextToken().doubleValue(), 0.0001); assertEquals(3.0, parser.nextToken().doubleValue(), 0.0001); }
@Test public void test_narrowBy_typeHandler() { JavaType result = JavaType.of(String.class, "string", Object.class, true); assertEquals(result, JavaType.of(String.class, "string", Object.class, true)); }
@Test public void testIsAbstract() { JavaType type = JavaTypes.newType(String.class, "String", "String", "String", "String", "String", "String", "String", "String", "String", "String", "String", "String", "String", "String", "String", "String", "String", "String", "String", "String", "String", "String", "String", "String", "String", "String", "String", "String", "String", "String", "String", "String", "String", "String", "String", "String", "String", "String", "String", "String", "String", "String", "String", "String", "String", "String", "String", "String", "String", "String", "String", "String", "String", "String", "String", "String", "String", "String", "String", "String", "String", "String", "String", "String", "String", "String", "String", "String", "String", "String", "String", "String", "String", "String", "String", "String", "String", "String
@Test public void testIsAbstract() { assertEquals(true, JavaType.INSTANCE.isAbstract()); assertEquals(false, JavaType.INSTANCE.isAbstract()); assertEquals(false, JavaType.INSTANCE.isAbstract()); }
@Test public void testIsConcrete() { JavaType ts = JavaType.get(String.class); assertTrue(ts.isConcrete()); ts = JavaType.get(Integer.class); assertTrue(ts.isConcrete()); ts = JavaType.get(Double.class); assertTrue(ts.isConcrete()); ts = JavaType.get(Integer.class); assertTrue(ts.isConcrete()); ts = JavaType.get(String.class); assertTrue(ts.isConcrete()); }
@Test public void testIsConcrete() { assertFalse(JavaType.INSTANCE.isConcrete()); }
@Test public void testIsThrowable() { assertFalse(JavaType.Throwable.class.isAssignableFrom(String.class)); assertTrue(JavaType.Throwable.class.isAssignableFrom(Throwable.class)); }
@Test public void testIsThrowable() { assertTrue(Throwable.class.isAssignableFrom(_Ra.class)); assertFalse(Throwable.class.isAssignableFrom(_Ra.class)); }
@Test public void serialize() throws IOException, JsonProcessingException { new EqualsTester().addEqualityGroup(new POJONode(true), new POJONode(true)).addEqualityGroup(new POJONode(false)).testEquals(); new EqualsTester().addEqualityGroup(new POJONode(null)).addEqualityGroup(new POJONode(null)).testEquals(); new EqualsTester().addEqualityGroup(new POJONode(true)).addEqualityGroup(new POJONode(false)).testEquals(); new EqualsTester().addEqualityGroup(new POJONode(true)).addEqualityGroup(new POJONode(false)).testEquals(); new EqualsTester().addEqualityGroup(new POJONode(true)).addEqualityGroup(new POJONode(false)).addEqualityGroup(new POJONode(true)).testEquals(); new EqualsTester().addEqualityGroup(new POJONode(true)).addEqualityGroup(new POJONode(false)).addEqualityGroup(new POJONode(true)).testEquals(); new EqualsTester().addEqualityGroup(new POJONode(true)).add
@Test public void testSerializeNull() throws IOException, JsonProcessingException { new Expectations() { { null.asBoolean(); result = true; } }; JsonGenerator jg = mock(JsonGenerator.class); new Expectations() { { null.asBoolean(true); result = false; } }; new Expectations() { { null.asLong(123); result = 123L; } }; new Expectations() { { null.asDouble(123); result = 123.456; } }; new Expectations() { { null.asBoolean(true); result = false; } }; new Expectations() { { null.asLong(123); result = 123L; } }; new Expectations() { { null.asDouble(123); result = 123.456; } }; new Expectations() { { null.asBoolean(true); result = false; } }; new Expectations() { { null.asLong(123L); result = 123L; } }; new Expectations() { { null.asDouble(123); result = 123.456; } }; new Expectations() { { null.asBoolean(true); result = false; } }; new Expectations() { { { null.asLong
@Test public void serialize() throws IOException, JsonProcessingException { new Expectations() { { [LINE] jg.writeObject(_value); [LINE] } }; }
@Test public void testWithFormat() { DateSerializer serializer = new DateSerializer(); serializer.withFormat(true, new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'")); assertEquals("2011-12-03T10:00:00Z", serializer.toString()); }
@Test public void testWithFormat() { DateSerializer serializer = new DateSerializer(); serializer.withFormat(true, null); serializer.withFormat(false, null); }
@Test public void test_serialization_with_null() throws IOException { DateSerializer instance = new DateSerializer(); instance.withFormat(true, null); }
@Test public void test_serialization_with_null() throws IOException { DateSerializer instance = new DateSerializer(); instance.withFormat(true, null); ByteArrayOutputStream out = new ByteArrayOutputStream(); instance.serialize(new Date(System.currentTimeMillis()), jgen, null); assertEquals(out.toString(), "{\"class\":\"uk.gov.gchq.gaffer.data.DateSerializer\",\"instance\":{\"class\":\"uk.gov.gchq.gaffer.data.DateSerializer\",\"fields\":[{\"type\":\"date\",\"value\":\"2017-01-01T00:00:00Z\"}]}}"); }
@Test public void _timestamp_null() { Date value = null; long timestamp = _timestamp(value); assertEquals(timestamp, 0L); }
@Test public void _timestamp_null() { assertEquals(0, _timestamp(null)); }
@Test public void serialize_timestamp_value() throws IOException, JsonGenerationException { Date value = new Date(); jgen.writeNumber(value.getTime()); jgen.flush(); assertThat(value.getTime(), is(Long.valueOf(value.getTime()))); }
@Test public void serialize_customFormat_should_be_serialized_using_custom_format() throws IOException { DateFormat customFormat = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"); DateSerializer instance = new DateSerializer(true, customFormat); long value = _timestamp(new Date()); instance.serialize(value, jgen, null); jgen.flush(); assertThat(jgen.toString(), is("123_000")); }
@Test public void serialize_customFormat_usesCustomFormat_when_customFormat_is_null() throws IOException, JsonGenerationException { DateFormat customFormat = mock(DateFormat.class); when(customFormat.format(any(Date.class))).thenReturn(null); DateSerializer customFormatSpy = mock(DateSerializer.class); when(customFormatSpy.format(any(Date.class))).thenReturn(null); DateSerializer customFormatSpy2 = mock(DateSerializer.class); when(customFormatSpy2.format(any(Date.class))).thenReturn(null); customFormatSpy.customFormat = customFormat; customFormatSpy2.withFormat(true, customFormat); Date value = new Date(); customFormatSpy.serialize(value, jgen, null); verify(jgen).writeString(null); }
@Test public void testGetInputType() { assertEquals(String.class, new LineNumberConverter().getInputType(typeFactory).getSourceType()); }
@Test public void testGetInputType() { Converter converter = mock(Converter.class); when(typeFactory.findTypeParameters(Converter.class, Converter.class)).thenReturn(new JavaType[]{converter}); assertEquals(JavaType.BOOLEAN, converter.getInputType(typeFactory)); }
@Test public void testGetInputType() { String expected = ".lang.String"; Converter converter = new Converter() { public String convert(Object value) throws Exception { return expected; } }; assertEquals(expected, converter.getInputType(typeFactory)); }
@Test public void testGetInputType() { assertEquals(JavaType.BOOLEAN, converter.getInputType(typeFactory)); }
@Test public void testBaseJsonNode() { String actual = new String(Json.decode(baseJsonNode, StandardCharsets.UTF_8)); Assert.assertEquals(baseJsonNode, actual); actual = new String(Json.decode(baseJsonNode, StandardCharsets.UTF_8)); Assert.assertEquals(baseJsonNode, actual); actual = new String(Json.decode(baseJsonNode, StandardCharsets.UTF_8)); Assert.assertEquals(baseJsonNode, actual); actual = new String(Json.decode(baseJsonNode, StandardCharsets.UTF_8)); Assert.assertEquals(baseJsonNode, actual); actual = new String(Json.decode(baseJsonNode, StandardCharsets.UTF_8)); Assert.assertEquals(baseJsonNode, actual); actual = new String(Json.decode(baseJsonNode, StandardCharsets.UTF_8)); Assert.assertEquals(baseJsonNode, actual); actual = new String(Json.decode(baseJsonNode, StandardCharsets.UTF_8)); Assert.assertEquals(baseJsonNode, actual); }
@Test public void findPath_should_return_the_value_of_the_field_in_the_graph() throws IOException { JsonNode actual = mapper.readTree("{\"foo\":1,\"bar\":2}"); JsonNode expected = mapper.readTree("{\"foo\":1,\"bar\":2}"); assertThat(actual).isEqualTo(expected); }
@Test public void findPath_missing() { Assertions.assertThrows(MissingNode.class, () -> { JsonNode result = mapper.findPath("foo"); Assertions.assertEquals(MissingNode.getInstance(), result); }); }
@Test public void findPath_valueIsNull() { JsonNode actual = mapper.readTree("{\"test\":null}"); Assert.assertNull(actual); actual = mapper.readTree("{\"test\":null}"); Assert.assertNull(actual); actual = mapper.readTree("{\"test\":null}"); Assert.assertNull(actual); actual = mapper.readTree("{\"test\":null}"); Assert.assertNull(actual); }
@Test public void findPath_should_return_the_instance_of_the_field_in_the_file() throws IOException { String fileContent = "foo=bar\n"; final MissingNode instance = MissingNode.getInstance(); assertThat(instance.findPath("foo")).isEqualTo(fileContent); }
@Test public void testUseForType() {.util.List<String> l = new.util.List<String>(); l.add("a"); l.add("b");.util.List<String> c = new.util.List<String>(); c.add("c"); Assert.assertTrue(l.useForType(.util.List.class)); Assert.assertFalse(l.useForType(.util.List.class)); Assert.assertFalse(l.useForType(.util.List.class)); Assert.assertFalse(l.useForType(.util.List.class)); Assert.assertFalse(l.useForType(.util.List.class)); Assert.assertFalse(l.useForType(.util.List.class)); Assert.assertFalse(l.useForType(.util.List.class)); Assert.assertFalse(l.useForType(.util.List.class)); Assert.assertFalse(l.useForType(.util.List.class)); Assert.assertFalse(l.useForType(.util.List.class)); Assert.assertFalse(l.useForType(
@Test public void testVersion() { Version version = mapper.version(); Assert.assertEquals(com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION, version); }
@Test public void testVersion() { Version version = mapper.version(); Assert.assertEquals(Version.VERSION, version); }
@Test public void registerModule() { Module module = new Module() { @Override public String getModuleName() { return "test"; } @Override public Version getMapperVersion() { return Version.of("1.9.0-SNAPSHOT"); } }; ObjectMapper mapper = _mapper.registerModule(module); Assert.assertEquals("1.9.0-SNAPSHOT", mapper.getCodecName()); Assert.assertEquals(ObjectMapper.class, mapper.getTypeFactory()); }
@Test public void testRegisterModule() { Module module = new Module() { @Override public String getModuleName() { return "testModule"; } }; new MockUp<ObjectMapper>() { @Mock public Version getMapperVersion() { return Version.of("1.9.0-SNAPSHOT"); } }; new MockUp<Module>() { @Mock public Version version() { return Version.of("1.9.0-SNAPSHOT"); } }; new MockUp<Module>() { @Mock public Version version() { return Version.of("1.9.0-SNAPSHOT"); } }; new MockUp<Module>() { @Mock public ObjectMapper mapper() { return mapper; } }; new MockUp<ObjectMapper>() { @Mock public Version version() { return Version.of("1.9.0-SNAPSHOT"); } }; new MockUp<Module>() { @Mock public ObjectMapper mapper() { return mapper; } }; new MockUp<Module>() { @Mock public Version version() { return Version.of("1.9.0-SNAPSHOT"); } }; new MockUp<Module>() { @Mock public Version version() { return Version.of("1.9.0-SNAPSHOT"); } }; new MockUp<Module>() { @Mock public Version version() { return Version.of("1.9.0-SNAPSHOT"); } }; new Mock
@Test public void registerModule() { Module module = new Module() { @Override public String getModuleName() { return "testModule"; } @Override public Version getMapperVersion() { return Version.of("1.9.0-SNAPSHOT"); } }; ObjectMapper mapper = new ObjectMapper(); mapper.registerModule(module); Module.SetupContext context = mapper.setupModule(context); context.getMapper().registerModule(module); }
@Test public void registerModule() { Module module = new Module() { @Override public Version version() { return Version.of("1.2.3"); } }; new MockUp<ObjectMapper>() { @Mock public Version getMapperVersion() { return Version.of("1.2.3"); } }; new MockUp<Module>() { @Mock public Version version() { return Version.of("1.2.3"); } }; new MockUp<Module>() { @Mock public Version getMapperVersion() { return Version.of("1.2.3"); } }; new MockUp<Module>() { @Mock public Version version() { return Version.of("1.2.3"); } }; new MockUp<Module>() { @Mock public Version version() { return Version.of("1.2.3"); } }; new MockUp<Module>() { @Mock public Version version() { return Version.of("1.2.3"); } }; new MockUp<Module>() { @Mock public Version version() { return Version.of("1.2.3"); } }; new MockUp<Module>() { @Mock public Version version() { return Version.of("1.2.3"); } }; new MockUp<Module>() { @Mock public Version version() { return Version.of("1.2.3"); } }; new MockUp
@Test public void testRegisterModule() { Module module = new Module() { @Override public String getModuleName() { return "testModule"; } @Override public Version getMapperVersion() { return Version.of("1.9.0-SNAPSHOT"); } }; ObjectMapper mapper = new ObjectMapper(); mapper.registerModule(module); Assert.assertEquals("1.9.0-SNAPSHOT", mapper.getMapperVersion().toString()); }
@Test public void registerModule() { Module module = new Module() { @Override public String getModuleName() { return "testModule"; } @Override public Version getMapperVersion() { return Version.of("1.9.0-SNAPSHOT"); } }; ObjectMapper mapper = new ObjectMapper(); mapper.registerModule(module); Module.SetupContext context = mapper.setupModule(new Module.SetupContext() { @Override public Version getMapperVersion() { return Version.of("1.9.0-SNAPSHOT"); } }); assertEquals("1.9.0-SNAPSHOT", context.getMapperVersion().get()); }
@Test public void testRegisterModule() { Module.SetupContext context = new Module.SetupContext() { @Override public String getModuleName() { return "test"; } }; new MockUp<ObjectMapper>() { @Override public Version getMapperVersion() { return Version.of("1.9.0-SNAPSHOT"); } }; context.registerModule(mapper); ObjectMapper mapper = context.getMapper(); assertEquals("1.9.0-SNAPSHOT", mapper.getCodecName()); assertEquals(ObjectMapper.class, mapper.getCodecTypeFactory()); assertEquals(ObjectMapper.class, mapper.getCodecFactory().getClass()); Module module = new Module() { @Override public String getModuleName() { return "test"; } }; context.registerModule(module); mapper = context.getMapper(); assertEquals("1.9.0-SNAPSHOT", mapper.getCodecName()); assertEquals(ObjectMapper.class, mapper.getCodecTypeFactory().getClass()); assertEquals(ObjectMapper.class, mapper.getCodecFactory().getClass()); }
@Test public void registerModule() { Module module = new Module() { @Override public String getModuleName() { return "testModule"; } @Override public Version getMapperVersion() { return Version.of("1.9.0-SNAPSHOT"); } }; ObjectMapper mapper = new ObjectMapper(); mapper.registerModule(module); Module.SetupContext context = mapper.setupModule(new Module.SetupContext() { @Override public Version getMapperVersion() { return Version.of("1.9.0-SNAPSHOT"); } }); assertEquals("1.9.0-SNAPSHOT", mapper.getOwner().getOwner()); }
@Test public void registerModule() { Module module = new Module() { @Override public String getModuleName() { return "testModule"; } @Override public Version getMapperVersion() { return Version.of("1.9.0-SNAPSHOT"); } }; ObjectMapper mapper = new ObjectMapper(); mapper.registerModule(module); Module.SetupContext context = new Module.SetupContext() { @Override public String getModuleName() { return "testModule"; } @Override public Version getMapperVersion() { return Version.of("1.9.0-SNAPSHOT"); } }; context.registerModule(context); ObjectMapper mapper2 = new ObjectMapper(); mapper2.registerModule(module); assertEquals(mapper, mapper2); }
@Test public void registerModule() { Module module = new Module() { @Override public String getModuleName() { return "testModule"; } @Override public Version getMapperVersion() { return null; } }; new MockUp<ObjectMapper>() { @Override public Module.SetupContext setupModule(new Module.SetupContext() { @Override public String getModuleName() { return "testModule"; } @Override public Version getMapperVersion() { return null; } }); @Override public void mapper(ObjectMapper mapper) { mapper.registerModule(module); } }; ObjectMapper mapper = new ObjectMapper(); mapper.registerModule(module); assertEquals("testModule", mapper.getOwner()); }
@Test public void registerModule() { final DeserializerFactory df = mock(DeserializerFactory.class); when(mapper._deserializationContext._factory.withAdditionalDeserializers(d)).thenReturn(df); final ObjectMapper mapper = new ObjectMapper(); mapper.registerModule(new Module.SetupContext() { @Override public Version getMapperVersion() { return Version.of("1.9"); } @Override public <T> T unwrap(Class<?> c) { throw new UnsupportedOperationException(); } }); assertThat(mapper.registerModule(new Module.SetupContext() { @Override public Version getMapperVersion() { return Version.of("1.9"); } @Override public <T> T unwrap(Class<?> c) { throw new UnsupportedOperationException(); } })); }
@Test public void registerModule() { final ObjectMapper mapper = new ObjectMapper(); mapper.registerModule(new Module.SetupContext() { @Override public Version getMapperVersion() { return Version.of("1.2.x"); } @Override public Version version() { return Version.of("1.2.x"); } }); assertThat(mapper.version(), is(Version.of("1.2.x"))); }
@Test public void registerModule() { Module module = new Module() { @Override public String getModuleName() { return "testModule"; } @Override public Version getMapperVersion() { return null; } }; new MockUp<ObjectMapper>() { @Override public Module.SetupContext setupModule(new Module.SetupContext() { @Override public String getModuleName() { return "testModule"; } @Override public Version getMapperVersion() { return null; } }); @Override public void mapper(ObjectMapper mapper) { mapper.registerModule(module); } }; ObjectMapper mapper = new ObjectMapper(); mapper.registerModule(module); assertEquals("testModule", mapper.getOwner()); }
@Test public void registerModule() { final ObjectMapper mapper = new ObjectMapper(); mapper.registerModule(new Module.SetupContext() { @Override public Version version() { return Version.of("1.9.0-SNAPSHOT"); } @Override public String getModuleName() { return "test"; } @Override public void setupModule(Module.SetupContext context) { } }); mapper.registerModule(new Module.SetupContext() { @Override public Version getMapperVersion() { return Version.of("1.9.0-SNAPSHOT"); } }); final TypeFactory factory = mapper.getTypeFactory(); final DeserializerFactory df = factory.getDeserializerFactory(); assertEquals(df, mapper.registerModule(new Module.SetupContext() { @Override public Version version() { return Version.of("1.9.0-SNAPSHOT"); } @Override public String getOwner() { return "test"; } })); }
@Test public void registerModule() { final ObjectMapper mapper = new ObjectMapper(); mapper.registerModule(new Module.SetupContext() { @Override public Version getMapperVersion() { return Version.of("1.2.x"); } @Override public Version version() { return Version.of("1.2.x"); } }); assertThat(mapper.version(), is(Version.of("1.2.x"))); }
@Test public void registerModule() { Module module = new Module() { @Override public String getModuleName() { return "testModule"; } @Override public Version getMapperVersion() { return null; } }; new MockUp<ObjectMapper>() { @Override public Module.SetupContext setupModule(new Module.SetupContext() { @Override public String getModuleName() { return "testModule"; } @Override public Version getMapperVersion() { return null; } }); @Override public void mapper(ObjectMapper mapper) { mapper.registerModule(module); } }; ObjectMapper mapper = new ObjectMapper(); mapper.registerModule(module); assertEquals("testModule", mapper.getOwner()); }
@Test public void testRegisterModule() { Module module = new Module() { @Override public String getModuleName() { return "testModule"; } @Override public Version getMapperVersion() { return null; } }; ObjectMapper mapper = new ObjectMapper(); mapper.registerModule(module); mapper.registerModule(new Module.SetupContext() { @Override public Version getMapperVersion() { return null; } }); }
@Test public void registerModule() { Module mockModule = mock(Module.class); when(mockModule.getModuleName()).thenReturn("test"); when(mockModule.version()).thenReturn(null); ObjectMapper mapper = new ObjectMapper(); mapper.registerModule(mockModule); verify(mockObjectMapper).registerModule(any(Module.SetupContext.class)); }
@Test public void testSerializeWithProvider() throws IOException { JsonFactory jsonFactory = new JsonFactory(); DefaultSerializerProvider provider = new DefaultSerializerProvider() { @Override public void write(Object obj, OutputStream stream) throws IOException { } }; ObjectMapper mapper = new ObjectMapper(jsonFactory); mapper.setSerializerProvider(provider); String json = mapper.writeValueAsString(new Wrapper(true)); assertEquals("true", json); }
@Test public void testSerializeWithCustomSerializerProvider() throws IOException { TypeSerializerProvider provider = new JsonSerializerProvider() { @Override public void write(Object obj, JsonMapping mapping) throws IOException { String json = mapper.writeValueAsString(obj); } }; DefaultSerializerProvider customProvider = new JsonSerializerProvider() { @Override public void write(Object obj, JsonMapping mapping) throws IOException { String json = mapper.writeValueAsString(obj); } }; DefaultTypeResolverBuilder t = new DefaultTypeResolverBuilder(new DefaultTyping()); t.setSerializerProvider(customProvider); ObjectMapper mapper = new ObjectMapper(mapper); TypeSerializer serializer = mapper.setSerializerProvider(provider); serializer.writeValue(obj, new SimpleImmutableMap<String, Object>()); }
@Test public void testSerializeWithCustomSerializerProvider() throws IOException { String json = "{\n" + " \"type\": \"record\",\n" + " \"name\": \"test\",\n" + " \"fields\": [\n" + " {\n" + " \"name\": \"test\",\n" + " \"type\": \"test\",\n" + " \"fields\": [\n" + " {\n" + " \"name\": \"testTwo\",\n" + " \"type\": \"testTwo\"\n" + " },\n" + " {\n" + " \"name\": \"testThree\",\n" + " \"type\": \"testThree\"\n" + " }\n" + " ]\n" + " }\n" + " ]\n" + "}"; ObjectMapper mapper = new ObjectMapper(); mapper.setSerializerProvider(new DefaultSerializerProvider() { @Override public TypeSerializer<Record> getSerializer(Class<?> type) { return TestTypes.record; } }); mapper.writeValueAsString(json); byte[] bytes = mapper.writeValueAsString(test); Assert.assertArrayEquals(json.getBytes("
@Test public void testCustomSerializerProvider() throws IOException { String json = "{\n" + " \"type\": \"custom\",\n" + " \"defaultProvider\": {\n" + " \"type\": \"custom\",\n" + " \"defaultProvider\": {\n" + " \"type\": \"custom\",\n" + " \"defaultProvider\": {\n" + " \"type\": \"custom\"\n" + " },\n" + " \"defaultProvider\": {\n" + " \"type\": \"custom\",\n" + " \"defaultProvider\": {\n" + " \"type\": \"custom\"\n" + " }\n" + " }\n" + " }\n" + " }\n" + "}"; TypeSerializerProvider sp = _mapper.getSerializerProvider(); Assert.assertEquals(sp.getClass(), CustomSerializerProvider.class); }
@Test public void testCustomSerializerProvider() throws IOException { final ObjectMapper mapper = new ObjectMapper(); final DefaultSerializerProvider provider = mapper.getSerializerProvider(); Assert.assertEquals(DefaultSerializerProvider.class, provider.getClass()); }
@Test public void testSubtypeResolver() { SubtypeResolver subtypeResolver = _mapper.getSubtypeResolver(); Assert.assertEquals(SubtypeResolver.class, subtypeResolver.getClass()); }
@Test public void testSubtypeResolver() { SubtypeResolver subtypeResolver = _mapper.getSubtypeResolver(); Assert.assertEquals(SubtypeResolver.class, subtypeResolver.getClass()); }
@Test public void testRegisterSubtypes() throws Exception { new Expectations() { { new SubtypeResolverBuilder().registerSubtypes(Arrays.asList(MySubType.class, MySubType.class)); } }; }
@Test public void testRegisterSubtypes() throws Exception { new Expectations() { { oneOf(mockTypeResolver).registerSubtypes(Mockito.any(Class[].class)); } }; try { new DefaultTypeResolverBuilder(mockTypeResolver).registerSubtypes(Mockito.any(Class[].class)); fail("Should have thrown IllegalArgumentException"); } catch (IllegalArgumentException e) { } }
@Test public void testRegisterSubtypes() throws Exception { Class<?> c = Foo.class; Collection<Foo> foos = new ArrayList<Foo>(); Foo foo = new Foo(); foo.registerSubtypes(foos); foos.add(bar); Foo bar = new Foo(); bar.registerSubtypes(foos); foos.add(bar); assertEquals(2, foos.size()); Foo foo = foos.iterator().next(); assertEquals(bar, foo.bar); }
@Test public void testRegisterSubtypes() throws Exception { new Expectations() { { oneOf(mockTypeResolver).registerSubtypes(with(any(JavaType.class))); } }; }
@Test public void testConstructType() throws Exception { Type type = new TypeToken<List<String>>() {}.getType(); assertEquals(type, _mapper.constructType(type)); }
@Test public void testConstructType() throws Exception { Type type = new SimpleType(String.class, null, null, null, null); JavaType.util.List<String>.util.List<String>.util.List<String>.util.List<String>.util.List<String>.util.List<String>.util.List<String>.util.List<String>.util.List<String>.util.List<String>.util.List<String>.util.List<String>.util.List<String>.util.List<String>.util.List<String>.util.List<String>.util.List<String>.util.List<String>.util.List<String>.util.List<String>.util.List<String>.util.List<String>.util.List<String>.util.List<String>.util.List<String>.util.List<String>.util.List<String>.util.List<String>.util.List<String>.util.List<String>.util.List<String>.
@Test public void testMapper() throws IOException { JsonFactory jsonFactory = new JsonFactory(); ObjectMapper mapper = jsonFactory.createMapper(); mapper.configure(JsonGenerator.Feature.UNWRAPPER, true); mapper.writeValueAsString(new Wrapper()); mapper.configure(JsonGenerator.Feature.UNWRAPPER, true); mapper.writeValueAsString(new Wrapper()); }
@Test public void testMapper_with_null() throws IOException { JsonFactory f = new JsonFactory(); new ObjectMapper(_mapperFactory).configure(_jsonFactory, false); }
@Test public void testJsonMapper_with_null_type() throws IOException { String json = "{\n" + " \"type\": \"null\",\n" + " \"id\": null\n" + "}"; JsonFactory jf = new JsonFactory(); jf.registerModule(new Module() { @Override public void define(Type type, Class<? extends Annotation> annotations, AnnotationContext context) { } @Override public void define(Type type, Class<? extends Annotation> annotations, AnnotationContext context) { } }); ObjectMapper mapper = new ObjectMapper(jf); mapper.configure(JsonGenerator.Feature.UNWRAPPER, true); mapper.readValue(json, null); }
@Test public void testDisable() { JsonFactory jsonFactory = new JsonFactory(); ObjectMapper jsonMapper = jsonFactory.createMapper(); SerializationConfig serializationConfig = jsonMapper.getSerializationConfig(); serializationConfig.setSerializationConfig(serializationConfig); ObjectMapper mapper = jsonMapper.disable(SerializationFeature.UNWRAP_ROOTS); Assert.assertEquals(mapper.writeValueAsString(new Object()), "{\"class\":\"uk.gov.gchq.gaffer.operation.model.Person\",\"name\":\"John\",\"age\":31}"); }
@Test public void testDisable() { JsonFactory jsonFactory = new JsonFactoryBuilder().build(); DefaultTypeResolver resolver = new DefaultTypeResolverBuilder(new DefaultTyping(ObjectMapper.DEFAULT)); ObjectMapper mapper = jsonFactory.createMapper(); mapper.disable(SerializationFeature.UNWRAP_ROOTS); mapper.enable(SerializationFeature.UNWRAP_ROOTS); mapper.disable(SerializationFeature.WRAP_ROOTS); mapper.disable(SerializationFeature.WRAP_ROOTS); }
@Test public void testDisable() throws IOException { JsonFactory jf = new JsonFactory(); DefaultSerializationConfig serializationConfig = new DefaultSerializationConfig(); serializationConfig.setSerializationConfig(serializationConfig); jf.registerModule(new Module() { @Override public void configure(Binder binder) { binder.bind(Foo.class).toInstance(Foo.class); } }); ObjectMapper mapper = new ObjectMapper(jf); SerializationConfig disable = mapper.getSerializationConfig(); Assert.assertEquals(disable.enabled(Deserializatio.class), true); }
@Test public void testWriteValue() throws IOException, JsonMappingException { StringWriter sw = new StringWriter(); JsonFactory jf = jf.getFactory(); DefaultTypeResolver d = new DefaultTypeResolverBuilder(jf).build(); d.writeValue(jgen, new Object()); jgen.flush(); DefaultTypeResolver d2 = new DefaultTypeResolverBuilder(jf).build(); d2.writeValue(jgen, new Object()); jgen.flush(); DefaultTypeResolver d3 = new DefaultTypeResolverBuilder(jf).build(); d3.writeValue(jgen, new Object()); jgen.flush(); DefaultTypeResolver d4 = new DefaultTypeResolverBuilder(jf).build(); d4.writeValue(jgen, new Object()); jgen.flush(); DefaultTypeResolver d5 = new DefaultTypeResolverBuilder(jf).build(); d5.writeValue(jgen, new Object()); jgen.flush(); DefaultTypeResolver d6 = new DefaultTypeResolverBuilder(jf).build(); d6.writeValue(jgen, new Object()); jgen.flush(); DefaultTypeResolver d7 = new DefaultTypeResolverBuilder(jf).build(); d7.writeValue(jgen, new Object
@Test public void testReadValueWithMap() throws IOException, JsonParseException { TypeReference valueTypeRef = new TypeReference(String.class, "String"); Map<String, String> map = _mapper.readValue(_mapper.writeValueAsString(_map), valueTypeRef); assertEquals("string", map.get("string")); }
@Test public void testReadValueWithReference() throws IOException, JsonParseException { String content = "{\n" + " \"type\": \"test\",\n" + " \"value\": {\n" + " \"foo\": \"bar\",\n" + " \"bar\": \"baz\"\n" + " }\n" + "}"; TypeReference valueTypeRef = new TypeReferenceImpl(Type.class, "test"); _mapper.readValue(content, valueTypeRef); assertEquals("bar", valueTypeRef.value); }
@Test public void testReadValue() throws IOException, JsonParseException { byte[] bytes = "hello world".getBytes(); Map<String, Object> map = _mapper.readValue(bytes, 0, bytes.length, JavaTypes.STRING); assertEquals("hello world", map.get("hello")); }
@Test public void testReadValue() throws IOException, JsonParseException { byte[] bytes = new byte[] { (byte) 0x01, (byte) 0x02, (byte) 0x03, (byte) 0x04, (byte) 0x05, (byte) 0x06, (byte) 0x07, (byte) 0x08, (byte) 0x09, (byte) 0x08, (byte) 0x09, (byte) 0x02, (byte) 0x07, (byte) 0x08, (byte) 0x09, (byte) 0x02, (byte) 0x02, (byte) 0x02, (byte) 0x02, (byte) 0x03, (byte) 0x04, (byte) 0x05, (byte) 0x06, (byte) 0x07, (byte) 0x08, (byte) 0x09, (byte) 0x02, (byte) 0x02, (byte) 0x02, (byte) 0x02, (byte) 0x03, (byte) 0x04, (byte) 0x05, (byte) 0
@Test public void writeValueAsString() throws Exception { Assert.assertEquals("foo", _mapper.writeValueAsString(Foo.class)); }
@Test public void testArray() throws IOException { final ByteArrayOutputStream baos = new ByteArrayOutputStream(); final ObjectWriter writer = mapper.writer(); writer.writeArray(new byte[] { 1, 2, 3, 4, 5 }); writer.close(); final ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray()); final ObjectReader reader = new ObjectReader(bais); final ObjectReader deser = new ObjectReader(bais); final DeserializationContext dc = mock(DeserializationContext.class); when(dc.deserializationContext()).thenReturn(dc); deser.readArray(new byte[] { 1, 2, 3, 4, 5 }, new Class[] { Integer.class, Integer.class }); deser.readArray(new byte[] { 1, 2, 3, 4, 5 }, new Class[] { Integer.class, Integer.class }); verify(dc, times(1)).deserializationContext(); verify(dc, times(1)).deserializationContext(); verify(dc, times(1)).deserializationContext(); verify(dc, times(1)).deserializationContext(); }
@Test public void testSerializeWithArray() throws IOException { final ObjectMapper mapper = new ObjectMapper(); final String json = "{\"a\": 1, \"b\": 2, \"c\": 3}"; final String[] expected = {"a", "b", "c", "d"}; final List<String> list = Arrays.asList(json, "a", "b", "c"); mapper.writeValue(list, expected); final List<String> list2 = Arrays.asList(json, "a", "b", "c"); final List<String> list3 = Arrays.asList(json, "a", "b", "c"); final List<String> list4 = Arrays.asList(json, "a", "b", "c", "d"); final List<String> list5 = Arrays.asList(json, "a", "b", "c", "d", "e"); final List<String> list6 = Arrays.asList(json, "a", "b", "c", "d", "e"); final List<String> list7 = Arrays.asList(json, "a", "b", "c", "d", "e", "f"); final List<String> list8
@Test public void testWriterWithType() throws IOException { final ObjectMapper mapper = new ObjectMapper(); final ObjectWriter writer = mapper.writerWithType(Foo.class); writer.writeObject(Foo.class, new Object[] { new Foo("foo"), new Foo("bar") }); writer.close(); }
@Test public void testWriterWithType() throws IOException { TypeFactory factory = new StandardTypeFactory(); TypeSerializerFactory t = factory.getSerializerFactory(); ObjectWriter writer = new ObjectWriter(writer, null, null); writer.writerWithType(Foo.class); writer.writerWithType(Foo.class); writer.writerWithType(Foo.class); writer.writerWithType(Foo.class); writer.writerWithType(Foo.class); writer.writerWithType(Foo.class); writer.writerWithType(Foo.class); }
@Test public void testInjectableValues() throws IOException { Class<?>[] classes = new Class[] {Foo.class, Foo.class, Foo.class, Foo.class, Foo.class, Foo.class, Foo.class, Foo.class, Foo.class, Foo.class, Foo.class, Foo.class, Foo.class, Foo.class, Foo.class, Foo.class, Foo.class, Foo.class, Foo.class, Foo.class, Foo.class, Foo.class, Foo.class, Foo.class, Foo.class, Foo.class, Foo.class, Foo.class, Foo.class, Foo.class, Foo.class, Foo.class, Foo.class, Foo.class, Foo.class, Foo.class, Foo.class, Foo.class, Foo.class, Foo.class, Foo.class, Foo.class, Foo.class, Foo.class, Foo.class, Foo.class, Foo.class, Foo.class, Foo.class, Foo.class, Foo.class, Foo.class, Foo.class, Foo.class, Foo.class, Foo.class, Foo.class, Foo.class, Foo.
@Test public void test_type_resolve_resolve_resolve_resolve_resolve_type() throws IOException { Class<?> type = new ByteBuddy().subclass(MySubType.class).method(isDeclaredBy(MySubType.class)).intercept(MySubType.INSTANCE).readValue(new StringReader("foo")); assertEquals("foo", type.getDeclaredField("foo").resolve("bar")); assertEquals("bar", type.getDeclaredField("bar").resolve("baz").resolve("qux")); }
@Test public void testInjectableValues() throws IOException { String json = "{\n" + " \"myField\": {\n" + " \"myField\": {\n" + " \"type\": \"myString\",\n" + " \"type\": \"myEnum\",\n" + " \"type\": \"myEnum\"\n" + " }\n" + " }\n" + "}"; JsonReader jsonReader = _mapper.reader(FormatSchema.of(MyEnum.class)); Iterator<MyEnum> myEnums = jsonReader.readValues().iterator(); Assert.assertEquals(myEnums.next(), "myEnum"); Assert.assertEquals(myEnums.next(), "myEnum"); Assert.assertEquals(myEnums.next(), "myEnum"); Assert.assertEquals(myEnums.next(), "myEnum"); Assert.assertEquals(myEnums.next(), "myEnum"); Assert.assertEquals(myEnums.next(), "myEnum"); Assert.assertEquals(myEnums.next(), "myEnum"); Assert.assertEquals(myEnums.next(), "myEnum"); Assert.assertEquals(myEnum
@Test public void testConvertValue() { String json = "{\"a\":1,\"b\":2,\"c\":3}"; JavaType a = new JavaType(String.class); a.setField1(new JavaType(String.class)); a.setField2(new JavaType(Integer.class)); a.setField3(new JavaType(Integer.class)); _mapper.writeValue(a, _typeFactory.constructType(a)); TypeReference<JavaType> b = new TypeReference<JavaType>(String.class); b.setField1(new JavaType(Integer.class)); b.setField2(new JavaType(Integer.class)); _mapper.writeValue(b, _typeFactory.constructType(b)); TypeReference<JavaType> c = new TypeReference<JavaType>(String.class); c.setField1(new JavaType(Integer.class)); c.setField2(new JavaType(Integer.class)); c.setField3(new JavaType(Integer.class)); _mapper.writeValue(c, _typeFactory.constructType(c)); TypeReference<JavaType> d = new TypeReference<JavaType>(String.class); d.setField1(
@Test public void testConvertValue() { JavaType t = new JavaType(String.class); t.setField(new JavaType(String.class)); t.setField(new JavaType(Integer.class)); t.setField(new JavaType(Long.class)); t.setField(new JavaType(Double.class)); t.setField(new JavaType(Float.class)); t.setField(new JavaType(Double.class)); t.setField(new JavaType(Byte.class)); t.setField(new JavaType(Byte.class)); t.setField(new JavaType(Byte.class)); t.setField(new JavaType(Byte.class)); t.setField(new JavaType(Byte.class)); t.setField(new JavaType(Byte.class)); t.setField(new JavaType(Byte.class)); t.setField(new JavaType(Byte.class)); t.setField(new JavaType(Byte.class)); t.setField(new JavaType(Byte.class)); t.setField(new JavaType(Byte.class)); t.setField(new JavaType(Byte.class));
@Test public void testConvertValue() { String s = "{\"a\":1,\"b\":2,\"c\":3}"; assertEquals(s, _mapper.convertValue(null, JavaTypes.STRING)); assertEquals(s, _mapper.convertValue(null, JavaTypes.BIGINT)); assertEquals(s, _mapper.convertValue(null, JavaTypes.STRING)); assertEquals(s, _mapper.convertValue(null, JavaTypes.BIGINT)); assertEquals(s, _mapper.convertValue(null, JavaTypes.STRING)); assertEquals(s, _mapper.convertValue(null, JavaTypes.BIGINT)); assertEquals(s, _mapper.convertValue(null, JavaTypes.BIGINT)); assertEquals(s, _mapper.convertValue(null, JavaTypes.BIGINT)); assertEquals(s, _mapper.convertValue(null, JavaTypes.BIGINT)); assertEquals(s, _mapper.convertValue(null, JavaTypes.BIGINT)); assertEquals(s, _mapper.convertValue(null, JavaTypes.BIGINT)); assertEquals(s, _mapper.convertValue(null, JavaTypes.BIGINT)); assertEquals(s, _mapper.
@Test public void testConvertNullValue() { Assert.assertNull(mapper.convertValue(null, JavaTypes.STRING)); }
@Test public void testConvertStringArrayToInteger() { String[] values = new String[] { "a", "b", "c" }; JavaType[] expected = new JavaType[] { JavaType.INTEGER, JavaType.INTEGER, JavaType.INTEGER, JavaType.INTEGER, JavaType.INTEGER, JavaType.INTEGER, JavaType.INTEGER, JavaType.INTEGER, JavaType.INTEGER, JavaType.INTEGER, JavaType.INTEGER, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null,
@Test public void testConfigAndWriteValue() throws IOException, JsonMappingException { StringWriter sw = new StringWriter(); JsonGenerator jgen = mock(JsonGenerator.class); new ObjectMa()._configAndWriteValue(jgen, new Object()); assertThat(sw.toString()).isEqualTo("{\"foo\":\"bar\"}"); }
@Test public void _configAndWriteValue_Closeable() throws IOException, JsonGenerationException, JsonMappingException { Closeable closeable = mock(Closeable.class); JsonGenerator jgen = mock(JsonGenerator.class); new DefaultTypeResolverBuilder(mock(DefaultTyping.class)).withCloseable(closeable). _configAndWriteValue(jgen, mock(Closeable.class)); verify(jgen).close(); }
@Test public void test_verifySchemaType_noSchema() { _mapper.verifySchemaType(null); }
@Test public void testVerifySchemaType() { new Expectations() { { _jsonFactory.canUseSchema(null); result = true; } }; _mapper.verifySchemaType(null); try { _mapper.verifySchemaType(new FormatSchema(null, null)); fail("Expected IllegalArgumentException"); } catch (IllegalArgumentException e) { } }
@Test public void testCanUseSchema() { new Expectations() { { _jsonFactory.canUseSchema(null); result = true; } }; _verifySchemaType(new FormatSchema(null, null, null)); try { _jsonFactory.canUseSchema(new FormatSchema(null, null, null)); fail(); } catch (IllegalArgumentException e) { } }
@Test public void testCanInstantiate() { new EqualsTester().addEqualityGroup(JavaType.BOOLEAN, Boolean.FALSE).addEqualityGroup(JavaType.BOOLEAN, Boolean.TRUE).testEquals(); new EqualsTester().addEqualityGroup(JavaType.BOOLEAN, Boolean.FALSE).testEquals(); new EqualsTester().addEqualityGroup(JavaType.BOOLEAN, Boolean.FALSE).testEquals(); new EqualsTester().addEqualityGroup(JavaType.BOOLEAN, Boolean.TRUE).testEquals(); new EqualsTester().addEqualityGroup(JavaType.BOOLEAN, Boolean.FALSE).testEquals(); new EqualsTester().addEqualityGroup(JavaType.BOOLEAN, Boolean.TRUE).testEquals(); new EqualsTester().addEqualityGroup(JavaType.BOOLEAN, Boolean.FALSE).testEquals(); new EqualsTester().addEqualityGroup(JavaType.BOOLEAN, Boolean.TRUE).testEquals(); new EqualsTester().addEqualityGroup(JavaType.BOOLEAN, Boolean.FALSE).testEquals(); new EqualsTester().addEqualityGroup(JavaType.BOOLEAN, Boolean.TRUE).testEquals(); new EqualsTester().addEqualityGroup(JavaType
@Test public void testCanInstantiate() { new MockUp<Boolean>() { @Mock public boolean canInstantiate() { return true; } }; new MockUp<Object>() { @Mock public boolean canInstantiate() { return false; } }; new MockUp<Object>() { @Mock public boolean canInstantiate() { return true; } }; new MockUp<Object>() { @Mock public boolean canInstantiate() { return false; } }; new MockUp<Object>() { @Mock public boolean canInstantiate() { return false; } }; new MockUp<Object>() { @Mock public boolean canInstantiate() { return false; } }; new MockUp<Boolean>() { @Mock public boolean canInstantiate() { return false; } }; new MockUp<Object>() { @Mock public boolean canInstantiate() { return false; } }; new MockUp<Object>() { @Mock public boolean canInstantiate() { return false; } }; new MockUp<Object>() { @Mock public boolean canInstantiate() { return false; } }; new MockUp<Object>() { @Mock public boolean canInstantiate() { return false; } }; new MockUp<Object>() { @Mock public boolean canInstantiate
@Test public void getTrue() { BooleanNode actual = BooleanNode.getTrue(); BooleanNode expected = BooleanNode.getTrue(); Assert.assertEquals(expected, actual); }
@Test public void testValueOf() { BooleanNode TRUE=BooleanNode.valueOf(true); BooleanNode FALSE=BooleanNode.valueOf(false); BooleanNode[] actual = BooleanNode.valueOf(true); BooleanNode[] expected = {BooleanNode.TRUE, BooleanNode.FALSE}; assertArrayEquals(expected, actual); }
@Test public void testGetNodeType() { BooleanNode TRUE=BooleanNode.getTrue(); BooleanNode FALSE=BooleanNode.getFalse(); assertEquals(TRUE, TRUE.asToken()); assertEquals(FALSE, FALSE.asToken()); }
@Test public void testGetNodeType() { BooleanNode TRUE=BooleanNode.getTrue(); BooleanNode FALSE=BooleanNode.getFalse(); assertEquals(TRUE, TRUE.getNodeType()); assertEquals(FALSE, FALSE.getNodeType()); }
@Test public void booleanValue() { BooleanNode TRUE=BooleanNode.getTrue(); BooleanNode FALSE=BooleanNode.getFalse(); assertEquals(TRUE, FALSE.asBoolean()); assertEquals(FALSE, TRUE.asBoolean()); }
@Test public void booleanValue() { BooleanNode TRUE=BooleanNode.getTrue(); BooleanNode FALSE=BooleanNode.getFalse(); assertEquals(TRUE, FALSE.asBoolean()); assertEquals(FALSE, TRUE.asBoolean()); }
@Test public void testAsText() { BooleanNode TRUE=BooleanNode.getTrue(); BooleanNode FALSE=BooleanNode.getFalse(); assertEquals("true", TRUE.asText()); assertEquals("false", FALSE.asText()); }
@Test public void asText() { BooleanNode TRUE=BooleanNode.getTrue(); BooleanNode FALSE=BooleanNode.getFalse(); assertEquals("true", TRUE.asText()); assertEquals("false", FALSE.asText()); }
@Test public void testEquals() { BooleanNode TRUE=BooleanNode.getTrue(); BooleanNode FALSE=BooleanNode.getFalse(); BooleanNode TRUE=BooleanNode.getFalse(); BooleanNode FALSE=BooleanNode.getTrue(); assertEquals(TRUE, TRUE); assertEquals(FALSE, FALSE); assertEquals(FALSE, FALSE); assertEquals(TRUE, FALSE); assertEquals(FALSE, TRUE); assertNotEquals(TRUE, FALSE); assertNotEquals(FALSE, TRUE); assertNotEquals(FALSE, TRUE); assertNotEquals(FALSE, FALSE); assertNotEquals(TRUE, FALSE); }
@Test public void testEquals() { BooleanNode TRUE=BooleanNode.getTrue(); BooleanNode FALSE=BooleanNode.getFalse(); BooleanNode TRUE2 = BooleanNode.getFalse(); BooleanNode FALSE2 = BooleanNode.getFalse(); assertEquals(TRUE, TRUE); assertEquals(FALSE, FALSE); assertEquals(TRUE, FALSE); assertEquals(FALSE, TRUE2); assertNotEquals(TRUE, FALSE2); assertNotEquals(FALSE, TRUE2); assertNotEquals(FALSE, FALSE); assertNotEquals(FALSE, TRUE); }
@Test public void testTransformer() { NameTransformer chained = new NameTransformer() { @Override public String reverse(String transformed) { return transformed; } }; assertEquals("", chained.transform("")); assertEquals("", chained.reverse("")); assertEquals("", chained.transform("")); assertEquals("", chained.transform("")); assertEquals("", chained.transform("")); assertEquals("", chained.transform("")); assertEquals("", chained.transform("")); assertEquals("", chained.transform("")); assertEquals("", chained.transform("")); assertEquals("", chained.transform("")); assertEquals("", chained.transform("")); assertEquals("", chained.transform("")); assertEquals("", chained.transform("")); assertEquals("", chained.transform("")); assertEquals("", chained.transform("")); assertEquals("", chained.transform("")); assertEquals("", chained.transform("")); assertEquals("", chained.transform("")); assertEquals("", chained.transform("")); assertEquals("", chained.transform("")); assertEquals("", chained.transform("")); assertEquals("", chained.transform("")); assertEquals("", chained.transform("")); assertEquals("", chained.transform("")); assertEquals("", chained.transform("")); assertEquals("", chained.transform("")); assertEquals("", chained.transform("")); assertEquals("", chained.transform("
@Test public void simpleTransformer() { NameTransformer ns = simpleTransformer("prefix", "suffix"); assertEquals("prefix + suffix", ns.transform("prefix").transform("suffix")); }
@Test public void simpleTransformer() { NameTransformer t = new NameTransformer() { @Override public String transform(String name) { return prefix + name + suffix; } }; assertEquals(t.transform("a"), prefix + "a"); assertEquals(t.transform("b"), prefix + "b"); assertEquals(t.transform("c"), prefix + "c"); }
@Test public void simpleTransformer() { NameTransformer ns = [LINE].simpleTransformer("a", "b"); assertEquals("a+b", ns.transform("a")); assertEquals("a+b", ns.transform("a")); assertEquals("a+b", ns.transform("a")); assertEquals("a+b", ns.transform("a+b")); }
@Test public void simpleTransformer() { NameTransformer ns = new NameTransformer() { @Override public String transform(String name) { return prefix + name; } }; assertEquals(prefix + name, ns.transform(prefix + name)); }
@Test public void testAsExternalTypeDeserializer() throws Exception { Class<?> type = getClass(); BeanProperty property = new BeanProperty(); property.setTypeId(".lang.String"); AsExternalTypeDeserializer src = new AsExternalTypeDeserializer(type, idResolver, property); Type type2 = bt.getJavaType().getDeclaredType("String"); assertEquals(".lang.String", type2.getName()); assertEquals(".lang.String", type2.getTypeProperty().getName()); }
@Test public void testAsExternalTypeDeserializer() throws Exception { Class<?> type = new ByteBuddy().subclass(Object.class).method(isDeclaredBy(Object.class)).method(isDeclaredBy(String.class)).method(isDeclaredBy(Object.class)).method(isDeclaredBy(String.class)).method(isDeclaredBy(Integer.class)).method(isDeclaredBy(Long.class)).method(isDeclaredBy(Double.class)).method(isDeclaredBy(Float.class)).method(isDeclaredBy(Double.class)).method(isDeclaredBy(Character.class)).method(isDeclaredBy(Character.class)).method(isDeclaredBy(Character.class)).method(isDeclaredBy(Character.class)).method(isDeclaredBy(String.class)).method(isDeclaredBy(Integer.class)).method(isDeclaredBy(Double.class)).method(isDeclaredBy(String.class)).method(isDeclaredBy(Date.class)).method(isDeclaredBy(Date.class)).method(isDeclaredBy(Date.class)).method(isDeclaredBy
@Test public void testAsExternalTypeDeserializer() throws Exception { Class<?> type = ExternalTypes.constructJavaType("B"); TypeDeserializer deserializer = new AsExternalTypeDeserializer(type, null); BeanProperty property = new BeanProperty("name", "String"); Type type2 = deserializer.forProperty(property); assertEquals(type, type2); }
@Test public void testAsExternalTypeDeserializer() throws Exception { Class<?> type = ExternalTypes.StringType; AsExternalTypeDeserializerDeserializerDeserializer deserializer = new AsExternalTypeDeserializerDeserializer(type, null, false, String.class); assertEquals(".lang.String", deserializer.forProperty(BeanProperty.create("name", String.class))); }
@Test public void testForProperty() { TypeDeserializer dt = bt.forProperty(new BeanProperty(DummyBean.class.getDeclaredField("prop"))); assertEquals(DummyBean.class, dt.getType()); }
@Test public void testForProperty() { TypeDeserializer src = new AsExternalTypeDeserializer( bt, idResolver, "type", false, Object.class); AsExternalTypeDeserializer src2 = new AsExternalTypeDeserializer( bt, idResolver, "type", false, Object.class); assertEquals(DeserializerType.class, src2.getBeanType()); }
@Test public void testNestedAsExternalTypeDeserializer() throws Exception { Class<?> type = getClass(); BeanProperty beanProperty = new BeanProperty(type, "bar", Boolean.class); AsExternalTypeDeserializer src = new AsExternalTypeDeserializer(type, beanProperty); TypeDeserializer typeDeserializer = src.forProperty(beanProperty); assertEquals(Boolean.class, typeDeserializer.getTypeType()); }
@Test public void test_getTypeInclusion() { Class<?> type = getClass().getClassLoader().getResource( "org/apache/qpid/adapter/JdkTypeResolver.asExternalType"); As typeInclusion = new AsExternalTypeDeserializer(type, idResolver, ".lang.String", false, String.class); assertEquals(As.EXTERNAL_PROPERTY, typeInclusion.getTypeInclusion()); }
@Test public void test() throws Exception { Class<?> ct = classLoader.loadClass(TestBean.class.getName()); AsTypeDeserializer src = new AsExternalTypeDeserializer(ct, null, As.EXTERNAL_PROPERTY, false, ct.getClass()); AsTypeDeserializer dst = new AsExternalTypeDeserializer(src, dst); assertEquals(As.EXTERNAL_PROPERTY, dst.getTypeInclusion()); }
@Test public void _parseBooleanPrimitive() throws IOException, JsonProcessingException { JsonParser jp = mock(JsonParser.class); when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_TRUE); when(jp.getText()).thenReturn("true"); when(jp.getNumberType()).thenReturn(NumberType.INT); when(jp.getIntValue()).thenReturn(0); Boolean result = _converter. _parseBooleanPrimitive(jp, ctxt); assertTrue(result); }
@Test public void testParseBooleanPrimitive() throws IOException, JsonProcessingException { MockJsonParser jp = new MockJsonParser("\"true\""); jp.setCurrentToken(JsonToken.VALUE_TRUE); assertFalse(_parseBooleanPrimitive(jp, null)); jp.setCurrentToken(JsonToken.VALUE_NULL); assertFalse(_parseBooleanPrimitive(jp, null)); jp.setCurrentToken(JsonToken.VALUE_NUMBER_INT); assertTrue(_parseBooleanPrimitive(jp, null)); jp.setCurrentToken(JsonToken.VALUE_NUMBER_INT); assertTrue(_parseBooleanPrimitive(jp, null)); jp.setCurrentToken(JsonToken.VALUE_NUMBER_INT); assertFalse(_parseBooleanPrimitive(jp, null)); }
@Test public void testParseShort() throws IOException, JsonProcessingException { new TestCase() { @Override public String getText() { return "23"; } @Override public int nextToken() { return 2; } @Override public boolean nextToken() { return jp.nextToken() == JsonToken.VALUE_STRING || jp.isToken(JsonToken.VALUE_STRING); } }.run(); }
@Test public void testParseShort() throws IOException, JsonProcessingException { new Mock(JsonToken.VALUE_STRING).setToken(JsonToken.VALUE_STRING); new Mock(JsonToken.VALUE_NUMBER_INT).setToken(JsonToken.VALUE_NUMBER_FLOAT); new Mock(JsonToken.VALUE_NUMBER_DOUBLE).setToken(JsonToken.VALUE_FLOAT); new Mock(JsonParser.class).setToken(JsonToken.VALUE_NUMBER_INT); new Mock(JsonToken.VALUE_NUMBER_FLOAT).setToken(JsonToken.VALUE_NUMBER_DOUBLE); new Mock(JsonToken.VALUE_STRING).setToken(JsonToken.VALUE_STRING); new Mock(JsonParser.class).setToken(JsonToken.VALUE_NUMBER_INT); new Mock(JsonToken.VALUE_NUMBER_FLOAT).setToken(JsonToken.VALUE_NUMBER_DOUBLE); new Mock(JsonToken.VALUE_STRING).setToken(JsonToken.VALUE_STRING); new Mock(JsonParser.class).setToken(JsonToken.VALUE_STRING); new Mock(JsonToken.VALUE_STRING).setToken(JsonToken.VALUE_NUMBER_INT); new Mock(JsonToken.VALUE
@Test public void testParseShort_MIN_MAX() throws IOException, JsonProcessingException { new Expectations() { { jp.getCurrentToken(); result = JsonToken.VALUE_NUMBER_INT; jp.getShortValue(); result = 1; } }; Assert.assertEquals(Short.MIN_VALUE, _parseShort(_parser, ctxt)); }
@Test public void testParseShortMin() throws IOException, JsonProcessingException { new Mock(JsonToken.VALUE_MIN_VALUE).assertEquals(Short.MIN_VALUE, _parser.parseShort(new JsonParser(), null)); new Mock(JsonToken.VALUE_MAX_VALUE).assertEquals(Short.MAX_VALUE, _parser.parseShort(new JsonParser(), null)); new Mock(JsonToken.VALUE_STRING).assertEquals("", _parser.parseShort(new JsonParser(), null)); new Mock(JsonToken.VALUE_NUMBER_INT).assertEquals(Short.MIN_VALUE, _parser.parseShort(new JsonParser(), null)); new Mock(JsonToken.VALUE_NUMBER_FLOAT).assertEquals(Short.MAX_VALUE, _parser.parseShort(new JsonParser(), null)); new Mock(JsonToken.VALUE_STRING).assertEquals("", _parser.parseShort(new JsonParser(), null)); new Mock(JsonToken.VALUE_STRING_MIN_VALUE).assertEquals("", _parser.parseShort(new JsonParser(), null)); new Mock(JsonToken.VALUE_STRING_MAX_VALUE).assertEquals("", _parser.parseShort(new Json
@Test public void testParseShortPrimitive() throws Exception { MockDeserializer mockDeserializer = new MockDeserializer(Short.MIN_VALUE); DeserializationContext mockContext = mockDeserializer.createMockContext(); mockDeserializer.setExpectedValue(Short.MIN_VALUE); mockDeserializer.setExpectedValue(Short.MAX_VALUE); try { new MockDeserializer(Short.MAX_VALUE).deserializeWithType(jp, mockContext, mockDeserializer); fail("should have failed"); } catch (IOException ioe) { } try { new MockDeserializer(Short.MIN_VALUE).deserializeWithType(jp, mockContext, mockDeserializer); fail("should have failed"); } catch (IOException ioe) { } }
@Test public void testParseLong() throws IOException, JsonProcessingException { new MockDeserializer<Long>() { @Override protected Long _parseLong(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { return Long.valueOf(jp.getCurrentToken().getText()); } }.handle(null); long value = new MockDeserializer<Long>() { @Override protected Long _parseLong(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { return Long.valueOf(jp.getCurrentToken().getText()); } }.handle(null); assertEquals(Long.valueOf(Long.MAX_VALUE), value); }
@Test public void testParseLong() throws JsonProcessingException { JsonParser jp = mock(JsonParser.class); when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); when(jp.getLongValue()).thenReturn(1L); when(jp.getText()).thenReturn("1.0"); Long value = _parseLong(jp, null); assertEquals(1L, value); }
@Test public void testParseLongPrimitive() throws IOException, JsonProcessingException { JsonParser jp = mock(JsonParser.class); when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); when(jp.getLongValue()).thenReturn(1L); DeserializationContext ctxt = mock(DeserializationContext.class); when(ctxt.mappingException(eq(String.class), eq(Long.class), eq("not a valid long value"))).thenReturn(new IOException()); long result = _parseLongPrimitive(jp, ctxt); assertEquals(1L, result); }
@Test public void testParseLongPrimitive() throws IOException, JsonProcessingException { JsonParser jp = mock(JsonParser.class); when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); when(jp.getLongValue()).thenReturn(1L); when(jp.getText()).thenReturn("1.0"); DeserializationContext ctxt = mock(DeserializationContext.class); when(ctxt.getMappingException(eq(String.class), eq(Long.class), eq(JsonToken.VALUE_NULL))).thenThrow(new IllegalArgumentException()); long result = deserializer._parseLongPrimitive(jp, ctxt); assertEquals(1L, result); }
@Test public void testParseLongPrimitive() throws IOException, JsonProcessingException { JsonParser jp = mock(JsonParser.class); when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); when(jp.getLongValue()).thenReturn(1L); when(jp.getText()).thenReturn("1.0"); DeserializationContext ctxt = mock(DeserializationContext.class); when(ctxt.mappingException(eq(String.class), eq(JsonToken.VALUE_NUMBER_INT))).thenReturn(null); long result = _parseLongPrimitive(jp, ctxt); assertEquals(1L, result); }
@Test public void testParseLongPrimitive() throws IOException, JsonProcessingException { Mockito.when(jp.getLongValue()).thenReturn(123L); Mockito.when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); Mockito.when(jp.getText()).thenReturn("123"); long result = StdDeserializer.INSTANCE.parseLongPrimitive(jp, ctxt); Assert.assertEquals(123L, result); Mockito.verify(ctxt).weirdStringException(Mockito.eq("123"), Mockito.eq(Mockito.eq(Mockito.class))); }
@Test public void testParseFloat() throws IOException, JsonProcessingException { Mockito.when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); Mockito.when(jp.getFloatValue()).thenReturn(0.1f); Mockito.when(jp.getText()).thenReturn("1.0"); Mockito.when(mapper.getType(JsonToken.VALUE_STRING)).thenReturn(JsonType.FLOAT); Assert.assertEquals(1.0f, _parseFloat(jp, null)); Mockito.verify(jp, Mockito.times(1)).getCurrentToken(); Mockito.verify(jp, Mockito.times(1)).getFloatValue(); }
@Test public void testParseFloat() throws IOException, JsonProcessingException { final JsonParser jp = mock(JsonParser.class); when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); when(jp.getText()).thenReturn("1.0"); when(jp.getNumber()).thenReturn(1.0f); final float result = _parseFloat(jp, null); assertEquals(result, 1.0f, 0.0f); }
@Test public void testParseFloat() throws IOException, JsonProcessingException { Mockito.when(jp.getText()).thenReturn("NaN"); Mockito.when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); Mockito.when(jp.getFloatValue()).thenReturn(Float.NaN); Mockito.when(jp.getText()).thenReturn("Infinity"); Assert.assertEquals(Float.POSITIVE_INFINITY, _parseFloat(_jp, null)); Mockito.when(jp.getText()).thenReturn("NaN"); Assert.assertEquals(Float.NaN, _parseFloat(_jp, null)); Mockito.when(jp.getText()).thenReturn("Infinity"); Assert.assertEquals(Float.POSITIVE_INFINITY, _parseFloat(_jp, null)); Mockito.when(jp.getText()).thenReturn("Infinity"); Assert.assertEquals(Float.NaN, _parseFloat(_jp, null)); Mockito.when(jp.getText()).thenReturn("Infinity"); Assert.assertEquals(Float.POSITIVE_INFINITY, _parseFloat(_jp, null)); Mockito.when(jp.getText()).thenReturn("Infinity"); Assert.assertEquals(Float.NaN, _parseFloat(_jp, null)); }
@Test public void testParseFloat() throws IOException, JsonProcessingException { Mockito.when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); Mockito.when(jp.getText()).thenReturn("NaN"); Mockito.when(jp.getNumber()).thenReturn(Float.NaN); Assert.assertEquals(Float.NaN, _parseFloat(_jp, null)); Mockito.verify(jp, Mockito.times(1)).getCurrentToken(); Mockito.verify(jp, Mockito.times(1)).getText(); Mockito.verify(jp, Mockito.times(1)).getNumber(); }
@Test public void _parseDoublePrimitive() throws IOException, JsonProcessingException { JsonParser jp = mock(JsonParser.class); when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NULL); when(jp.getText()).thenReturn(" "); double result = objectUnderTest.._parseDoublePrimitive(jp, null); assertEquals(Double.POSITIVE_INFINITY, result, 0.0); }
@Test public void testParseDoublePrimitive() throws IOException, JsonProcessingException { Mockito.when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); Mockito.when(jp.getDoubleValue()).thenReturn(0.0); Mockito.when(jp.getText()).thenReturn("I"); Mockito.when(jp.getToken()).thenReturn(JsonToken.VALUE_STRING); Mockito.when(jp.getText()).thenReturn("NaN"); Assert.assertEquals(-0.0, _parseDoublePrimitive(_jp, null), 0.0); Mockito.when(jp.getText()).thenReturn("NaN"); Assert.assertEquals(Double.NaN, _parseDoublePrimitive(_jp, null), 0.0); Mockito.when(jp.getText()).thenReturn("Infinity"); Assert.assertEquals(Double.POSITIVE_INFINITY, _parseDoublePrimitive(_jp, null), 0.0); Mockito.when(jp.getText()).thenReturn("INF"); Assert.assertEquals(Double.POSITIVE_INFINITY, _parseDoublePrimitive(_jp, null), 0.0); Mockito.when(jp.getText()).thenReturn("NaN"); Assert.assertEquals(Double.NaN, _parseDoublePrimitive(_jp, null), 0.0); }
@Test public void should_report_unknown_property_if_unknown_property_is_not_found() throws Exception { new Expectations() {{ ctxt.reportUnknownProperty(null, null, this); }}; JsonParser jp = mock(JsonParser.class); DeserializationContext ctxt = mock(DeserializationContext.class); new MockUp<JsonParser>() { @Mock void handleUnknownProperty(JsonParser jp, DeserializationContext ctxt, Object instance, String propName) throws IOException, JsonProcessingException { jp.skipChildren(); } }; new MockUp<JsonDeserializer>() { @Mock void handleUnknownProperty(JsonParser jp, DeserializationContext ctxt, Object instance, String propName) throws IOException, JsonProcessingException { jp.skipChildren(); } }; mock.verify(ctxt).handleUnknownProperty(jp, this, null, this); }
@Test public void testSkipUnknownProperty() throws Exception { new Expectations() { { jp.skipChildren(); } }; }
@Test public void testIterableSerializer() throws Exception { TypeSerializer vts = new TypeSerializerFactoryImpl(); TypeSerializer container = new TypeSerializerFactoryImpl(); container.setTypeSerializer(vts); ContainerSerializer<?> containerSerializer = new ContainerSerializer<>(Container.class, false, vts, null); containerSerializer.serializeContents(new ArrayList<>(), jgen, new DefaultSerializerProvider()); jgen.flush(); Type type = container.getType(); assertEquals(JavaType.getTypeName(String.class), type); }
@Test public void testIterableSerializer() throws Exception { TypeSerializer vts = new TypeSerializerImpl(); BeanProperty property = new BeanProperty(); IterableSerializer serializer = new IterableSerializer(JavaType.get(Iterable.class), false, vts, property); serializer.serializeContents(Arrays.asList(Arrays.asList("a", "b", "c"), Arrays.asList("d", "e", "f")), jgen, null); jgen.flush(); Type type = new TypeToken<Iterable<String>>() {}.getType(); assertEquals(type, iterable.getType()); assertEquals(Arrays.asList("a", "b", "c"), iterable.getValues()); }
@Test public void testIterableSerializer() throws Exception { TypeSerializer vts = new DefaultTypeSerializer(BasicType.INSTANCE); BeanProperty property = new BeanProperty("name", "name"); IterableSerializer serializer = new IterableSerializer(BasicType.INSTANCE, property, vts, null); List<String> list = Arrays.asList("a", "b", "c"); serializer.serializeContents(list, jgen, null); jgen.flush(); TypeSerializer actual = mapper.getTypeSerializer(BasicType.INSTANCE).deserialize(list); Assert.assertEquals(BasicType.INSTANCE, actual); }
@Test public void testIterableSerializer() throws Exception { TypeSerializer vts = new DefaultTypeSerializer(BasicType.INSTANCE); BeanProperty property = new BeanProperty("name", "name"); IterableSerializer serializer = new IterableSerializer(BasicType.INSTANCE, false, vts, null); serializer.serializeContents(Collections.singletonList("a"), jgen, null); jgen.flush(); TypeSerializer actual = mapper.readValue(sw.toString(), TypeSerializer.class); Assert.assertEquals(BasicType.INSTANCE, actual); }
@Test public void should_serialize_iterable_withResolved_type_serializer() throws Exception { TypeSerializer vts = new DefaultTypeSerializer(Generators.newDefault()); BeanProperty property = new BeanProperty("a", new TypeSerializerImpl()); IterableSerializer serializer = new IterableSerializer(JavaType.INT, false, vts, null); serializer.withResolved(property, vts, null); JsonSerializer<?> elementSerializer = new JsonSerializerFactory().createObjectSerializer(); serializeAndDeserialize(serializer, elementSerializer); }
@Test public void serializeIterableWithResolved() throws Exception { BeanProperty property = new BeanProperty("a", Lists.newArrayList(1, 2, 3)); IterableSerializer src = new IterableSerializer(JavaType.INTEGER, false, vts, jsonSerializer); BeanSerializer b = new BeanSerializer(JavaType.INTEGER, false, vts, jsonSerializer); src.withResolved(property, vts, b); assertEquals("{\"a\":[1, 2, 3]}", toString(src)); }
@Test public void testAnyGetterWriter() throws Exception { BeanProperty property = new BeanProperty(); AnnotatedMember member = mock(AnnotatedMember.class); MapSerializer serializer = mock(MapSerializer.class); AnyGetterWriter writer = new AnyGetterWriter(property, member, serializer); writer.getAnyGetterWriter(property, member, serializer); }
@Test public void testAnyGetterWriter() throws Exception { BeanProperty property = new BeanProperty(); AnnotatedMember member = mock(AnnotatedMember.class); MapSerializer serializer = mock(MapSerializer.class); AnyGetterWriter writer = new AnyGetterWriter(property, member, serializer); writer.getAndSerialize(bean, jgen, provider); verify(member, times(1)).get(); }
@Test public void testAnyGetterWriter() throws Exception { BeanProperty property = new BeanProperty(); AnnotatedMember member = mock(AnnotatedMember.class); MapSerializer serializer = mock(MapSerializer.class); AnyGetterWriter writer = new AnyGetterWriter(property, member, serializer); writer.getAndSerialize(new Object(), jgen, null); verify(member, times(1)).get(); }
@Test public void testAnyGetterWriter() throws Exception { BeanProperty property = new BeanProperty(); AnnotatedMember member = mock(AnnotatedMember.class); MapSerializer serializer = mock(MapSerializer.class); AnyGetterWriter writer = new AnyGetterWriter(property, member, serializer); writer.getAndSerialize(new Object(), jgen, null); verify(member, times(1)).get(); }
@Test public void testGetAndSerialize() throws Exception { BeanProperty bean = new BeanProperty(); bean.property = new BeanProperty("a"); bean.getAndSerialize(bean, _jgen, _provider); verify(bean).property(); }
@Test public void testGetAndSerialize() throws Exception { AnnotatedMember member = mock(AnnotatedMember.class); BeanProperty bean = mock(BeanProperty.class); when(bean.getMember()).thenReturn(member); AnyGetterWriter anyGetterWriter = new AnyGetterWriter(property, member, _serializer); when(property.getName()).thenReturn("any-getter"); when(member.getValue(bean)).thenReturn(null); AnyGetterWriter anyGetterWriter2 = new AnyGetterWriter(property, member, _serializer2); when(property.getName()).thenReturn("any-getter2"); when(member.getValue(bean)).thenReturn(new Object()); AnyGetterWriter anyGetterWriter3 = new AnyGetterWriter(property, member, _serializer3); when(property.getName()).thenReturn("any-getter3"); when(member.getValue(bean)).thenReturn(new Object()); AnyGetterWriter anyGetterWriter4 = new AnyGetterWriter(property, member, _serializer4); when(property.getName()).thenReturn("any-getter4"); when(member.getValue(bean)).thenReturn(new Object()); AnyGetterWriter anyGetterWriter5 = new AnyGetterWriter(property, member, _serializer5); when(property.getName()).thenReturn("any
@Test public void testGetAndSerialize() throws Exception { BeanProperty property = mock(BeanProperty.class); AnnotatedMember member = mock(AnnotatedMember.class); when(property.getAccessor()).thenReturn(member); AnyGetterWriter anyGetterWriter = new AnyGetterWriter(property, member, _serializer); Object bean = new Object(); anyGetterWriter.getAndSerialize(bean, _generator, _provider); verify(property).getAccessor(); verify(member).getValue(bean); verify(serializer).serializeFields(bean, _generator, _provider); }
@Test public void testGetAndSerialize() throws Exception { AnnotatedMember member = mock(AnnotatedMember.class); BeanProperty bean = mock(BeanProperty.class); when(bean.getGetter()).thenReturn(member); AnyGetterWriter writer = new AnyGetterWriter(bean, null, _serializer); writer.getAndSerialize(bean, _generator, _provider); verify(bean).getGetter(); }
@Test public void serializeMap() throws Exception { BeanProperty bean = new BeanProperty(); bean.property = new BeanProperty("name", "value"); bean.getter = new AnyGetterWriter(bean.property, null, _serializer); _writer.serializeFields(bean, _generator, _provider); verify(bean.getter).getValue(bean); }
@Test public void should_resolve_the_map_serializer() throws Exception { BeanProperty property = new BeanProperty(); property.setId("id"); property.setPrimitiveProperty(true); AnyGetterWriter writer = new AnyGetterWriter(property, null, null); writer.resolve(provider); assertThat(writer.getMap().get("id"), is("id")); }
@Test public void resolve() throws Exception { BeanProperty property = new BeanProperty(); property.setId("id"); AnyGetterWriter writer = new AnyGetterWriter(property, accessor, _serializer); writer.resolve(null); writer.getAndSerialize(bean, jgen, _provider); jgen.flush(); assertThat(writer.getValues(), containsInAnyOrder(id("id"))); }
@Test public void testNumericNode() { JsonParser parser = JsonParser.getInstance(); NumericNode nod = (NumericNode) parser.parse("{\"number\":1,\"numberType\":2,\"double\":3,\"double\":4}", JsonNodeType.instance); Assert.assertEquals(1, nod.numberValue()); Assert.assertEquals(2, nod.numberValue()); Assert.assertEquals(3, nod.numberValue()); Assert.assertEquals(4, nod.numberValue()); Assert.assertEquals(4, nod.numberValue()); Assert.assertEquals(6, nod.numberValue()); Assert.assertEquals(7, nod.numberValue()); }
@Test public void testInclude() { SerializationConfig config = new SerializationConfig(base("src/test/resources/Foo.class")); SerializationConfig expect = new SerializationConfig(base("src/test/resources/Foo.class"), new JsonInclude.Include(IncludeType.INCLUDE)); expect.with(ClassIntrospector.INTERFACE).andReturn(Foo.class); expect.with(ClassIntrospector.INTERFACE).andReturn(Foo.class); expect.with(ClassIntrospector.INTERFACE).andReturn(Foo.class); expect.with(ClassIntrospector.INTERFACE).andReturn(Foo.class); expect.with(ClassIntrospector.INTERFACE).andReturn(Foo.class); expect.with(ClassIntrospector.INTERFACE).andReturn(Foo.class); expect.with(ClassIntrospector.INTERFACE).andReturn(Foo.class); expect.with(ClassIntrospector.INTERFACE).andReturn(Foo.class); expect.with(ClassIntrospector.INTERFACE).andReturn(Foo.class); expect.with(ClassIntrospector.INTERFACE).andReturn(Foo.class); expect.with(ClassIntrospector.INTERFACE).andReturn(Foo.class); expect.with(ClassIntrospector.INTERFACE
@Test public void test_with_int_int_int() { SerializationConfig config = new SerializationConfig( new BaseSettings().withBase(Integer.class).withClassIntrospector(int.class).with(ClassIntrospector.INT).with(ClassIntrospector.INT).with(ClassIntrospector.INT).with(ClassIntrospector.INT).with(ClassIntrospector.INT).with(ClassIntrospector.INT).with(ClassIntrospector.INT).with(ClassIntrospector.INT).with(ClassIntrospector.INT).with(ClassIntrospector.INT).with(ClassIntrospector.INT).with(ClassIntrospector.INT).with(ClassIntrospector.INT).with(ClassIntrospector.INT).with(ClassIntrospector.INT).with(ClassIntrospector.INT).with(ClassIntrospector.INT).with(ClassIntrospector.INT).with(ClassIntrospector.INT).with(ClassIntrospector.INT).with(ClassIntrospector.INT).with(ClassIntrospector.INT).with(ClassIntrospector.INT).with(
@Test public void testWithPropertyNamingStrategy() { SerializationConfig config = new SerializationConfig(base, Ma.json("foo").with(PropertyNamingStrategy.UNIQUE_NAMED)); assertEquals(_base, config.with(PropertyNamingStrategy.UNIQUE_NAMED)); }
@Test public void test_nested_naming_strategy() { SerializationConfig config = new SerializationConfig(base, SubtypeResolver.JSON_PATTERN, Collections.singletonMap("pns", "foo", "bar")); new Expectations() {{ base.withPropertyNamingStrategy(NamingStrategyNamingStrategyNamingStrategyNamingStrategyNamingStrategy.YARD); result = Json.createObject(); result = Json.createObject(); result = Json.createObject(); result = Json.createObject(); result = Json.createObject(); result = Json.createObject(); result = Json.createObject(); result = SerializationConfig.DEFAULT.with(NamingStrategyNamingStrategyNamingStrategyNaming.YARD); result = Json.createObject(); result = SerializationConfig.DEFAULT.with(NamingStrategyNamingStrategyNamingStrategyNaming.YARD); result = Json.createObject(); result = SerializationConfig.DEFAULT.with(NamingStrategyNamingStrategyNamingStrategyNaming.YARD); result = SerializationConfig.DEFAULT.with(NamingStrategyNamingStrategyNamingStrategyNaming.YARD); result = Json.createObject(); result = SerializationConfig.DEFAULT.with(NamingStrategyNamingStrategyNamingStrategyNaming.YARD); result = SerializationConfig.DEFAULT.with(NamingStrategyNamingStrategyNaming
@Test public void testWith() { SerializationConfig config = new SerializationConfig(base("127.0.0.1:9200,00:00:30"), mixins); config.with(TimeZone.getTimeZone("UTC")); assertThat(config, equalTo(base("127.0.0.1:9200,00:00:30"))); config = new SerializationConfig(base("127.0.0.1:9200,00:00:30"), mixins); config.with(TimeZone.getTimeZone("UTC")); assertThat(config, equalTo(base("127.0.0.1:9200,00:00:30"))); }
@Test public void testWith() { SerializationConfig config = new SerializationConfig(base, SubtypeResolver.parse("dateTime"), mixins); assertEquals(base, config.with(TimeZone.getTimeZone("UTC"))); assertEquals(base, config.with(TimeZone.getTimeZone("UTC+0000"))); assertEquals(base, config.with(TimeZone.getTimeZone("UTC+0000"))); assertEquals(base, config.with(TimeZone.getTimeZone("UTC+0000+0000"))); assertEquals(base, config.with(TimeZone.getTimeZone("UTC+0000+0000"))); assertEquals(base, config.with(TimeZone.getTimeZone("UTC+0000+0000"))); assertEquals(base, config.with(TimeZone.getTimeZone("UTC+0000+0000"))); assertEquals(base, config.with(TimeZone.getTimeZone("UTC+0000+0000"))); assertEquals(base, config.with(TimeZone.getTimeZone("UTC+0000+0000"))); assertEquals(base, config.with(TimeZone.getTimeZone("UTC+0000+0000"))); assertEquals(base, config.with(TimeZone.getTimeZone("UTC+0000+0000"))); assertEquals(base, config.with(TimeZone.getTimeZone("UTC+0000+0000"))); assertEquals(base, config.
@Test public void testInclude() { SerializationConfig config = new SerializationConfig(base, Include.include("foo.bar", Include.Include.class)); assertEquals("[SerializationConfig: flags=0x4294]", config.toString()); }
@Test public void testSerializationConfig() { SerializationConfig config = new SerializationConfig( new SerializationConfig.Builder().with(Mappe.class, new Class<?>[]{Integer.class}).with(Mappe.class, new Class<?>[]{Integer.class}).build(), Mappe.class); assertEquals("[SerializationConfig: flags=0x0" + "]", config.toString()); }
@Test public void testUrlDeserializer() { JsonDeserializer<?> deserializer = Deserializer.find(URL.class, "url"); JsonDeserializer<?> expectedDeserializer = Deserializer.instance; assertEquals(expectedDeserializer, deserializer); }
@Test public void testJackson() throws Exception { JsonDeserializer<?> deserializer = Deserializer.find(String.class, "UTF-8"); assertThat(deserializer).isInstanceOf(StringDeserializer.class); }
@Test public void testPath() { JsonDeserializer<?> deserializer = Deserializer.find(Path.class, "path"); assertThat(deserializer).isNotNull(); assertThat(deserializer.readValue()).isEqualTo("path"); }
@Test public void testURLDeserializer() { }
@Test public void testURLDeserialize() throws IOException { final String urlString = "http: final UUID uuid = UUID.randomUUID(); final DeserializationContext ctxt = mock(DeserializationContext.class); final URL[] urls = new URL[LINE] { new URL(urlString) }; final URLDeserializer deserializer = new URLDeserializer(); final DeserializationContext[] deserCtx = new DeserializationContext[LINE]; deserializerCtx[0] = deserializer; deserializerCtx[1] = deserializer; deserializerCtx[2] = deserializerCtx; final String[] lines = new String[] { "line1", "line2", "line3" }; final URL[] deserValues = new URL[lines.length]; for (int i = 0; i < lines.length; i++) { final String line = lines[i]; final UUID newUrl = deserializer.deserialize(line, ctxt); Assert.assertEquals(newUrl, newUrl); } }
@Test public void testURLDeserialize() throws IOException { final String urlString = "http: final String urlString2 = "http: final String urlString3 = "http: final String urlString4 = "http: final String urlString5 = "http: final String urlString6 = "http: final String urlString7 = "http: final String urlString8 = "http: final String urlString9 = "http: final String urlString10 = "http: final String urlString11 = "http: final String urlString12 = "http: final String urlString13 = "http: final String urlString14 = "http: final String urlString15 = "http: final String urlString16 = "http: final String urlString21 = "http: final String urlString22 = "http: final String urlString2223 = "http: final String urlString2224 = "http: final String urlString31 = "http: final String urlString32 = "http: final String urlString3134 = "http: final String urlString3235 = "http: final String urlString3240 = "http: final String urlString313435 = "http: final String urlString
@Test public void testCharsetDeserializer() { }
@Test public void testDeserialize() throws Exception { JsDeserializer deserializer = new JsDeserializer(); DeserializationContext context = mock(DeserializationContext.class); JsonDeserializer<?> deser = deserializer.deserialize(".lang.String", context); Assert.assertEquals(".lang.String", deser.deserialize(".lang.String", context)); Assert.assertEquals(".lang.String", deser.deserialize(".lang.String", context)); Assert.assertEquals(".lang.String", deser.deserialize(".lang.String", context)); Assert.assertEquals(".lang.String", deser.deserialize(".lang.String", context)); Assert.assertEquals(".lang.String", deser.deserialize(".lang.String", context)); Assert.assertEquals(".lang.String", deser.deserialize(".lang.String", context)); Assert.assertEquals(".lang.String", deser.deserialize(".lang.String", context)); Assert.assertEquals(".lang.String", deser.deserialize(".lang.String", context)); Assert.assertEquals(".lang.String", deser.deserialize(".lang.String", context));
@Test public void test_deserialize() throws IOException { final String charsetName = "UTF-8"; final DeserializationContext context = mock(DeserializationContext.class); final JsonDeserializer<UUID> deserializer = new CharsetDeserializer(); final Charset charset = deserializer.deserialize(charsetName, context); assertEquals(charsetName, charset.name()); }
@Test public void createContextual_propertyNull() throws Exception { Annotated bean = new AnnotatedBean() { @Override public void setFormat(JsonFormat.Value format) { this.format = format; } }; JsonSerializer<?> ctx = new JsonSerializerFactory().createContextual(null, bean); Assert.assertNotNull(ctx); }
@Test public void createContextual() throws JsonMappingException { BeanProperty property = new BeanProperty(Annotated.class, "foo"); JsonSerializer<?> contextual = new JsonSerializer() { @Override public void createContextual(SerializerProvider prov, BeanProperty property) throws JsonMappingException { } }; JsonFormat.Value format = new JsonFormat.Value(null, null, null, null); JsonSerializer<?> contextual2 = contextual.createContextual(null, property); Assert.assertEquals(null, contextual2); }
@Test public void createContextual_null() throws JsonMappingException { BeanProperty property = new BeanProperty(Shape.STRING, null); JsonSerializer<?> contextual = this.mocker.getComponentUnderTest().createContextual(null, property); Assert.assertNull(contextual); }
@Test public void contextual_null() throws JsonMappingException { BeanProperty property = new BeanProperty(null, "value"); JsonSerializer<?> contextual = new JsonSerializerProvider() { @Override public void createContextual(SerializerProvider prov, BeanProperty property) throws JsonMappingException { } }; JsonSerializer<?> contextual2 = new JsonSerializerProvider() { @Override public void createContextual(SerializerProvider prov, BeanProperty property) throws JsonMappingException { } }; JsonSerializer<?> contextual3 = new JsonSerializerProvider() { @Override public void createContextual(SerializerProvider prov, BeanProperty property) throws JsonMappingException { } }; JsonSerializer<?> contextual4 = new JsonSerializerProvider() { @Override public void createContextual(SerializerProvider prov, BeanProperty property) throws JsonMappingException { } }; JsonSerializer<?> contextual5 = new JsonSerializerProvider() { @Override public void createContextual(SerializerProvider prov, BeanProperty property) throws JsonMappingException { } }; JsonSerializer<?> contextual6 = new JsonSerializerProvider() { @Override public void createContextual(SerializerProvider prov, BeanProperty property) throws JsonMappingException { } }; JsonSerializer<?> contextual7 = new JsonSerializerProvider() {
@Test public void contextual_null() throws JsonMappingException { SimpleDateFormat df = new SimpleDateFormat(DATE_FORMAT); SimpleDateFormat df2 = new SimpleDateFormat(DATE_FORMAT); df2.setTimeZone(TimeZone.getTimeZone("GMT+2")); BeanProperty property = new BeanProperty(SimpleDateFormat.class, "str", df); JsonSerializer<?> contextual = this.mocker.getComponentUnderTest().createContextual(null, property); Assert.assertNull(contextual); }
@Test public void createContextual_null() throws JsonMappingException { BeanProperty property = new BeanProperty(null, "value"); JsonSerializer<?> contextual = new JsonSerializer() { @Override public void createContextual(SerializerProvider prov, BeanProperty property) throws JsonMappingException { } }; JsonFormat.Value value = new JsonFormat.Value(null); contextual.setFormat(value); JsonSerializer<?> contextual2 = contextual.createContextual(null, property); Assert.assertEquals(value, contextual2); }
@Test public void createContextual() throws JsonMappingException { BeanProperty property = new BeanProperty(new Class<?>(), "name"); JsonSerializer<?> contextual = new JsonSerializer() { @Override public void createContextual(SerializerProvider prov, BeanProperty property) throws JsonMappingException { } }; JsonFormat.Value format = new JsonFormat.Value(null, null, null, null); JsonSerializer<?> contextual2 = contextual.createContextual(null, property); Assert.assertEquals(format, contextual2); }
@Test public void contextual_null() throws JsonMappingException { BeanProperty property = new BeanProperty(null, "value"); JsonSerializer<?> contextual = new JsonSerializer() { @Override public void createContextual(SerializerProvider prov, BeanProperty property) throws JsonMappingException { } }; contextual.setFormat(null); JsonSerializer<?> contextual2 = new JsonSerializer() { @Override public void createContextual(SerializerProvider prov, BeanProperty property) throws JsonMappingException { } }; Assert.assertEquals(null, contextual2.get(property)); }
@Test public void createContextual() throws JsonMappingException { BeanProperty property = new BeanProperty(TestBean.class, "loc"); JsonSerializer<?> contextual = new JsonSerializerProvider() { @Override public void createContextual(SerializerProvider prov, BeanProperty property) throws JsonMappingException { } }; JsonSerializer<?> contextual2 = new JsonSerializerProvider() { @Override public void createContextual(SerializerProvider prov, BeanProperty property2) throws JsonMappingException { } }; JsonSerializer<?> contextual3 = new JsonSerializerProvider() { @Override public void createContextual(SerializerProvider prov, BeanProperty property) throws JsonMappingException { } }; JsonSerializer<?> contextual4 = new JsonSerializerProvider() { @Override public void createContextual(SerializerProvider prov, BeanProperty property) throws JsonMappingException { } }; JsonSerializer<?> contextual5 = new JsonSerializerProvider() { @Override public void createContextual(SerializerProvider prov, BeanProperty property) throws JsonMappingException { } }; JsonSerializer<?> contextual6 = new JsonSerializerProvider() { @Override public void createContextual(SerializerProvider prov, BeanProperty property) throws JsonMappingException { } }; JsonSerializer<?> contextual7 = new JsonSerializerProvider
@Test public void createContextual_null() throws JsonMappingException { BeanProperty property = new BeanProperty(null, "loc"); JsonSerializer<?> contextual = prov.createContextual(null, property); Assert.assertNotNull(contextual); }
@Test public void createContextual_null() throws Exception { SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"); BeanProperty property = new BeanProperty(null, "date"); JsonSerializer<?> contextual = df.createContextual(null, property); Assert.assertNotNull(contextual); }
@Test public void createContextual() throws JsonMappingException { BeanProperty property = new BeanProperty(Annotated.class, "date"); JsonSerializer<?> contextual = new JsonSerializerProvider() { @Override public void createContextual(SerializerProvider prov, BeanProperty property) throws JsonMappingException { } }; JsonSerializer<?> contextual2 = new JsonSerializerProvider() { @Override public void createContextual(SerializerProvider prov, BeanProperty property2) throws JsonMappingException { } }; JsonSerializer<?> contextual3 = new JsonSerializerProvider() { @Override public void createContextual(SerializerProvider prov, BeanProperty property) throws JsonMappingException { } }; JsonSerializer<?> contextual4 = new JsonSerializerProvider() { @Override public void createContextual(SerializerProvider prov, BeanProperty property) throws JsonMappingException { } }; JsonSerializer<?> contextual5 = new JsonSerializerProvider() { @Override public void createContextual(SerializerProvider prov, BeanProperty property) throws JsonMappingException { } }; JsonSerializer<?> contextual6 = new JsonSerializerProvider() { @Override public void createContextual(SerializerProvider prov, BeanProperty property) throws JsonMappingException { } }; JsonSerializer<?> contextual7 = new JsonSerializerProvider()
@Test public void createContextual() throws JsonMappingException { BeanProperty property = new BeanProperty(Annotated.class, "date"); JsonSerializer<?> contextual = prov.getTimeZone(); JsonSerializer<?> contextual2 = contextual.createContextual(null, property); Assert.assertEquals(null, contextual2); }
@Test public void setTimeZone() throws JsonMappingException { SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS"); df.setTimeZone(TimeZone.getTimeZone("GMT")); BeanProperty property = new BeanProperty(null, "date", df); JsonSerializer<?> contextual = this.cut.createContextual(null, property); Assert.assertEquals(df.setTimeZone(null), contextual); }
@Test public void contextual_null() throws JsonMappingException { BeanProperty property = new BeanProperty(null, "value"); JsonSerializer<?> contextual = new JsonSerializerProvider() { @Override public void createContextual(SerializerProvider prov, BeanProperty property) throws JsonMappingException { } }; JsonSerializer<?> contextual2 = new JsonSerializerProvider() { @Override public void createContextual(SerializerProvider prov, BeanProperty property) throws JsonMappingException { } }; JsonSerializer<?> contextual3 = new JsonSerializerProvider() { @Override public void createContextual(SerializerProvider prov, BeanProperty property) throws JsonMappingException { } }; JsonSerializer<?> contextual4 = new JsonSerializerProvider() { @Override public void createContextual(SerializerProvider prov, BeanProperty property) throws JsonMappingException { } }; JsonSerializer<?> contextual5 = new JsonSerializerProvider() { @Override public void createContextual(SerializerProvider prov, BeanProperty property) throws JsonMappingException { } }; JsonSerializer<?> contextual6 = new JsonSerializerProvider() { @Override public void createContextual(SerializerProvider prov, BeanProperty property) throws JsonMappingException { } }; JsonSerializer<?> contextual7 = new JsonSerializerProvider() {
@Test public void testGetAnnotation() { Annotation annotation = _info.getAnnotation(Annotation.class); Assert.assertEquals(Annotation.class, annotation.getType()); }
@Test public void testGetAnnotation() { Annotation annotation = mock(Annotation.class); when(annotation.getName()).thenReturn("value"); when(annotation.getAnnotation(String.class)).thenReturn("value"); assertEquals(annotation, _mocked.getAnnotation(String.class)); }
@Test public void resolve_propertyWithDeserializationContext_noTypeDeserializer() throws JsonMappingException { MockInstantiator valueInstantiator = new MockInstantiator(); MockConfig config = new MockConfig(); MockInstantiator.configure(config, valueInstantiator); MockInstantiator.instantiate(new MockInstantiator()); ExternalTypeHandler extTypes = null; ExternalTypeHandler.Builder extTypesBuilder = new ExternalTypeHandler.Builder(); extTypesBuilder.addExternal(new PropertyBasedCreator(null, null, null)); extTypesBuilder.addExternal(new PropertyBasedCreator(null, null, null)); extTypesBuilder.addExternal(new PropertyBasedCreator(null, null, null)); assertEquals(extTypesBuilder.build(), new ExternalTypeHandler.Builder().addExternal(new PropertyBasedCreator(null, null, null, null)).build()); }
@Test public void testResolve() throws JsonMappingException { Instantiator valueInstantiator = createMock(Instantiator.class); SettableBeanProperty propertyBasedCreator = createMock(SettableBeanProperty.class); SettableBeanProperty propertyBasedValue = createMock(SettableBeanProperty.class); TypeDeserializer typeDeser = createMock(TypeDeserializer.class); SettableBeanProperty propertyBasedCreator = createMock(SettableBeanProperty.class); SettableBeanProperty propertyBasedValue = createMock(SettableBeanProperty.class); SettableBeanProperty propertyBasedPropertyValue = createMock(SettableBeanProperty.class); SettableBeanProperty propertyBasedPropertyValue2 = createMock(SettableBeanProperty.class); SettableBeanProperty propertyBasedPropertyValue3 = createMock(SettableBeanProperty.class); SettableBeanProperty propertyBasedPropertyValue4 = createMock(SettableBeanProperty.class); SettableBeanProperty propertyBasedPropertyValue5 = createMock(SettableBeanProperty.class); expect(propertyBasedCreator.construct(Mockito.any(DeserializationContext.class), Mockito.any(SettableBeanProperty[].class), Mockito.any(SettableBeanProperty.class))).andReturn(propertyBasedPropertyValue, propertyBasedValue, propertyBasedPropertyValue2, propertyBasedPropertyValue
@Test public void testResolve() throws JsonMappingException { new Expectations() { { mockInstantiator.canCreateFromObjectWith(); result = true; } }; ExternalTypeHandler extTypes = new ExternalTypeHandler.Builder().a(new AType("a")).a(new BType("b")).build(); ExternalTypeHandler resolver = new ExternalTypeHandler.Builder().a(new BType("c")).a(new CType("d")).build(); resolver.resolve(ctxt); }
@Test public void testResolveManagedReferenceProperty() { ContainerDeserializerBase containerDeserializer = (ContainerDeserializerBase) context.getBean("container"); ContainerDeserializerBase containerDeserializer2 = (ContainerDeserializerBase) context.getBean("container"); ContainerDeserializerBase containerDeserializer3 = (ContainerDeserializerBase) context.getBean("container"); BeanDeserializerBase containerDeserializer4 = (ContainerDeserializerBase) context.getBean("container"); BeanDeserializerBase containerDeserializer5 = (ContainerDeserializerBase) context.getBean("container"); BeanDeserializerBase containerDeserializer6 = (ContainerDeserializerBase) context.getBean("container"); SettableBeanProperty beanProp = new SettableBeanProperty("test", containerDeserializer, containerDeserializer2, containerDeserializer3, containerDeserializer4, containerDeserializer5); Assert.assertEquals(beanProp, containerDeserializer.resolveManagedReferenceProperty(context, beanProp)); Assert.assertEquals(beanProp, containerDeserializer.resolveManagedReferenceProperty(context, containerProp2)); Assert.assertEquals(beanProp, containerDeserializer.resolveManagedReferenceProperty(context, containerProp3)); Assert.assertEquals(beanProp, containerDeserializer.resolveManagedReferenceProperty(context, containerProp4)); Assert.assertEquals(beanProp, containerDeserializer.resolveManaged
@Test public void testResolveManagedReferenceProperty() { MockDeserializer mock = new MockDeserializer(); ContainerDeserializer mockContainer = new MockContainerDeserializer(); MockDeserializer mockDeserializer = new MockDeserializer(); MockContainerDeserializer mockContainerDeserializer = new MockContainerDeserializer(); MockBeanDeserializer mockBeanDeserializer = new MockBeanDeserializer(); MockBeanDeserializer mockBeanDeserializer = new MockBeanDeserializer(); MockDeserializer mockDeserializer = new MockDeserializer(); mock.setContentDeserializer(mockContainerDeserializer); mock.setManagedReferenceName(null); mock.setManagedReferenceName(null); mock.setValueDeserializer(mockBeanDeserializer); mock.setManagedReferenceName(null); mock.setValueDeserializer(mockBeanDeserializer); mock.setBackReference("foo"); mock.setBackProp(mockBeanProperty); mock.setManagedReferenceName("bar"); mock.setManagedReferenceProperty(mockBeanProperty); mock.setValueDeserializer(mockBeanDeserializer); mock.setBackProp(mockBeanProperty); mock.setBackProp(mockContainerDeserializer); mock.setManagedReferenceName("baz"); mock.setValueDeserializer(mockBeanDeserializer); mock.setBackProp(mockBeanProperty); mock.setBackProp(mockContainerDeserializer); mock.setManagedReferenceName("bar"); mock
@Test public void testResolveManagedReferenceProperty() { MockDeserializer mockDeserializer = new MockDeserializer(); SettableBeanProperty beanProp = new SettableBeanProperty(); beanProp.setManagedReferenceName("foo"); beanProp.setValueDeserializer(mockDeserializer); Assert.assertEquals(mockDeserializer, _resolveManagedReferenceProperty(_mockContext, beanProp)); Assert.assertEquals(mockDeserializer, _resolveManagedReferenceProperty(_mockContext, null)); Assert.assertEquals(mockDeserializer, _resolveManagedReferenceProperty(_mockContext, new MockContainerDeserializer(mockDeserializer))); Assert.assertEquals(mockDeserializer, _resolveManagedReferenceProperty(_mockContext, new MockContainerDeserializer(mockDeserializer))); }
@Test public void resolveManagedReferenceProperty_withContentDeserializer_shouldResolveIt() { MockDeserializer mockContentDeser = new MockDeserializer(); ContainerDeserializer mockContainerDeserializer = new MockContainerDeserializer(); ContainerDeserializer mockContainerDeserializer2 = new MockContainerDeserializer(); BeanDeserializer mockBeanDeserializer = new BeanDeserializerBase(); mockContainerDeserializer.setContentDeserializer(mockContainerDeserializer); mockContainerDeserializer2.setContentDeserializer(mockBeanDeserializer2); MockDeserializer mockDeserializer = new MockDeserializer(); mockDeserializer.setContentDeserializer(mockContainerDeserializer); mockDeserializer.setManagedReferenceName("refName"); mockDeserializer.setManagedReferenceName("prop"); SettableBeanProperty beanProp = new SettableBeanProperty(); beanProp.setManagedReferenceName("prop"); beanProp.setValue("value"); mockContentDeser.setManagedReferenceName("refName"); SettableBeanProperty property = mock(SettableBeanProperty.class); mockDeserializer.setManagedReferenceName("prop"); property.setValue(property); Assert.assertEquals(property, mockContentDeser.resolveManagedReferenceProperty(mockContext, beanProp)); Assert.assertEquals(property, mockContainerDeserializer.resolveManagedReferenceProperty(mockContext, beanProp)); Assert.assertEquals(property, mockContainerDeserializer2.
@Test public void testResolveManagedReferenceProperty_managedReferenceName_null() { MockDeserializer mockDeserializer = new MockDeserializer(); SettableBeanProperty managedReferenceProperty = new SettableBeanProperty(); managedReferenceProperty.setManagedReferenceName(null); mockDeserializer.addManagedReferenceProperty(managedReferenceProperty); Assert.assertEquals(mockDeserializer, _resolver._resolveManagedReferenceProperty(_mockDeserializer, managedReferenceProperty)); }
@Test public void testResolveInnerClassValuedProperty() { class MyBean implements Bean { public void foo() {} } MyBean myBean = new MyBean(); MyBeanProperty myProperty = new MyBeanProperty(); myProperty.setMyBean(myBean); MyBeanProperty innerProperty = new MyBeanProperty(); innerProperty.setMyBean(myBean); MyBeanProperty innerProperty2 = new MyBeanProperty(); innerProperty2.setMyBean(myBean2); MyBeanProperty innerProperty3 = new MyBeanProperty(); innerProperty3.setMyBean(myBean3); MyBeanProperty innerProperty4 = new MyBeanProperty(); innerProperty4.setMyBean(myBean4); MyBeanProperty innerProperty5 = new MyBeanProperty(); innerProperty5.setMyBean(myBean5); MyBeanProperty innerProperty6 = new MyBeanProperty(); innerProperty6.setMyBean(myBean6); MyBeanProperty innerProperty7 = new MyBeanProperty(); innerProperty7.setMyBean(innerProperty7); MyBeanProperty innerProperty8 = new MyBeanProperty(); innerProperty8.setMyBean(innerProperty8); MyBeanProperty innerProperty9 = new MyBeanProperty(); innerProperty9.setMyBean(innerProperty
@Test public void testResolveInnerClassValuedProperty() { class TestBean implements Bean { public String name; } class TestBean2 extends TestBean { public String name; } class TestBean3 extends TestBean { public String name; } class TestBean4 extends TestBean { public String name; } class TestBean5 extends TestBean { public String name; } class TestBean6 extends TestBean { public String name; } class TestBean7 extends TestBean { public String name; } class TestBean8 extends TestBean { public String name; } class TestBean9 extends TestBean { public String name; } class TestBean10 extends TestBean { public String name; } class TestBean11 extends TestBean { public String name; } class TestBean12 extends TestBean { public String name; } class TestBean21 extends TestBean { public String name; } class TestBean22 extends TestBean { public String name; } class TestBean23 extends TestBean { public String name; } class TestBean24 extends TestBean { public String name; } class TestBean24[] { public String name; } class TestBean23[] a; } class TestBean24[] b; new TestBean24[] { public String name; }
@Test public void testResolveInnerClassValuedProperty() { class TestBean implements Bean { public void test() { } } TestBean bean = new TestBean(); bean.test = new TestBean(); bean.test.setMyString("abc"); SettableBeanProperty property = new SettableBeanProperty(); property.setType(TestBean.class); property.setValueInstantiator(new MockInstantiator()); SettableBeanProperty innerBeanProperty = new SettableBeanProperty(); innerBeanProperty.setInnerClass(bean); property.setValueDeserializer(new BeanDeserializer()); bean.test = new TestBean(); innerBeanProperty.setMyString("abc"); SettableBeanProperty innerBeanProperty2 = new SettableBeanProperty(); innerBeanProperty2.setType(TestBean.class); property.setValueDeserializer(new BeanDeserializer()); property.setValueInstantiator(new MockInstantiator()); SettableBeanProperty innerBeanProperty3 = new SettableBeanProperty(); innerBeanProperty3.setType(TestBean.class); property.setValueDeserializer(new BeanDeserializer()); property.setValueInstantiator(new MockInstantiator()); SettableBeanProperty innerBeanProperty4 = new SettableBeanProperty(); innerBeanProperty4.setType(TestBean.class
@Test public void testResolveInnerClassValuedProperty() { class TestBean implements Bean { public void test() { } } class TestBean2 extends TestBean { public void test2() { } } class TestBean3 extends TestBean { public void test3() { } } class TestBean4 extends TestBean { public void test4() { } } class TestBean5 extends TestBean { public void test5() { } } class TestBean6 extends TestBean { public void test6() { } } class TestBean7 extends TestBean { public void test7() { } } class TestBean8 extends TestBean9 { public void test8() { } } class TestBean9 extends TestBean10 { public void test9(String s) { } } class TestBean10 extends TestBean11 { public void test10(String s, int s1, int s2) { } } class TestBean10 extends TestBean12 { public void test10(String s, int s1, int s2, int s3, int s4, int s5, int s6, int s7, int s8) { } } class TestBean10 extends TestBean10 { public void test10(String s, int s1, int s2, int s3, int s
@Test public void testResolveInnerClassValuedProperty() { class MyBean { public void foo() {} } MyBean myBean = new MyBean(); MyBean.foo = myBean; MyBean.bar = new MyBean.bar(); MyBean.bar.baz = new MyBean.bar.baz(); MyBean.bar baz = new MyBean.bar.baz(); MyBean.bar baz2 = new MyBean.bar.baz2(); DeserializationContext ctxt = mock(DeserializationContext.class); SettableBeanProperty prop = mock(SettableBeanProperty.class); when(prop.getType()).thenReturn(MyBean.class); when(prop.canCreateUsingDefault()).thenReturn(true); when(prop.getValueDeserializer()).thenReturn(mock(Deserializer.class)); when(mock(Deserializer.class).getValueInstantiator()).thenReturn(mock(Instantiator.class)); when(mock(MyBean.class).getRawClass()).thenReturn(MyBean.class); when(prop.getValueInstantiator()).thenReturn(mock(Instantiator.class)); when(mock(MyBean.class).getRawClass()).thenReturn(MyBean.class); when(prop.hasField(eq("foo"))).thenReturn
@Test public void testResolveInnerClassValuedProperty() { class TestBean implements Bean { public void test() { } } TestBean bean = new TestBean(); bean.test = bean; bean.test2 = new TestBean(); bean.test3 = new TestBean(); bean.test4 = new TestBean(); bean.test5 = new TestBean(); bean.test6 = new TestBean(); bean.test7 = new TestBean(); bean.test8 = new TestBean(); bean.test9 = new TestBean(); bean.test10 = new TestBean(); bean.test11 = new TestBean(); bean.test12 = new TestBean(); bean.test13 = new TestBean(); bean.test14 = new TestBean(); bean.test21 = new TestBean(); bean.test22 = new TestBean(); bean.test23 = new TestBean(); bean.test24 = new TestBean(); bean.test24 = new TestBean(); bean.test25 = new TestBean(); bean.test25 = new TestBean(); bean.test25 = new TestBean(); bean.test25 = new TestBean(); bean.test25 = new TestBean(); bean.test25 = new TestBean();
@Test public void testResolveInnerClassValuedProperty() { class TestBean implements Bean { public void test() { } } MockConfig config = new MockConfig(); MockDeserializer<Object> deser = new MockDeserializer<Object>() { @Override public Class<? extends Annotation> annotationType() { return TestBean.class; } }; MockInstantiator vi = new MockInstantiator(); MockBeanType type = new MockBeanType(); type.setRawClass(TestBean.class); MockDeserializer<Object> deser2 = new MockDeserializer<Object>() { @Override public Class<? extends Annotation> annotationType() { return TestBean.class; } }; config.setCanOverrideAccessModifiers(true); MockDeserializer<Object> deser3 = new MockDeserializer<Object>() { @Override public Class<? extends Annotation> annotationType() { return TestBean.class; } }; config.setCanCreateUsingDefault(true); MockDeserializationContext ctxt = new MockDeserializationContext(config, vi, deser2, deser3); SettableBeanProperty property = new SettableBeanProperty(type, new MockBeanType()); property.set(DeserializationContext.Source.class, deser3); Assert.assertEquals(Deserializer.class, deser2.getDeserializer().getClass()); Assert
@Test public void testResolveInnerClassValuedProperty() { class TestBean implements Bean { public void test() { } } MockDeserializationContext ctxt = new MockDeserializationContext(); ctxt.setConf(conf); SettableBeanProperty property = ClassUtil.getInnerClassValuedProperty(ctxt, property); assertEquals(property.getType(), TestBean.class); }
@Test public void test_resolveInnerClassValuedProperty_default() { class A implements Bean { public void foo() {} } class B extends A { public void foo() {} } class C extends A { public void foo() {} } class D extends A { public void foo() {} } class E extends A { public void foo() {} } class F extends A { public void foo() {} } class G extends A { public void foo() {} } class D extends A { public void foo() {} } class D extends A { public void foo() {} } class E extends A { public void foo() {} } class F extends A { public void foo() {} } class G extends A { public void foo() {} } class D extends A { public void foo() {} } class D extends A { public void foo(int a, double b) {} } class E extends A { public void foo(int a, double b, double c) {} } class E extends A { public void foo(int a, double b, double c) {} } class F extends A { public void foo(int a, double b, double c) {} } class D extends A { public void foo(int a, double b, double c) {} }
@Test public void testKnownPropertyNames() { final SettableBeanProperty prop = new SettableBeanProperty(new QName("foo"), "bar"); final BeanDeserializerBase src = new BeanDeserializerBase(src, false); final List<Object> names = new ArrayList<Object>(); for (Object name : src.getKnownPropertyNames()) { names.add(name); } assertEquals("bar", names.get(0)); }
@Test public void testPropertyValueBasedCreator() throws IOException, JsonMappingException { MockBeanType type = new MockBeanType(); type.setPropertyBasedCreator(new MockPropertyBasedCreator()); MockBeanDeserializer mockDeserializer = mock(MockBeanDeserializer.class); when(mockDeserializer.deserialize(jp, mockContext)).thenReturn(null); when(mockDeserializer.deserialize(jp, mockContext)).thenReturn(null); BeanDeserializerBase beanDeserializerBase = new BeanDeserializerBase(mockDeserializerBuilder, mockBeanDesc, mockBeanPropertyMap); beanDeserializerBase.deserializeFromObjectUsingNonDefault(jp, mockContext); verify(mockDeserializer).deserialize(jp, mockContext); }
@Test public void deserializeFromNumber_deserializeFromObjectId_readFromInt() throws IOException, JsonProcessingException { Mockito.when(jp.getNumberType()).thenReturn(NumberType.INT.getNumberValue()); Mockito.when(_valueInstantiator.createUsingDelegate(Mockito.eq(ctxt), Mockito.eq(mock(Object.class))))).thenReturn(new Object()); Mockito.when(_objectIdReader.read(Mockito.eq(ObjectId.class), Mockito.eq(0))).thenReturn(1); Object bean = _objectIdReader.readObject(jp, ctxt); assertEquals(bean, new Object()); Mockito.verify(valueInstantiator, Mockito.times(1)).createUsingDelegate(Mockito.eq(ctxt), Mockito.eq(mock(Object.class))); }
@Test public void construct() { ViewMatcher matcher = [LINE].construct(new Class<?>[]{String.class, Boolean.class}); Assert.assertTrue(matcher instanceof Single); Assert.assertTrue(matcher.isVisibleForView(String.class)); Assert.assertTrue(matcher.isVisibleForView(Boolean.class)); Assert.assertTrue(matcher.isVisibleForView(String.class)); Assert.assertTrue(matcher.isVisibleForView(Boolean.class)); }
@Test public void construct() { Class<?>[] classes = null; ViewMatcher matcher = [LINE].construct(classes); Assert.assertTrue(matcher instanceof Empty.instance); Assert.assertTrue(matcher.matches(null)); Assert.assertTrue(matcher.matches(Empty.instance)); Assert.assertTrue(matcher.matches(Single.class)); Assert.assertTrue(matcher.matches(Single.class)); Assert.assertTrue(matcher.matches(Single.class)); Assert.assertTrue(matcher.matches(Single.class)); Assert.assertTrue(matcher.matches(Single.class)); Assert.assertTrue(matcher.matches(Single.class)); Assert.assertTrue(matcher.matches(Single.class)); Assert.assertTrue(matcher.matches(Single.class)); Assert.assertTrue(matcher.matches(Single.class)); Assert.assertTrue(matcher.matches(Single.class)); Assert.assertTrue(matcher.matches(Single.class)); Assert.assertTrue(matcher.matches(Empty.instance)); }
@Test public void construct() { TestView view1 = new TestView("single"); TestView view2 = new TestView("single2"); TestView view3 = new TestView("single3"); TestView view4 = new TestView("single4"); TestView view5 = new TestView("single5"); TestView view6 = new TestView("single6"); TestView view7 = new TestView("single7"); Assert.assertTrue(view1.isVisibleForView(TestView.class)); Assert.assertTrue(view2.isVisibleForView(TestView.class)); Assert.assertTrue(view3.isVisibleForView(TestView.class)); Assert.assertTrue(view4.isVisibleForView(TestView.class)); Assert.assertTrue(view5.isVisibleForView(TestView.class)); Assert.assertTrue(view6.isVisibleForView(TestView.class)); Assert.assertTrue(view7.isVisibleForView(TestView.class)); Assert.assertTrue(view5.isVisibleForView(TestView.class)); Assert.assertTrue(view6.isVisibleForView(Empty.instance)); Assert.assertFalse(view4.isVisibleForView(TestView
@Test public void construct() { new Asserting(new ViewMatcher[] { Empty.instance }) { @Override public ViewMatcher construct(Class<?>[] classes) { return Empty.instance; } }.matches(new View[]{Single.class, Single.class, Multi.class, Empty.instance}); }
@Test public void construct() { Class<?>[] classes = new Class<?>[] {String.class, Boolean.class, Boolean.class, Boolean.class, String.class, Boolean.class, Boolean.class, Boolean.class, Boolean.class, Boolean.class, Boolean.class, Boolean.class, Boolean.class, Boolean.class, Boolean.class, Boolean.class, Boolean.class, Boolean.class, Boolean.class, Boolean.class, Boolean.class, Boolean.class, Boolean.class, Boolean.class, Boolean.class, Boolean.class, Boolean.class, Boolean.class, Boolean.class, Boolean.class, Boolean.class, Boolean.class, Boolean.class, Boolean.class, Boolean.class, Boolean.class, Boolean.class, Boolean.class, Boolean.class, Boolean.class, Boolean.class, Boolean.class, Boolean.class, Boolean.class, Boolean.class, Boolean.class, Boolean.class, Boolean.class, Boolean.class, Boolean.class, Boolean.class, Boolean.class, Boolean.class, Boolean.class, Boolean.class, Boolean.class, Boolean.class, Boolean.class, Boolean.class, Boolean.
@Test public void construct() { new Asserting(new ViewMatcher[] { Empty.instance, Single.instance }) { @Override public ViewMatcher construct(Class<?>[] classes) { return Empty.instance; } }.matches(new View[]{Single.class, Single.class, Empty.instance, Multi.class, Multi.class}); }
@Test public void construct() { Class<?>[] classes = new Class<?>[] { Empty.instance, Single.instance }; new TestSubject(classes) { @Override public void test(ViewMatcher view) { } }.test(Empty.instance); }
@Test public void test_isVisibleForView() { Assert.assertFalse(single.isVisibleForView(activeView)); Assert.assertFalse(multi.isVisibleForView(activeView)); Assert.assertFalse(multi.isVisibleForView(activeView)); Assert.assertFalse(multi.isVisibleForView(activeView)); }
@Test public void test_isVisibleForView() throws Exception { Assert.assertFalse(single.isVisibleForView(activeView)); Assert.assertFalse(multi.isVisibleForView(activeView)); Assert.assertFalse(multi.isVisibleForView(activeView)); Assert.assertFalse(multi.isVisibleForView(activeView)); }
@Test public void testSingle() { Single single = new Single(String.class); Assert.assertEquals(single.view, "Single"); Assert.assertEquals(single.visible, "true"); Assert.assertEquals(single.visible, "false"); }
@Test public void test_isVisibleForView() { TestView testView = new TestView(Single.class); assertTrue(testView.isVisibleForView(Single.class)); assertFalse(testView.isVisibleForView(AbstractSingle.class)); }
@Test public void test_isVisibleForSingle() { Single r = new Single(Single.class); Assert.assertTrue(r.isVisibleForView(Single.class)); }
@Test public void testJsonNodeDeserializer() { new AssertThrows(NullPointerException.class, () -> { new AssertThrows(NullPointerException.class, () -> deserializer.deserialize(null, null)); }); }
@Test public void testGetDeserializer() { JsonDeserializer<? extends JsonNode> deserializer = Deserializer.getDeserializer(Object.class); Assert.assertTrue(deserializer instanceof ObjectDeserializer); Assert.assertTrue(deserializer instanceof ArrayDeserializer); Assert.assertTrue(deserializer instanceof BaseNodeDeserializer); }
@Test public void testGetDeserializer() { JsonDeserializer<? extends JsonNode> deserializer = Deserializer.getInstance(); Assert.assertTrue(deserializer instanceof ObjectNode); Assert.assertTrue(deserializer.deserialize(new ObjectMapper().createObjectNode(), DeserializationContext.NULL_CONTEXT).isNull()); Assert.assertTrue(deserializer.deserialize(new ObjectMapper().createArrayNode(), DeserializationContext.NULL_CONTEXT).isArrayNode()); Assert.assertTrue(deserializer.deserialize(new ObjectMapper().createArrayNode(), DeserializationContext.NULL_CONTEXT).isNull()); Assert.assertTrue(deserializer.deserialize(new ObjectMapper().createArrayNode(), DeserializationContext.NULL_CONTEXT).isArrayNode()); Assert.assertTrue(deserializer.deserialize(new ObjectMapper().createObjectNode(), DeserializationContext.NULL_CONTEXT).isObject()); Assert.assertTrue(deserializer.deserialize(new ObjectMapper().createObjectNode(), DeserializationContext.NULL_CONTEXT).isObject()); Assert.assertTrue(deserializer.deserialize(new ObjectMapper().createArrayNode(), DeserializationContext.NULL_CONTEXT).isArrayNode()); Assert.assertTrue(deserializer.deserialize(new ObjectMapper().createArrayNode(), DeserializationContext.NULL_CONTEXT).
@Test public void testArrayDeserializer() { JsonDeserializer<? extends ArrayNode> deserializer = Deserializer.getInstance(); ArrayNode instance = (ArrayNode) deserializer.deserialize( mapper.createObjectNode("a"), mapper.createDeserializer(ArrayNode.class)); Assert.assertEquals(instance, deserializer); }
@Test public void testGetDeserializer() { JsonDeserializer<? extends ArrayNode> instance = Deserializer.getInstance(); Assert.assertTrue(instance instanceof BaseNodeDeserializer); ObjectNode jsonNode = (ObjectNode)instance; Assert.assertTrue(jsonNode instanceof ObjectNode); ObjectNode arrayNode = (ObjectNode)instance; Assert.assertTrue(arrayNode instanceof ArrayNode); ObjectNode objectNode = (ObjectNode)instance; Assert.assertTrue(objectNode instanceof ObjectNode); ObjectNode objectNode2 = (ObjectNode)instance; Assert.assertTrue(objectNode2.isArrayNode()); Assert.assertTrue(objectNode2.isObjectNode()); ObjectNode arrayNode2 = (ObjectNode)instance; Assert.assertTrue(arrayNode2.isArrayNode()); Assert.assertTrue(arrayNode2.isObjectNode()); ObjectNode objectNode3 = (ObjectNode)instance; Assert.assertTrue(objectNode3.isArrayNode()); Assert.assertTrue(objectNode3.isObjectNode()); Assert.assertTrue(objectNode3.isArrayNode()); }
@Test public void testArrayDeserializer() { Assert.assertTrue(Deserializer.getInstance().deserialize(JsonNode.class, null).isInstanceOf(ArrayDeserializer.class)); }
@Test public void shouldDeserializeAnyNode() throws IOException, JsonProcessingException { final JsonParser jp = mock(JsonParser.class); final DeserializationContext context = mock(DeserializationContext.class); when(jp.getCurrentToken()).thenReturn(Token.START_ARRAY); when(jp.getCurrentToken()).thenReturn(Token.START_OBJECT); when(context.getNodeFactory()).thenReturn(mock(NodeFactory.class)); when(context.getNode(anyInt())).thenReturn(mock(Node.class)); when(jp.getCurrentToken()).thenReturn(Token.START_ARRAY); when(jp.getCurrentToken()).thenReturn(Token.START_OBJECT); when(jp.getCurrentToken()).thenReturn(Token.START_ARRAY); when(jp.getCurrentToken()).thenReturn(Token.START_ARRAY); when(mapper.readTree(any(JsonNode.class))).thenReturn(new ObjectNode()); final JsonNode result = deserializer.deserialize(jp, context); assertThat(result).isNotNull(); assertThat(result.asText()).isEqualTo("true"); }
@Test public void shouldDeserializeAnyNode() throws IOException { final JsonParser jp = mock(JsonParser.class); when(jp.getCurrentToken()).thenReturn(Token.START_OBJECT); when(jp.getCurrentToken()).thenReturn(Token.START_ARRAY); when(jp.getCurrentToken()).thenReturn(Token.START_OBJECT); when(jp.getCurrentToken()).thenReturn(Token.START_ARRAY); when(jp.getCurrentToken()).thenReturn(Token.START_ARRAY); when(jp.getCurrentToken()).thenReturn(Token.START_ARRAY); when(jp.getCurrentToken()).thenReturn(Token.START_OBJECT); ObjectNode result = deserializer.deserialize(jp, ctxt); assertThat(result, is(instanceOf(Node.class))); }
@Test public void shouldDeserializeObjectNode() throws Exception { when(jp.getCurrentToken()).thenReturn(Token. START_OBJECT); when(nodeFactory.createNode()).thenReturn(mock(Node.class)); when(jp.getCurrentToken()).thenReturn(Token. START_OBJECT); when(jp.getCurrentToken()).thenReturn(Token. START_ARRAY); when(nodeFactory.createNode()).thenReturn(mock(Node.class)); when(mapper.readTree(any(JsonNode.class))).thenReturn(mock(Node.class)); when(mapper.readTree(any(JsonNode.class))).thenReturn(mock(Node.class)); when(mapper.readTree(any(JsonNode.class))).thenReturn(mock(Node.class)); when(mapper.readTree(any(JsonNode.class))).thenReturn(mock(Node.class)); when(mapper.readTree(any(JsonNode.class))).thenReturn(mock(Node.class)); when(mapper.readTree(any(JsonNode.class))).thenReturn(mock(Node.class)); when(mapper.readTree(any(JsonNode.class))).thenReturn(mock(Node.class)); when(mock.getCurrent
@Test public void deserializeObject() throws IOException, JsonProcessingException { final ObjectMapper mapper = new ObjectMapper(); final String json = "{\"a\":1,\"b\":2,\"c\":3}"; final JsonParser jp = mapper.createParser(json); final DeserializationContext ctxt = mock(DeserializationContext.class); when(ctxt.getNodeFactory()).thenReturn(mapper.createNodeFactory()); when(jp.getCurrentToken()).thenReturn(Token.START_OBJECT); when(jp.getCurrentToken()).thenReturn(Token.START_ARRAY); when(jp.getCurrentToken()).thenReturn(Token.START_OBJECT); when(jp.get(JsonNode.class)).thenReturn(JsonNode.valueOf(json)); ObjectNode actual = deserializer.deserialize(jp, ctxt); assertThat(actual).isEqualTo(JsonNode.valueOf(json)); }
@Test public void shouldDeserializeAnyNode() throws IOException, JsonProcessingException { Mockito.when(jp.getCurrentToken()).thenReturn(Token.START_ARRAY); Mockito.when(ctx.getNodeFactory()).thenReturn(nodeFactory); Mockito.when(nodeFactory.createNode()).thenReturn(null); JsonNode result = deserializer.deserialize(jp, ctx); Assert.assertTrue(result instanceof ObjectNode); Assert.assertEquals(nodeFactory, ((Node) result).getNode()); Mockito.verify(ctx).getNodeFactory(); Mockito.verify(nodeFactory).createNode(); Mockito.verify(nodeFactory).createNode(); Mockito.verify(nodeFactory).createNode(); Mockito.verify(nodeFactory).createNode(); Mockito.verify(nodeFactory).createNode(); Mockito.verify(nodeFactory).createNode(); Mockito.verify(nodeFactory).createNode(); Mockito.verify(nodeFactory).createNode(); Mockito.verify(nodeFactory).createNode(); Mockito.verify(nodeFactory).createNode(); Mockito.verify(nodeFactory).createNode(); Mockito.verify(nodeFactory).createNode(); Mockito.verify(nodeFactory).createNode(); Mockito.verify(nodeFactory).createNode(); }
@Test public void deserializeArray() throws IOException, JsonProcessingException { final JsonParser jp = mock(JsonParser.class); when(jp.getCurrentToken()).thenReturn(Token.START_ARRAY); when(jp.getCurrentToken()).thenReturn(Token.START_OBJECT); when(jp.getArrayElements()).thenReturn(ArrayNode.create(ArrayNode.create(ArrayNode.create(ObjectNode.create(ObjectNode.create(ObjectNode.create(ObjectNode.create(ObjectNode.create(ObjectNode.create(ObjectNode.create(ObjectNode.create(ObjectNode.create(ObjectNode.create(ObjectNode.create(ObjectNode.create(ObjectNode.create(ObjectNode.create(ObjectNode.create(ObjectNode.create(ObjectNode.create(ObjectNode.create(ObjectNode.create(ObjectNode.create(ObjectNode.create(ObjectNode.create(ObjectNode.create(ObjectNode.create(ObjectNode.create(ObjectNode.create(ObjectNode.create(ObjectNode.create(ObjectNode.create(ObjectNode.create(ObjectNode.create(ObjectNode.create(ObjectNode.create(ObjectNode.create(ObjectNode.create
@Test public void shouldDeserializeAnyNode() throws IOException, JsonProcessingException { JsonNode node = deserializer.deserialize(getJsonParser("{'a': 1, 'b': 2}"), context); assertThat(node, is(instanceOf(AnyNode.class))); assertThat(node, is(instanceOf(Node.class))); }
@Test public void shouldDeserializeAny() throws IOException { when(jp.getCurrentToken()).thenReturn(Token.START_OBJECT); when(ctx.getNodeFactory()).thenReturn(nodeFactory); when(nodeFactory.createNode()).thenReturn(null); when(jp.getToken()).thenReturn(Token.START_ARRAY); when(ctx.getNodeFactory()).thenReturn(nodeFactory); when(nodeFactory.createNode()).thenReturn(null); ObjectNode result = deserializer.deserialize(jp, ctx); assertThat(result).isNotNull(); assertThat(result.get("array").asText()).isEqualTo("foo"); }
@Test public void testArray() { new AssertThrows(NullPointerException.class, () -> DESERIALIZER.deserializeWithType(null, null, null)); }
@Test public void testGetInstance() { Assert.assertNotNull(_deserializer); Assert.assertEquals(_instance, _deserializer.getInstance()); }
@Test public void deserializeObject() throws IOException, JsonProcessingException { final JsonParser jp = mock(JsonParser.class); final DeserializationContext ctxt = mock(DeserializationContext.class); final JsonNodeFactory nodeFactory = mock(NodeFactory.class); when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.getCurrentToken()).thenReturn(JsonToken.FIELD_NAME); when(nodeFactory.createNode()).thenReturn(node); when(jp.getToken()).thenReturn(JsonToken.START_OBJECT); when(jp.getCurrentToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.getNodeFactory()).thenReturn(nodeFactory); ObjectNode result = deserializer.deserialize(jp, ctxt); assertEquals(node, result); }
@Test public void deserializeObject() throws IOException, JsonProcessingException { final ObjectNode expectedNode = mapper.readValue("{\"name\":\"value\"}", ObjectNode.class); final JsonParser jp = mock(JsonParser.class); when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); when(jp.getCurrentToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.getToken()).thenReturn(JsonToken.START_OBJECT); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.getCurrentToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.getCurrentToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.getToken()).thenReturn(JsonToken.FIELD_NAME); when(mapper.readValue("{\"name\":\"value\"}", ObjectNode.class)).thenReturn(expectedNode); final DeserializationContext ctxt = mock(DeserializationContext.class); final JsonDeserializer deserializer = new TestDeserializer(); final DeserializationContext deserContext = mock(DeserializationContext.class); when(deser.deserialize(jp, ctxt)).thenReturn(expectedNode); final ObjectNode actualNode = deserializer.deserialize(jp, ctxt); assertEquals(expectedNode, actualNode);
@Test public void deserializeObject() throws IOException, JsonProcessingException { final ObjectNode expectedNode = mapper.readValue("{\"name\":\"John\"}", ObjectNode.class); final JsonParser jp = mock(JsonParser.class); when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); when(jp.getCurrentToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.getToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); when(jp.getCurrentToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.getCurrentToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.getCurrentToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.getToken()).thenReturn(JsonToken.START_OBJECT); when(jp.getCurrentToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.getToken()).thenReturn(JsonToken.FIELD_NAME); when(mapper.createArray(expectedNode)).thenReturn(expectedNode); final DeserializationContext ctxt = mock(DeserializationContext.class); when(ctxt.getNodeFactory()).thenReturn(mapper); final ObjectNode actualNode = deserializer.deserialize
@Test public void deserializeObject() throws IOException, JsonProcessingException { JsonNodeFactory nf = mock(JsonNodeFactory.class); when(nf.createNode()).thenReturn(mock(Node.class)); when(nf.createArray()).thenReturn(new ArrayNode(new int[]{1, 2, 3})); when(nf.createToken(JsonToken.START_OBJECT)).thenReturn(JsonToken.START_OBJECT); when(nf.createToken(JsonToken.FIELD_NAME)).thenReturn(JsonToken.START_OBJECT); when(nf.createArray()).thenReturn(new ArrayNode(new int[]{1, 2, 3})); when(nf.createToken(JsonToken.START_OBJECT)).thenReturn(JsonToken.START_ARRAY); when(nf.createToken(JsonToken.FIELD_NAME)).thenReturn(JsonToken.START_OBJECT); when(nf.createToken(JsonToken.START_ARRAY)).thenReturn(JsonToken.START_ARRAY); when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); when(jp.getCurrentToken()).thenReturn(JsonToken.START_ARRAY); when(jp.getCurrentToken()).thenReturn(
@Test public void testBaseNodeDeserializer() { new BaseNodeDeserializer().deserializeWithType( jp, null, null); }
@Test public void testBaseNodeDeserializer() { new MockUp<JsonNode>() { @Mock protected void _reportProblem(JsonNode d) { } }; JsonDeserializer deserializer = new BaseNodeDeserializer(); Assert.assertEquals(JsonNode.class, deserializer.deserialize(jp, null).getClass()); Assert.assertEquals(new MockUp<JsonNode>() { @Mock protected void _reportProblem(JsonNode d) { } }); }
@Test public void deserializeObject() throws Exception { final String json = "{\"name\": \"Joe\",\"age\":31}"; final JsonParser jp = mock(JsonParser.class); when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); when(jp.getCurrentToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); ObjectNode result = objectUnderTest.deserializeObject(jp, mock(DeserializationContext.class), nodeFactory); assertThat(result).isEqualTo(objectNode); }
@Test public void deserializeObject_with_empty_string() throws IOException, JsonProcessingException { Mockito.when(mockJsonParser.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); Mockito.when(mockJsonParser.nextToken()).thenReturn(JsonToken.FIELD_NAME); Mockito.when(mockJsonParser.getText()).thenReturn(""); ObjectNode node = mapper.deserializeObject(mockJsonParser, mockDeserializationContext, mockNodeFactory); Assert.assertEquals(node, objectMapper.readTree(nodeFactory.objectNode()).get(0)); Mockito.verify(mockJsonParser, Mockito.times(1)).getCurrentToken(); Mockito.verify(mockDeserializationContext, Mockito.times(1)).getBody(); }
@Test public void deserializeObject() throws IOException, JsonProcessingException { Mockito.when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); Mockito.when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); Mockito.when(nodeFactory.objectNode()).thenReturn(node); Mockito.when(node.textNode("foo")).thenReturn("bar"); Mockito.when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); Mockito.when(jp.nextToken()).thenReturn(JsonToken.VALUE_STRING); Mockito.when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); Mockito.when(jp.nextToken()).thenReturn(JsonToken.VALUE_STRING); Mockito.when(nodeFactory.textNode("foo")).thenReturn("bar"); Mockito.when(jp.nextToken()).thenReturn(JsonToken.VALUE_STRING); Mockito.when(jp.nextToken()).thenReturn(JsonToken.VALUE_STRING); final ObjectNode result = objectUnderTest.deserializeObject(jp, ctxt, nodeFactory); Assert.assertEquals("bar", result.get("foo")); Mockito.verify(nodeFactory).objectNode(); Mockito.verify(jp, Mockito.times(1)).nextToken
@Test public void deserializeObject() throws IOException, JsonProcessingException { final String value = "value"; final JsonParser jp = mock(JsonParser.class); when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.getText()).thenReturn(value); mapper.writeValueAsString(value); final ObjectNode result = mapper.deserializeObject(jp, mock(DeserializationContext.class), mock(NodeFactory.class)); assertThat(result).isEqualTo(value); }
@Test public void deserializeObject() throws IOException, JsonProcessingException { final String value = "value"; final JsonParser jp = mock(JsonParser.class); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.textNode(value)).thenReturn(value); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.nextToken()).thenReturn(JsonToken.VALUE_STRING); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.nextToken()).thenReturn(JsonToken.VALUE_STRING); ObjectNode result = mapper.deserializeObject(jp, mock(DeserializationContext.class), mock(JsonFactory.class)); assertThat(result).isNotNull(); assertThat(result.get("value")).isEqualTo(value); }
@Test public void should_deserialize_object_array() throws IOException, JsonProcessingException { final String value = "value"; final JsonParser jp = mock(JsonParser.class); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.getToken()).thenReturn(JsonToken.START_OBJECT); when(jp.nextToken()).thenReturn(JsonToken.VALUE_ARRAY); when(jp.textNode(value)).thenReturn(value); mapper.writeValueAsString(value); final JsonNode[] actual = mapper.readValue(new StringReader(value)); assertThat(actual).hasSize(1); assertThat(actual[0]).isEqualTo(value); }
@Test public void deserializeObject_should_return_object_object() throws IOException, JsonProcessingException { Mockito.when(jp.getCurrentName()).thenReturn(JsonToken.FIELD_NAME); Mockito.when(nodeFactory.objectNode()).thenReturn(node); Mockito.when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); Mockito.when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); Mockito.when(jp.nextToken()).thenReturn(JsonToken.VALUE_STRING); Mockito.when(nodeFactory.textNode("value")).thenReturn(node); Mockito.when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); Mockito.when(jp.getCurrentName()).thenReturn(JsonToken.VALUE_STRING); Mockito.when(nodeFactory.textNode("value")).thenReturn(node); final ObjectNode result = mapper.deserializeObject(jp, ctxt, nodeFactory); Assert.assertEquals(node, result); }
@Test public void deserializeObject() throws IOException, JsonProcessingException { final String json = "{\"name\": \"Joe\",\"age\":31}"; final JsonNodeFactory nodeFactory = mock(JsonNodeFactory.class); when(nodeFactory.textNode("Joe")).thenReturn(json); final JsonNode result = objectUnderTest.deserializeObject(jp, ctxt, nodeFactory); assertThat(result).isEqualTo(json); }
@Test public void should_deserialize_object_with_start_object() throws IOException { final String value = "value"; final ObjectNode node = objectMapper.readValue(json(value)); Mockito.when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); Mockito.when(nodeFactory.objectNode()).thenReturn(node); Mockito.when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); Mockito.when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); Mockito.when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); Mockito.when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); Mockito.when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); Mockito.when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); Mockito.when(jp.nextToken()).thenReturn(JsonToken.VALUE_STRING); Mockito.when(mapper.writeValueAsString(value)).thenReturn(value); final ObjectNode deserializedObject = mapper.deserializeObject(jp, context, mapper); Assert.assertEquals(value, deserializedObject); }
@Test public void deserializeObject() throws IOException, JsonProcessingException { JsonNodeFactory nodeFactory = mock(JsonNodeFactory.class); when(nodeFactory.objectNode()).thenReturn(node); when(node.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(node.textNode("foo")).thenReturn("bar"); when(nodeFactory.textNode("bar")).thenReturn(node); ObjectNode result = deserializeObject(json("{\"foo\": \"bar\"}"), ctxt, nodeFactory); assertThat(result).isEqualTo(node); }
@Test public void deserializeObject_value() throws IOException, JsonProcessingException { final String value = "value"; Mockito.when(mockJParser.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); Mockito.when(mockJParser.nextToken()).thenReturn(JsonToken.FIELD_NAME); Mockito.when(mockJParser.getTextNode(value)).thenReturn(value); Mockito.when(mockObjectMapper.createObjectNode()).thenReturn(node); Mockito.when(mockObjectMapper.createObjectNode()).thenReturn(node); Mockito.when(mockObjectMapper.createObjectNode()).thenReturn(new ObjectNode(node)); Mockito.when(mockObjectMapper.createObjectNode()).thenReturn(new ObjectNode(new JsonNodeFactory().textNode(value))); Mockito.when(mockObjectMapper.createObjectNode()).thenReturn(new ObjectNode(new JsonNodeFactory().textNode(value))); final ObjectNode result = objectUnderTest.deserializeObject(mockJParser, mockDeserializationContext, mockObjectMapperFactory); Mockito.verify(mockObjectMapper).createObjectNode(); Mockito.verify(mockObjectMapper).createObjectNode(); Mockito.verify(mockObjectMapper).createObjectNode(); Mockito.verify(mockObjectMapper).createObjectNode(); Mockito.verify(mockObjectMapper).createArrayNode();
@Test public void deserializeObject() throws IOException, JsonProcessingException { JsonNodeFactory nodeFactory = mock(JsonNodeFactory.class); when(nodeFactory.objectNode()).thenReturn(node); when(nodeFactory.textNode("foo")).thenReturn(node); when(nodeFactory.textNode("bar")).thenReturn(node); when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.getCurrentName()).thenReturn("foo"); when(jp.nextToken()).thenReturn(JsonToken.FIELD_VALUE_STRING); when(jp.nextToken()).thenReturn(JsonToken.FIELD_VALUE_STRING); ObjectNode result = objectUnderTest.deserializeObject(jp, ctxt, nodeFactory); assertEquals("foo", result.get("foo")); }
@Test public void deserializeObject() throws IOException, JsonProcessingException { JsonNodeFactory nodeFactory = mock(JsonNodeFactory.class); when(nodeFactory.objectNode()).thenReturn(node); when(node.nextToken()).thenReturn(JsonToken.START_OBJECT); when(node.textNode("foo")).thenReturn("bar"); when(nodeFactory.textNode("bar")).thenReturn("baz"); ObjectNode result = objectUnderTest.deserializeObject(jsonParser, ctxt, nodeFactory); assertThat(result).isEqualTo(node); }
@Test public void deserializeArray() throws IOException, JsonProcessingException { final String value = "[\"a\",\"b\",\"c\"]"; final ObjectNode node = mapper.readValue(value, ObjectNode.class); Mockito.when(jp.nextToken()).thenReturn(JsonToken.START_ARRAY); Mockito.when(nodeFactory.objectNode()).thenReturn(node); Mockito.when(jp.getText()).thenReturn(value); Mockito.when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); Mockito.when(jp.getCurrentName()).thenReturn("a"); Mockito.when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); Mockito.when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME_AND_VALUE); Mockito.when(nodeFactory.textNode("a")).thenReturn(node); Mockito.when(nodeFactory.textNode("b")).thenReturn(node); Mockito.when(nodeFactory.textNode("c")).thenReturn(node); final JsonNode result = objectUnderTest.deserializeObject(jp, ctxt, nodeFactory); Assert.assertEquals(value, result); Mockito.verify(nodeFactory).objectNode(); Mockito.verify(jp, Mockito.times(1)).nextToken();
@Test public void deserializeObject() throws IOException, JsonProcessingException { JsonNodeFactory nodeFactory = mock(JsonNodeFactory.class); when(nodeFactory.objectNode()).thenReturn(node); when(nodeFactory.textNode("foo")).thenReturn(node); when(nodeFactory.textNode("bar")).thenReturn(node); when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.getCurrentName()).thenReturn("foo"); when(jp.nextToken()).thenReturn(JsonToken.FIELD_VALUE_STRING); when(jp.nextToken()).thenReturn(JsonToken.FIELD_VALUE_STRING); ObjectNode result = objectUnderTest.deserializeObject(jp, ctxt, nodeFactory); assertEquals("foo", result.get("foo")); }
@Test public void should_deserialize_string_value() throws IOException, JsonProcessingException { JsonNodeFactory nodeFactory = mock(JsonNodeFactory.class); when(nodeFactory.textNode("value")).thenReturn(mock(JsonNode.class)); when(mock(JsonParser.class)).thenReturn(mock(JsonParser.class)); when(mock(JsonParser.class)).thenReturn(mock(JsonParser.class)); when(mock(JsonParser.class)).thenReturn(mock(JsonParser.class)); when(mock(JsonParser.class)).thenReturn(mock(JsonParser.class)); when(mock(JsonParser.class)).thenReturn(mock(JsonParser.class)); when(mock(JsonParser.class)).thenReturn(mock(JsonParser.class)); when(mock(JsonParser.class)).thenReturn(mock(JsonParser.class)); when(mock(JsonParser.class)).thenReturn(mock(JsonParser.class)); when(mock(JsonParser.class)).thenReturn(mock(JsonParser.class)); when(mock(JsonParser.class)).thenReturn(mock(JsonParser.class)); when(mock(JsonParser.class)).thenReturn(mock(JsonParser.class)); when(mock(JsonParser
@Test public void deserializeObject_textNode() throws IOException, JsonProcessingException { Mockito.when(mockJParser.getText()).thenReturn("value"); Mockito.when(mockNodeFactory.textNode("value")).thenReturn(node); ObjectNode result = objectUnderTest.deserializeObject(mockJParser, mockContext, mockNodeFactory); Mockito.verify(mockNodeFactory).textNode("value"); Mockito.verifyNoMoreInteractions(mockContext, mockNodeFactory); Assert.assertEquals("value", result.get("value")); }
@Test public void deserializeObject() throws IOException, JsonProcessingException { JsonNodeFactory nodeFactory = mock(JsonNodeFactory.class); when(nodeFactory.objectNode()).thenReturn(node); when(nodeFactory.textNode("foo")).thenReturn(node); when(nodeFactory.textNode("bar")).thenReturn(node); when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.getCurrentName()).thenReturn("foo"); when(jp.nextToken()).thenReturn(JsonToken.FIELD_VALUE_STRING); when(jp.nextToken()).thenReturn(JsonToken.FIELD_VALUE_STRING); ObjectNode result = objectUnderTest.deserializeObject(jp, ctxt, nodeFactory); assertEquals("foo", result.get("foo")); }
@Test public void deserializeObject() throws IOException, JsonProcessingException { JsonNodeFactory nodeFactory = mock(JsonNodeFactory.class); when(nodeFactory.objectNode()).thenReturn(node); when(nodeFactory.textNode("foo")).thenReturn(node); ObjectNode result = objectUnderTest.deserializeObject(jp, ctxt, nodeFactory); assertThat(result).isEqualTo(node); }
@Test public void should_deserialize_any_when_any_is_null() throws Exception { final JsonNodeFactory nodeFactory = mock(JsonNodeFactory.class); when(nodeFactory.objectNode()).thenReturn(null); final String value = "value"; when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); when(jp.getText()).thenReturn(value); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.getCurrentName()).thenReturn("any"); when(jp.nextToken()).thenReturn(JsonToken.FIELD_VALUE_STRING); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME_VALUE_STRING); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME_VALUE_STRING); when(nodeFactory.textNode(value)).thenReturn(value); final JsonNode result = deserializeObject(jp, ctxt, nodeFactory); assertThat(result).isNotNull(); assertThat(result.asText()).isEqualTo(value); }
@Test public void deserializeObject_replace() throws IOException, JsonProcessingException { final ObjectNode node = mapper.readValue("{\"foo\":\"bar\"}", JsonNode.class); final ObjectNode result = node.replace(fieldName, value); assertThat(result).isEqualTo(value); }
@Test public void deserializeObject() throws IOException, JsonProcessingException { final String value = "value"; final ObjectNode node = objectMapper.readValue(JsonUtils.toString(value)); final ObjectNode result = mapper.readValue(JsonUtils.toString(value)); assertThat(result).isEqualTo(value); }
@Test public void deserializeObject() throws IOException, JsonProcessingException { JsonNodeFactory nodeFactory = mock(JsonNodeFactory.class); when(nodeFactory.objectNode()).thenReturn(node); when(nodeFactory.textNode("foo")).thenReturn(node); when(nodeFactory.textNode("bar")).thenReturn(node); ObjectNode result = objectUnderTest.deserializeObject(jp, ctxt, nodeFactory); assertThat(result).isEqualTo(node); }
@Test public void deserializeArray_withNullValueString_shouldThrow() throws Exception { Mockito.when(mockJsonParser.nextToken()).thenReturn(null); Mockito.when(mockJsonFactory.te(null)).thenReturn(mockStringNode); ArrayNode result = objectUnderTest.deserializeArray(mockJsonParser, mockDeserializationContext, mockFactory); Mockito.verify(mockJsonNode).add(any(Node.class)); Mockito.verify(mockJsonNode).add(any(Node.class)); }
@Test public void deserializeArray_withNullValue() throws IOException, JsonProcessingException { JsonNodeFactory nodeFactory = mock(JsonNodeFactory.class); when(nodeFactory.textNode("foo")).thenReturn(null); when(nodeFactory.textNode("bar")).thenReturn(null); JsonNode mockJsonNode = mock(JsonNode.class); when(mockJsonParser.nextToken()).thenReturn(JsonToken.NULL); when(mockJsonParser.textNode("foo")).thenReturn(mockJsonNode); when(mockJsonNode.textNode("bar")).thenReturn(mockJsonNode); JsonNode mockJsonNode2 = mock(JsonNode.class); when(mockJsonNode2.textNode("foo")).thenReturn(mockJsonNode2); when(mockJsonNode2.textNode("bar")).thenReturn(mockJsonNode2); ArrayNode node = testSubject.deserializeArray(mockJsonParser, ctxt, nodeFactory); verify(mockJsonNode).add(any(Node.class)); }
@Test public void shouldDeserializeArray() throws IOException { JsonNodeFactory nodeFactory = new JsonNodeFactory(); JsonNodeFactory.textNode("foo"); JsonNodeFactory.textNode("bar"); JsonNodeFactory.textNode("baz"); JsonNodeFactory.textNode("quux"); JsonNodeFactory.textNode("quux"); JsonNodeFactory.textNode("quux"); JsonNodeFactory.textNode("foo"); JsonNodeFactory.textNode("bar"); JsonNode[] testArray = new JsonNode[] { nodeFactory.textNode("foo"), nodeFactory.textNode("bar") }; new Thread(new Runnable() { @Override public void run() { try { new ArrayNode(testArray).deserializeArray(jp, ctxt, nodeFactory); } catch (IOException e) { e.printStackTrace(); } } }).start(); new Thread(new Runnable() { @Override public void run() { try { new ArrayNode(testArray).deserializeArray(jp, ctxt, nodeFactory); } catch (IOException e) { e.printStackTrace(); } } }).start(); new Thread(new Runnable() { @Override public void run() { try { new ArrayNode(testArray).deserializeArray(jp, ctxt, nodeFactory); } catch (IOException e) { e.printStackTrace();
@Test public void shouldDeserializeArray() throws IOException, JsonProcessingException { JsonNodeFactory nodeFactory = mock(JsonNodeFactory.class); when(nodeFactory.arrayNode()).thenReturn(new ArrayNode()); when(jp.nextToken()).thenReturn(JsonToken.START_ARRAY); when(jp.nextToken()).thenReturn(JsonToken.VALUE_STRING); when(jp.getText()).thenReturn("test"); ArrayNode result = deserializeArray(jp, ctxt, nodeFactory); assertThat(result).isEqualTo(arrayNode); }
@Test public void should_deserialize_array_nodes_with_null_value() throws IOException { JsonNodeFactory nodeFactory = new JsonNodeFactory(); JsonNode testArrayNode = nodeFactory.objectNode(); when(jp.nextToken()).thenReturn(JsonToken.valueOf(null)); when(jp.getText()).thenReturn("testArray"); ArrayNode result = deserializer.deserializeArray(jp, ctxt, nodeFactory); assertThat(result).isNotNull(); }
@Test public void shouldDeserializeArray() throws IOException { JsonNodeFactory nodeFactory = new JsonNodeFactory(); JsonNodeFactory.textNode("foo"); JsonNodeFactory.arrayNode(); try (JsonParser jp = new JsonParser(new ByteArrayInputStream(array("foo", "bar", "baz"))) { new TestDeserializer(nodeFactory).deserializeArray(jp, ctxt, nodeFactory); } new TestDeserializer(nodeFactory).deserializeArray(jp, ctxt, nodeFactory); }
@Test public void shouldDeserializeArray() throws IOException, JsonProcessingException { JsonNodeFactory nodeFactory = new JsonNodeFactory(); JsonNode node = nodeFactory.objectNode(); when(jp.nextToken()).thenReturn(JsonToken.valueOf("array")); when(jp.getText()).thenReturn("array"); ArrayNode result = deserializer.deserializeArray(jp, ctxt, nodeFactory); assertThat(result).isInstanceOf(ArrayNode.class); }
@Test public void deserializeArray() throws IOException, JsonProcessingException { JsonNodeFactory nodeFactory = new JsonNodeFactory(); JsonNodeFactory.textNode("foo"); JsonNodeFactory.arrayNode(); try (JsonParser jp = new JsonParser(new ByteArrayInputStream(new byte[] { 1, 2, 3}))) { new TestDeserializer(nodeFactory).deserializeArray(jp, ctxt, nodeFactory); } }
@Test public void shouldDeserializeArray() throws IOException, JsonProcessingException { JsonNodeFactory nodeFactory = JsonNodeFactory.instance; JsonNode node = nodeFactory.objectNode(); when(jp.nextToken()).thenReturn(null); when(jp.getText()).thenReturn("test"); when(nodeFactory.textNode("test")).thenReturn("test1"); when(ctx.mappingContext()).thenReturn(ctxt); when(ctxt.arrayNode()).thenReturn(node); ArrayNode result = test.deserializeArray(jp, ctxt, nodeFactory); assertThat(result).isEqualTo(node); }
@Test public void deserializeArray() throws IOException, JsonProcessingException { Mockito.when(jp.nextToken()).thenReturn(JsonToken.START_ARRAY); Mockito.when(jp.getText()).thenReturn("array"); Mockito.when(nodeFactory.textNode("array")).thenReturn(node); ArrayNode result = deserializer.deserializeArray(jp, ctxt, nodeFactory); Assert.assertEquals("array", result.get(0)); Mockito.verify(node).add(any(Node.class)); Mockito.verify(ctx, Mockito.times(1)).mappingException(anyString()); }
@Test public void shouldDeserializeArray() throws IOException, JsonProcessingException { JsonNodeFactory nodeFactory = mock(JsonNodeFactory.class); when(nodeFactory.arrayNode()).thenReturn(new ArrayNode()); when(jp.nextToken()).thenReturn(null); when(jp.getText()).thenReturn("test"); when(ctx.mappingException()).thenReturn(new MappingException("Unexpected end-of-input when binding data into ArrayNode")); ArrayNode result = deserializeArray(jp, ctxt, nodeFactory); assertThat(result).isNotNull(); }
@Test public void deserializeAny_null() throws Exception { Mockito.when(jp.getCurrentToken()).thenReturn(Token.START_OBJECT); Mockito.when(jp.getEmbeddedObject()).thenReturn(null); JsonNode actual = objectUnderTest.deserializeAny(jp, ctxt, nodeFactory); Assert.assertNull(actual); Mockito.verify(nodeFactory).nullNode(); }
@Test public void shouldDeserializeAny() throws IOException, JsonProcessingException { when(jp.getCurrentToken()).thenReturn(Token.START_OBJECT); when(jp.getCurrentToken()).thenReturn(Token.START_ARRAY); when(jp.getEmbeddedObject()).thenReturn(new Object()); when(jp.getToken()).thenReturn(Token.VALUE_EMBEDDED_OBJECT); when(jp.getEmbeddedObject()).thenReturn(null); JsonNode actual = deserializeAny(jp, ctxt, nodeFactory); assertThat(actual, instanceOf(Node.class)); assertThat((Node) actual, instanceOf(Node.class)); }
@Test public void shouldDeserializeAny() throws Exception { Mockito.when(jp.getCurrentToken()).thenReturn(Token.START_OBJECT); Mockito.when(jp.getEmbeddedObject()).thenReturn(new Object()); Mockito.when(jp.getToken()).thenReturn(Token.START_ARRAY); Mockito.when(jp.getEmbeddedObject()).thenReturn(Arrays.asList("foo", "bar")); Mockito.when(deserializationContext.getType()).thenReturn(Token.START_OBJECT); Mockito.when(deserializationContext.getDeserializer()).thenReturn(Deserializer.class); Mockito.when(deserializationContext.getClassLoader()).thenReturn(getClass().getClassLoader()); JsonNode actual = deserializeAny(jp, mapper, DeserializationContext.DEFAULT_NODE_FACTORY); Assert.assertNotNull(actual); Assert.assertTrue(actual instanceof ObjectNode); ObjectNode expectedNode = mapper.readTree(new ByteArrayInputStream(new byte[] { 1, 2, 3 }).asText()); Assert.assertEquals(expectedNode, actual); }
@Test public void deserializeAny_null() throws Exception { when(jp.getCurrentToken()).thenReturn(JsonParser.NumberType.NUMBER); when(jp.getNumberType()).thenReturn(JsonParser.NumberType.NULL); when(jsonNodeFactory.binaryNode(any())).thenReturn(null); assertThat(deserializeAny(jp, ctxt, mapper)).isNull(); }
@Test public void deserializeAny() throws IOException, JsonProcessingException { final JsonParser jp = mock(JsonParser.class); when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); when(jp.getToken()).thenReturn(JsonParser.NumberType.BIG_INTEGER); when(jp.getEmbeddedObject()).thenReturn(null); when(jp.getToken()).thenReturn(JsonToken.VALUE_EMBEDDED_OBJECT); when(jp.getEmbeddedNode()).thenReturn(null); final JsonNode actual = deserializer.deserializeAny(jp, ctxt, nodeFactory); assertThat(actual).isNotNull(); assertThat(actual.asText()).isEqualTo("value"); }
@Test public void deserializeAny() throws Exception { when(jp.getBigIntegerValue()).thenReturn(BigInteger.valueOf(1234)); when(nodeFactory.numberNode(BigInteger.valueOf(1234)).thenReturn(node); JsonNode result = deserializeAny(jp, ctxt, nodeFactory); assertThat(result, is(node)); }
@Test public void deserializeAny() throws IOException, JsonProcessingException { final JsonParser jp = mock(JsonParser.class); when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); when(jp.getEmbeddedObject()).thenReturn(null); when(jp.getToken()).thenReturn(JsonToken.VALUE_EMBEDDED_OBJECT); when(jp.getToken()).thenReturn(JsonToken.START_ARRAY); when(jp.getEmbeddedObject()).thenReturn(new byte[] { 1, 2, 3 }); mapper.writeValueAsString(new Integer(1)); mapper.writeValueAsString(new Double(2)); mapper.writeValueAsString(new String("42")); mapper.writeValueAsString(new Integer(2)); mapper.writeValueAsString(new byte[] {3, 4, 5}); mapper.writeValueAsString(new byte[] {5, 6, 7}); mapper.writeValueAsString(new byte[] {9, 8, 9}); mapper.writeValueAsString(new byte[] {9, 10, 11, 12}); mapper.writeValueAsString(new byte[] {9, 10, 11, 12}); mapper.writeValueAsString(new byte[] {9, 10, 11, 12}); mapper.writeValueAsString(new byte[] {9, 10, 11, 12}); mapper.write
@Test public void deserializeAny() throws Exception { when(jp.getIntValue()).thenReturn(42); when(nodeFactory.numberNode(42)).thenReturn(node); assertThat(deserializeAny(jp, ctxt, nodeFactory), is(instanceOf(numberNode.class))); }
@Test public void deserializeAny() throws Exception { when(jp.getLongValue()).thenReturn(42L); when(nodeFactory.numberNode(42L)).thenReturn(node); when(jp.getCurrentToken()).thenReturn(Token.START_OBJECT); when(jp.getLongValue()).thenReturn(42L); JsonNode result = deserializeAny(jp, ctxt, nodeFactory); assertThat(result, is(node)); }
@Test public void testMaterializeAbstractType() throws JsonMappingException { MockDeserializationContext context = new MockDeserializationContext(); context.setConfig(mockFactoryConfig); MockAbstractTypeResolver resolver = new MockAbstractTypeResolver(); context.setAbstractTypeResolvers(Collections.singleton(resolver)); MockAbstractTypeResolver.AbstractTypeResolver resolver2 = new MockAbstractTypeResolver(); context.setConfig(mockFactoryConfig2); MockFactoryConfig mockFactoryConfig = new MockFactoryConfig(); MockBeanDescription mockDesc = new MockBeanDescription(); MockBeanDescription mockBeanDesc2 = new MockBeanDescription(); MockBeanDescription mockBeanDesc3 = new MockBeanDescription(); MockBeanDescription mockBeanDesc4 = new MockBeanDescription(); MockBeanDescription mockBeanDesc5 = new MockBeanDescription(); MockBeanDeserializer mockBeanDeserializer = new MockBeanDeserializer(); MockDeserializerFactoryConfig mockDeserializerFactoryConfig = new MockDeserializerFactoryConfig(); mockDeserializerFactoryConfig.setAbstractTypeResolvers(Collections.singleton(resolver)); mockDeserializerFactoryConfig.setAbstractTypeResolvers(Collections.singleton(resolver2)); mockDeserializerFactoryConfig.setFactoryConfig(mockFactoryConfig); MockDeserializerFactory mockDeserializer = new MockDeserializerFactory(); mockDeserializer.setBeanDescription
@Test public void testMaterializeAbstractType() throws JsonMappingException { BeanDescription beanDesc = new BeanDescription(); beanDesc.setBeanClass(MyBean.class); beanDesc.setBeanInterface(MyInterface.class); beanDesc.setBeanInterface(MyInterface.class); JavaType abstractType = MockFactory.class.getMethod("abstractMethod").getGenericReturnType(); MockFactory.configure(abstractType, null); DeserializationContext ctxt = mock(DeserializationContext.class); when(ctxt.getConfig()).thenReturn(mock(DeserializationConfig.class));.util.List<AbstractTypeResolver> abstractTypeResolvers = mock(List.class); when(abstractTypeResolvers.contains(MockFactory.class)).thenReturn(true); when(mockFactoryConfig.abstractTypeResolvers()).thenReturn(abstractTypeResolvers); _factoryConfig.abstractTypeResolvers = abstractTypeResolvers; _factoryConfig.defaultConcreteTypeResolvers = null; [LINE] protected AbstractTypeResolver[] abstractTypeResolvers = new AbstractTypeResolver[] { mock(AbstractTypeResolver.class) }; [LINE] protected JavaType materializeAbstractType(ctxt, JavaType type, beanDesc) throws JsonMapping
@Test public void testBeanDeserializerBuilder() throws Exception { BeanDescription beanDesc = new BeanDescription(); beanDesc.setInjectable(true); beanDesc.setInjectable(true); JsonDeserializer<Object> deserializer = builder.buildBeanDeserializer(new DeserializationContext(_ctxt, _beanDesc), JavaType.OBJECT, beanDesc); Object result = deserializer.deserialize(new StringReader(json)); assertEquals(result, obj); }
@Test public void shouldAddBeanProps() throws JsonMappingException { BeanDeserializerBuilder builder = new BeanDeserializerBuilder(); BeanDescription beanDesc = new BeanDescription(Foo.class); beanDesc.setFoo("foo"); beanDesc.setBar("bar"); beanDesc.setIgnoreUnknownProperties(true); beanDesc.setIgnoreSetter(true); beanDesc.setIgnoreGetter(true); beanDesc.setIgnoreSetter(false); beanDesc.setIgnoreGetter(false); beanDesc.setIgnoreSetter(true); beanDesc.setIgnoreSetter(false); beanDesc.setIgnoreGetter(true); beanDesc.setIgnoreSetter(false); beanDesc.setIgnoreSetter(false); beanDesc.setIgnoreGetter(true); beanDesc.setIgnoreSetter(false); beanDesc.setIgnoreSetter(false); beanDesc.setIgnoreSetter(true); beanDesc.setIgnoreSetter(false); beanDesc.setIgnoreGetter(true); beanDesc.setIgnoreSetter(false); beanDesc.setIgnoreSetter(false); beanDesc.setIgnoreSetter(true); beanDesc.setIgnoreSetter(false); beanDesc.setIgnoreGetter(true); beanDesc.setIgnoreSetter(false); beanDesc.
@Test public void should_set_property_name_on_setterless_property() throws JsonMappingException { class TestBean { public void test() { } } BeanDeserializerBuilder builder = new BeanDeserializerBuilder(); MockDeserializationContext ctxt = new MockDeserializationContext(new Properties(), null); BeanDescription beanDesc = new BeanDescription(TestBean.class, builder); new TestBean(ctxt, beanDesc).addBeanProps(ctxt, beanDesc, builder); }
@Test public void beanProps() throws JsonMappingException { BeanDeserializerBuilder builder = BeanDeserializerBuilder.newInstance(); MockDeserializationContext ctxt = MockDeserializationContext.deserialize(getClass().getResourceAsStream("/beanProps.json"), MockDeserializationContext.class); MockBeanDescription beanDesc = new MockBeanDescription(); beanDesc.setIgnoreUnknownProperties(true); beanDesc.setIgnoreProperties(new String[] {"foo"}); beanDesc.setBeanDeserializer(new MyBeanDeserializer()); beanDesc.setBeanDeserializer(new MyBeanDeserializer()); beanDesc.setBeanDeserializer(new MyBeanDeserializer()); beanDesc.setBeanDeserializer(new MyBeanDeserializer()); beanDesc.setBeanDeserializer(new MyBeanDeserializer()); beanDesc.setBeanDeserializer(new MyBeanDeserializer()); beanDesc.setBeanDeserializer(new MyBeanDeserializer()); beanDesc.setBeanDeserializer(new MyBeanDeserializer()); beanDesc.setBeanDeserializer(new MyBeanDeserializer()); beanDesc.setBeanDeserializer(new MyBeanDeserializer()); beanDesc.setBeanDeserializer(new MyBeanDeserializer()); beanDesc.setBeanDeserializer(new MyBeanDeserializer()); beanDesc.setBeanDeserializer(new MyBeanDeserializer()); beanDesc.setBeanDeserializer(new MyBeanDeserializer());
@Test public void testFilterBeanProps() throws JsonMappingException { class Test implements BeanDeserializer { public void init() { } } BeanDescription beanDesc = new BeanDescription(); beanDesc.setId("id"); beanDesc.setClass("name"); beanDesc.setSetter(new TestSetter()); beanDesc.setGetter(new TestGetter()); beanDesc.setSetter(new TestSetter()); beanDesc.setIgnored("ignored"); List<BeanPropertyDefinition> result = beanDesc.filterBeanProps(null, beanDesc, null, null); Assert.assertEquals(2, result.size()); Assert.assertEquals("id", result.get(0).getId()); Assert.assertEquals("name", result.get(1).getId()); Assert.assertEquals("name", result.get(2).getName()); }
public void testFilterBeanProps() throws JsonMappingException { BeanDeserializerBuilder builder = new BeanDeserializerBuilder(); BeanDeserializer beanDesc = new BeanDeserializerDeserializer(new Class[]{}, new Class[]{}, new Class[]{}, new Class[]{}, new Class[]{}, new Class[]{}, new Class[]{}, new Class[]{}, new Class[]{}, new Class[]{}, new Class[]{}, new Class[]{}, new Class[]{}, new Class[]{}, new Class[]{}, new Class[]{}, new Class[]{}, new Class[]{}, new Class[]{}, new Class[]{}, new Class[]{}, new Class[]{}, new Class[]{}, new Class[]{}, new Class[]{}, new Class[]{}, new Class[]{}, new Class[]{}, new Class[]{}, new Class[]{}, new Class[]{}, new Class[]{}, new Class[]{}, new Class[]{}, new Class[]{}, new Class[]{}, new Class[]{}, new Class[]{}, new Class[]{}, new Class[]{}, new Class[]{}, new Class[]{}, new Class[]{}, new Class[]{}, new Class[]{}, new Class[]{}, new Class[]{}, new Class[]{}, new Class[]{}, new Class[]{}, new Class[]{}, new Class[]{}, new Class[]{}, new Class[]{}, new Class[]{}, new Class[]{
@Test public void testFilterBeanProps() throws JsonMappingException { class Test implements BeanDeserializer { public void init() { } } BeanDescription beanDesc = new BeanDescription(); beanDesc.setId("id"); beanDesc.setClass("name"); beanDesc.setSetter(new TestSetter()); beanDesc.setGetter(new TestGetter()); beanDesc.setSetter(new TestSetter()); beanDesc.setIgnored("ignored"); List<BeanPropertyDefinition> result = beanDesc.filterBeanProps(null, beanDesc, null, null); Assert.assertEquals(2, result.size()); Assert.assertEquals("id", result.get(0).getId()); Assert.assertEquals("name", result.get(1).getId()); Assert.assertEquals("name", result.get(2).getName()); }
@Test public void testConstructSettableProperty() throws JsonMappingException { BeanDescription beanDesc = new BeanDescription(); beanDesc.addProperty(new BeanProperty.Std("required", null)); beanDesc.addProperty(new BeanProperty.Std("optional", null)); beanDesc.addProperty(new BeanProperty.Std("optional2", null)); BeanProperty property = constructSettableProperty(ctxt, beanDesc, beanDesc.getBeanPropertyDefinition(), JavaTypes.get(String.class)); assertNotNull(property); assertEquals("required", property.getType().toString()); }
@Test public void testConstructSetterlessProperty() throws Exception { BeanPropertyDefinition propDef = new BeanPropertyDefinition(beanDesc, "prop1", "prop2", "prop3"); DeserializationContext ctxt = mock(DeserializationContext.class); BeanDescription beanDesc = mock(BeanDescription.class); when(beanDesc.bindingsForBeanType()).thenReturn(beanType); when(ctxt.canOverrideAccessModifiers()).thenReturn(true); when(ctxt.canOverrideType()).thenReturn(false); when(ctxt.canOverrideValueModifiers()).thenReturn(true); when(ctxt.canOverrideValue()).thenReturn(false); when(ctxt.canOverrideValue()).thenReturn(true); when(ctxt.canOverrideValue()).thenReturn(false); [LINE] public Class<? extends Annotation> annotationType() { return null; } [LINE] public SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, AnnotatedMethod getter, Class<?> type) throws JsonMappingException { return null; } [LINE] public SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, AnnotatedMethod getter, Class<?> type2) throws JsonMappingException { return null; } [LINE] public SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt,
@Test public void testConstructSetterlessProperty() throws JsonMappingException { class BeanBean extends BeanBean { @JsonProperty("name") public String name() { return "name"; } } BeanDescription beanDesc = new BeanDescription(new BeanBean()); BeanPropertyDefinition propDef = new BeanPropertyDefinition(beanDesc, "name"); DeserializationContext ctxt = mock(DeserializationContext.class); when(ctxt.canOverrideAccessModifiers()).thenReturn(true); when(ctxt.getType(beanDesc.bindingsForBeanType())).thenReturn(JavaType.of(String.class)); when(ctxt.getTypeHandler()).thenReturn(mock(TypeDeserializer.class)); when(ctxt.canOverrideValueModifiers()).thenReturn(true); BeanDeserializer<String> beanDeser = mock(BeanDeserializer.class); when(beanDeser.getTypeHandler()).thenReturn(beanDeser); when(beanDesc.getAnnotations()).thenReturn(new Annotation[] { MockBean.class }); AnnotatedMethod getter = PropertyUtils.getPropertyGetter(beanDesc, "name"); [LINE] final SettableBeanProperty setter = constructSetterlessProperty(ctxt, beanDesc, propDef); setter.setName("name"); setter.setValue("value"); setter.fixAccess();
@Test public void testConstructSetterlessProperty() throws Exception { BeanDescription beanDesc = new BeanDescription(); beanDesc.bindingsForBeanType("com.foo.Bar"); beanDesc.bindingsForBeanType("com.foo.Bar"); BeanPropertyDefinition propDef = new BeanPropertyDefinition(); BeanPropertyDefinition setterlessPropDef = new BeanPropertyDefinition(); setterlessPropDef.setGetter(propDef.getGetter()); setterlessPropDef.setType(String.class); setterlessPropDef.setAnnotation(SettableBeanProperty.class.getAnnotation(SetterlessProperty.class)); DeserializationContext ctxt = mock(DeserializationContext.class); when(ctxt.canOverrideAccessModifiers()).thenReturn(true); when(ctxt.getType(beanDesc.bindingsForBeanType())).thenReturn(JavaType.of(String.class)); SettableBeanProperty setterlessProp = constructSetterlessProperty(ctxt, beanDesc, propDef); assertEquals("bar", setterlessProp.getValue()); }
@Test public void testConstructSetterlessProperty() throws Exception { BeanPropertyDefinition def = new BeanPropertyDefinition(beanDesc, "name", "string", "string", true); setter.setType(String.class); setter.set("name", "string"); setter.set("true", true); setter.set("false", false); setter.set("null", null); BeanProperty bean = new BeanProperty(beanDesc, "name", "string", "string", false); setter.setType(String.class); bean.set("true", true); setter.set("false", false); setter.set("null", null); setter.set("null", null); setter.set("null", null); setter.set("false", true); setter.set("null", null); setter.set("null", null); setter.set("null", null); setter.set("null", null); setter.set("null", null); setter.set("null", null); setter.set("null", null); setter.set("null", null); setter.set("null", null); setter.set("null", null); setter.set("null", null); setter.set("null", null); setter
@Test public void testConstructSetterlessProperty() throws Exception { BeanDescription beanDesc = new BeanDescription(); beanDesc.addProperty(new AnnotatedMethod(SetterlessBean.class.getMethod("setFoo", String.class), "bar")); beanDesc.addProperty(new AnnotatedMethod(SetterlessBean.class.getMethod("setBar", String.class), "baz")); beanDesc.addProperty(new AnnotatedMethod(SetterlessBean.class.getMethod("setBar", String.class), "qux")); BeanPropertyDefinition propDef = new BeanPropertyDefinition(beanDesc); BeanDeserializerFactory factory = BeanDeserializerFactory.newInstance(); DeserializationContext ctxt = new DeserializationContext(beanDesc, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null); SettableBean
@Test public void testSetterlessProperty() throws Exception { BeanDescription beanDesc = new BeanDescription(BindingsForBeanType.class, "testBean"); beanDesc.addProperty(new AnnotatedMethod(TestBean.class.getMethod("setTest", String.class), "testValue")); beanDesc.addProperty(new AnnotatedMethod(TestBean.class.getMethod("setTest2", Integer.class), "testValue2")); beanDesc.addProperty(new AnnotatedMethod(TestBean.class.getMethod("test3", String.class), "testValue3")); beanDesc.addProperty(new AnnotatedMethod(TestBean.class.getMethod("test4", Integer.class), "testValue4")); beanDesc.addProperty(new AnnotatedMethod(TestBean.class.getMethod("test5"), "testValue5")); beanDesc.addProperty(new AnnotatedMethod(TestBean.class.getMethod("test6"), "testValue6")); beanDesc.addProperty(new AnnotatedMethod(TestBean.class.getMethod("test7"), "testValue7")); beanDesc.addProperty(new AnnotatedMethod(TestBean.class.getMethod("test8"), "testValue8")); beanDesc
@Test public void testSetterlessProperty() throws Exception { BeanDescription beanDesc = new BeanDescription(); beanDesc.bindingsForBeanType("com.foo.Bar"); beanDesc.methodsForSetterless(); BeanPropertyDefinition propDef = new BeanPropertyDefinition(beanDesc, "bar"); DeserializationContext ctxt = new DeserializationContext(new DefaultObjectMapper()); SettableBeanProperty setterlessProperty = new SettableBeanProperty(propDef, JavaType.DEFAULT, null, beanDesc.getClassAnnotations(), null); setterlessProperty.setField("bar"); setterlessProperty.setMethod("method"); setterlessProperty.setType(JavaType.DEFAULT); setterlessProperty.setGetter(propDef); setterlessProperty.setField("baz"); setterlessProperty.setField("qux"); setterlessProperty.setField("qux"); setterlessProperty.setField("qux"); setterlessProperty.setField("qux"); setterlessProperty.setField("qux"); setterlessProperty.setField("qux"); setterlessProperty.setField("qux"); setterlessProperty.setField("qux"); setterlessProperty.setField("qux"); setterlessProperty.setField("qux");
@Test public void testConstructSetterlessProperty() throws Exception { BeanDescription beanDesc = new BeanDescription(); beanDesc.bindingsForBeanType("com.foo.Bar"); beanDesc.getSetterlessAnnotations().add(new Annotation("set")); beanDesc.getSetterlessAnnotations().add(new Annotation("set")); BeanPropertyDefinition propDef = new BeanPropertyDefinition(beanDesc, "bar"); DeserializationContext ctxt = mock(DeserializationContext.class); BeanDeserializer<Object> beanDeser = mock(BeanDeserializer.class); when(ctxt.canOverrideAccessModifiers()).thenReturn(true); when(ctxt.getType(beanDesc.bindingsForBeanType())).thenReturn(JavaType.of(Bar.class)); when(ctxt.getTypeHandler()).thenReturn(BeanDeserializer.class.getName()); SettableBeanProperty setterlessProp = new SettableBeanProperty(propDef, beanDesc, null); setterlessProp.setValueDeserializer(beanDeser); BeanPropertyDefinition setterlessPropDef2 = new BeanPropertyDefinition(beanDesc, "bar"); setterlessPropDef2.setGetter(new AnnotatedMethod(SetterlessProperty.class.getName(), "set")); setterlessPropDef2.setSetter(new AnnotatedMethod
@Test public void testConstructSetterlessProperty() throws Exception { BeanPropertyDefinition propDef = new BeanPropertyDefinition(BEAN_NAME, "name", "value"); BeanDescription beanDesc = new BeanDescription(beanDesc); BeanPropertyDefinition propDef2 = new BeanPropertyDefinition(BEAN_NAME, "name2", "value2"); DeserializationContext ctxt = mock(DeserializationContext.class); when(ctxt.canOverrideAccessModifiers()).thenReturn(true); when(ctxt.getType(beanDesc.bindingsForBeanType())).thenReturn(JavaType.of(String.class)); SettableBeanProperty prop = setter.constructSetterlessProperty(ctxt, beanDesc, propDef2); assertEquals("name2", prop.propertyName); assertEquals("value2", prop.propertyValue); }
@Test public void testConstructSetterlessProperty() throws Exception { BeanDescription beanDesc = new BeanDescription(); beanDesc.bindingsForBeanType("com.example.Foo"); BeanPropertyDefinition propDef = new BeanPropertyDefinition(beanDesc, "prop"); SettableBeanProperty setter = constructSetterlessProperty(ctxt, beanDesc, propDef); Assert.assertEquals("prop", setter.property); }
@Test public void constructSetterlessProperty() throws Exception { BeanDescription beanDesc = new BeanDescription(TestBean.class); BeanPropertyDefinition propDef = new BeanPropertyDefinition(TestBean.class, "name", "string"); SettableBeanProperty expected = new SettableBeanProperty( new BeanPropertyDefinition(TestBean.class, "name", "string"), new TypeDeserializer<TestBean>(), null); BeanDeserializer<TestBean> deserializer = beanDesc.bindingsForBeanType(); DeserializationContext ctxt = mock(DeserializationContext.class); when(ctxt.canOverrideAccessModifiers()).thenReturn(true); when(ctxt.getDeserializer()).thenReturn(deserializer); when(deserializer.getType(eq(TestBean.class))).thenReturn(JavaType.of(String.class)); BeanDeserializerFactoryConfig config = new BeanDeserializerFactoryConfig(false); BeanDeserializer<TestBean> beanDeser = new BeanDeserializer<TestBean>(config); BeanDeserializer<TestBean> beanDeserializerFactory = new BeanDeserializer<TestBean>(beanDesc, beanDeser, config); DeserialDeserializer<TestBean> deserial = new DeserialDeserializer<TestBean>(deserial); SettableBeanProperty beanProperty
@Test public void testSimpleFilterProvider() { new SimpleFilterProvider().addFilter("id", new SimpleFilterProvider().addFilter("id2", new SimpleFilterProvider().addFilter("id3", new SimpleFilterProvider().addFilter("id4", new SimpleFilterProvider().addFilter("id5", new SimpleFilterProvider().addFilter("id6", new SimpleFilterProvider().addFilter("id7", new SimpleFilterProvider().addFilter("id8", new SimpleFilterProvider().addFilter("id9", new SimpleFilterProvider().addFilter("id10", new SimpleFilterProvider().addFilter("id11", new SimpleFilterProvider().addFilter("id20", new SimpleFilterProvider().addFilter("id21", new SimpleFilterProvider().addFilter("id22", new SimpleFilterProvider().addFilter("id22", new SimpleFilterProvider().addFilter("id23", new SimpleFilterProvider().addFilter("id24", new SimpleFilterProvider().addFilter("id24", new SimpleFilterProvider().addFilter("id40", new SimpleFilterProvider().addFilter("id40", new SimpleFilterProvider().addFilter("id40", new SimpleFilterProvider().addFilter("id41", new SimpleFilterProvider().addFilter("
@Test public void testSimpleFilterProvider() { new SimpleFilterProvider().addFilter("id", new DummyFilter()); new SimpleFilterProvider().addFilter("id2", new DummyFilter()); new SimpleFilterProvider().addFilter("id3", new DummyFilter()); new SimpleFilterProvider().addFilter("id4", new DummyFilter()); new SimpleFilterProvider().addFilter("id5", new DummyFilter()); new SimpleFilterProvider().addFilter("id6", new DummyFilter()); new SimpleFilterProvider().addFilter("id7", new DummyFilter()); new SimpleFilterProvider().addFilter("id8", new DummyFilter()); new SimpleFilterProvider().addFilter("id9", new DummyFilter()); new SimpleFilterProvider().addFilter("id10", new DummyFilter()); new SimpleFilterProvider().addFilter("id2", new DummyFilter()); new SimpleFilterProvider().addFilter("id3", new DummyFilter()); new SimpleFilterProvider().addFilter("id4", new DummyFilter()); new SimpleFilterProvider().addFilter("id5", new DummyFilter()); new SimpleFilterProvider().addFilter("id6", new DummyFilter()); new SimpleFilterProvider().addFilter("id7", new DummyFilter()); new SimpleFilterProvider().addFilter("id8", new DummyFilter
@Test public void testSimpleFilterProvider() { SimpleFilterProvider provider = new SimpleFilterProvider(); provider.addFilter("id", new SimpleFilterProvider.DefaultFilter()); provider.addFilter("id2", new SimpleFilterProvider.Filter()); provider.addFilter("id3", new SimpleFilterProvider.Filter()); provider.addFilter("id4", new SimpleFilterProvider.Filter()); provider.addFilter("id5", new SimpleFilterProvider.Filter()); provider.addFilter("id6", new SimpleFilterProvider.Filter()); provider.addFilter("id7", new SimpleFilterProvider.Filter()); provider.addFilter("id8", new SimpleFilterProvider.Filter()); provider.addFilter("id9", new SimpleFilterProvider.Filter()); provider.addFilter("id10", new SimpleFilterProvider.Filter()); provider.addFilter("id11", new SimpleFilterProvider.Filter()); provider.addFilter("id12", new SimpleFilterProvider.Filter()); provider.addFilter("id13", new SimpleFilterProvider.Filter()); provider.addFilter("id14", new SimpleFilterProvider.Filter()); provider.addFilter("id15", new SimpleFilterProvider.Filter()); provider.addFilter("id16", new SimpleFilterProvider.Filter());
@Test public void testSimpleFilterProvider() { SimpleFilterProvider provider = new SimpleFilterProvider(); provider.addFilter("id", new SimpleFilterProvider.DefaultFilter()); provider.addFilter("id2", new SimpleFilterProvider.DefaultFilter()); provider.addFilter("id3", new SimpleFilterProvider.DefaultFilter()); provider.addFilter("id4", new SimpleFilterProvider.DefaultFilter()); provider.addFilter("id5", new SimpleFilterProvider.DefaultFilter()); provider.addFilter("id6", new SimpleFilterProvider.DefaultFilter()); provider.addFilter("id7", new SimpleFilterProvider.DefaultFilter()); provider.addFilter("id8", new SimpleFilterProvider.DefaultFilter()); provider.addFilter("id9", new SimpleFilterProvider.DefaultFilter()); provider.addFilter("id10", new SimpleFilterProvider.DefaultFilter()); provider.addFilter("id11", new SimpleFilterProvider.DefaultFilter()); provider.addFilter("id12", new SimpleFilterProvider.DefaultFilter()); provider.addFilter("id13", new SimpleFilterProvider.DefaultFilter()); provider.addFilter("id14", new SimpleFilterProvider.DefaultFilter()); provider.addFilter("id15", new SimpleFilterProvider.DefaultFilter());
@Test public void addFilter() { SimpleFilterProvider f = new SimpleFilterProvider(); f.addFilter("id", new DummyFilter()); f.addFilter("id2", new DummyFilter()); f.addFilter("id3", new DummyFilter()); f.addFilter("id4", new DummyFilter()); f.addFilter("id5", new DummyFilter()); f.addFilter("id6", new DummyFilter()); f.addFilter("id7", new DummyFilter()); f.addFilter("id8", new DummyFilter()); f.addFilter("id9", new DummyFilter()); f.addFilter("id10", new DummyFilter()); f.addFilter("id11", new DummyFilter()); f.addFilter("id12", new DummyFilter()); f.addFilter("id13", new DummyFilter()); f.addFilter("id14", new DummyFilter()); f.addFilter("id15", new DummyFilter()); f.addFilter("id16", new DummyFilter()); f.addFilter("id17", new DummyFilter()); f.addFilter("id18", new DummyFilter()); f.addFilter("id19", new DummyFilter()); f.addFilter("id21", new DummyFilter()); f.add
@Test public void testAddFilter() { SimpleFilterProvider provider = new SimpleFilterProvider(); provider.addFilter("id", new TestFilter()); SimpleFilterProvider provider2 = new SimpleFilterProvider(); provider2.addFilter("id2", new TestFilter()); provider.addFilter("id3", new TestFilter()); provider2.addFilter("id4", new TestFilter()); provider2.addFilter("id5", new TestFilter()); provider2.addFilter("id6", new TestFilter()); provider2.addFilter("id7", new TestFilter()); provider2.addFilter("id8", new TestFilter()); provider2.addFilter("id9", new TestFilter()); provider2.addFilter("id10", new TestFilter()); provider2.addFilter("id11", new TestFilter()); provider2.addFilter("id12", new TestFilter()); SimpleFilterProvider provider3 = new SimpleFilterProvider(); provider3.addFilter("id1", new TestFilter()); provider3.addFilter("id2", new TestFilter()); SimpleFilterProvider provider4 = new SimpleFilterProvider(); provider4.addFilter("id1", new TestFilter()); provider4.addFilter("id2", new TestFilter()); provider4.addFilter("id3", new TestFilter()); SimpleFilterProvider provider5 = new SimpleFilterProvider
@Test public void addFilter() { SimpleFilterProvider provider = new SimpleFilterProvider(); provider.addFilter("id", new DummyFilter()); SimpleFilterProvider provider2 = new SimpleFilterProvider(); provider2.addFilter("id2", new DummyFilter()); provider.addFilter("id3", new DummyFilter()); provider2.addFilter("id4", new DummyFilter()); SimpleFilterProvider provider3 = new SimpleFilterProvider(); provider3.addFilter("id3", new DummyFilter()); provider3.addFilter("id4", new DummyFilter()); provider3.addFilter("id5", new DummyFilter()); provider3.addFilter("id6", new DummyFilter()); SimpleFilterProvider provider4 = new SimpleFilterProvider(); provider4.addFilter("id1", new DummyFilter()); provider4.addFilter("id2", new DummyFilter()); SimpleFilterProvider provider5 = new SimpleFilterProvider(); provider5.addFilter("id3", new DummyFilter()); SimpleFilterProvider filter4 = new SimpleFilterProvider(); filter4.addFilter("id4", new DummyFilter()); filter4.addFilter("id5", new DummyFilter()); filter4.addFilter("id6", new DummyFilter()); SimpleFilterProvider filter5 = new SimpleFilterProvider(); filter5.addFilter("id5", new DummyFilter()); filter5.addFilter("
@Test public void testFindFilter() { SimpleFilterProvider f = new SimpleFilterProvider(); f.setDefaultFilter(new SimpleFilterProvider()); f.addFilter("foo", new SimpleFilterProvider().setDefaultFilter(new SimpleFilterProvider())); f.addFilter("bar", new SimpleFilterProvider().addFilter("baz", new SimpleFilterProvider().setDefaultFilter(new SimpleFilterProvider())); assertEquals(f.findFilter("foo"), new SimpleFilterProvider().findFilter("foo")); assertEquals(f.findFilter("bar"), new SimpleFilterProvider().findFilter("baz")); assertEquals(f.findFilter("baz"), new SimpleFilterProvider().findFilter("bar")); }
@Test public void testFindFilter() { SimpleFilterProvider f = new SimpleFilterProvider(); f.addFilter("foo", new SimpleFilterProviderTest.FilterProvider()); f.addFilter("bar", new SimpleFilterProviderTest.FilterProvider()); f.addFilter("baz", new SimpleFilterProviderTest.FilterProvider()); assertEquals(f.findFilter("foo"), new SimpleFilterProviderTest.FilterProvider().findFilter("bar")); assertEquals(f.findFilter("baz"), new SimpleFilterProviderTest.FilterProvider().findFilter("baz")); }
@Test public void testFindFilter() { SimpleFilterProvider f = new SimpleFilterProvider(); f.addFilter("test", new TestFilterProvider()); f.addFilter("test2", new TestFilterProvider()); f.addFilter("test3", new TestFilterProvider()); f.addFilter("test4", new TestFilterProvider()); f.addFilter("test5", new TestFilterProvider()); f.addFilter("test6", new TestFilterProvider()); f.addFilter("test7", new TestFilterProvider()); f.addFilter("test8", new TestFilterProvider()); f.addFilter("test9", new TestFilterProvider()); f.addFilter("test10", new TestFilterProvider()); f.addFilter("test11", new TestFilterProvider()); f.addFilter("test12", new TestFilterProvider()); f.addFilter("test13", new TestFilterProvider()); f.addFilter("test14", new TestFilterProvider()); f.addFilter("test15", new TestFilterProvider()); f.addFilter("test16", new TestFilterProvider()); f.addFilter("test21", new TestFilterProvider()); f.addFilter("test22", new TestFilterProvider()); f.addFilter("test23",
@Test public void testFindFilter() { SimpleFilterProvider f = new SimpleFilterProvider(); f.setDefaultFilter(new SimpleFilterProvider()); f.addFilter("foo", new SimpleFilterProvider().setDefaultFilter(new SimpleFilterProvider())); f.addFilter("bar", new SimpleFilterProvider().addFilter("baz", new SimpleFilterProvider().setDefaultFilter(new SimpleFilterProvider())); f.findFilter("foo"); f.findFilter("bar"); f.findFilter("baz"); f.findFilter("bar"); f.findFilter("baz"); }
@Test public void testWithType() throws Exception { new Expectations() { { new Std(NAME, type, WRAP_NAME, contextAnnotations, null, true); } }; new Expectations() { { new Std(NAME, type, WRAP_NAME, contextAnnotations, null, true); } }; new Expectations() { { new Std(NAME, type, WRAP_NAME, contextAnnotations, null, true); } }; new Expectations() { { new Std(NAME, type, WRAP_NAME, contextAnnotations, null, true); } }; new Expectations() { { new Std(NAME, type, WRAP_NAME, contextAnnotations, null, true); } }; new Expectations() { { new Std(NAME, type, WRAP_NAME, contextAnnotations, null, true); } }; new Expectations() { { new Std(NAME, type, WRAP_NAME, contextAnnotations, null, true); } }; new Expectations() { { new Std(NAME, type, WRAP_NAME, contextAnnotations, null, true); } }; new Expectations() { { new Std(NAME, type, WRAP_NAME, contextAnnotations, null, true); } }; new Expectations() { { new Std(NAME,
@Test public void testWithType() throws Exception { Std s = new Std("name", JavaType.OBJECT, new PropertyName("wrapperName"), new Annotations(), new AnnotatedMember(Collections.emptyList()), true); assertEquals(s.withType(JavaType.OBJECT), new Std("name", JavaType.OBJECT, new PropertyName("wrapperName"), new Annotations(), new AnnotatedMember(Collections.emptyList()), true)); }
@Test public void serializeWithType_null() throws IOException, JsonGenerationException { String value = null; new EqualsSerializer().serializeWithType(value, jgen, null, null); }
@Test public void serializeWithType_typePrefixAndSuffix_should_be_serialized_correctly() throws IOException, JsonGenerationException { new ToStringSerializer().serializeWithType("value", jgen, null, null); verify(typeSer).writeTypePrefixForScalar("value", jgen); verify(typeSer).writeTypeSuffixForScalar("value", jgen); }
@Test public void serializeWithType_double() throws IOException { String value = "42"; JsonGenerator jgen = mock(JsonGenerator.class); new ToStringSerializer().serializeWithType(value, jgen, null, null); verify(jgen).writeString(value); }
@Test public void serializeWithType_typePrefixAndSuffix_works() throws Exception { new EqualsSerializer() { @Override public void serialize(Object value, JsonGenerator jgen, JsonGenerationException ex) throws IOException, JsonGenerationException { ex.printStackTrace(); } }.serializeWithType("value", jgen, null, null); }
@Test public void test_withAlwaysAsId() { ObjectIdWriter w = ObjectIdWriter.construct(JavaType.INT, SerializedString.EMPTY, ObjectIdGenerator.INSTANCE, SERIALIZER, true).withAlwaysAsId(true); w.withAlwaysAsId(false); w.withAlwaysAsId(true); }
@Test public void test_withAlwaysAsId() { ObjectIdWriter w = ObjectIdWriter.construct(JavaType.INT, "foo", new TestObjectIdGenerator(), new JsonSerializer<?>(), true); w.withAlwaysAsId(true); w.withAlwaysAsId(false); w.withAlwaysAsId(true); }
@Test public void testWithAlwaysAsId() { ObjectIdWriter w = ObjectIdWriter.construct(JavaType.OBJECT, SerializedString.EMPTY, ObjectIdGenerators.generatingGenerator(Generators.reverseOrder()), null, false); w.withAlwaysAsId(true); w.withAlwaysAsId(false); w.withAlwaysAsId(true); assertEquals(ObjectIdWriter.construct(JavaType.OBJECT, SerializedString.EMPTY, ObjectIdGenerators.generatingGenerator(Generators.reverseOrder()), null, false), w); }
@Test public void test_withAlwaysAsId() { ObjectIdWriter w = new ObjectIdWriter(JavaType.INTEGER, SerializedString.EMPTY, ObjectIdGenerator.INSTANCE, true); w.withAlwaysAsId(true); w.withAlwaysAsId(false); }
@Test public void testMap() throws Exception { Map map = new Map(); map.put("a", "value"); map.put("b", "value"); map.put("c", "value"); assertEquals("{\"a\":\"value\",\"b\":\"value\"}", map.toString()); }
@Test public void map() throws Exception { Map map = new Map(next, value, "foo"); assertEquals("foo", map.get("foo")); assertEquals("bar", map.get("bar")); }
@Test public void map() { Map map = new Map(next, value, "foo"); assertEquals(map._key, "foo"); assertEquals(map.get("foo"), "foo"); }
@Test public void testAssign() throws IOException, JsonProcessingException { Map<String, Object> bean = new HashMap<>(); bean.put("a", "a"); bean.put("b", "b"); bean.put("c", "c"); new Regular(next, "a", bean).assign(bean); assertEquals("a", bean.get("a")); assertEquals("b", bean.get("b")); assertEquals("c", bean.get("c")); }
@Test public void testAssign() throws IOException, JsonProcessingException { Map<String, Object> bean = new HashMap<>(); ((Map<String, Object>) bean).put("a", "a"); new Regular(next, "a", (SettableBeanProperty) null).put("b", "b"); new Any(next, "b", (SettableAnyProperty) null).assign(bean); assertEquals("a", bean.get("a")); assertEquals("b", bean.get("b")); assertEquals("b", bean.get("b")); }
@Test public void testBasicSerializerFactoryConfig() { JsonSerializer<?> serializer = new JsonSerializer<Object>((JsonSerializer<?>) new JavaTypeSerializer(String.class)); serializer.serialize("key", "value"); serializer.serialize("key", "value"); serializer.serialize("key", "value"); serializer.serialize("key", "value"); serializer.serialize("key", "value"); serializer.serialize("key", "value"); serializer.serialize("key", "value"); serializer.serialize("key", "value"); serializer.serialize("key", "value"); serializer.serialize("key", "value"); }
@Test public void testBasicSerializerFactoryConfig() { JsonSerializer<Object> serializer = new JsonSerializer<Object>("\"key\""); JsonSerializerProvider provider = new JsonSerializerProvider(); SerializerFactoryConfig config = new DefaultSerializerFactoryConfig(); config.setUseSerializedFields(true); config.setUseSerializedMethods(true); config.setUseSerializedMethods(true); BasicSerializerFactory basicSerializerFactory = new BasicSerializerFactory(config); serializer.serialize("key", "value"); serializer.serialize("key", "value"); serializer.serialize("key", "value"); serializer.serialize("key", "value"); serializer.serialize("key", "value"); serializer.serialize("key", "value"); serializer.serialize("key", "value"); serializer.serialize("key", "value"); serializer.serialize("key", "value"); serializer.serialize("key", "value"); serializer.serialize("key", "value"); serializer.serialize("key", "value"); serializer.serialize("key", "value"); serializer.serialize("key", "value"); serializer.serialize("key", "value"); }
@Test public void testWithSerializerModifier() { JsonSerializer<?> serializer = new BasicSerializerFactory(new JsonSerializerConfig()).withSerializerModifier(BeanSerializerModifier.APPEND); JsonSerializer<?> deserializer = new BasicSerializerFactory(new JsonSerializerConfig()).withSerializerModifier(BeanSerializerModifier.DELETE); assertEquals(serializer, deserializer); }
@Test public void testBeanSerializerModifier() { JsonSerializer<?> serializer = new BasicSerializerFactory(new JsonSerializerFactoryConfig()).withSerializerModifier(BeanSerializerModifier.PUBLIC); assertEquals(BasicSerializerFactory.class, serializer.getClass()); JsonSerializer<?> innerSerializer = serializer.getSerializer(); assertEquals(BasicSerializerFactory.class, innerSerializer.getClass()); JsonSerializer<?> innerInner = innerSerializer.getSerializer(); assertEquals(BasicSerializerFactory.class, innerInner.getClass()); }
@Test public void testFindSerializerByAnnotations() throws Exception { BeanDescription beanDesc = new BeanDescription(); beanDesc.setAnnotated(Foo.class.getDeclaredMethod("findSerializerByAnnotations")); beanDesc.setAnnotated(Bar.class.getDeclaredMethod("findSerializerByAnnotations")); JsonSerializer<?> serializer = beanDesc.findSerializerByAnnotations(null, null, beanDesc); assertThat(serializer).isNotNull(); assertThat(serializer.getClass().getCanonicalName()).isEqualTo("org.apache.cxf.tools.fortest.JsonSerializer"); }
@Test public void testFindSerializerByAnnotations() throws Exception { BeanDescription beanDesc = new BeanDescription(); beanDesc.setCanOverrideAccessModifiers(true); @SuppressWarnings("unchecked") JsonSerializer<?> serializer = (JsonSerializer<?>) BasicSerializerFactory.findSerializerByAnnotations(prov, JavaType.get(String.class), beanDesc); assertThat(serializer).isNotNull(); }
@Test public void testFindSerializerByAnnotations() throws Exception { BeanDescription beanDesc = new BeanDescription(); beanDesc.setBeanName("testBean"); beanDesc.setBeanClass(TestBean.class); @SuppressWarnings("unchecked") JsonSerializer<?> serializer = (JsonSerializer<?>) BasicSerializerFactory.getFactory(beanDesc).findSerializerByAnnotations(prov, JavaType.getBeanType(), beanDesc); assertThat(serializer).isNotNull(); }
@Test public void findSerializerByAnnotations_annotation_returns_SerializableSerializer_instance() throws Exception { BeanDescription beanDesc = new BeanDescription(); beanDesc.setAnnotated(JsonSerializable.class.getDeclaredMethod("jsonSerializable")); beanDesc.setBeanDescription(beanDesc); JsonSerializer<?> serializer = beanDesc.findSerializerByAnnotations(prov, JsonSerializable.class, beanDesc); assertThat(serializer).isInstanceOf(SerializableSerializer.class); }
@Test public void testFindSerializerByAnnotations() throws Exception { BeanDescription beanDesc = new BeanDescription(); beanDesc.setAnnotated(Foo.class.getDeclaredMethod("bar")); beanDesc.setAnnotated(Bar.class.getDeclaredMethod("baz")); JsonSerializer<?> serializer = beanDesc.findSerializerByAnnotations(null, Bar.class, beanDesc); assertThat(serializer).isNotNull(); assertThat(serializer.getClass().getCanonicalName()).isEqualTo("com.github.karafaultyler.bar"); }
@Test public void testFindSerializerByPrimaryType() throws Exception { JsonSerializer<?> ser = findSerializerByPrimaryType(null, Date.class, null, false); assertThat(ser).isInstanceOf(DateSerializer.class); }
@Test public void testBuildCollectionSerializer() throws Exception { beanDesc = new BeanDescription(); beanDesc.setType(String.class); beanDesc.setFormat(JsonFormat.Value.STRING); JsonSerializer<?> ser = mock(JsonSerializer.class); when(ser.findCollectionSerializer(any(SerializationConfig.class), eq(String.class), eq(beanDesc), eq(null), eq(null))).thenReturn(ser); mockStaticType(ser); JsonSerializer<?> actual = buildCollectionSerializer(SerializationConfig.DEFAULT, null, beanDesc, false, null, null); assertEquals(actual, null); }
@Test public void testBuildMapSerializer() throws Exception { BeanDescription beanDesc = new BeanDescription(); beanDesc.setBeanName("testMap"); JsonSerializer<?> mapSerializer = mock(JsonSerializer.class); when(mapType.findMapSerializer(any(SerializationConfig.class), any(BeanDescription.class), any(Boolean.class), any(JsonSerializer.class), any(TypeSerializer.class))).thenReturn(mapSerializer); when(mapSerializer.build(any(SerializationConfig.class), any(BeanDescription.class), any(Boolean.class), any(TypeSerializer.class), any(TypeSerializer.class))).thenReturn(null); JsonSerializer<?> ser = serializers.findMapSerializer(null, mapType, beanDesc, false, null, null); verify(mapSerializer).build(null, beanDesc); verify(mapSerializer).build(null, beanDesc); verify(mapSerializer).build(null, beanDesc); }
@Test public void testBuildMapSerializer() throws Exception { ObjectMapper mapper = new ObjectMapper(); mapper.configure(SerializationConfig.NONE, new Properties()); mapper.configure(SerializationConfig.JSON_SERIALIZER, new JsonSerializerFactory()); mapper.configure(SerializationConfig.JSON_SERIALIZER, new JsonSerializerFactory()); mapper.configure(SerializationConfig.JSON_SERIALIZER, new JsonSerializerFactory()); mapper.configure(SerializationConfig.JSON_SERIALIZER, new JsonSerializerFactory()); mapper.configure(SerializationConfig.JSON_SERIALIZER, new JsonSerializerFactory()); mapper.configure(SerializationConfig.JSON_SERIALIZER, new JsonSerializerFactory()); mapper.configure(SerializationConfig.JSON_SERIALIZER, new JsonSerializerFactory()); mapper.configure(SerializationConfig.JSON_SERIALIZER, new JsonSerializerFactory()); mapper.configure(SerializationConfig.JSON_SERIALIZER, new JsonSerializerFactory()); mapper.configure(SerializationConfig.JSON_SERIALIZER, new JsonSerializerFactory()); mapper.configure(SerializationConfig.JSON_SERIALIZER, new JsonSerializerFactory()); mapper.configure(SerializationConfig.JSON_SERIALIZER, new JsonSerializerFactory()); mapper.configure(SerializationConfig.JSON_
@Test public void testBuildArraySerializer() throws Exception { ArrayType arrayType = (ArrayType) TypeRegistry.getType(ArrayType.class, "array"); BeanDescription beanDesc = mock(BeanDescription.class); when(beanDesc.getBeanType()).thenReturn(arrayType); when(arrayType.getRawClass()).thenReturn(String[].class); JsonSerializer<?> serializer = mock(JsonSerializer.class); when(serializer.findArraySerializer(any(SerializationConfig.class), eq(arrayType), eq(beanDesc), eq(null), eq(null))).thenReturn(serializer); when(serializer.serialize(any(Class.class), eq(beanDesc), eq(null))).thenReturn("foo"); JsonSerializer<?> actualSerializer = mock(JsonSerializer.class); when(actualSerializer.serialize(any(Class.class), eq(beanDesc), eq(null))).thenReturn("bar"); JsonSerializer<?> expectedSerializer = mock(JsonSerializer.class); when(actualSerializer.serialize(any(Class.class), eq(beanDesc), eq(expectedSerializer))).thenReturn("bar"); when(serializer.buildArraySerializer(any(SerializationConfig.class), eq(arrayType), eq(bean
@Test public void testBuildArraySerializer() throws Exception { String[] array = new String[]{"a", "b", "c"}; TypeSerializer[] serializers = new TypeSerializer[] { StringArraySerializer.instance, StringArraySerializer.instance, StringArraySerializer.instance }; JsonSerializer<?> serializer = ArrayType.array(array); assertEquals(ArraySerializer.instance, serializer); mapper.setSerializationConfig(SerializationConfig.DEFAULT); JsonSerializer<?> actualSerializer = serializer.buildArraySerializer(SerializationConfig.DEFAULT, null, false, serializers, null); assertEquals(ArraySerializer.instance, actualSerializer); }
@Test public void testBuildIteratorSerializer() throws Exception { TypeSerializer valueTypeSerializer = TypeFactory.unknownType(); BeanDescription beanDesc = mock(BeanDescription.class); when(beanDesc.getSerializerType()).thenReturn(ValueType.STRING); JsonSerializer<?> serializer = serialization.buildIteratorSerializer(null, JavaType.STRING, beanDesc, false); assertThat(serializer).isEqualTo(ValueType.STRING); }
@Test public void testSettableAnyProperty() throws Exception { class Test { public void foo() { } } class Test2 extends Bean { public void foo() { } } class Test3 extends Bean { public void foo() { } } class Test4 extends Bean { public void foo() { } } class Test5 extends Bean { public void foo() { } } class Test6 extends Bean { public void foo() { } } class Test7 extends Bean { public void foo() { } } class Test8 extends Bean { public void foo() { } } class Test9 extends Bean { public void foo() { } } class Test10 extends Bean { public void foo() { } } class Test11 extends Bean { public void foo() { } } class Test12 extends Bean { public void foo() { } } class Test12_1 = new Test12(); class Test11_2 = new Test11(); class Test11_3 = new Test11(); class Test12_2 = new Test12(); } class Test11_3 = new Test11(); class Test12_4 = new Test12(); class Test12_5.setFoo(new Test12()); class Test12_2 = new Test12(); class Test12_3 = new Test12(); class Test12_4.
@Test public void testSettableAnyProperty() throws Exception { class Test { public void v1() { } } class Test2 extends Bean { public void v2() { } } class Test3 extends Bean { public void v3() { } } class Test4 extends Bean { public void v4() { } } class Test5 extends Bean { public void v5() { } } class Test6 extends Bean { public void v6() { } } class Test7 extends Bean { public void v7() { } } class Test8 extends Bean { public void v8() { } } class Test9 extends Bean { public void v9() { } } class Test10 extends Bean { public void v10() { } } class Test11 extends Bean { public void v11() { } } class Test12 extends Bean { public void v12() { } } class Test12_2 extends Bean { public void v13() { } } } class Test11_1 = new Test11(); class Test11_2 = new Test11(); class Test12_3 = new Test12(); new SettableAnyProperty(new TestProperty(), null, JavaType.DEFAULT, null).withValueDeserializer(new JsonDeserializer<Object>() { @Override public Object deserialize(Json
@Test public void testSettableAnyProperty() throws Exception { class Test { public void foo() { } } class Test2 extends Bean { public void foo() { } } class Test3 extends Bean { public void foo() { } } class Test4 extends Bean { public void foo() { } } class Test5 extends Bean { public void foo() { } } class Test6 extends Bean { public void foo() { } } class Test7 extends Bean { public void foo() { } } class Test8 extends Bean { public void foo() { } } class Test9 extends Bean { public void foo() { } } class Test10 extends Bean { public void foo() { } } class Test11 extends Bean { public void foo() { } } class Test12 extends Bean { public void foo() { } } class Test12_1 = Bean.class; public SettableAnyProperty(BeanProperty property, Method rawSetter, JavaType type, JsonDeserializer<Object> valueDeser) throws NoSuchMethodException, SecurityException, IllegalArgumentException { } } Test1 instance = new Test1(); instance.foo(); SettableAnyProperty m1 = new SettableAnyProperty(property, null, JavaType.BOOLEAN, valueDeser); assertEquals(m1.foo
@Test public void testSettableAnyProperty() throws Exception { class Test { public void foo() { } } class Test2 extends Bean { public void foo() { } } class Test3 extends Bean { public void foo() { } } class Test4 extends Bean { public void foo() { } } class Test5 extends Bean { public void foo() { } } class Test6 extends Bean { public void foo() { } } class Test7 extends Bean { public void foo() { } } class Test8 extends Bean { public void foo() { } } class Test9 extends Bean { public void foo() { } } class Test10 extends Bean { public void foo() { } } class Test11 extends Bean { public void foo() { } } class Test12 extends Bean { public void foo() { } } class Test21 extends Bean { public void foo() { } } class Test22 extends Bean { public void foo() { } } class Test23 extends Bean { public void foo() { } } } class Test22_1 = new Test23(); class Test23_2 = new Test23(); SettableAnyProperty m1 = new SettableAnyProperty(new BeanProperty(new BeanProperty.Foo(), "bar", true), null, JavaType
@Test public void testSettableAnyProperty() throws Exception { class Test { public void foo() { } } class Test2 extends Bean { public void foo() { } } class Test3 extends Bean { public void foo() { } } class Test4 extends Bean { public void foo() { } } class Test5 extends Bean { public void foo() { } } class Test6 extends Bean { public void foo() { } } class Test7 extends Bean { public void foo() { } } class Test8 extends Bean { public void foo() { } } class Test9 extends Bean { public void foo() { } } class Test10 extends Bean { public void foo() { } } class Test11 extends Bean { public void foo() { } } class Test12 extends Bean { public void foo() { } } class Test21 extends Bean { public void foo() { } } class Test22 extends Bean { public void foo() { } } class Test23 extends Bean { public void foo() { } } } class Test22_1 = new Test23(); SettableAnyProperty m1 = new SettableAnyProperty(new Test1(), null, JavaType.OBJECT, null); SettableAnyProperty m2 = new SettableAnyProperty(new Test
@Test public void testSettableAnyProperty() throws Exception { class Test { public void foo() { } } class Test2 extends Bean { public void foo() { } } class Test3 extends Bean { public void foo() { } } class Test4 extends Bean { public void foo() { } } class Test5 extends Bean { public void foo() { } } class Test6 extends Bean { public void foo() { } } class Test7 extends Bean { public void foo() { } } class Test8 extends Bean { public void foo() { } } class Test9 extends Bean { public void foo() { } } class Test10 extends Bean { public void foo() { } } class Test11 extends Bean { public void foo() { } } class Test12 extends Bean { public void foo() { } } class Test21 extends Bean { public void foo() { } } class Test22 extends Bean { public void foo() { } } class Test23 extends Bean { public void foo() { } } } class Test22_1 = Bean.class; assertEquals(new Test1, class1.foo()); assertEquals(new Test2, class1.foo()); assertEquals(new Test3, class1.foo()); assertEquals(new Test3, class1.foo()); assertEquals(new Test4,
@Test public void testSettableAnyProperty() throws Exception { class Test { public void test() { } } BeanProperty property = new BeanProperty(); bean.setProperty(property); SettableAnyProperty setter = new SettableAnyProperty(property, null, JavaTypes.STRING, null); setter.setValueDeserializer(new JsonDeserializer<Object>() { @Override public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException { return "test"; } }); assertEquals(bean.getType(), setter.getType()); assertEquals(bean.getProperty(), setter.getProperty()); assertEquals(property.getType(), setter.getType()); assertEquals(property.getRawSetter(), setter.getRawSetter()); assertEquals(property.getValueDeser(), setter.getValueDeser()); }
@Test public void testWithValueDeserializer() throws Exception { class Test { public void foo() { } } Test instance = new Test(); bean.withValueDeserializer(new JsonDeserializer<Object>() { @Override public Object deserialize(JsonParser jp, DeserializationContext ctxt, Object instance, String propName) throws IOException, JsonProcessingException { return instance; } }); Assert.assertEquals(instance.foo(), "bar"); }
@Test public void testWithValueDeser() throws Exception { BeanProperty bean = new BeanProperty("name", "value"); bean.set(new Object(), St.NULL); bean.set(new Object(), St.NULL); bean.set(new Object(), St.NULL); bean.set(new Object(), St.NULL); bean.set(new Object(), St.NULL); bean.set(new Object(), St.NULL); bean.set(new Object(), St.NULL); bean.set(new Object(), St.NULL); bean.set(new Object(), St.NULL); assertEquals(BeanProperty.NAME, bean.getName()); }
@Test public void testGetProperty() { BeanProperty beanProperty = new BeanProperty(); beanProperty.setId("id"); beanProperty.setString("string"); beanProperty.setBooleanProperty(true); BeanProperty beanProperty2 = new BeanProperty(); beanProperty2.setId("id2"); beanProperty2.setString("string2"); beanProperty2.setBooleanProperty(false); BeanProperty beanProperty3 = new BeanProperty(); beanProperty3.setId("id3"); beanProperty3.setString("string3"); beanProperty3.setBooleanProperty(true); BeanProperty beanProperty4 = new BeanProperty(); beanProperty4.setId("id4"); beanProperty4.setString("string4"); beanProperty4.setBooleanProperty(false); beanProperty4.setBooleanProperty(true); beanProperty4.setBooleanProperty(false); beanProperty4.setString("string4"); beanProperty4.setBooleanProperty(true); beanProperty4.setBooleanProperty(false); assertEquals(beanProperty2, beanProperty.getProperty()); assertEquals(beanProperty3, beanProperty2.getProperty()); assertEquals(beanProperty3, beanProperty3.getProperty()); assertEquals(beanProperty4, beanProperty4.getBean()); assertEquals(beanProperty2, beanProperty2.getBean()); assertEquals(beanProperty3, beanProperty
@Test public void testHasValueDeserializer() throws Exception { BeanProperty property = new BeanProperty(); property.setId("id"); property.setType(String.class); BeanProperty getter = new BeanProperty(); getter.setId("id"); getter.setType(String.class); getter.setValueDeserializer(new JsonDeserializer<Object>() { @Override public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { return null; } }); Assert.assertTrue(property.hasValueDeserializer()); }
@Test public void getType() { assertEquals(JavaType.OBJECT, classUnderTest.getType()); }
@Test public void should_set_property_on_settable_any_property_on_settable_any_property_on_settable_any_property_on_settable_any_property() throws Exception { class TestBean implements Bean { public void set(int value) { } } TestBean instance = new TestBean(); jp.nextToken(); jp.nextToken(); instance.set("value"); instance.deserializeAndSet(jp, null, instance, "value"); assertThat(instance.get("value")).isEqualTo("value"); }
@Test public void testWithNonDefaultSetter() throws IOException, JsonProcessingException { BeanProperty instance = new BeanProperty(); instance.set("a", 1); instance.set("b", 2); jp.set("a", 1); instance.deserializeAndSet(jp, null, "a"); assertEquals(2, jp.getCount()); assertEquals("a", jp.get(0).getValue()); }
@Test public void testDeserialize() throws Exception { class Test { public void test() { } } MockDeserializer mockDeserializer = new MockDeserializer(); MockDeserializer mockDeserializer2 = new MockDeserializer(); MockDeserializer mockMock = new MockDeserializer(); String json = "{\"test\": \"test\"}"; when(mockDeserializer.deserialize(jp, mockDeserializer)).thenReturn(json); assertEquals(json, mockDeserializer.deserialize(jp, mockDeserializer2)); assertEquals(json, mockDeserializer2.deserialize(jp, mockDeserializer2)); }
@Test public void testWithNullDeserializer() throws IOException, JsonProcessingException { MockDeserializer mockDeserializer = new MockDeserializer(); MockJsonParser jp = new MockJsonParser(new StringReader(null)); Mockito.when(mockDeserializer.deserialize(jp, mockDeserializer)).thenReturn(null); Mockito.when(_mockDeserializer.deserialize(jp, mockDeserializer)).thenReturn(null); assertEquals(null, mockDeserializer.deserialize(jp, mockDeserializer)); Mockito.verify(_mockDeserializer).deserialize(jp, mockDeserializer); }
@Test public void testWithNullDeserializer() throws IOException, JsonProcessingException { new Expectations() { { jp.getCurrentToken(); result = JsonToken.VALUE_NULL; } }; new MockUp<Annotation>() { @Mock public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { return null; } }; new MockUp<Annotation>() { @Mock public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { return "null"; } }; new MockUp<Annotation>() { @Mock public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { return "null"; } }; new MockUp<Annotation>() { @Mock public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { return "null"; } }; new MockUp<Annotation>() { @Mock public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { return "null"; } }; new MockUp<Annotation>() { @Mock public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { return "null"; } }; new MockUp<Annotation>() { @Mock
@Test public void testDeserializeNull() throws Exception { MockDeserializer mockDeserializer = new MockDeserializer(); when(mockDeserializer.deserialize(jp, mockDeserializer.getDeserializationContext())).thenReturn(null); assertEquals(null, mockDeserializer.deserialize(jp, mockDeserializer.getDeserializationContext())); }
@Test public void testSet() throws IOException { class Example { public void foo() { } } Example instance = new Example(); instance.set(instance, "foo", "bar"); assertEquals("bar", instance.foo); }
@Test public void testSet() throws IOException { class Example { public void example(Object o1, Object o2, String s) { } } Example instance = new Example(); instance.example = "hello"; instance.set(instance, "example", "world"); assertEquals("world", instance.example); }
@Test public void testSet() throws IOException { class Example { public void example(Object o, String s) { } } Example instance = new Example(); instance.example = "foo"; instance.set(instance, "example", "bar"); assertEquals("bar", instance.example); }
@Test public void testConstructWithoutSuperTypes() { try { constructWithoutSuperTypes(TestC.class, null, null); fail("Should not be able to construct without super-types"); } catch (IllegalArgumentException iae) { assertEquals("Cannot find @SuperType annotation on type TestC", iae.getMessage()); } try { constructWithoutSuperTypes(TestC.class, null, null); fail("Should not be able to construct without super-types"); } catch (IllegalArgumentException iae) { assertEquals("Cannot find @SuperType annotation on type TestC", iae.getMessage()); } }
@Test public void testConstructWithoutSuperTypes() { try { AnnotatedClass.constructWithoutSuperTypes(Test.class, null, null); fail("Should not be able to construct without super-types"); } catch (IllegalArgumentException iae) { } }
@Test public void testResolveCreators() { resolveCreators(); }
@Test public void testBaseTypeName() { assertEquals(".lang.Integer", new TypeDeserializerBase<Integer>(Integer.class, null, "int", false, Integer.class).baseTypeName()); assertEquals(".lang.Long", new TypeDeserializerBase<Long>(Long.class, null, "long", false, Long.class).baseTypeName()); assertEquals(".lang.Long", new TypeDeserializerBase<Long>(Long.class, null, "long", false, Long.class).baseTypeName()); assertEquals(".lang.Long", new TypeDeserializerBase<Long>(Long.class, null, "long", false, Long.class).baseTypeName()); assertEquals(".util.List", new TypeDeserializerBase<List>(List.class, null, ".util.List", false, List.class).baseTypeName()); assertEquals(".util.Map", new TypeDeserializerBase<Map>(Map.class, null, ".util.Map", false, Map.class).baseTypeName()); assertEquals(".util.Map<String, Object>", new TypeDeserializerBase<Map<String, Object>>(Map.class, null, ".util.Map", false, String
@Test public void testResolveAbstractType() { DeserializationConfig config = new DeserializationConfig(); config.setClass(MyBean.class); JavaType.lang.String result = _resolver.resolveAbstractType(config, JavaType.valueOf(String.class)); Assert.assertEquals(JavaType.valueOf(String.class), result); }
@Test public void test_null() { Assert.assertNull(new SimpleAbstractTypeResolver().resolveAbstractType(null, JavaTypes.STRING)); }
@Test public void sqlDateSerializer() { }
@Test public void serializeJavaDate() throws IOException, JsonGenerationException {.sql.Date value = new.sql.Date(DATE); new SqlDateSerializer().serialize(value, jgen, null); verify(jgen).writeString(value.toString()); }
@Test public void serializeJavaDateToString() throws IOException, JsonGenerationException { SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"); sdf.setTimeZone(TimeZone.getTimeZone("GMT")); String dateString = sdf.format(new Date(1985, 4, 23, 59, 59, 999));.util.Date value = new.util.Date(1985, 4, 23, 59, 999);.util.DateSerializer serializer = new SqlDateSerializer(); serializer.serialize(value, jgen, null); jgen.flush(); JsonNode schema = jgen.readTree(new StringReader(dateString)); Assert.assertEquals(schema.toString(), ".util.Date"); }
@Test public void test_idFromValueAndType() { String id = "[LINE]"; String actual = sut.idFromValueAndType(id, String.class); Assert.assertEquals(id, actual); }
@Test public void test_idFromValueAndType() { String id = "org.apache.oling.json.JsonTypeInfoImpl"; assertEquals(id, idFromValueAndType(new JsonPrimitive("org.apache.oling.json.JsonTypeInfoImpl"), JavaTypes.String.class)); assertEquals(id, idFromValueAndType(new JsonPrimitive("org.apache.oling.json.JsonTypeInfoImpl"), JavaTypes.String.class)); assertEquals(id, idFromValueAndType(new JsonPrimitive("org.apache.oling.json.JsonTypeInfoImpl"), JavaTypes.String.class)); assertEquals(id, idFromValueAndType(new JsonPrimitive("org.apache.oling.json.JsonTypeInfoImpl"), JavaTypes.String.class)); assertEquals(id, idFromValueAndType(new JsonPrimitive("org.apache.oling.json.JsonTypeInfoImpl"), JavaTypes.String.class)); assertEquals(id, idFromValueAndType(new JsonPrimitive("org.apache.oling.json.JsonTypeInfoImpl"), JavaTypes.String.class)); assertEquals(id, idFromValueAndType(new JsonPrimitive("org.apache.oling.json.JsonTypeInfoImpl"), JavaTypes
@Test public void testArrayComparator() { String[] values = { "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "l", "k", "l", "k", "l", "k", "l", "k", "l", "k", "l", "k", "l", "k", "l", "k", "l", "k", "l", "k", "l", "k", "l", "k", "l", "k", "l", "k", "l", "k", "l", "k", "l", "k", "l", "k", "l", "k", "l", "k", "l", "k", "l", "k", "l", "k", "l", "k", "l", "k", "l", "k", "l", "k", "l", "k", "l", "k", "l", "k", "l", "k", "l", "k", "l", "k", "l", "k", "
@Test public void testInnerClassProperty() { InnerClassProperty inner = new InnerClassProperty(mock(InnerClassProperty.class), "foo"); assertEquals(mock(InnerClassProperty.class), inner.getMember()); }
@Test public void testInnerClassProperty() { InnerClassProperty inner = new InnerClassProperty(new InnerClassProperty(), "foo"); assertEquals(InnerClassProperty.class, inner.getMember().getClass()); }
@Test public void testInnerClassProperty() { InnerClassProperty inner = new InnerClassProperty(new InnerClassProperty(new InnerClassProperty("a"), "b"), "c"); assertEquals(new InnerClassProperty(new InnerClassProperty(new InnerClassProperty("a"), "b"), "c"), inner); }
@Test public void testInnerClassProperty() { class C { public C(String a, String b) { } } C c = new C(); InnerClassProperty inner = new InnerClassProperty(new InnerClassProperty(new InnerClassProperty(new InnerClassProperty(new InnerClassProperty(new InnerClassProperty(new InnerClassProperty(new InnerClassProperty(new InnerClassProperty(new InnerClassProperty(new InnerClassProperty(new InnerClassProperty(new InnerClassProperty(new InnerClassProperty(new InnerClassProperty(new InnerClassProperty(new InnerClassProperty(new InnerClassProperty(new InnerClassProperty(new InnerClassProperty(new InnerClassProperty(new InnerClassProperty(new InnerClassProperty(new InnerClassProperty(new InnerClassProperty(new InnerClassProperty(new InnerClassProperty(new InnerClassProperty(new InnerClassProperty(new InnerClassProperty(new InnerClassProperty(new InnerClassProperty(new InnerClassProperty(new InnerClassProperty(new InnerClassProperty(new InnerClassProperty(new InnerClassProperty(new InnerClassProperty(new InnerClassProperty(new InnerClassProperty(new InnerClassProperty(new InnerClassProperty(new InnerClassProperty(new InnerClassProperty
@Test public void deserializeAndSet_deserializeWithTypeAndThrows() throws Exception { DeserializationContext ctxt = mock(DeserializerContext.class); when(ctxt.deserializeWithType(eq(JsonToken.VALUE_NULL), eq(String.class))).thenThrow(new RuntimeException()); InnerClassProperty bean = new InnerClassProperty(new SeaDeserializer(), null); bean.deserializeAndSet(jp, ctxt, bean); }
@Test public void deserializeAndSetThrowsException() throws IOException, JsonProcessingException { JsonParser jp = mock(JsonParser.class); when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NULL); when(jp.hasToken(JsonToken.VALUE_NULL)).thenReturn(true); DeserializationContext ctxt = mock(DeserializationContext.class); when(ctxt.getDeserializer()).thenReturn(mock(Deserializer.class)); when(ctxt.getProvider()).thenReturn(mock(NullProvider.class)); new JsonToken(JsonToken.VALUE_NULL, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null
@Test public void deserializeAndSet_deserializeWithTypeAndThrows() throws IOException, JsonProcessingException { InnerClassPropert creator = new InnerClassPropert(); DeserializationContext ctxt = mock(DeserializerContext.class); when(ctxt.deserializeWithType(eq(JsonToken.VALUE_NULL), eq(null))).thenThrow(new RuntimeException()); new InnerClassPropert(creator).deserializeAndSet(jp, ctxt, null); }
@Test public void deserializeAndSet_valueIsNull_throwsException() throws IOException, JsonProcessingException { JsonParser jp = mock(JsonParser.class); DeserializationContext ctxt = mock(DeserializationContext.class); when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NULL); when(ctxt.getDeserializer()).thenReturn(mock(Deserializer.class)); when(jp.hasToken(JsonToken.VALUE_NULL)).thenReturn(true); publi.deserializeAndSet(jp, ctxt, null); verify(ctxt, never()).getDeserializer(); }
@Test public void deserializeAndSet_withDeserializer() throws IOException, JsonProcessingException { new Expectations() { { mockDeserializer.deserializeWithType(jp, ctxt, null); result = new Object(); } }; new Expectations() { { mockDeserializer.deserializeWithType(jp, ctxt, null); result = new Object(); } }; }
@Test public void testDeserializeAndSet() throws IOException, JsonProcessingException { class InnerClassProperty implements Bean { private String innerClassProperty; public InnerClassProperty(Settab tab, String innerClassProperty) { this.innerClassProperty = innerClassProperty; } } Settab bean = new Settab(); bean.setInnerClassProperty(new InnerClassProperty(bean)); new InnerClassProperty(bean, bean.getInnerClassProperty()).deserializeAndSet(jp, null, bean); assertEquals("innerClassProperty", bean.getInnerClassProperty()); }
@Test public void testNewInstance() throws JsonProcessingException { new Expectations() { { _creator.newInstance(bean); result = null; } }; }
@Test public void deserializeAndSet_deserializeWithType_deserializeWithType() throws IOException, JsonProcessingException { new Expectations() { { mockDeserializer.deserializeWithType(jp, ctxt, (Type<Object>) null); } }; new Expectations() { { mockDeserializer.deserializeWithType(jp, ctxt, (Type<Object>) null); } }; }
@Test public void deserializeAndSet_deserializeWithType_deserializeWithType() throws IOException, JsonProcessingException { DeserializationContext ctxt = mock(DeserializationContext.class); when(_creator.newInstance(eq(bean))).thenReturn(new InnerClassPropertest()); InnerClassPropertest bean = new InnerClassPropertest(); bean.deserializeAndSet(_jp, ctxt, bean); verify(_valueDeserializer).deserializeWithType(jp, ctxt, (Object) bean.getValue()); }
@Test public void testSet() throws IOException { OuterClassProperty outer = new OuterClassProperty(null, null); OuterClassProperty inner = new OuterClassProperty(outer, "inner"); outer.set(inner, "value"); assertEquals(outer.getMember(), inner.getMember()); outer.set(inner, "value"); assertEquals(outer.getMember(), inner.getMember()); }
@Test public void testSet() throws IOException { TestClass instance = new TestClass(); instance._delegate.set(instance, "value"); Assert.assertEquals("value", instance._delegate.getAndReturn(instance)); }
@Test public void testJsonSchema() { ObjectNode schema = JsonNodeFactory.instance.objectNode(); JsonSchema schema2 = new JsonSchema(schema); assertEquals(schema, schema2); }
@Test public void testJsonSchema() throws IOException { JsonNode schema = mapper.readTree("{\"schema\":{\"type\":\"object\",\"name\":\"test\"}}"); JsonSchema jsonSchema = new JsonSchema(schema); assertEquals(schema, jsonSchema.getSchemaNode()); }
@Test public void testGetSchemaNode() { ObjectNode schemaNode = mapper.readValue("{\"foo\":\"bar\"}", JsonSchema.class); assertEquals(schemaNode, jsonSchema.getSchemaNode()); }
@Test public void testGetSchemaNode() { ObjectNode schemaNode = mapper.readValue("{\"foo\":\"bar\"}", JsonSchema.class); assertEquals(schema, mapper.getSchemaNode()); }
@Test public void testEquals() throws Exception { JsonSchema schema1 = mapper.readValue("{\"schema\":{\"name\":\"test\"}}", JsonSchema.class); JsonSchema schema2 = mapper.readValue("{\"schema\":{\"name\":\"test\"}}", JsonSchema.class); JsonSchema schema3 = mapper.readValue("{\"schema\":{\"name\":\"test\"}}", JsonSchema.class); JsonSchema schema4 = mapper.readValue("{\"schema\":{\"name\":\"test\"}}", JsonSchema.class); JsonSchema schema5 = mapper.readValue("{\"schema\":{\"name\":\"test\"}}", JsonSchema.class); JsonSchema schema6 = mapper.readValue("{\"schema\":{\"name\":\"test\"}}", JsonSchema.class); JsonSchema schema7 = mapper.readValue("{\"schema\":{\"name\":\"test\"}}", JsonSchema.class); JsonSchema schema8 = mapper.readValue("{\"schema\":{\"name\":\"test\"}}", JsonSchema.class); JsonSchema schema9 = mapper.readValue("{\"schema\":{\"name\":\"test\"}}", JsonSchema.class); JsonSchema schema10 = mapper.readValue("{\"schema
@Test public void testEquals() { JsonSchema schema1 = new JsonSchema(new ObjectNode()); JsonSchema schema2 = new JsonSchema(new ObjectNode()); JsonSchema schema3 = new JsonSchema(new ObjectNode()); JsonSchema schema4 = new JsonSchema(new ObjectNode()); Assert.assertTrue(schema1.equals(schema1)); Assert.assertTrue(schema1.equals(schema2)); Assert.assertTrue(schema1.equals(schema3)); Assert.assertTrue(schema1.equals(schema4)); Assert.assertTrue(schema1.equals(schema1)); Assert.assertTrue(schema1.equals(schema2)); Assert.assertTrue(schema1.equals(schema3)); Assert.assertTrue(schema1.equals(schema4)); Assert.assertTrue(schema1.equals(schema1)); Assert.assertTrue(schema1.equals(schema4)); Assert.assertTrue(schema1.equals(schema1)); Assert.assertTrue(schema1.equals(schema2)); Assert.assertTrue(schema1.equals(schema1)); Assert.assertTrue(schema1.equals(schema2)); Assert.assertTrue(schema1.equals(schema3)); Assert.assertTrue(schema1.equals(schema4)); }
@Test public void testEqualsNull() { JsonSchema schema = new JsonSchema(null); assertFalse(schema.equals(null)); }
@Test public void testEquals() { JsonSchema schema1 = new JsonSchema(new ObjectNode()); JsonSchema schema2 = new JsonSchema(new ObjectNode()); JsonSchema schema3 = new JsonSchema(new ObjectNode()); Assert.assertFalse(schema1.equals(schema2)); Assert.assertFalse(schema1.equals(schema3)); Assert.assertFalse(schema1.equals(null)); Assert.assertFalse(schema1.equals(schema2)); Assert.assertFalse(schema1.equals(schema3)); }
@Test public void testEquals() { JsonSchema schema1 = new JsonSchema(new ObjectNode()); JsonSchema schema2 = new JsonSchema(new ObjectNode()); assertEquals(schema1, schema2); assertEquals(schema2, schema1); }
@Test public void testEqualsNull() { JsonSchema schema = new JsonSchema(null); JsonSchema schema2 = new JsonSchema(null); assertEquals(schema, schema2); }
@Test public void equalsTest() { JsonSchema schema1 = new JsonSchema(new ObjectNode()); JsonSchema schema2 = new JsonSchema(new ObjectNode()); JsonSchema schema3 = new JsonSchema(new ObjectNode()); JsonSchema schema4 = new JsonSchema(new ObjectNode()); Assert.assertTrue(schema1.equals(schema1)); Assert.assertTrue(schema1.equals(schema2)); Assert.assertFalse(schema1.equals(null)); Assert.assertFalse(schema1.equals(schema3)); Assert.assertFalse(schema1.equals(schema4)); Assert.assertFalse(schema1.equals(schema5)); Assert.assertFalse(schema1.equals(null)); Assert.assertFalse(schema1.equals(schema4)); }
@Test public void testGetDefaultSchemaNode() { JsonNode schemaNode = JsonNodeFactory.instance.objectNode(); JsonNode schemaNode2 = JsonNodeFactory.instance.objectNode(); JsonNode schemaNode3 = JsonNodeFactory.instance.objectNode(); JsonNode schemaNode4 = JsonNodeFactory.instance.objectNode(); JsonNode schemaNode5 = JsonNodeFactory.instance.objectNode(); JsonNode schemaNode6 = JsonNodeFactory.instance.objectNode(); JsonNode schemaNode7 = JsonNodeFactory.instance.objectNode(); JsonNode schemaNode8 = JsonNodeFactory.instance.objectNode(); JsonNode schemaNode9 = JsonNodeFactory.instance.objectNode(); JsonNode schemaNode10 = JsonNodeFactory.instance.objectNode(); JsonNode schemaNode11 = JsonNodeFactory.instance.objectNode(); JsonNode schemaNode12 = JsonNodeFactory.instance.objectNode(); JsonNode schemaNode13 = JsonNodeFactory.instance.objectNode(); JsonNode schemaNode14 = JsonNodeFactory.instance.objectNode(); JsonNode schemaNode15 = JsonNodeFactory.instance.objectNode(); JsonNode schemaNode16 = JsonNodeFactory.instance.objectNode(); JsonNode schemaNode17 = JsonNodeFactory.instance.objectNode(); JsonNode schemaNode18 = JsonNodeFactory.instance.objectNode(); JsonNode schemaNode181 = JsonNodeFactory.instance.object
@Test public void testGetDefaultSchemaNode() { ObjectNode schemaNode = JsonNodeFactory.instance.objectNode(); JsonNode schema = JsonNodeFactory.instance.objectNode(); JsonNode schemaNode2 = JsonNodeFactory.instance.objectNode(); JsonNode schema2 = JsonNodeFactory.instance.objectNode(); JsonNode schema = JsonNodeFactory.instance.objectNode(); JsonNode schema2 = JsonNodeFactory.instance.objectNode(); JsonNode schema = JsonNodeFactory.instance.objectNode(); JsonNode schema2 = JsonNodeFactory.instance.objectNode(); assertEquals(schema, schema); assertEquals(schemaNode, schema2); assertEquals(schemaNode, schema2); assertEquals(schemaNode, JsonNodeFactory.instance.objectNode()); assertEquals(schemaNode, JsonNodeFactory.instance.objectNode()); assertEquals(schemaNode, JsonNodeFactory.instance.objectNode()); assertEquals(schemaNode, JsonNodeFactory.instance.objectNode()); assertEquals(schemaNode, JsonNodeFactory.instance.objectNode()); assertEquals(schemaNode, JsonNodeFactory.instance.objectNode()); assertEquals(schemaNode, JsonNodeFactory.instance.objectNode()); assertEquals(schemaNode, JsonNodeFactory.instance.objectNode()); assertEquals(schemaNode, JsonNodeFactory.instance.objectNode()); assertEquals(schemaNode, JsonNodeFactory.instance.objectNode()); assertEquals
@Test public void testGetDefaultSchemaNode() { ObjectNode objectNode = JsonNodeFactory.instance.objectNode(); objectNode.put("type", "any"); objectNode.put("value", "any"); objectNode.put("type", "any"); ObjectNode schemaNode = JsonNodeFactory.instance.objectNode(); ObjectNode schema = JsonNodeFactory.instance.objectNode(); schema.put("type", "any"); ObjectNode schemaNode2 = JsonNodeFactory.instance.objectNode(); schema.put("type", "any"); ObjectNode schema2 = JsonNodeFactory.instance.objectNode(); schema2.put("type", "any"); JsonSchema jsonSchema = new JsonSchema(schemaNode); assertEquals(objectNode, jsonSchema.getDefaultSchemaNode()); assertEquals(schemaNode, jsonSchema.getSchemaNode()); }
@Test public void testGetDefaultSchemaNode() { ObjectNode schemaNode = JsonNodeFactory.instance.objectNode(); ObjectNode objectNode = JsonNodeFactory.instance.objectNode(); objectNode.put("type", "any"); ObjectNode schemaNode2 = JsonNodeFactory.instance.objectNode(); ObjectNode schemaNode3 = JsonNodeFactory.instance.objectNode(); ObjectNode schemaNode4 = JsonNodeFactory.instance.objectNode(); ObjectNode schemaNode5 = JsonNodeFactory.instance.objectNode(); ObjectNode schemaNode6 = JsonNodeFactory.instance.objectNode(); ObjectNode schemaNode7 = JsonNodeFactory.instance.objectNode(); ObjectNode schemaNode8 = JsonNodeFactory.instance.objectNode(); ObjectNode schemaNode9 = JsonNodeFactory.instance.objectNode(); ObjectNode schemaNode10 = JsonNodeFactory.instance.objectNode(); ObjectNode schemaNode11 = JsonNodeFactory.instance.objectNode(); ObjectNode schemaNode12 = JsonNodeFactory.instance.objectNode(); ObjectNode schemaNode13 = JsonNodeFactory.instance.objectNode(); ObjectNode schemaNode14 = JsonNodeFactory.instance.objectNode(); ObjectNode schemaNode15 = JsonNodeFactory.instance.objectNode(); ObjectNode schemaNode16 = JsonNodeFactory.instance.objectNode(); ObjectNode schemaNode17 = JsonNodeFactory.instance.objectNode(); ObjectNode schemaNode
@Test public void testWithClassIntrospector() { BaseSettings baseSettings = new BaseSettings(null, null, null, null, null, null, null, null, null, null); ClassIntrospector ci = ClassIntrospector.of(BaseClass.class); BaseSettings baseSettings2 = baseSettings.withClassIntrospector(ci); assertEquals(BaseClass.class, baseSettings2.class); }
@Test public void testWithClassIntrospector() { BaseSettings baseSettings = new BaseSettings( MockIntrospector.class, null, null, null, null, null, null, null, null, null, null); ClassIntrospector ci = MockIntrospector.class.getIntrospector(); baseSettings.withClassIntrospector(ci); assertEquals(ci, baseSettings.classIntrospector); }
@Test public void testWithClassIntrospector() { BaseSettings base = new BaseSettings(Mockito.mock(Introspector.class), Mockito.mock(AnnotationIntrospector.class), Mockito.mock(VisibilityChecker.class), Mockito.mock(PropertyNamingStrategy.class), Mockito.mock(TypeFactory.class), Mockito.mock(HandlerInstantiator.class), Mockito.mock(Locale.class), Mockito.mock(TimeZone.class), Base64Variant.EMPTY); ClassIntrospector ci = Mockito.mock(Introspector.class); BaseSettings base2 = base.withClassIntrospector(ci); assertEquals(ci, base2); }
@Test public void testWith() { BaseSettings base = new BaseSettings(Introspector.INTERFACE, VisibilityChecker.PUBLIC, null, null, null, null, null, null, null, null, null); StdDateFormat df = new StdDateFormat(); Date date = new Date(); BaseSettings clone = base.with(TimeZone.getTimeZone("GMT")); assertEquals(date, clone.getDate()); assertEquals(date, clone.with(TimeZone.getTimeZone("GMT"))); }
@Test public void testWith() { BaseSettings base = new BaseSettings(Introspector.INTERFACE, VisibilityChecker.PUBLIC, null, null, null, null, null, null, null); StdDateFormat df = StdDateFormat.INSTANCE; Date date = new Date(); Base64Variant defaultBase64 = new Base64Variant(); base.withClassIntrospector(Introspector.INTERFACE); base.withAnnotationIntrospector(Introspector.INTERFACE); base.withPropertyNamingStrategy(PropertyNamingStrategy.STRING); base.withHandlerInstantiator(new HandlerInstantiator(date, null)); assertEquals(date, base.with(TimeZone.getTimeZone("GMT-04:00"))); assertEquals(defaultBase64, base.with(TimeZone.getTimeZone("GMT-04:00"))); }
@Test public void testWith() { StdDateFormat df = StdDateFormat.getInstance(); BaseSettings base = new BaseSettings(Introspector.INTERFACE, null, null, null, null, null, null, null, null, null, null); StdDateFormat newdf = (StdDateFormat) base.with(TimeZone.getTimeZone("GMT")); assertEquals(newdf, newdf.clone()); }
@Test public void testWith() { StdDateFormat df = StdDateFormat.get(Locale.US); BaseSettings base = new BaseSettings(Introspector.PUBLIC, null, null, null, null, null, null, null, null, null, null, null); StdDateFormat clone = (StdDateFormat) base.clone(); clone.with(TimeZone.getTimeZone("GMT")); assertEquals(clone, base); }
@Test public void testWith() { StdDateFormat df = StdDateFormat.get(DATE_FORMAT); StdDateFormat df2 = (StdDateFormat) df.clone(); df2.setTimeZone(TimeZone.getTimeZone("GMT+2")); new BaseSettings(ClassIntrospector.INTERFACE, null, null, null, df2, null, null, null, null).with(TimeZone.getTimeZone("GMT+2")); }
@Test public void testWith() { Base base = new BaseBuilder().withClassIntrospector(ClassIntrospector.INTERFACE).withAnnotationIntrospector(ClassIntrospector.INTERFACE).withPropertyNamingStrategy(PropertyNamingStrategy.DEFAULT_VALUE_DELIMITER).withTypeFactory(Object.class).withHandlerInstantiator(null, null, null, null); assertEquals(base, new BaseBuilder().withClassIntrospector(ClassIntrospector.INTERFACE).withAnnotationIntrospector(ClassIntrospector.INTERFACE).withPropertyNamingStrategy(PropertyNamingStrategy.DEFAULT_VALUE_DELIMITER).withTypeFactory(Object.class).withHandlerInstantiator(null, null, null, null).withBase64(Base64.getEncoder()).build()); }
@Test public void testConstructorLocale() { BaseSettings settings = new BaseSettings(BaseClass.class, null, null, null, null, null, null, null); Locale locale = settings.getLocale(); Assert.assertEquals(Locale.US, locale); }
@Test public void testConstructorLocale() { BaseSettings settings = new BaseSettings(null, null, null, null, null, null, null, null); assertEquals(Locale.US, settings.getLocale()); }
@Test public void testShortBuilder() { ShortBuilder b = new ShortBuilder(); new Iterator<ShortBuilder>(b.getShortBuilder()).hasNext(); assertEquals(b, new ShortBuilder().setShortBuilder(b).getShortBuilder()); b = new ShortBuilder(); new Iterator<ShortBuilder>(b.getShortBuilder()).hasNext(); assertEquals(b, new ShortBuilder().setShortBuilder(b).getShortBuilder()); b = new ShortBuilder(); new Iterator<ShortBuilder>(b.getShortBuilder()).hasNext(); assertEquals(b, new ShortBuilder().setShortBuilder(b).getShortBuilder()); }
@Test public void testShortBuilder() { ShortBuilder b = new ShortBuilder(); new Iterator<ShortBuilder>(b).getShortBuilder(); new Iterator<ShortBuilder>(b).getShortBuilder(); new Iterator<ShortBuilder>(b).getShortBuilder(); new Iterator<ShortBuilder>(b).getShortBuilder(); new Iterator<ShortBuilder>(b).getShortBuilder(); new Iterator<ShortBuilder>(b).getShortBuilder(); new Iterator<ShortBuilder>(b).getShortBuilder(); new Iterator<ShortBuilder>(b).getShortBuilder(); new Iterator<ShortBuilder>(b).getShortBuilder(); new Iterator<ShortBuilder>(b).getShortBuilder(); new Iterator<ShortBuilder>(b).getShortBuilder(); new Iterator<ShortBuilder>(b).getShortBuilder(); new Iterator<ShortBuilder>(b).getShortBuilder(); new Iterator<ShortBuilder>(b).getShortBuilder(); new Iterator<ShortBuilder>(b).getShortBuilder(); new Iterator<ShortBuilder>(b).getShortBuilder(); new Iterator<ShortBuilder>(b).getShortBuilder(); new Iterator<ShortBuilder>(b).getShortBuilder(); new Iterator<ShortBuilder>(b).getShortBuilder(); new Iterator<ShortBuilder>(b).getShort
@Test public void testShortBuilder() { ShortBuilder b = new ShortBuilder(); b.setShortBuilder(null); Assert.assertNull(b.getShortBuilder()); b = new ShortBuilder(); b.setShortBuilder(Short.MAX_VALUE); Assert.assertEquals(b.getShortBuilder(), Short.MAX_VALUE); b = new ShortBuilder(); b.setShortBuilder(Short.MIN_VALUE); Assert.assertEquals(b.getShortBuilder(), Short.MIN_VALUE); b = new ShortBuilder(); b.setShortBuilder(Short.MAX_VALUE); Assert.assertEquals(b.getShortBuilder(), Short.MAX_VALUE); b = new ShortBuilder(); b.setShortBuilder(Short.MIN_VALUE); Assert.assertEquals(b.getShortBuilder(), Short.MIN_VALUE); b = new ShortBuilder(); b.setShortBuilder(Short.MAX_VALUE); Assert.assertEquals(b.getShortBuilder(), Short.MAX_VALUE); }
@Test public void testShortBuilder() { ShortBuilder b = new ShortBuilder(); b.setShortBuilder(Short.valueOf((short)1)); Assert.assertEquals(b, new ShortBuilder().setShortBuilder(Short.valueOf((short)1)).build()); b = new ShortBuilder(); b.setShortBuilder(null); Assert.assertNull(b.getShortBuilder()); b = new ShortBuilder(); b.setShortBuilder(Short.valueOf((short)1)); Assert.assertNull(b.getShortBuilder()); b = new ShortBuilder(); b.setShortBuilder(Short.valueOf((short)1)); Assert.assertEquals(b, new ShortBuilder().setShortBuilder(Short.valueOf((short)1)).build()); b = new ShortBuilder(); b.setShortBuilder(Short.valueOf((short)1)); Assert.assertNull(b.getShortBuilder()); }
@Test public void testLongBuilder() { LongBuilder b = new LongBuilder(); b.setLongBuilder(b); LongBuilder b2 = b.getLongBuilder(); assertEquals(b, b2); b2 = null; b = b.getLongBuilder(); assertEquals(b, b2); b2 = b.getLongBuilder(); assertEquals(b, b2); }
@Test public void testLongBuilder() { LongBuilder b = new LongBuilder(); b.setLongBuilder(1234567890L); assertTrue(b.getLongBuilder() == 1234567890L); b = new LongBuilder(); b.setLongBuilder(1234567890L); assertTrue(b.getLongBuilder() == 1234567890L); b = new LongBuilder(); b.setLongBuilder(1234567890L); assertTrue(b.getLongBuilder() == 1234567890L); b = new LongBuilder(); b.setLongBuilder(1234567890L); assertTrue(b.getLongBuilder() == 1234567890L); b = new LongBuilder(); b.setLongBuilder(1234567890L); assertTrue(b.getLongBuilder() == 1234567890L); b = new LongBuilder(); b.setLongBuilder(1234567890L); assertTrue(b.getLongBuilder() == 1234567890L); b = new LongBuilder(); b.setLongBuilder(1234567890L); assertTrue(b.getLongBuilder() == 1234567890L); b = new LongBuilder(); b.setLongBuilder(1234567890L); assertTrue(b.getLongBuilder() == 1234567890L); b = new LongBuilder(); b.setLongBuilder(
@Test public void testLongBuilder() { LongBuilder b = new LongBuilder(); b.setLongBuilder(null); LongBuilder b2 = b.getLongBuilder(); assertTrue(b.equals(b2)); b2 = b.new LongBuilder(); b2.setLongBuilder(null); b = b.new LongBuilder(); b2.setLongBuilder(b2); assertTrue(b.equals(b2)); b2 = b.new LongBuilder(); b2.setLongBuilder(b2); assertTrue(b.equals(b2)); }
@Test public void testLongBuilder() { LongBuilder b = new LongBuilder(); b.setLongBuilder(1234567890L); LongBuilder b2 = b.getLongBuilder(); assertEquals(1234567890L, b2.getLongBuilder().longValue()); b2 = b.new LongBuilder(); b2.setLongBuilder(1234567890L); b2 = b.new LongBuilder(); b2.setLongBuilder(1234567890L); assertEquals(1234567890L, b2.getLongBuilder().longValue()); b2 = b.new LongBuilder(); b2.setLongBuilder(1234567890L); b2 = b.new LongBuilder(); b2.setLongBuilder(1234567890L); assertEquals(1234567890L, b2.getLongBuilder().longValue()); }
@Test public void testDoubleBuilder() { DoubleBuilder b = new DoubleBuilder(); b.setDoubleBuilder(true); DoubleBuilder b2 = b.getDoubleBuilder(); assertTrue(b2.equals(b)); b2 = new DoubleBuilder(); b2.setDoubleBuilder(false); b2 = b.getDoubleBuilder(); assertTrue(b2.equals(b)); b2 = null; }
@Test public void testDoubleBuilder() { DoubleBuilder b = new DoubleBuilder(); b.setDoubleBuilder(DoubleBuilder.EMPTY); assertTrue(b.getDoubleBuilder() == null); b = new DoubleBuilder(); b.setDoubleBuilder(DoubleBuilder.EMPTY); assertTrue(b.getDoubleBuilder() == null); b = new DoubleBuilder(); b.setDoubleBuilder(DoubleBuilder.EMPTY); assertTrue(b.getDoubleBuilder() == null); b = new DoubleBuilder(); b.setDoubleBuilder(DoubleBuilder.EMPTY); assertTrue(b.getDoubleBuilder() == null); b = new DoubleBuilder(); b.setDoubleBuilder(DoubleBuilder.EMPTY); assertTrue(b.getDoubleBuilder() == null); }
@Test public void testDoubleBuilder() { DoubleBuilder b = new DoubleBuilder(); b.setDoubleBuilder(DoubleBuilder.EMPTY); DoubleBuilder b2 = b.getDoubleBuilder(); assertTrue(b2.equals(b)); b2 = b.getDoubleBuilder(); assertTrue(b2.equals(b)); b2 = null; b = b.getDoubleBuilder(); assertTrue(b2.equals(b)); }
@Test public void testDoubleBuilder() { DoubleBuilder b = new DoubleBuilder(); b.setDoubleBuilder(1.0); assertEquals(b, b.getDoubleBuilder()); b = null; b.setDoubleBuilder(DoubleBuilder.EMPTY); assertEquals(b, b.getDoubleBuilder()); b = new DoubleBuilder(); b.setDoubleBuilder(DoubleBuilder.POSITIVE_INFINITY); assertEquals(b, b.getDoubleBuilder()); b = new DoubleBuilder(); b.setDoubleBuilder(DoubleBuilder.POSITIVE_INFINITY); assertEquals(b, b.getDoubleBuilder()); b = new DoubleBuilder(); b.setDoubleBuilder(DoubleBuilder.POSITIVE_INFINITY); assertEquals(b, b.getDoubleBuilder()); b = new DoubleBuilder(); b.setDoubleBuilder(DoubleBuilder.POSITIVE_INFINITY); assertEquals(b, b.getDoubleBuilder()); }
@Test public void testShortBuilder() { ShortBuilder builder = new ShortBuilder(); Iterator<Short> iter = builder.getShortBuilder().newIterator(); assertTrue(iter.hasNext()); assertEquals(new ShortBuilder().setByte(new byte[] { (byte)0?1 : (byte)0?2 : (byte)0?3 }).setShort(new short[] { (short)0?1 : (short)0?3 : (short)0?4 })); assertTrue(iter.hasNext()); assertEquals(new ShortBuilder().setByte(new byte[] { (byte)0?1 : (byte)0?2 : (byte)0?3 : (byte)0?4 })); assertTrue(iter.hasNext()); assertEquals(new ShortBuilder().setShort(new short[] { (short)0?1 : (short)0?3 : (short)0?4 : (short)0?5 })); assertTrue(iter.hasNext()); assertEquals(new ShortBuilder().setShort(new short[] { (short)0?1 : (short)0?3 : (short)0?4 : (short)0?5 })); assertTrue(iter.hasNext()); assertEquals(new ShortBuilder().set
@Test public void test_constructArray() { T[] array = new T[] { new ByteBuilder().setByte(new byte[] {0, (byte)0}).setShort(new short[] {0, (short)0}).setLong(new long[] {0, (long)0}).setFloat(new FloatBuilder().setFloat(new FloatBuilder().setFloat(new FloatBuilder().setFloat(new FloatBuilder().setFloat(1.0))).setDouble(new doubleBuilder().setDouble(1.0)).build(), new int[] {0, (byte)0}) }; Iterator<Short> iter = array[0].constructArray(array.length); assertTrue(iter.hasNext()); assertArrayEquals(new short[] {0, (byte)0}, iter.next()); }
@Test public void testByteBuilder() { byte[] array = new byte[] { (byte) 0b1111111, (byte) 0b1111111, (byte) 0b1111111, (byte) 0b1111111, (byte) 0b1111111, (byte) 0b1111111, (byte) 0b1111111, (byte) 0b1111111, (byte) 0b1111111, (byte) 0b1111111, (byte) 0b1111111, (byte) 0b1111111, (byte) 0b1111111, (byte) 0b1111111, (byte) 0b1111111, (byte) 0b1111111, (byte) 0b1111111, (byte) 0b1111111, (byte) 0b1111111, (byte) 0b1111111, (byte) 0b1111111, (byte) 0b1111111, (byte) 0b1111111, (byte) 0b1111111, (byte) 0b1111111, (byte) 0b1111111, (byte) 0b1111111, (byte) 0b1111111, (byte) 0b1111111, (byte) 0b1111
@Test public void testLongBuilder() { LongBuilder b = new LongBuilder(); b.setLong(42); b.setFloatBuilder(1.1f); b.setDoubleBuilder(3.43d); assertEquals(b, b.getLongBuilder()); }
@Test public void test_constructArray() { assertTrue(new LongBuilder().setLongBuilder(new long[] {0, 1, 2}).constructArray(8) == 2); assertTrue(new LongBuilder().setLongBuilder(new long[] {0, 1, 2}).constructArray(8) == 2); assertTrue(new LongBuilder().setLongBuilder(new long[] {0, 1, 2}).constructArray(8) == 10); assertTrue(new LongBuilder().setLongBuilder(new long[] {0, 1, 2}).constructArray(8) == 10); assertTrue(new LongBuilder().setLongBuilder(new long[] {0, 1, 2}).constructArray(8) == 10); assertTrue(new LongBuilder().setLongBuilder(new long[] {0, 1, 2}).constructArray(8) == 10); assertTrue(new LongBuilder().setLongBuilder(new long[] {0, 1, 2}).constructArray(8) == 10); assertTrue(new LongBuilder().setLongBuilder(new long[] {0, 1, 2}).constructArray(8) == 10); assertTrue(new LongBuilder().setLongBuilder(new long[] {0, 1, 2, 2}).constructArray(8) == 10); assertTrue(new LongBuilder().setLongBuilder(new long[] {0, 1, 2, 2}).constructArray(8) == 10); assertTrue(new
@Test public void testByteBuilder() { byte[] array = new byte[] {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; BooleanBuilder b = new BooleanBuilder(); b.setBoolBuilder(true); b.setByteBuilder(new ByteBuilder().setInt(array)); b.setLongBuilder(new LongBuilder().setLong(array.length)); FloatBuilder f = new FloatBuilder(); f.setFloatBuilder(new FloatBuilder().setDoubleBuilder(array)); DoubleBuilder d = new DoubleBuilder(); d.setDoubleBuilder(array.length); assertEquals(array, b.build().constructArray(array.length)); }
@Test public void testDoubleBuilder() { DoubleBuilder b = new DoubleBuilder(); Assert.assertEquals(b.getByteBuilder().getLongValue(), publ.getByteBuilder().getLongValue()); Assert.assertEquals(b.getFloatBuilder().getFloatValue(), publ.getFloatBuilder().getFloatValue()); }
@Test public void test_constructArray() { Double[] array = new DoubleBuilder().setByteBuilder().setShortBuilder().setLongBuilder().setFloatBuilder().setDoubleBuilder().setDoubleBuilder().build(); assertArrayEquals(new double[] {0, 1, 2, 3, 4, 5}, array); }
@Test public void testDoubleArray() { Double[] array = new DoubleBuilder().setArray(Double.class, new double[] {1.0}).build().constructArray(Integer.MAX_VALUE); assertArrayEquals(new double[] {1.0}, array); array = new DoubleBuilder().setArray(Double.class, new double[] {1.0}).setArray(Integer.MAX_VALUE); assertArrayEquals(new double[] {1.0}, array); array = new DoubleBuilder().setArray(Double.class, new double[] {1.0}).setArray(Integer.MAX_VALUE); assertArrayEquals(new double[] {1.0}, array); array = new DoubleBuilder().setArray(Double.class, new double[] {1.0}).setArray(Integer.MAX_VALUE); assertArrayEquals(new double[] {1.0}, array); }
@Test public void testArrayComparator() { assertEquals(ArrayComparator.getArrayComparator(null), null); assertEquals(ArrayComparator.getArrayComparator(null), null); assertEquals(ArrayComparator.getArrayComparator(new Object[] {}), null); assertEquals(ArrayComparator.getArrayComparator(new Object[] { "a", "b", "c" }), new Object[] { "a", "b", "c" }); assertEquals(ArrayComparator.getArrayComparator(new Object[] { "a", "b", "c" }), new Object[] { "a", "b", "c" }); assertEquals(ArrayComparator.getArrayComparator(new Object[] { "a", "b", "c" }), new Object[] { "a", "b", "c" }); assertEquals(ArrayComparator.getArrayComparator(new Object[] { "a", "b", "c" }), new Object[] { "a", "b", "c" }); assertEquals(ArrayComparator.getArrayComparator(new Object[] { "a", "b", "c" }), new Object[] { "a", "b", "c" }); assertEquals(ArrayComparator.getArrayComparator(new Object[] { "a", "b",
@Test public void testArrayComparator() { assertArrayEquals(new Object[] { 1, 2, 3 }, getArrayComparator(new Object[] { 1, 2, 3 })); assertArrayEquals(new Object[] { 1, 2, 3 }, getArrayComparator(new Object[] { 1, 2, 3 })); assertArrayEquals(new Object[] { 1, 2, 3 }, getArrayComparator(new Object[] { 1, 2, 3 })); assertArrayEquals(new Object[] { 1, 2, 3 }, getArrayComparator(new Object[] { 1, 2, 3 })); assertArrayEquals(new Object[] { 1, 2, 3 }, getArrayComparator(new Object[] { 1, 2, 3 })); assertArrayEquals(new Object[] { 1, 2, 3 }, getArrayComparator(new Object[] { 1, 2, 3 })); assertArrayEquals(new Object[] { 1, 2, 3 }, getArrayComparator(new Object[] { 1, 2, 3 })); assertArrayEquals(new Object[] { 1, 2, 3 }, getArrayComparator(new Object[] { 1, 2, 3 })); assertArrayEquals(new Object[] { 1, 2, 3 }, getArrayComparator(new Object[] { 1, 2, 3 })); assertArrayEquals(new Object[] { 1, 2, 3 }, getArrayComparator(new Object[] { 1, 2, 3 })); assertArrayEquals(new Object[] { 1, 2, 3 }, getArrayComparator(new Object[] { 1, 2, 3 })); assertArrayEquals(new
@Test public void testArrayComparator() { assertArrayEquals(new Class[] { Integer.class, Integer.class }, getArrayComparator(new Integer[] { Integer.valueOf(0), Integer.valueOf(0), Integer.valueOf(0)) }); assertArrayEquals(new Class[] { Integer.class, Integer.class }, getArrayComparator(new Integer[] { Integer.valueOf(0), Integer.valueOf(0), Integer.valueOf(0)) }); assertArrayEquals(new Class[] { Integer.class, Integer.class }, getArrayComparator(new Integer[] { Integer.valueOf(0), Integer.valueOf(0), Integer.valueOf(0)) }); assertArrayEquals(new Class[] { Integer.class, Integer.class }, getArrayComparator(new Integer[] { Integer.valueOf(0), Integer.valueOf(0), Integer.valueOf(0)) }); assertArrayEquals(new Class[] { Integer.class, Integer.class }, getArrayComparator(new Integer[] { Integer.valueOf(0), Integer.valueOf(0), Integer.valueOf(0)) }); assertArrayEquals(new Class[] { Integer.class, Integer.class }, getArrayComparator(new Integer[] { Integer.valueOf(0), Integer.valueOf(0), Integer.valueOf(0)) }); assertArrayEquals(new Class[] { Integer.class, Integer.class }, getArrayComparator(
@Test public void testArrayComparator() { final Object[] defaultValueValues = { null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null
@Test public void testArrayComparator() { final Object defaultValue = new Object() { @Override public int getLength() { return 10; } }; final Object comparator = new Object() { @Override public int getLength() { return 10; } }; assertArrayEquals(new Object[] { 0, null, null, null, null }, getArrayComparator(defaultValue)); assertArrayEquals(new Object[] { 0, null, null, null }, getArrayComparator(defaultValue)); assertArrayEquals(new Object[] { 0, null, null, null }, getArrayComparator(defaultValue)); assertArrayEquals(new Object[] { 0, null, null, null }, getArrayComparator(defaultValue)); assertArrayEquals(new Object[] { 0, null, null, null }, getArrayComparator(defaultValue)); assertArrayEquals(new Object[] { 0, null, null, null }, getArrayComparator(defaultValue)); assertArrayEquals(new Object[] { 0, null, null, null }, getArrayComparator(defaultValue)); assertArrayEquals(new Object[] { 0, null, null, null }, getArrayComparator(defaultValue)); assertArrayEquals(new Object[] { 0, null, null, null }, getArrayComparator(defaultValue)); assertArrayEquals(new Object[] { 0, null, null, null }, getArrayComparator(defaultValue)); assertArrayEquals(new Object[]
@Test public void testArrayComparator() { Object[] values = new Object[] { "a", "b", "c" }; Arrays.sort(values); Arrays.sort(values); Arrays.sort(values); Arrays.sort(values); Arrays.sort(values); Arrays.sort(values); Arrays.sort(values); Arrays.sort(values); Arrays.sort(values); Arrays.sort(values); }
@Test public void testArrayComparator() { Object[] defaultValueValues = new Object[] { null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null
@Test public void testArrayComparator() { Object[] emptyArray = new Object[] {}; Arrays.fill(emptyArray, 0, 1); Arrays.fill(emptyArray, 1, 2); Arrays.fill(emptyArray, 2, 3); Arrays.fill(emptyArray, 4, 5); Arrays.fill(emptyArray, 6, 7); Arrays.fill(emptyArray, 8, 9); Arrays.fill(emptyArray, 9, 10); Arrays.fill(emptyArray, 10, 10); Arrays.fill(emptyArray, 11, 12); Arrays.fill(emptyArray, 12, 13); Arrays.fill(emptyArray, 14, 15); Arrays.fill(emptyArray, 16, 16); Arrays.fill(emptyArray, 17, 18); Arrays.fill(emptyArray, 16, 16); Arrays.fill(emptyArray, 17, 18); Arrays.fill(emptyArray, 17, 18); Arrays.fill(emptyArray, 17, 18); Arrays.fill(emptyArray, 17, 18); Object comparator = getArrayComparator(null); assertEquals(comparator, emptyArray); assertEquals(comparator, getArrayComparator(null)); assertEquals(comparator, getArrayComparator(null)); assertEquals(comparator, getArrayComparator(null)); assertEquals(comparator, getArrayComparator(null, 4)); assertEquals(compar
@Test public void testArrayComparator() { final int[] ints = new int[] {1, 2, 3, 4, 5, 6, 7, 8, 9}; final int[] emptyInts = new int[] {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; final int[] emptyNull = new int[] {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; final int[] emptyDifferentInts = new int[] {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; assertArrayEquals(new Object[] {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}, getArrayComparator(emptyInts)); assertArrayEquals(new Object[] {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}, getArrayComparator(emptyInts)); assertArrayEquals(new Object[] {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}, getArrayComparator(emptyNull)); assertArrayEquals(new Object[] {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}, getArrayComparator(emptyInts)); assertArrayEquals(new Object[] {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}, getArrayComparator(emptyNull)); assertArrayEquals(new Object[] {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}, getArrayComparator(emptyNull)); assertArrayEquals(new Object[] {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}, getArrayComparator
@Test public void testArrayComparator() { assertArrayEquals(new Object[] { 1, 2, 3 }, getArrayComparator(null)); assertArrayEquals(new Object[] { 1, 2, 3 }, getArrayComparator(new Object[] { 1, 2, 3 })); assertArrayEquals(new Object[] { 1, 2, 3 }, getArrayComparator(new Object[] { 1, 2, 3 })); assertArrayEquals(new Object[] { 1, 2, 3 }, getArrayComparator(new Object[] { 1, 2, 3 })); assertArrayEquals(new Object[] { 1, 2, 3 }, getArrayComparator(new Object[] { 1, 2, 3 })); assertArrayEquals(new Object[] { 1, 2, 3 }, getArrayComparator(new Object[] { 1, 2, 3 })); assertArrayEquals(new Object[] { 1, 2, 3 }, getArrayComparator(new Object[] { 1, 2, 3 })); assertArrayEquals(new Object[] { 1, 2, 3 }, getArrayComparator(new Object[] { 1, 2, 3 })); assertArrayEquals(new Object[] { 1, 2, 3 }, getArrayComparator(new Object[] { 1, 2, 3 })); assertArrayEquals(new Object[] { 1, 2, 3 }, getArrayComparator(new Object[] { 1, 2, 3 })); assertArrayEquals(new Object[] { 1, 2, 3 }, getArrayComparator(new Object[] { 1, 2, 3 })); assertArrayEquals(new Object[] { 1, 2, 3
@Test public void testArrayComparator() { assertArrayEquals(new Object[] { "a", "b", "c" }, getArrayComparator(null)); assertArrayEquals(new Object[] { "a", "b", "c" }, getArrayComparator(new Object[] { "a", "b", "c" })); assertArrayEquals(new Object[] { "a", "b", "c" }, getArrayComparator(new Object[] { "a", "b", "c" })); assertArrayEquals(new Object[] { "a", "b", "c" }, getArrayComparator(new Object[] { "a", "b", "c" })); assertArrayEquals(new Object[] { "a", "b", "c" }, getArrayComparator(new Object[] { "a", "b", "c" })); assertArrayEquals(new Object[] { "a", "b", "c" }, getArrayComparator(new Object[] { "a", "b", "c" })); assertArrayEquals(new Object[] { "a", "b", "c" }, getArrayComparator(new Object[] { "a", "b", "c" })); assertArrayEquals(new Object[] { "a", "b", "c" }, getArrayComparator(
@Test public void testArrayComparator() { assertArrayEquals(new Object[] { null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null
@Test public void testArrayComparator() { assertArrayEquals(new Object[] { null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null
@Test public void testArrayComparator() { assertArrayEquals(new Object[] { "a", "b", "c" }, getArrayComparator(new Object[] { "a", "b", "c" })); assertArrayEquals(new Object[] { "a", "b", "c" }, getArrayComparator(new Object[] { "a", "b", "c" })); assertArrayEquals(new Object[] { "a", "b", "c" }, getArrayComparator(new Object[] { "a", "b", "c" })); assertArrayEquals(new Object[] { "a", "b", "c" }, getArrayComparator(new Object[] { "a", "b", "c" })); assertArrayEquals(new Object[] { "a", "b", "c" }, getArrayComparator(new Object[] { "a", "b", "c" })); assertArrayEquals(new Object[] { "a", "b", "c" }, getArrayComparator(new Object[] { "a", "b", "c" })); assertArrayEquals(new Object[] { "a", "b", "c" }, getArrayComparator(new Object[] { "a", "b", "c" })); assertArrayEquals(new Object[] { "
@Test public void testArrayComparator() { final Object[] defaultValueValues = { null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null
@Test public void testWithAbstractTypeResolver() { DeserializerFactoryConfig deser = new DeserializerFactoryConfig().withAbstractTypeResolver(new NoOpAbstractTypeResolver()).withAdditionalDeserializers(Deserializerializers.STRING_DESERIALIZER).withAdditionalKeyDeserializers(Deserializerializers.STRING_DESERIALIZER).withAdditionalDeserializerModifiers(BeanDeserializerModifier.DESERIALIZER_MODIFIER).withValueInstantiators(new MockValueInstantiators()).build(); DeserializerFactoryConfig deser2 = new DeserializerFactoryConfig().withAbstractTypeResolver(new NoOpAbstractTypeResolver()).withAdditionalDeserializers(Deserializerializers.STRING_DESERIALIZER).withAdditionalKeyDeserializers(Deserializerializers.STRING_DESERIALIZER).withAdditionalDeserializerModifiers(BeanDeserializerModifier.DESERIALIZER_MODIFIER).withValueInstantiators(new MockValueInstantiators()).build(); assertEquals(deser, deser2); }
@Test public void testWithAbstractTypeResolver() { DeserializerFactoryConfig config = new DeserializerFactoryConfig().withAdditionalDeserializers(Deserializerializers.BEAN_DESERIALIZER).withAdditionalKeyDeserializers(Deserializerializers.BEAN_DESERIALIZER).withDeserializerModifier(BeanDeserializerModifier.ANNOTATION_NULL).withValueInstanti(new SimpleInstanti("foo", null)); assertEquals(new DeserializerFactoryConfig().withAbstractTypeResolver(new DefaultAbstractTypeResolver(new DefaultTypeResolver(new DefaultTypeResolver(new DefaultTypeResolver(new DefaultTypeResolver(new DefaultTypeResolver(new DefaultTypeResolver(new DefaultTypeResolver(new DefaultTypeResolver(new DefaultTypeResolver(new DefaultTypeResolver(new DefaultTypeResolver(new DefaultTypeResolver(new DefaultTypeResolver(new DefaultTypeResolver(new DefaultTypeResolver(new DefaultTypeResolver(new DefaultTypeResolver(new DefaultTypeResolver(new DefaultTypeResolver(new DefaultTypeResolver(new DefaultTypeResolver(new DefaultTypeResolver(new DefaultTypeResolver(new DefaultTypeResolver(new DefaultTypeResolver(new DefaultTypeResolver(new DefaultTypeResolver(new DefaultTypeResolver(new DefaultTypeResolver(new DefaultTypeResolver
@Test public void testWithAbstractTypeResolver() { DeserializerFactoryConfig config = new DeserializerFactoryConfig().withAbstractTypeResolver(new NoOpAbstractTypeResolver(new NoOpAbstractTypeResolver())); DeserializerFactoryConfig config2 = config.withAbstractTypeResolver(new NoOpAbstractTypeResolver(new NoOpAbstractTypeResolver())); assertThat(config, equalTo(config2)); }
@Test public void testWithAbstractTypeResolver() { DeserializerFactoryConfig deser = new DeserializerFactoryConfig().withAdditionalDeserializers(Deserializerializers.BEAN_DESERIALIZER).withAdditionalKeyDeserializers(Deserializerializers.BEAN_DESERIALIZER).withAdditionalDeserializerModifiers(BeanDeserializerModifier.DESERIALIZER_FINAL).withValueInstantiators(new MockValueInstantiators(Instant.EPOCH)).withAdditionalDeserializers(Deserializerializers.BEAN_DESERIALIZER).withAdditionalKeyDeserializers(Deserializerializers.BEAN_DESERIALIZER).withAdditionalModifiers(BeanDeserializerModifier.DESERIALIZER_FINAL).withValueInstantiators(new MockValueInstantiators(Instant.EPOCH)).withAdditionalDeserializers(Deserializerializers.BEAN_DESERIALIZER).withAdditionalModifiers(DeserializerModifier.DESERIALIZER_FINAL).withAdditionalKeyDeserializers(Deserializerializers.BEAN_DESERIALIZER).withAdditionalModifiers(DeserializerModifier.DESERIALIZER_FINAL).withValueInstantiators(new MockValueInstantiators(Instant.EPOCH)).
@Test public void test_constructor_named_transformer() throws Exception { StringWriter sw = new StringWriter(); new UnwrappingBeanPropertyWriter(writer, new NameTransformer() { @Override public void transform(String s, String s2){ sw.append(s); } }); writer.close(); }
@Test public void testWriter() throws Exception { StringWriter sw = new StringWriter(); new UnwrappingBeanPropertyWriter(new JsonWriter(sw), new NameTransformer() { @Override public void transform(String s, JsonValue s2) throws Exception { sw.append("\"a\"").append("b").append("c").append("d").append("e").append("f").append("g").append("h").append("i").append("j").append("k").append("l").append("l").append("l").append("k").append("l").append("k").append("l").append("k").append("l").append("k").append("l").append("k").append("l").append("k").append("l").append("k").append("l").append("k").append("l").append("k").append("l").append("k").append("l").append("k").append("l").append("k").append("l").append("k").append("l").append("k").append("l").append("k").append("l").append("k").append("l").append("k").append("l").append("k").append("l").
@Test public void test_rename() throws Exception { NameTransformer transformer = new NameTransformer() { @Override public void transform(String name, String value) { } }; UnwrappingBeanPropertyWriter writer = new UnwrappingBeanPropertyWriter(new JsonBeanPropertyWriter(), transformer); writer.rename(transformer); writer.serializeAsField(new Object(), JsonGenerator.getInstance(), new SimpleSerializerProvider()); }
@Test public void serializeAsField() throws Exception { TestClass bean = new TestClass(); bean.foo = "bar"; bean.bar = "baz"; _serialiser.serializeAsField(bean, _jgen, null); assertEquals("bar", bean.bar); }
@Test public void serializeAsField_beanIsNull() throws Exception { Foo foo = new Foo(); foo.foo = null; Foo bar = new Foo(); bar.foo = foo; JsonGenerator jgen = mock(JsonGenerator.class); when(jgen.writerFor(eq(foo))).thenReturn(bar); _testBean.serializeAsField(foo, jgen, null); verify(_testBean, never()).foo(); }
@Test public void serializeAsField_null() throws Exception { TestBean bean = new TestBean(); bean.foo = null; JsonGenerator jgen = mock(JsonGenerator.class); _writer.serializeAsField(bean, jgen, null); verify(_writer, never()).flush(); }
@Test public void serializeAsField() throws Exception { JsonSerializer<Object> ser = _serializer; JsonGenerator jgen = mock(JsonGenerator.class); when(ser.isEmpty(anyObject())).thenReturn(true); when(ser.iterator()).thenReturn(new Object[] { "foo" }); JsonSerializer<Object> bean = new JsonSerializer<Object>(); bean.serializeAsField(new Object(), jgen, null); verify(jgen).writeString("foo"); }
@Test public void serializeAsField_suppressableNull() throws Exception { TestBean bean = new TestBean(); bean.suppressableNull = null; _writer.serializeAsField(bean, _jgen, null); assertThat(_writer.flush(), is(true)); }
@Test public void serializeAsField() throws Exception { TestBean bean = new TestBean(); bean.setFoo("bar"); bean.setBar("baz"); JsonGenerator jgen = mock(JsonGenerator.class); when(jgen.flush()).thenReturn(true); JsonSerializer<Object> ser = mock(JsonSerializer.class); when(ser.isEmpty(bean)).thenReturn(true); when(ser.iterator()).thenReturn(Collections.emptyIterator()); _serialiser.serializeAsField(bean, jgen, null); verify(_dynamicSerializers).add(eq(bean)); }
@Test public void serializeAsField_bean() throws Exception { TestBean bean = new TestBean(); bean.foo = "bar"; bean.bar = "baz"; _writer.serializeAsField(bean, _jgen, null); assertEquals("bar", bean.bar); }
@Test public void serializeAsField() throws Exception { TestBean bean = new TestBean(); bean.setFoo("bar"); bean.setBar("baz"); JsonSerializer<Object> ser = mock(JsonSerializer.class); when(ser.isUnwrappingSerializer()).thenReturn(true); when(ser.iterator()).thenReturn(Collections.singletonList("foo")); JsonSerializer<Object> mapper = mock(JsonSerializer.class); when(mapper.serializerFor(TestBean.class)).thenReturn(mapper); mapper.serializeAsField(bean, null, null); verify(ser).isUnwrappingSerializer(); verify(mapper).serialize(bean); }
@Test public void serializeAsField() throws Exception { TestBean bean = new TestBean(); bean.setFoo("bar"); bean.setBar("baz"); JsonGenerator jgen = mock(JsonGenerator.class); when(jgen.flush()).thenReturn(true); JsonSerializer<Object> ser = mock(JsonSerializer.class); when(ser.isEmpty(bean)).thenReturn(true); when(ser.iterator()).thenReturn(Collections.emptyIterator()); JsonSerializer<Object> mapper = mock(JsonSerializer.class); when(mapper.serializerFor(TestBean.class)).thenReturn(ser); mapper.serializeAsField(bean, jgen, null); verify(jgen).flush(); }
@Test public void serializeAsField() throws Exception { TestBean bean = new TestBean(); JsonGenerator jgen = mock(JsonGenerator.class); when(bean.get(eq("foo"))).thenReturn(null); when(bean.get(eq("bar"))).thenReturn("foo"); _serial.serializeAsField(bean, jgen, null); verify(_serial).serialize("foo", jgen, null); }
@Test public void testAssignSerializer() throws Exception { JsonSerializer<Object> ser = new JsonSerializer<Object>() { @Override public void unwrappingSerializer(JsonSerializer<Object> jsonSerializer) throws Exception { } }; JsonSerializer<Object> unwrappingSerializer = new JsonSerializer<Object>() { @Override public void unwrappingSerializer(JsonSerializer<Object> jsonSerializer) throws Exception { } }; JsonSerializer<Object> unwrappingSerializer2 = new JsonSerializer<Object>() { @Override public void unwrappingSerializer(JsonSerializer<Object> jsonSerializer2) throws Exception { } }; JsonSerializer<Object> unwrappingSerializer3 = new JsonSerializer<Object>() { @Override public void unwrappingSerializer(JsonSerializer<Object> jsonSerializer) throws Exception { } }; JsonSerializer<Object> unwrappingSerializer4 = new JsonSerializer<Object>() { @Override public void unwrappingSerializer(JsonSerializer<Object> jsonSerializer) throws Exception { } }; JsonSerializer<Object> unwrappingSerializer5 = new JsonSerializer<Object>() { @Override public void unwrappingSerializer(JsonSerializer<Object> jsonSerializer) throws Exception { } }; JsonSerializer<Object> unwrappingSerializer
@Test public void testAssignSerializer() throws Exception { JsonSerializer<Object> ser = new JsonSerializer<Object>() { @Override public void unwrappingSerializer(JsonSerializer<Object> jsonSerializer) throws Exception { } }; JsonSerializer<Object> unwrappingSerializer = new JsonSerializer<Object>() { @Override public void unwrappingSerializer(JsonSerializer<Object> jsonSerializer) throws Exception { } }; JsonSerializer<Object> jsonSerializer2 = new JsonSerializer<Object>() { @Override public void unwrappingSerializer(JsonSerializer<Object> jsonSerializer2) throws Exception { } }; JsonSerializer<Object> jsonSerializer3 = new JsonSerializer<Object>() { @Override public void unwrappingSerializer(JsonSerializer<Object> jsonSerializer) throws Exception { } }; JsonSerializer<Object> jsonSerializer4 = new JsonSerializer<Object>() { @Override public void unwrappingSerializer(JsonSerializer<Object> jsonSerializer) throws Exception { } }; JsonSerializer<Object> jsonSerializer5 = new JsonSerializer<Object>() { @Override public void unwrappingSerializer(JsonSerializer<Object> jsonSerializer) throws Exception { } }; JsonSerializer<Object> jsonSerializer6 = new JsonSerializer<Object>() { @Override public void un
@Test public void testAssignSerializer() throws Exception { TestBean bean = new TestBean(); JsonSerializer<Object> serializer = new JsonSerializer<Object>() { @Override public void unwrappingSerializer(JsonSerializer<Object> jsonSerializer) throws Exception { jsonSerializer.unwrappingSerializer(jsonSerializer); } }; bean.assignSerializer(serializer); }
@Test public void testAssignSerializer() throws Exception { NameTransformer transformer = new NameTransformer(); JsonSerializer<Object> jsonSerializer = new JsonSerializer<>(); JsonSerializer<Object> jsonWrapper = new JsonSerializer<>(); transformer.addNameTransformer(new NameTransformer() { @Override public void transform(Object o, JsonSerializationContext context) throws Exception { context.assertEquals(o, jsonWrapper); } }); JsonSerializer<Object> jsonWrapper2 = new JsonSerializer<>(); transformer.addNameTransformer(new NameTransformer() { @Override public void transform(Object o, JsonSerializationContext context) throws Exception { context.assertEquals(o, jsonWrapper2); } }); JsonSerializer<Object> jsonWrapper3 = new JsonSerializer<>(); transformer.addNameTransformer(new NameTransformer() { @Override public void transform(Object o, JsonSerializationContext context) throws Exception { context.assertEquals(o, jsonWrapper3); } }); JsonSerializer<Object> jsonWrapper4 = new JsonSerializer<>(); transformer.addNameTransformer(new NameTransformer() { @Override public void transform(Object o, JsonSerializationContext context) throws Exception { context.assertEquals(o, jsonWrapper4); } }); JsonSerializer<Object> jsonWrapper5 = new JsonSerializer
@Test public void testAssignSerializer() throws Exception { UnwrappingBeanSerializer unwrappingBeanSerializer = new UnwrappingBeanSerializer(new JsonPrimitiveType(String.class), new JsonPrimitiveType(Integer.class)); UnwrappingBeanPropertyWriter writer = new UnwrappingBeanPropertyWriter(new MockUnwrappingBeanPropertyWriter(unwrappingBeanSerializer), new MockNameTransformer()); writer.assignSerializer(new JsonSerializer<Object>() { @Override public void unwrappingSerializer(JsonSerializer<Object> jsonSerializer) throws Exception { } }); writer.assignSerializer(new JsonSerializer<Object>() { @Override public void unwrappingSerializer(JsonSerializer<Object> jsonSerializer) throws Exception { } }); }
@Test public void testAssignSerializer() throws Exception { UnwrappingBeanPropertyWriter w = new UnwrappingBeanPropertyWriter(new JsonWriter(getClass().getResourceAsStream("/test-bean-prop.json"), new JsonEncodingProvider()), new NameTransformer()); w.assignSerializer(new JsonSerializer<Object>() { @Override public void serializeAsField(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception { } }); JsonReader reader = new JsonReader(getClass().getResourceAsStream("/test-bean-prop.json")); JsonArray json = reader.readAsJsonArray(); assertEquals(json.get("id"), "foo"); JsonArray json2 = reader.readAsJsonArray(); assertEquals(json2.get("id"), "bar"); JsonArray json3 = reader.readAsJsonArray(); assertEquals(json3.get("id"), "baz"); JsonArray json4 = reader.readAsJsonArray(); assertEquals(json4.get("id"), "bar"); JsonArray json5 = reader.readAsJsonArray(); assertEquals(json5.get("id"), "baz"); JsonArray json6 = reader.readAsJsonArray(); assertEquals(json6.get("id"), "bar"); JsonArray json7 = reader.readAsJsonArray(); assertEquals(
@Test public void createContextual_property_annotation_writer_is_null() throws JsonMappingException { BeanProperty property = new BeanProperty(); AnnotationIntrospector intr = provider.getAnnotationIntrospector(); AnnotationIntrospector annotationIntrospector = intr.findAnnotationIntrospector(); AnnotationIntrospector.Setter setter = provider.objectIdSetterInstance(property, null); setter.setIgnore("foo"); setter.setAlwaysAsId("bar"); JsonSerializer<?> contextual = provider.createContextual(null, property); JsonSerializer<?> context = contextual.createContextual(null, property); JsonAssert.assertEquals( "{\"foo\":\"bar\"}", context.writeValueAsString(property)); }
@Test public void createContextual_property_annotation_null() throws JsonMappingException { BeanProperty property = new BeanProperty(null, "id"); AnnotationIntrospector intr = new AnnotationIntrospector(); AnnotationIntrospector.BeanPropertyInfo info = new AnnotationIntrospector.BeanPropertyInfo(property, intr); AnnotationIntrospector.BeanPropertyInfo info2 = new AnnotationIntrospector.BeanPropertyInfo(info, null); AnnotationIntrospector.BeanPropertyInfo info3 = new AnnotationIntrospector.BeanPropertyInfo(info, null); AnnotationIntrospector.BeanPropertyInfo info4 = new AnnotationIntrospector.BeanPropertyInfo(info, null); info2.addProperty(info3); info3.addProperty(info4); JsonSerializer<?> contextual = _oide.createContextual(null, property); JsonParser parser = Json.createReader(contextual).readTree(); String json = (String) parser.parse(json); assertTrue(json.contains("id")); assertTrue(json.contains("id")); assertTrue(json.contains("null")); }
@Test public void serializeWithType_customTypeId_works_as_expected() throws IOException, JsonGenerationException { TestBean bean = new TestBean(); bean.setId("id"); bean.setStringProperty("stringProperty"); bean.setBooleanProperty(true); bean.setBooleanBooleanObjectProperty(false); bean.setBooleanObjectObjectProperty(true); bean.setBooleanObjectObjectObjectProperty(false); bean.setBooleanObjectObjectObjectProperty(true); bean.setBooleanObjectObjectObjectProperty(false); bean.setBooleanObjectObjectObjectProperty(true); bean.setBooleanObjectObjectObjectObjectProperty(false); bean.setBooleanObjectObjectObjectObjectProperty(true); bean.setBooleanObjectObjectObjectObjectProperty(false); bean.setBooleanObjectObjectObjectObjectObjectProperty(true); bean.setBooleanObjectObjectObjectObjectObjectProperty(false); bean.setBooleanObjectObjectObjectObjectObjectProperty(true); bean.setBooleanObjectObjectObjectObjectObjectProperty(false); bean.setBooleanObjectObjectObjectObjectObjectProperty(true); bean.setBooleanObjectObjectObjectObjectObjectProperty(false); bean.setBooleanObjectObjectObjectObjectObjectProperty(true); bean.setBooleanObjectObjectObjectObject
@Test public void testSerializeWithType_writer() throws IOException, JsonGenerationException { TestBean bean = new TestBean(); bean.setId("id"); bean.setPropertyFilterId("filterId"); bean.setPropertyFilterType("string"); bean.setPropertyFilterFilterType("filterType"); bean.setpropertyFilterFilterFilterId("filterFilterId"); StringWriter writer = new StringWriter(); _objectIdWriter.serializeWithType(bean, writer, null, null); assertThat(writer.toString()).isEqualTo("id=\"id\""); }
@Test public void testCustomId() throws IOException, JsonGenerationException { TestClassWithCustomId bean = new TestClassWithCustomId(); bean.setId("id"); bean.setMyCustomId("myCustomId"); bean.setMyCustomField("myCustomField"); bean.setMyCustomField("myCustomField"); bean.setMyCustomField("myCustomField"); bean.setMyCustomField("myCustomField"); bean.setMyCustomField("myCustomField"); bean.setMyCustomField("myCustomField"); bean.setMyCustomField("myCustomField"); bean.setMyCustomField("myCustomField"); bean.setMyCustomField("myCustomField"); bean.setMyCustomField("myCustomField"); bean.setMyCustomField("myCustomField"); bean.setMyCustomField("myCustomField"); bean.setMyCustomField("myCustomField"); bean.setMyCustomField("myCustomField"); bean.setMyCustomField("myCustomField"); bean.setMyCustomField("myCustomField"); bean.setMyCustomField("myCustomField"); bean.setMyCustomField("myCustomField"); bean.setMyCustomField("myCustomField"); bean
@Test public void testSerializeWithType_propertyFilterId() throws IOException, JsonGenerationException { TestBean bean = new TestBean(); bean.setId("id"); bean.setPropertyFilterId("filterId"); bean.setPropertyFilterId("filterId2"); bean.setBeanId("beanId"); StringWriter writer = new StringWriter(); JsonGenerator jgen = new JsonGenerator(writer); TypeSerializer typeSerializer = mock(TypeSerializer.class); PropertyFilterIdFilter idFilter = mock(PropertyFilterIdFilter.class); when(idFilter.filterId(eq("beanId"))).thenReturn(idFilter); bean.setBeanId("beanId"); bean.setPropertyFilterId("id"); bean.setBeanId("beanId2"); bean.setBeanId("beanId3"); bean.setBeanId("beanId4"); bean.setBeanId("beanId5"); bean.setBeanId("beanId6"); bean.setBeanId("beanId7"); bean.setBeanId("beanId8"); bean.setBeanId("beanId9"); bean.setBeanId("beanId10"); bean.setBeanId("beanId11"); bean.setBeanId("beanId12");
@Test public void testWriteCustomTypePrefix() throws IOException, JsonGenerationException { TestBean bean = new TestBean(); bean.setId("id"); bean.setStringField("stringField"); bean.setBooleanField(true); bean.setBooleanBooleanBooleanBooleanBooleanObjectField(true); bean.setBooleanBooleanBooleanBooleanBooleanObjectField(true); bean.setBooleanBooleanBooleanBooleanBooleanObjectField(true); bean.setBooleanBooleanBooleanBooleanBooleanObjectField(true); bean.setBooleanBooleanBooleanBooleanObjectField(false); bean.setBooleanBooleanBooleanBooleanObjectField(false); bean.setBooleanBooleanBooleanBooleanObjectField(true); bean.setBooleanBooleanBooleanObjectField(false); bean.setBooleanBooleanBooleanObjectField(true); bean.setBooleanBooleanBooleanObjectField(false); bean.setBooleanBooleanBooleanObjectField(false); bean.setBooleanBooleanObjectBooleanObjectField(true); bean.setBooleanBooleanObjectBooleanObjectField(false); bean.setBooleanBooleanObjectBooleanObjectField(true); bean.setBooleanBooleanObjectBooleanObjectField(false); bean.setBooleanBooleanObjectBooleanObjectField(true); bean.setBooleanBooleanObjectBooleanObjectField(false); bean.set
@Test public void testSerializeWithType_propertyFilterIdWriter() throws IOException, JsonGenerationException { Bean bean = new Bean(); bean.setId("id"); bean.setPropertyFilterId(null); StringWriter writer = new StringWriter(); JsonGenerator jgen = mock(JsonGenerator.class); TypeSerializer typeSerializer = mock(TypeSerializer.class); when(typeSerializer.writeCustomTypePrefixForObject(bean)).thenReturn("id"); when(typeSerializer.writeCustomTypeSuffixForObject(bean)).thenReturn("id"); bean.serializeWithType(bean, jgen, typeSerializer, typeSerializer); verify(writer).writeString("id"); verify(typeSerializer).writeCustomTypeSuffixForObject(bean); }
@Test public void testSerializeWithType_propertyFilterId() throws IOException, JsonGenerationException { Bean bean = new Bean(); bean.setId("id"); bean.setPropertyFilterId("filterId"); bean.setBeanIdWriter(new StringWriter()); TypeSerializer typeSerializer = mock(TypeSerializer.class); when(typeSerializer.writeCustomTypePrefixForObject(bean, jgen)).thenReturn("id"); bean.serializeWithType(bean, jgen, typeSerializer, null); verify(typeSerializer).writeCustomTypePrefixForObject(bean, jgen, "filterId"); }
@Test public void testSerializeWithType_propertyFilterId() throws IOException, JsonGenerationException { TestBean bean = new TestBean(); bean.setId("id"); bean.setPropertyFilterId("filterId"); bean.setPropertyFilterId("filterId2"); bean.setBeanId("beanId"); StringWriter writer = new StringWriter(); JsonGenerator jgen = new JsonGenerator(writer); TypeSerializer typeSerializer = mock(TypeSerializer.class); PropertyFilterIdFilter idFilter = mock(PropertyFilterIdFilter.class); when(idFilter.filterId(eq("beanId"))).thenReturn(idFilter); bean.setBeanId("beanId"); bean.setPropertyFilterId("id"); bean.setBeanId("beanId2"); bean.setBeanId("beanId3"); bean.setBeanId("beanId4"); bean.setBeanId("beanId5"); bean.setBeanId("beanId6"); bean.setBeanId("beanId7"); bean.setBeanId("beanId8"); bean.setBeanId("beanId9"); bean.setBeanId("beanId10"); bean.setBeanId("beanId11"); bean.setBeanId("beanId12");
@Test public void testWriteCustomTypeSuffixForObject() throws IOException, JsonGenerationException { TestBean bean = new TestBean(); bean.setId("id"); bean.setStringField("stringField"); bean.setBooleanField(true); bean.setBooleanBooleanBooleanBooleanObjectField(true); bean.setBooleanBooleanBooleanBooleanObjectField(false); bean.setBooleanBooleanBooleanBooleanObjectField(true); bean.setBooleanBooleanBooleanBooleanObjectField(false); bean.setBooleanBooleanBooleanObjectField(true); bean.setBooleanBooleanBooleanObjectField(false); bean.setBooleanBooleanBooleanObjectField(true); bean.setBooleanBooleanBooleanObjectField(false); bean.setBooleanBooleanObjectField(true); bean.setBooleanBooleanObjectField(false); bean.setBooleanBooleanObjectField(true); bean.setBooleanObjectBooleanObjectField(false); bean.setBooleanObjectBooleanObjectField(true); bean.setBooleanObjectBooleanObjectField(false); bean.setBooleanObjectBooleanObjectField(true); bean.setBooleanObjectBooleanObjectField(false); bean.setBooleanObjectBooleanObjectField(true); bean.setBooleanObjectBooleanObjectField(false); bean.setBooleanObjectBoolean
@Test public void testSerializeWithObjectId() throws IOException, JsonGenerationException { TestBean bean = new TestBean(); bean.propertyFilterId = null; bean.propertyFilterFilterName = "foo"; bean.propertyFilterType = "bar"; bean.propertyFilterFilterFilterType = "baz"; bean.propertyFilterFilterFilterFilterFilterId = null; TestBean bean2 = new TestBean(); bean2.propertyFilterId = "bar"; bean2.propertyFilterType = "baz"; bean2.propertyFilterFilterFilterType = "baz"; bean2.propertyFilterFilterFilterFilterFilterName = "bar"; bean2.propertyFilterFilterFilterType = "baz"; bean2.propertyFilterFilterFilterFilterType = "baz"; bean2.propertyFilterFilterFilterFilterFilterType = "baz"; bean2.propertyFilterFilterFilterFilterFilterFilterType = "baz"; bean2.propertyFilterFilterFilterFilterFilterFilterType = "baz"; bean2.propertyFilterFilterFilterFilterFilterFilterType = "baz"; bean2.propertyFilterFilterFilterFilterFilterType = "baz"; bean2.propertyFilterFilterFilterFilterFilterType2 = "baz"; bean2.propertyFilterFilterFilterFilterType2 = "baz"; bean2.propertyFilterFilterType2 = "baz"; bean
@Test public void _serializeWithObjectId_propertyFilterId_propertyFilterId_propertyFilterId_filtered() throws IOException, JsonGenerationException { TestBean bean = new TestBean(); bean.propertyFilterId = null; TestBean bean2 = new TestBean(); bean2.propertyFilterId = "testBean2"; bean2.propertyFilterFilterId = null; bean2.propertyFilterFilterFilterName = "testBean2FilterName"; bean2.propertyFilterFilterFilterFilterType = "testBean2FilterType"; bean2.propertyFilterFilterFilterFilterType = "testBean2FilterType"; bean2.propertyFilterFilterFilterFilterFilterName = "testBean2FilterName"; bean2.propertyFilterFilterFilterType = "testBean2FilterType"; bean2.propertyFilterFilterFilterFilterTypeFilter = "testBean2FilterType"; bean2.propertyFilterFilterFilterFilterTypeFilter = "testBean2FilterType"; bean2.propertyFilterFilterFilterFilterTypeFilter = "testBean2FilterType"; bean2.propertyFilterFilterFilterFilterTypeFilter = "testBean2FilterType"; bean2.propertyFilterFilterFilterFilterTypeFilter = "testBean2FilterType"; bean2.propertyFilterFilterFilterTypeFilter = "testBean2FilterType";
@Test public void filterWithFilter() throws Exception { BeanPropertyWriter[] props = new BeanPropertyWriter[] { new BeanPropertyWriter(beanId, "id", "string"), new BeanPropertyWriter(beanId, "name", "string"), new BeanPropertyWriter(beanId, "age", "int") }; new MockUp<NoFilter>() { @Mock public void handle(NoFilter filter) throws IOException { } }; new MockUp<Filter>() { @Mock public void handle(NoFilter filter) throws IOException { } }; new MockUp<Getter>() { @Mock public boolean handle(Getter getter) throws IOException { return true; } }; new MockUp<Setter>() { @Mock public boolean handle(Setter setter) throws IOException { return false; } }; new MockUp<Filter>() { @Mock public boolean handle(Setter filter) throws IOException { return false; } }; new MockUp<BeanPropertyWriter>() { @Mock public void handle(Setter setter) throws IOException { } }; new MockUp<BeanPropertyWriter>() { @Mock public void handle(BeanPropertyWriter bean) throws IOException { } }; new MockUp<NoFilter>() { @Mock public boolean handle(Setter setter) throws IOException { return false; }
@Test public void testFilterWithNonFilter() throws IOException, JsonGenerationException { class Test implements BeanPropertyWriter { @Override public void serializeAsField(Object bean, JsonGenerator jgen, SerializerProvider provider) throws IOException { } @Override public void setFilter(BeanPropertyFilter filter) { } @Override public void filterOutFields(Object bean, JsonGenerator jgen, SerializerProvider provider) throws IOException { } } TestBean bean = new TestBean(); bean.setA("A"); bean.setB("B"); bean.setC("C"); bean.setD("D"); bean.setE("E"); bean.setF(new TestF()); bean.setG(new TestG()); bean.setH(new TestH()); bean.setI(new TestI()); bean.setF(new TestF()); bean.setG(new TestF()); bean.setH(new TestF()); bean.setI(new TestI()); bean.setF(new TestF()); bean.setG(new TestF()); bean.setH(new TestF()); bean.setI(new TestF()); bean.setF(new TestF()); bean.setG(new TestF());
@Test public void testFilterWithFilter() throws IOException, JsonGenerationException { BeanPropertyWriter[] writerArray = new BeanPropertyWriter[] { mock(BeanPropertyWriter.class), mock(BeanPropertyWriter.class), mock(BeanPropertyWriter.class) }; when(_bean.getBeanPropertyWriterArray()).thenReturn(writerArray); _provider.setActiveView(bean); _testBean.serializeFieldsFiltered(_bean, _jgen, _provider); verify(bean).getBeanPropertyWriterArray(); verify(bean).getBeanPropertyWriter(); }
@Test public void testFilterWithNonFilter() throws IOException, JsonGenerationException { final TestBean bean = new TestBean(); bean.setFoo("bar"); bean.setBar("baz"); bean.setFoo(null); bean.setBar(null); bean.setFoo(null); bean.setBar(null); bean.setFoo(null); bean.setBar(null); bean.setBar(null); bean.setFoo(null); bean.setBar(null); bean.setBar(null); bean.setFoo(null); bean.setBar(null); bean.setBar(null); bean.setFoo(null); bean.setBar(null); bean.setBar(null); bean.setBar(null); bean.setBar(null); bean.setBar(null); bean.setBar(null); bean.setBar(null); bean.setBar(null); bean.setBar(null); bean.setBar(null); bean.setBar(null); bean.setBar(null); bean.setBar(null); bean.setBar(null); bean.setBar(null); bean.setBar(null); bean.setBar(
@Test public void testFilter() throws IOException, JsonGenerationException { BeanPropertyWriter writer = new BeanPropertyWriter(); writer.set("id", "id"); writer.set("name", "name"); writer.set("age", 10); writer.set("month", 20); writer.set("day", 30); writer.set("month", 2); writer.set("month", 2); writer.set("day", 40); provider.setActiveView(view); bean.setBeanProperty("id", "id"); bean.setBeanProperty("name", "name"); bean.setBeanProperty("month", 10); bean.setBeanProperty("day", 40); provider.setActiveView(view); bean.setBeanProperty("month", 10); bean.setBeanProperty("month", 10); bean.setBeanProperty("day", 10); bean.setBeanProperty("month", 10); bean.setBeanProperty("month", 10); bean.setBeanProperty("month", 10); bean.setBeanProperty("month", 10); bean.setBeanProperty("month", 10); bean.setBeanProperty("month", 20); bean.setBeanProperty("month", 10); bean.setBeanProperty("month", 10); bean.setBeanProperty("month", 10); bean.
@Test public void filterWithNonFilter() throws IOException, JsonGenerationException { TestBean bean = new TestBean(); bean.setFoo("bar"); bean.setBar("baz"); bean.setFoo(null); bean.setBar(null); bean.setFoo(null); bean.setBar(null); bean.setFoo(null); bean.setBar(null); bean.setFoo(null); bean.setBar(null); bean.setBar(null); bean.setFoo(null); bean.setBar(null); bean.setFoo(null); bean.setBar(null); bean.setBar(null); bean.setFoo(null); bean.setBar(null); bean.setBar(null); bean.setBar(null); bean.setBar(null); bean.setBar(null); bean.setBar(null); bean.setBar(null); bean.setBar(null); bean.setBar(null); bean.setBar(null); bean.setBar(null); bean.setBar(null); bean.setBar(null); bean.setBar(null); bean.setBar(null); bean.setBar(null);
@Test public void testSerializeFieldsFiltered() throws IOException, JsonGenerationException { TestBean bean = new TestBean(); bean.setA(new A()); bean.setB(new B()); bean.setC(new C()); bean.setD(new D()); bean.setE(new E()); bean.setF(new F()); bean.setG(new G()); bean.setH(new D()); bean.setI(new F()); bean.setJ(new D()); bean.setF(new G()); bean.setG(new D()); bean.setH(new D()); bean.setI(new F()); bean.setJ(new D()); bean.setD(new E()); bean.setF(new D()); bean.setG(new D()); bean.setH(new D()); bean.setI(new D()); bean.setF(new D()); bean.setD(new E()); bean.setF(new D()); bean.setG(new D()); bean.setH(new D()); bean.setI(new D()); bean.setF(new D()); bean.setD(new E()); bean.setF(new D
@Test public void testSerializeFieldsFiltered() throws IOException, JsonGenerationException { TestBean bean = new TestBean(); bean.setA(new A()); bean.setB(new B()); bean.setC(new C()); bean.setD(new D()); bean.setE(new E()); bean.setF(new F()); bean.setG(new G()); bean.setH(new D()); bean.setI(new F()); bean.setJ(new D()); bean.setF(new Df()); bean.setG(new Df()); bean.setH(new Df()); bean.setI(new Df()); bean.setF(new Df()); bean.setD(new Df()); bean.setI(new Df()); bean.setF(new Df()); bean.setD(new Df()); bean.setF(new Df()); bean.setG(new Df()); bean.setH(new Df()); bean.setI(new Df()); bean.setF(new Df()); bean.setD(new Df()); bean.setF(new Df()); bean.setI(new D
@Test public void testSerializeFieldsFiltered() throws IOException, JsonGenerationException { BeanPropertyWriter[] props = new BeanPropertyWriter[] {bean -> bean.getField("field1"), bean -> bean.getField("field2"), bean -> bean.getField("field3"), bean -> bean.getField("field4") }; BeanPropertyWriter[] filterProps = new BeanPropertyWriter[] {bean -> bean.getField("field1"), bean -> bean.getField("field2")}; BeanPropertyFilter[] filterOverrides = new BeanPropertyFilter[] {bean -> bean.getField("field1"), bean -> bean.getField("field2")}; BeanPropertyWriter[] filterOverrides = new BeanPropertyWriter[] {filterOverrides}; filterOverrides[0] = filterOverrides[1]; filterOverrides[1] = filterOverrides[2]; filterOverrides[2] = filterOverrides[3]; filterOverrides[3] = filterOverrides[4]; _manager.serializeFieldsFiltered(_bean, _jgen, _provider); assertEquals("\"field1\",\"field2\",\"field3\"); }
@Test public void testFilterWithNonFilter() throws IOException, JsonGenerationException { final TestBean bean = new TestBean(); bean.setFoo("Foo"); bean.setBar("Bar"); bean.setFoo(null); bean.setBar(null); bean.setFoo(null); bean.setBar(null); bean.setFoo(null); bean.setBar(null); bean.setBar(null); bean.setFoo(null); bean.setBar(null); bean.setBar(null); bean.setFoo(null); bean.setBar(null); bean.setBar(null); bean.setFoo(null); bean.setBar(null); bean.setBar(null); bean.setBar(null); bean.setBar(null); bean.setBar(null); bean.setBar(null); bean.setBar(null); bean.setBar(null); bean.setBar(null); bean.setBar(null); bean.setBar(null); bean.setBar(null); bean.setBar(null); bean.setBar(null); bean.setBar(null); bean.setBar(null); bean.setBar(
@Test public void testFilterWithOutFields() throws IOException, JsonGenerationException { TestBean bean = new TestBean(); bean.setFoo("bar"); bean.setBar("baz"); bean.setFoo("foo"); bean.setBar("baz"); bean.setBar("foo"); bean.setBar("bar"); bean.setBar("baz"); bean.setBar("foo"); bean.setBar("bar"); bean.setBar("baz"); bean.setBar("foo"); bean.setBar("bar"); bean.setBar("baz"); bean.setBar("foo"); bean.setBar("bar"); bean.setBar("baz"); bean.setBar("foo"); bean.setBar("bar"); bean.setBar("foo"); bean.setBar("bar"); bean.setBar("foo"); bean.setBar("bar"); bean.setBar("foo"); bean.setBar("bar"); StringWriter out = new StringWriter(); JsonGenerator jgen = new JsonGenerator(out); _thrown.expect(JsonGenerationException.class); _thrown.expectMessage("Cannot iterate over fields [LINE] and filter [null, bar, bar, bar]"); _thrown.expectMessage("
@Test public void testSerializeAsField() throws IOException, JsonGenerationException { final BeanPropertyFilter filter = new BeanPropertyFilter(bean, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null,
@Test public void testAnyGetterWriter() throws IOException, JsonGenerationException { BeanPropertyWriter writer = new BeanPropertyWriter(); writer.setFieldName("field1"); writer.setFieldType("string"); writer.setExclude("field2"); writer.setExclude("field3"); writer.setExclude("field4"); bean.setSomeBoolean(true); bean.setSomeBoolean(false); bean.setSomeBoolean(true); bean.setSomeBoolean(false); bean.setSomeBoolean(true); bean.setSomeBoolean(false); bean.setSomeBoolean(true); bean.setSomeBoolean(false); bean.setSomeBoolean(true); bean.setSomeBoolean(false); bean.setSomeBoolean(true); bean.setSomeBoolean(false); bean.setSomeBoolean(false); bean.setSomeBoolean(true); bean.setSomeBoolean(false); bean.setSomeBoolean(false); bean.setSomeBoolean(false); bean.setSomeBoolean(false); bean.setSomeBoolean(true); bean.setSomeBoolean(false); bean.setSomeBoolean(true); bean.setSomeBoolean(false); bean.setSomeBoolean(true); bean.setSomeBoolean(false);
@Test public void findFilter_filterProvider() throws Exception { BeanPropertyWriter[] writerArray = new BeanPropertyWriter[] { mockFilter(FIELD_FILTER_ID, FIELD_FILTER_NAME, FIELD_FILTER_TYPE, FIELD_FILTER_NAME, FIELD_FILTER_TYPE, FIELD_FILTER_TYPE, FIELD_FILTER_NAME, FIELD_FILTER_TYPE, FIELD_FILTER_TYPE, FIELD_FILTER_NAME, FIELD_FILTER_TYPE, FIELD_FILTER_TYPE, FIELD_FILTER_TYPE, FIELD_FILTER_NAME, FIELD_FILTER_TYPE, FIELD_FILTER_TYPE, FIELD_FILTER_TYPE, FIELD_FILTER_TYPE, FIELD_FILTER_TYPE, FIELD_FILTER_TYPE, FIELD_FILTER_TYPE, FIELD_FILTER_TYPE, FIELD_FILTER_TYPE, FIELD_FILTER_TYPE, FIELD_FILTER_TYPE, FIELD_FILTER_TYPE, FIELD_FILTER_TYPE, FIELD_FILTER_TYPE, FIELD_FILTER_TYPE, FIELD_FILTER_TYPE, FIELD_FILTER_TYPE, FIELD_FILTER_TYPE, FIELD_FILTER_TYPE, FIELD_FILTER_TYPE, FIELD_FILTER_TYPE, FIELD_FILTER_TYPE, FIELD_FILTER_TYPE, FIELD_FILTER_
@Test public void findFilter_filterProvider() throws Exception { BeanPropertyWriter[] writerArray = new BeanPropertyWriter[] { mockFilterProvider(false), mockFilterProvider(true) }; BeanSerializerBase src = new BeanSerializerBase(writerArray, new MockFilterProvider()); BeanPropertyWriter[] properties = new BeanPropertyWriter[] { mockFilterProvider(true) }; BeanSerializerFilter filter = new TestBeanPropertyFilter(src, properties); filters.add(filter); src.findFilter(new MockFilterProvider(true)); filters.add(filter); src.findFilter(new MockFilterProvider(true)); filters.add(filter); src.findFilter(new MockFilterProvider(true)); filters.add(filter); src.findFilter(new MockFilterProvider(true)); filters.add(filter); src.findFilter(new MockFilterProvider(true)); filters.add(filter); src.findFilter(new MockFilterProvider(true)); filters.add(filter); src.findFilter(new MockFilterProvider(true)); }
@Test public void findFilter_filterProvider() throws Exception { FilterProvider provider = mock(FilterProvider.class); when(provider.getFilterProvider()).thenReturn(provider); BeanPropertyFilter filter = new FilterPropertyFilter("test", "test"); filter.setField("test"); filter.setField("test2"); BeanPropertyFilter filter2 = new FilterPropertyFilter("test2", "test2"); filter2.setField("test"); filter2.setField("test"); filter2.setField("test3"); filter2.setField("test4"); filter2.setField("test5"); filter2.setField("test6"); filter2.setField("test7"); filter2.setField("test8"); filter2.setField("test9"); filter2.setField("test10"); filter2.setField("test11"); filter2.setField("test12"); filter2.setField("test13"); filter2.setField("test14"); filter2.setField("test15"); filter2.setField("test16"); filter2.setField("test21"); filter2.setField("test22"); filter2.setField("test23"); filter2.setField("test23"); filter2.setField("test24"); filter2.setField("test23");
@Test public void testFilterProvider() throws Exception { TestBeanSerializer b1 = new TestBeanSerializer(); TestBeanSerializer b2 = new TestBeanSerializer(); TestBeanSerializer b3 = new TestBeanSerializer(); BeanPropertyWriter[] properties = new BeanPropertyWriter[1]; BeanPropertyWriter[] filteredProperties = new BeanPropertyWriter[2]; filters = new FilterProvider[]{b1, b2, b3}; filters.addPropertyFilter(new PropertyFilter("test", "testValue")); filters.addPropertyFilter(new PropertyFilter("test2", "testValue2")); filters.addPropertyFilter(new PropertyFilter("test3", "testValue3")); filters.addPropertyFilter(new PropertyFilter("test4", "testValue4")); filters.addPropertyFilter(new PropertyFilter("test5", "testValue5")); filters.addPropertyFilter(new PropertyFilter("test6", "testValue6")); filters.addPropertyFilter(new PropertyFilter("test7", "testValue7")); filters.addPropertyFilter(new PropertyFilter("test8", "testValue8")); filters.addPropertyFilter(new PropertyFilter("test9", "testValue9")); filters.addPropertyFilter(new PropertyFilter("test10", "testValue10"));
@Test public void findFilter_null() throws Exception { FilterProvider provider = new FilterProvider() { @Override public Filter getFilter(String filterId) { return null; } }; BeanPropertyFilter filter = filters.findFilter(new JsonPrimitiveFilterProvider()); Assert.assertNotNull(filter); }
@Test public void findFilter() throws Exception { BeanPropertyFilter filter = new FilterProvider() { @Override public boolean isMatch(FilterPropertyFilter filterPropertyFilter) { return filterPropertyFilter instanceof JsonPathFilter; } }; BeanPropertyFilter result = new JsonPathFilter(filter.getFilterId()); BeanPropertyFilter result2 = new JsonPathFilter(filter.getFilterId()); BeanPropertyFilter result3 = new JsonPathFilter(filter.getFilterId()); BeanPropertyFilter result4 = new JsonPathFilter(filter.getFilterId()); BeanPropertyFilter result5 = new JsonPathFilter(filter.getFilterId()); BeanPropertyFilter result6 = new JsonPathFilter(filter.getFilterId()); assertEquals(result, result2); assertEquals(result3, result4); assertEquals(result5, result5); }
@Test public void shouldGetSchemaFromFilter() throws JsonMappingException { JsonSerializerProvider provider = new JsonSerializerProvider(); provider.setField("filter", new BeanPropertyFilter(new Property("prop1", "value1"), new Property("prop2", "value2"))); provider.setField("filter2", new BeanPropertyFilter(new Property("prop3", "value3"))); JsonNode schema = _filter.getSchema(provider, null); assertEquals("object", schema.get("filter").asText()); }
@Test public void testFilterDepositSchemaProperty() throws JsonMappingException { BeanPropertyWriter prop = new BeanPropertyWriter(); PropertyFilter filter = new PropertyFilter(); filter.depositSchemaProperty(prop, new JsonNode(), null); Assert.assertEquals("{\"id\":1,\"prop\":{\"$ref\":\"id\"}}", filter.toString()); }
@Test public void testChangeProperties() { BeanPropertyWriter bean1 = new BeanPropertyWriter(); bean1.setFieldName("name"); bean1.setFieldType("string"); bean1.setOrder("one"); BeanPropertyWriter bean2 = new BeanPropertyWriter(); bean2.setFieldName("name"); bean2.setFieldType("string"); bean2.setOrder("two"); List<BeanPropertyWriter> beanProperties = Arrays.asList(bean1, bean2); BeanPropertyWriter beanPropertyWriter1 = new BeanPropertyWriter(); beanPropertyWriter1.setFieldName("name"); beanPropertyWriter1.setFieldType("string"); beanPropertyWriter1.setOrder("one"); beanProperties.add(beanPropertyWriter1); BeanPropertyWriter beanPropertyWriter2 = new BeanPropertyWriter(); beanPropertyWriter2.setFieldName("name"); beanPropertyWriter2.setFieldType("string"); beanProperties.add(beanPropertyWriter2); beanProperties.add(beanPropertyWriter2); BeanPropertyWriter beanPropertyWriter3 = new BeanPropertyWriter(); beanPropertyWriter3.setFieldName("name"); beanPropertyWriter3.setFieldType("string"); beanProperties.add(beanPropertyWriter3); beanProperties.add(beanPropertyWriter3); beanProperties.add(beanPropertyWriter3); beanProperties.add(beanPropertyWriter3);
@Test public void testChangeProperties() { BeanPropertyWriter writer1 = new BeanPropertyWriter(); beanProps.add(writer1); BeanPropertyWriter writer2 = new BeanPropertyWriter(); beanProps.add(writer2); beanProps.add(writer3); List<BeanPropertyWriter> beanProperties = new ArrayList<>(); beanProperties.add(writer1); beanProperties.add(writer2); List<BeanPropertyWriter> beanPropertiesAfterChange = beanProps.changeProperties(config, beanDesc, beanProperties); Assert.assertEquals(2, beanPropertiesAfterChange.size()); Assert.assertEquals(beanPropsAfterChange.get(0), beanPropertiesAfterChange.get(0)); Assert.assertEquals(beanPropsAfterChange.get(1), beanPropertiesAfterChange.get(1)); }
@Test public void orderProperties() { BeanPropertyWriter bean1 = new BeanPropertyWriter("id", "id", "idValue"); BeanPropertyWriter bean2 = new BeanPropertyWriter("id", "id2", "idValue"); BeanPropertyWriter bean3 = new BeanPropertyWriter("id", "id3", "idValue"); List<BeanPropertyWriter> beanProperties = Arrays.asList(bean1, bean2, bean3); MockSerializationConfig config = new MockSerializationConfig(); config.setBeanProperties(beanProperties); MockBeanSerializerBuilder builder = new MockBeanSerializerBuilder(); MockBeanSerializer serializer = new MockBeanSerializer(); serializer.addSerializer(writer, bean1); serializer.addSerializer(writer, bean2); MockBeanSerializerBuilder builder2 = new MockBeanSerializerBuilder(); MockBeanSerializer serializer2 = new MockBeanSerializer(); MockBeanSerializer serializer3 = new MockBeanSerializer(); List<BeanPropertyWriter> beanProperties = Arrays.asList(beanPropertyWriter, beanPropertyWriter2, beanPropertyWriter3); MockBeanSerializer mockBeanSerializer = new MockBeanSerializer(); List<BeanPropertyWriter> beanPropertiesWithWriter = Arrays.asList(beanPropertyWriter, beanPropertyWriter3); beanPropertiesWithWriter.add(writer, bean3); beanPropertiesWith
@Test public void orderProperties() { BeanPropertyWriter writer1 = new BeanPropertyWriter("foo", "bar"); BeanPropertyWriter writer2 = new BeanPropertyWriter("foo", "bar"); BeanPropertyWriter writer3 = new BeanPropertyWriter("foo", "bar"); List<BeanPropertyWriter> beanProperties = Arrays.asList(writer1, writer2, writer3); SerializationConfig config = new SerializationConfig(); config.setBeanProperties(beanProperties); List<BeanPropertyWriter> beanPropertiesList = beanProperties.stream().map(bean -> bean.getBeanProperties().get(0)).collect(Collectors.toList()); assertEquals(beanPropertiesList, beanPropertiesList); }
@Test public void testMutatorPrefix() { POJOPropertiesCollector collector = new POJOPropertiesCollector(config, forSerialization, type, classDef, Stri.DEFAULT_STRI_PREFIX); assertEquals(config.isMutatorPrefix(), forSerialization); assertEquals(config.getMutatorPrefix(), mutatorPrefix); }
@Test public void testPojoPropertiesCollector() throws NoSuchMethodException, SecurityException, IllegalArgumentException, IllegalAccessException { MapperConfig<?> config = MapperConfig.create(ClassWithAnnotatedProperty.class.getName()); POJOPropertiesCollector collector = new POJOPropertiesCollector(config, false, JavaTypes.get(String.class), null, null); assertTrue(collector.forSerialization()); assertTrue(collector.type.equals(String.class)); assertTrue(collector.class.equals(MyPojo.class)); assertTrue(collector.mutatorPrefix.equals("set")); }
@Test public void testPojoPropertiesCollector() throws NoSuchMethodException, SecurityException, IllegalArgumentException, IllegalAccessException { MapperConfig<?> config = MapperConfig.create(Class.class); AnnotatedClass classDef = new AnnotatedClass(Class.class); classDef.setMethod("equals", Object.class); POJOPropertiesCollector collector = new POJOPropertiesCollector(config, false, classDef, null); assertTrue(collector.forSerialization); assertTrue(collector.forSerialization); }
@Test public void testPojoPropertiesCollector() throws NoSuchMethodException, SecurityException, IllegalArgumentException, IllegalAccessException { MapperConfig<?> config = MapperConfig.create(ClassWithAnnotatedProperty.class.getName()); POJOPropertiesCollector collector = new POJOPropertiesCollector(config, false, JavaTypes.get(String.class), null, null); assertEquals(config.getType(), collector.getType()); assertEquals(config.isAnnotationProcessingEnabled(), collector.isAnnotationProcessingEnabled()); assertEquals(config.getDefaultVisibilityChecker(), collector.getVisibilityChecker()); }
@Test public void testPojoPropertiesCollector() throws NoSuchMethodException, SecurityException, IllegalArgumentException, IllegalAccessException { MapperConfig<?> config = MapperConfig.create(Class.class); AnnotatedClass classDef = new AnnotatedClass(Class.class); POJOPropertiesCollector collector = new POJOPropertiesCollector(config, false, classDef, null); assertEquals(classDef, collector.getClass()); assertEquals(config.isAnnotationProcessingEnabled(), collector.isAnnotationProcessingEnabled()); assertEquals(config.getDefaultVisibilityChecker(), collector.getVisibilityChecker()); }
@Test public void testMutatorPrefix() { MapperConfig<?> config = new MapperConfig<>(); config.setMutatorPrefix(null); POJOPropertiesCollector collector = new POJOPropertiesCollector(config, false, JavaType.OBJECT, null, null); assertEquals("", collector.mutatorPrefix); }
@Test public void testAnnotationIntrospector() { MapperConfig<?> config = new MapperConfig<>(false, false, TestPojo.class.getDeclaredMethod("annotationIntrospector", String.class), null); POJOPropertiesCollector collector = new POJOPropertiesCollector(config, false, TestPojo.class, null, null); assertTrue(collector instanceof AnnotationIntrospector); AnnotationIntrospector annotationIntrospector = (AnnotationIntrospector) collector; assertTrue(annotationIntrospector.isAutoDetectVisibility()); }
@Test public void testAnnotationProcessingEnabled() { MapperConfig<?> config = MapperConfig.create(false, false, TestPojo.class.getName()); POJOPropertiesCollector collector = new POJOPropertiesCollector(config, false, TestPojo.class, null); assertTrue(collector.forSerialization); assertFalse(collector.forSerialization); assertFalse(collector.classDef.getAnnotationProcessingEnabled()); assertNull(collector.mutatorPrefix); }
@Test public void testMutatorPrefix() { MapperConfig<?> config = mapper.config(NO_ANNOTATION_PROCESSING, false); AnnotatedClass classDef = AnnotatedClass.class; String prefix = "m"; POJOPropertiesCollector collector = new POJOPropertiesCollector(config, false, classDef, prefix); assertTrue(collector.forSerialization); assertFalse(collector.forSerialization); assertFalse(collector.mutatorPrefix); }
@Test public void testGetJsonValueMethod() { POJOPropertiesCollector collector = new POJOPropertiesCollector(config, false, JavaTypes.getAnonymousClass(), null); AnnotatedMethod jsonValueMethod = collector.getJsonValueMethod(); Assert.assertNotNull(jsonValueMethod); Assert.assertEquals(Arrays.asList(new Object[] {"foo"}, new Object[] {"bar"}), jsonValueMethod.getParameters()); }
@Test public void testGetJsonValueMethod() { AnnotatedMethod jsonValueMethod = classDef.getJsonValueMethod(); assertEquals(null, jsonValueMethod); }
@Test public void test_getPropertyMap() { POJOPropertiesCollector collector = new POJOPropertiesCollector(mapperConfig, false, JavaType.OBJECT, null, null); Map<String, POJOPropertyBuilder> properties = collector.getPropertyMap(); assertEquals("pojo properties", 1, properties.size()); assertEquals("pojo properties", 1, properties.get("pojo_properties")); }
@Test public void test_getPropertyMap() { POJOPropertiesCollector collector = new POJOPropertiesCollector(mapperConfig, false, JavaType.OBJECT, AnnotatedClass.class, null); assertEquals(mapperConfig.getProperties().size(), collector.getPropertyMap().size()); }
@Test public void testCollect() { POJOPropertiesCollector collector = new POJOPropertiesCollector(new MapperConfig<>(MapperFeature.USE_WRAPPER_NAME_AS_PROPERTY_NAME, false, JavaTyp.DEFAULT), false, JavaTyp.DEFAULT); collector.collect(); assertEquals("pojo", collector.getField("foo").getName()); assertEquals("foo", collector.getField("foo").getClassName()); assertEquals("foo", collector.getField("foo").getClassName()); assertEquals("foo", collector.getField("foo").getClassName()); assertEquals("foo", collector.getField("foo").getClassName()); assertEquals("foo", collector.getField("foo").getClassName()); assertEquals("foo", collector.getField("foo").getClassName()); assertEquals("foo", collector.getField("foo").getClassName()); assertEquals("foo", collector.getField("foo").getClassName()); assertEquals("foo", collector.getField("foo").getClassName()); assertEquals("foo", collector.getField("foo").getClassName()); assertEquals("foo", collector.getField("foo").getClassName()); assertEquals("foo", collector.getField("foo").getClassName()); assertEquals("foo", collector.getField("foo").getClassName()); assertEquals("foo
@Test public void testCollect() { POJOPropertiesCollector collector = new POJOPropertiesCollector(config, false, JavaType.OBJECT, AnnotatedClapojo, PojoPropertiesCollector.class); collector.collect(); assertEquals("Unexpected number of properties", 2, collector.getProperties().size()); assertEquals("Unexpected properties name", "foo", collector.getProperties().get("foo")); assertEquals("Unexpected properties value", "bar", collector.getProperties().get("bar")); assertEquals("Unexpected properties value", "foo", collector.getProperties().get("foo")); assertEquals("Unexpected properties value", "bar", collector.getProperties().get("bar")); assertEquals("Unexpected properties value", "foo", collector.getProperties().get("foo")); assertEquals("Unexpected properties value", "bar", collector.getProperties().get("bar")); assertEquals("Unexpected properties value", "foo", collector.getProperties().get("foo")); assertEquals("Unexpected properties value", "foo", collector.getProperties().get("foo")); assertEquals("Unexpected properties value", "bar", collector.getProperties().get("bar")); assertEquals("Unexpected properties value", "foo", collector.getProperties().get("foo")); assertEquals("Unexpected properties value", "bar", collector.getProperties().get("bar
@Test public void testCollect() { POJOPropertiesCollector collector = new POJOPropertiesCollector(config, false, JavaType.OBJECT, AnnotatedClass.class); collector.collect(); assertEquals("", collector.getFields().get("name")); assertEquals("", collector.getFields().get("type")); assertEquals("", collector.getFields().get("name")); assertEquals("", collector.getFields().get("type")); assertEquals("", collector.getFields().get("name")); assertEquals("", collector.getFields().get("type")); assertEquals("", collector.getFields().get("name")); assertEquals("", collector.getFields().get("type")); assertEquals("", collector.getFields().get("type")); assertEquals("", collector.getFields().get("type")); assertEquals("", collector.getFields().get("type")); assertEquals("", collector.getFields().get("type")); assertEquals("", collector.getFields().get("type")); assertEquals("", collector.getFields().get("type")); assertEquals("", collector.getFields().get("type")); assertEquals("", collector.getFields().get("type")); assertEquals("", collector.getFields().get("type")); assertEquals("", collector.getFields().get("type")); assertEquals("",
@Test public void testCollect() { POJOPropertiesCollector collector = new POJOPropertiesCollector(config, false, JavaType.OBJECT, AnnotatedClass.class, null); collector.collect(); assertEquals("", collector.getFields().get(0).getName()); assertEquals("", collector.getFields().get(0).getDescription()); assertEquals("", collector.getFields().get(0).getClassName()); assertEquals("", collector.getFields().get(0).getDescription()); assertEquals("", collector.getFields().get(0).getClassName()); assertEquals("", collector.getFields().get(0).getDescription()); assertEquals("", collector.getFields().get(0).getClassName()); assertEquals("", collector.getFields().get(0).getDescription()); assertEquals("", collector.getFields().get(0).getClassName()); assertEquals("", collector.getFields().get(0).getDescription()); assertEquals("", collector.getFields().get(0).getClassName()); assertEquals("", collector.getFields().get(0).getDescription()); assertEquals("", collector.getFields().get(0).getClassName()); assertEquals("", collector.getFields().get(0).getDescription()); assertEquals("", collector.getFields().get(0).getClassName()); assertEquals("", collector.getFields().get(0).getDescription()); assertEquals("", collector.getFields().get(0).
@Test public void testCollect() { POJOPropertiesCollector collector = new POJOPropertiesCollector(config, false, JavaType.OBJECT, null, null); collector.collect(); assertEquals("", collector.getFields().get(0).getName()); assertEquals("", collector.getFields().get(0).getNamespace()); assertEquals("", collector.getFields().get(0).getPrefix()); assertEquals("", collector.getFields().get(0).getSuffix()); assertEquals("", collector.getFields().get(0).getPrefix()); assertEquals("", collector.getFields().get(0).getSuffix()); assertEquals("", collector.getFields().get(0).getPrefix()); assertEquals("", collector.getFields().get(0).getSuffix()); assertEquals("", collector.getFields().get(0).getPrefix()); assertEquals("", collector.getFields().get(0).getSuffix()); assertEquals("", collector.getFields().get(0).getPrefix()); assertEquals("", collector.getFields().get(0).getSuffix()); assertEquals("", collector.getFields().get(0).getPrefix()); assertEquals("", collector.getFields().get(0).getSuffix()); assertEquals("", collector.getFields().get(0).getPrefix()); assertEquals("", collector.getFields().get(0).getSuffix()); assertEquals("", collector.getFields().get(0).getPrefix());
@Test public void testCollect() { POJOPropertiesCollector collector = new POJOPropertiesCollector(config, false, JavaType.of(String.class), AnnotatedClass.class, null); collector.collect(); assertEquals("", collector.getFields().get(0).getName()); assertEquals("", collector.getFields().get(0).getAnnotations().get(0)); assertEquals("", collector.getFields().get(0).getNamingStrategy().getNamingStrategy().getNamingStrategy()); assertEquals("", collector.getFields().get(0).getNamingStrategy().getNamingStrategy().getNamingStrategy().getNamingStrategy()); assertEquals("", collector.getFields().get(0).getNamingStrategy().getNamingStrategy().getNamingStrategy().getNamingStrategy()); assertEquals("", collector.getFields().get(0).getNamingStrategy().getNamingStrategy().getNamingStrategy().getNamingStrategy()); assertEquals("", collector.getFields().get(0).getNamingStrategy().getNamingStrategy().getNamingStrategy().getNamingStrategy()); assertEquals("", collector.getFields().get(0).getNamingStrategy().getNamingStrategy().getNamingStrategy().getNamingStrategy()); assertEquals("", collector.getFields().get(0).getNamingStrategy().getNamingStrategy().getNamingStrategy().getNamingStrategy()); assertEquals("", collector.getFields
@Test public void testRemoveUnwantedProperties() { POJOPropertiesCollector collector = new POJOPropertiesCollector(config, false, JavaType.OBJECT, null); collector.collect(); assertEquals(0, collector.getProperties().size()); }
@Test public void testRenameProperties() { PojoPropertiesCollector collector = new POJOPropertiesCollector(new MapperConfig<>(MapperFeature.USE_WRAPPER_NAME_AS_PROPERTY_NAME, false, JavaType.of(String.class), AnnotatedClalapojo), false, JavaType.of(String.class), null, null); collector.collect(); assertEquals("", collector.getFields().get(0).getName()); assertEquals("", collector.getFields().get(0).getNamingStrategy().getNamingStrategy().getNamingStrategy()); assertEquals("", collector.getFields().get(0).getNamingStrategy().getNamingStrategy().getNamingStrategy().getNamingStrategy().getNamingStrategy()); assertEquals("", collector.getFields().get(0).getNamingStrategy().getNamingStrategy().getNamingStrategy().getNamingStrategy().getNamingStrategy().getNamingStrategy().getNamingStrategy().getNamingStrategy().getNamingStrategy().getNamingStrategy().getNamingStrategy().getNamingStrategy().getNamingStrategy().getNamingStrategy().getNamingStrategy().getNamingStrategy().getNamingStrategy()); assertEquals("", collector.getFields().get(0).getNamingStrategy().getNamingStrategy().getNamingStrategy().getNamingStrategy().getNamingStrategy().getNamingStrategy()); assertEquals("",
@Test public void testNamingStrategy() { MapperConfig<?> config = mock(MapperConfig.class); when(config.isEnabled(MapperFeature.USE_WRAPPER_NAME_AS_PROPERTY_NAME)).thenReturn(true); when(config.isEnabled(MapperFeature.USE_WRAPPER_NAME_AS_PROPERTY_NAME_PREFIX)).thenReturn(true); POJOPropertiesCollector collector = new POJOPropertiesCollector(config, false); collector.collect(); verify(config).isEnabled(MapperFeature.USE_WRAPPER_NAME_AS_PROPERTY_NAME); verify(config).isEnabled(MapperFeature.USE_WRAPPER_NAME_AS_PROPERTY_NAME); }
@Test public void testNamingStrategy() { MapperConfig<?> config = mock(MapperConfig.class); when(config.isEnabled(MapperFeature.USE_WRAPPER_NAME_AS_PROPERTY_NAME)).thenReturn(true); POJOPropertiesCollector collector = new POJOPropertiesCollector(config, false, JavaType.of(String.class), AnnotatedClonable.class, new DefaultNamingStrategy(), JavaType.of(String.class), new DefaultNamingStrategy()); collector.collect(); verify(config, times(1)).isEnabled(MapperFeature.USE_WRAPPER_NAME_AS_PROPERTY_NAME); verify(config, times(1)).isEnabled(MapperFeature.USE_WRAPPER_NAME_AS_PROPERTY_NAME); }
@Test public void testCollect() { MapperConfig<?> config = mock(MapperConfig.class); when(config.isEnabled(MapperFeature.USE_WRAPPER_NAME_AS_PROPERTY_NAME)).thenReturn(true); POJOPropertiesCollector collector = new POJOPropertiesCollector(config, false); collector.collect(); verify(config).isEnabled(MapperFeature.USE_WRAPPER_NAME_AS_PROPERTY_NAME); }
@Test public void testTrimByVisibility() { POJOPropertiesCollector collector = new POJOPropertiesCollector(config, false, JavaType.OBJECT, null); collector.collect(); assertEquals("", collector.getFields().get(0).trimByVisibility()); assertEquals("", collector.getFields().get(1).trimByVisibility()); assertEquals("", collector.getFields().get(2).trimByVisibility()); assertEquals("", collector.getFields().get(3).trimByVisibility()); assertEquals("", collector.getFields().get(4).trimByVisibility()); assertEquals("", collector.getFields().get(5).trimByVisibility()); assertEquals("", collector.getFields().get(6).trimByVisibility()); assertEquals("", collector.getFields().get(7).trimByVisibility()); assertEquals("", collector.getFields().get(8).trimByVisibility()); assertEquals("", collector.getFields().get(9).trimByVisibility()); assertEquals("", collector.getFields().get(10).trimByVisibility()); assertEquals("", collector.getFields().get(11).trimByVisibility()); assertEquals("", collector.getFields().get(12).trimByVisibility()); assertEquals("", collector.getFields().get(13).trimByVisibility()); assertEquals("", collector.getFields().get(14
@Test public void testCollect() { MapperConfig<?> config = mock(MapperConfig.class); when(config.isEnabled(MapperFeature.USE_WRAPPER_NAME_AS_PROPERTY_NAME)).thenReturn(true); POJOPropertiesCollector collector = new POJOPropertiesCollector(config, false); collector.collect(); verify(config).isEnabled(MapperFeature.USE_WRAPPER_NAME_AS_PROPERTY_NAME); }
@Test public void testMergeAnnotations() { POJOPropertiesCollector collector = new POJOPropertiesCollector(config, false, JajoNamingStrategy.DEFAULT); collector.collect(); assertEquals("", collector.getProperties().get("foo")); assertEquals("", collector.getFields().get("bar")); assertEquals("", collector.getMethods().get("foo")); assertEquals("", collector.getCreators().get("bar")); assertEquals("", collector.getInjectables().get("bar")); assertEquals("", collector.getProperties().get("foo")); assertEquals("", collector.getMethods().get("bar")); assertEquals("", collector.getFields().get("baz")); assertEquals("", collector.getMethods().get("bar")); assertEquals("", collector.getFields().get("baz")); assertEquals("", collector.getMethods().get("bar")); }
@Test public void testDisableWrapperName() { MapperConfig<?> config = mock(MapperConfig.class); when(config.isEnabled(MapperFeature.USE_WRAPPER_NAME_AS_PROPERTY_NAME)).thenReturn(false); POJOPropertiesCollector collector = new POJOPropertiesCollector(config, null); collector.collect(); verify(config).isEnabled(MapperFeature.USE_WRAPPER_NAME_AS_PROPERTY_NAME); verifyNoMoreInteractions(config); }
@Test public void testSort() { POJOPropertiesCollector collector = new POJOPropertiesCollector(config, false, JavaType.of(String.class), AnnotatedClass.class, null); collector.collect(); assertEquals("Should have 3 properties", 3, collector.getProperties().size()); assertEquals("Should have 2 properties", 2, collector.getProperties().size()); assertEquals("Should have 3 properties", 3, collector.getProperties().get(0).getFields().size()); assertEquals("Should have 2 properties", 2, collector.getProperties().get(0).getFields().size()); assertEquals("Should have 2 properties", 2, collector.getProperties().get(0).getFields().size()); assertEquals("Should have 2 properties", 2, collector.getProperties().get(0).getFields().get(0).getFields().size()); assertEquals("Should have 2 properties", 2, collector.getProperties().get(0).getFields().get(0).getFields().size()); assertEquals("Should have 2 properties", 2, collector.getProperties().get(0).getFields().get(0).getFields().size()); assertEquals("Should have 2 properties", 2, collector.getProperties().get(0).getFields().get(0).getFields().size()); assertEquals("Should have 2 properties", 2, collector.getProperties().get(0).getFields().get(0).getFields().
@Test public void testCollect() throws NoSuchFieldException, IllegalAccessException { MapperConfig<?> config = mock(MapperConfig.class); when(config.isEnabled(MapperFeature.USE_WRAPPER_NAME_AS_PROPERTY_NAME)).thenReturn(true); POJOPropertiesCollector collector = new POJOPropertiesCollector(config, false, JavaType.of(String.class), AnnotatedClass.class, PojoPropertiesCollector.class); assertEquals(collector.collect(), new PojoPropertiesCollector(config, false, JavaType.of(String.class), AnnotatedClass.class, PojoPropertiesCollector.class)); }
@Test public void test_sortProperties() { classUnderTest.setSortable(true); classUnderTest.setSortable(false); classUnderTest.setSortable(true); classUnderTest.setSortable(false); classUnderTest.setSortable(true); classUnderTest.setSortable(false); classUnderTest.setSortable(true); classUnderTest.setSortable(false); classUnderTest.setSortable(true); classUnderTest.setSortable(false); classUnderTest.setSortable(true); classUnderTest.setSortable(false); classUnderTest.setSortable(true); classUnderTest.setSortable(false); classUnderTest.setSortable(true); classUnderTest.setSortable(false); classUnderTest.setSortable(true); classUnderTest.setSortable(false); classUnderTest.setSortable(true); classUnderTest.setSortable(false); classUnderTest.setSortable(true); classUnderTest.setSortable(true); classUnderTest.setSortable(false); classUnderTest.setSortable(true); classUnderTest.setSortable(true); classUnderTest.setSortable(false); classUnderTest.setSortable(true); classUnderTest
@Test public void test_sortProperties_propertyOrder() { AnnotationIntrospector intr = createIntrospector(false); intr.setConfig(new AnnotationConfig(false)); AnnotationIntrospectorIntrospector intr2 = createIntrospector(true); intr2.setConfig(new AnnotationConfig(true)); AnnotationIntrospector intr3 = createIntrospector(false); intr3.setConfig(new AnnotationConfig(true)); intr3.sortProperties(); assertEquals(new String[] { "prop1", "prop2" }, intr3.getConfig().getProps()); assertEquals(new String[] { "prop1", "prop2" }, intr3.getConfig().getProps()); }
@Test public void test_sortProperties_propertyOrder_propertyOrder_sort_property_order() { class Test { private String s; private String s2 = "s1"; private String s3 = "s2"; @SuppressWarnings("unused") AnnotationIntrospector introspector = Mockito.mock(AnnotationIntrospector.class); Mockito.when(introspector.findSerializationSortAlphabetically(_classDef)).thenReturn(null); Mockito.when(introspector.findSerializationPropertyOrder(Mockito.any(Class.class))).thenReturn(new String[] { s, s2 }); Mockito.when(introspector.findSerializationPropertyOrder(Mockito.any(Class.class))).thenReturn(new String[] { s2, s3 }); new Test(new Test(), true).assertTrue(introspector.sortProperties()); }
@Test public void testSortPropertiesAlphabetically() { class Test { public void test() { } } { class Test { public void test() { } } } { class Test { public void test() { } } } { class Test { public void test() { } } } { class Test { public void test() { } } } { class Test { public void test() { } } } { class Test { public void test() { } } } { class Test { public void test() { } } } { class Test { public void test() { } } } { class Test { public void test() { } } } { class Test { public void test() { } } } { class Test { public void test() { } } } { class Test { public void test() { } } } { class Test { public void test() { } } } { class Test { public void test() { } } } { class Test { public void test() { } } } { class Test { public void test() { } } } } { class Test { public void test() { } } } { } } { class Test { public void test() { } } } { } } { } { } { } { } { } {
@Test public void test_sortProperties_propertyOrder_propertyOrder_defaultOrder() { class Test { private String s; private String s2 = "s"; private String s3 = "s3"; } class TestConfig { @JsonProperty private String s; @JsonProperty private String s2 = "s2"; @JsonProperty private String s3 = "s3"; @JsonProperty private String s4 = "s4"; @JsonProperty private String s5 = "s5"; @JsonProperty private String s6; @JsonProperty private String s7; @JsonProperty private String s8; @JsonProperty private String s9; @JsonProperty private String s10; @JsonProperty private String s11; @JsonProperty private String s12; @JsonProperty private String s13; @JsonProperty private String s21; @JsonProperty private String s22; @JsonProperty private String s23; @JsonProperty private String s31; @JsonProperty private String s31; @JsonProperty private String s4; @JsonProperty private String s31; @JsonProperty private String s31; @JsonProperty private String s31; @JsonProperty private String s32; @JsonProperty private String s31; @JsonProperty private String s31; @JsonProperty private String s31; @JsonProperty private String s31; @JsonProperty private
@Test public void testSortPropertiesAlphabetically() { class Test { private String s1; private String s2; private String s3; private String s1; private String s2; private String s1; private String s2; private String s1; private String s2; private String s1; private String s2; private String s3; private String s1; s1 = "a"; s2 = "b"; s1 = "c"; s2 = "d"; s1 = "s1"; s2 = "s2"; s1 = "s1"; s2 = "s2"; s1 = "s1"; s2 = "s2"; s1 = "s1"; s2 = "s2"; s1 = "s1"; s2 = "s2"; s1 = "s1"; s2 = "s2"; s1 = "s1"; s2 = "s2"; s1 = "s1"; s2 = "s1"; s2 = "s2"; _config.setSortAlphabetically(false); _config.setShouldSortPropertiesAlphabetically(true); _config.setShouldSortPropertiesAlphabetically(false); _config.setShouldSortPropertiesAlphabetically(true);
@Test public void testSortProperties() { AnnotationIntrospector intr = new AnnotationIntrospector(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null,
@Test public void testSortPropertiesAlphabetically() { class Test { public void test() { } } { class Test { public void test() { } } } { class Test { public void test() { } } } { class Test { public void test() { } } } { new Test().test(); } { new Test().test(); } { new Test().test(); } { new Test().test(); } { new Test().test(); } { new Test().test(); } { new Test().test(); } { new Test().test(); } { new Test().test(); } { new Test().test(); } { new Test().test(); } { new Test().test(); } { new Test().test(); } { new Test().test(); } { new Test().test(); } { new Test().test(); } { new Test().test(); } { new Test().test(); } { new Test().test(); } { new Test().test(); } { new Test().test(); } { new Test().test(); } { new Test().test(); } { new Test().test(); } { new Test().test(); } { new Test().test(); } { new Test().test(); } } { new Test().test(); } {
@Test public void testSortPropertiesAlphabetically() { class Test { private String name; private String description; @Test private String[] props; @Test private String[] name; @Test private String[] description; @Test private String[] props2; @Test public void testSortPropertiesAlphabetically() { props = new String[] { "name", "description", "desc", "desc" }; } @Test public void testSortPropertiesAlphabetically() { props = new String[] { "name", "description", "desc", "desc" }; } } TestConfig config = new TestConfig(); config.setSortAlphabetically(true); AnnotationIntrospector introspector = Mockito.mock(AnnotationIntrospector.class); Mockito.when(introspector.findSerializationSortAlphabetically(Mockito.eq(Test.classDef))).thenReturn(new String[] { "name", "desc", "desc" }); Mockito.when(introspector.findSerializationPropertyOrder(Mockito.eq(Test.classDef))).thenReturn(new String[] { "name", "desc" }); new Test(config).sortProperties(); }
@Test public void testSortPropertiesAlphabetically() { class Test { private String s; private String s2; public Test(String s, String s2) { this.s = s; } } TestConfig config = new TestConfig(); config.setSortAlphabetically(true); config.setShouldSortPropertiesAlphabetically(false); class Test.setConfig(config); class Test.setProperties(ImmutableMap.of("s", s, "s2", s2)); assertEquals(new TreeMap<String, POJOPropertyBuilder>(10).size(), 1); assertEquals(new TreeMap<String, POJOPropertyBuilder>(10).size(), 2); assertEquals(new TreeMap<String, POJOPropertyBuilder>(10).size(), 2); assertEquals(new TreeMap<String, POJOPropertyBuilder>(10).size(), 1); assertEquals(new TreeMap<String, POJOPropertyBuilder>(10).size(), 2); assertEquals(new TreeMap<String, POJOPropertyBuilder>(10).size(), 1); assertEquals(new TreeMap<String, POJOPropertyBuilder>(10).size(), 2); assertEquals(new TreeMap<String, POJOPropertyBuilder>(10).size(), 1); assertEquals(new TreeMap<String, POJOPropertyBuilder>(10).size(), 2); }
@Test public void testSortProperties() { class Test { public void test() { } } { class TestBuilder { public void test() { } } class TestBean { public void test() { } } class TestBean2 { public void test() { } } class TestBean3 { public void test() { } } class TestBean4 { public void test() { } } class TestBean5 { public void test() { } } class TestBean6 { public void test() { } } class TestBean7 { public void test() { } } class TestBean8 { public void test() { } } class TestBean9 { public void test() { } } class TestBean10 { public void test() { } } class TestBean11 { public void test() { } } class TestBean12 { public void test() { } } class TestBean21 { public void test() { } } class TestBean22 { public void test() { } } } class TestBean23 { public void test() { } } class TestBean24 { public void test() { } } class TestBean242 { public void test() { } } class TestBean243 { public void test() { } } class TestBean244 {
@Test public void testAddFields() { classUnderTest.addFields(); classUnderTest.addFields(); classUnderTest.addFields(); classUnderTest.addFields(); classUnderTest.addFields(); classUnderTest.addFields(); }
@Test public void testAddFields() { classUnderTest.addFields(); assertField(EXPECTED_FIELD_NAME, EXPECTED_FIELD_NAME, "a"); assertField(EXPECTED_FIELD_NAME, EXPECTED_FIELD_NAME, "b"); assertField(EXPECTED_FIELD_NAME, EXPECTED_FIELD_NAME, "c"); }
@Test public void testAddFields() { classUnderTest.addFields(); assertField(EXPECTED_FIELD, "impl", " expl", "impl"); assertField(EXPECTED_FIELD, "impl", " expl", "impl"); assertField(EXPECTED_FIELD, "impl", " expl", "impl"); assertField(EXPECTED_FIELD, "impl", " expl", "impl"); assertField(EXPECTED_FIELD, "impl", " expl", "impl"); assertField(EXPECTED_FIELD, "impl", " expl", "impl"); assertField(EXPECTED_FIELD, "impl", " expl", "impl"); assertField(EXPECTED_FIELD, "impl", " expl", "impl"); assertField(EXPECTED_FIELD, "impl", " expl", "impl"); assertField(EXPECTED_FIELD, "impl", " expl", "impl"); assertField(EXPECTED_FIELD, "impl", " expl", "impl"); assertField(EXPECTED_FIELD, "impl", " expl", "impl"); assertField(EXPECTED_FIELD, "impl", " expl", "impl", "impl"); assertField(EXPECTED_FIELD, "impl", " expl", "impl",
@Test public void testAddFields() { class Test { public void test() { } } new Test() { @Override protected void test() { } @Override protected void test() { } @Override protected void test() { } @Override protected void test() { } @Override protected void test() { } @Override protected void test() { } @Override protected void test() { } @Override protected void test() { } @Override protected void test() { } @Override protected void test() { } @Override protected void test() { } @Override protected void test() { } @Override protected void test() { } @Override protected void test() { } @Override protected void test() { } @Override protected void test() { } @Override protected void test() { } @Override protected void test() { } @Override protected void test() { } @Override protected void test() { } @Override protected void test() { } @Override protected void test() { } @Override protected void test() { } @Override protected void test() { } @Override protected void test() { } @Override protected void test() { } @Override public void test() { } @Override public void test() { } @Override public void test() { } @
@Test public void testAddCreators() { classUnderTest.addCreators(); assertEquals(1, classUnderTest.getCreators().size()); }
@Test public void _addCreators() { AnnotationIntrospector ai = mock(AnnotationIntrospector.class); when(ai.findNameForDeserialization(null)).thenReturn(null); AnnotationIntrospector.Builder builder = mock(AnnotationIntrospector.Builder.class); when(builder.annotationIntrospector()).thenReturn(ai); builder.addCreators(); assertEquals(new AnnotationIntrospectorImpl(), builder.annotationIntrospector); }
@Test public void testAddCreators() { classUnderTest.addCreators(); }
@Test public void testAddCreators() { class Test { public void test() { } } Test(String s) { class Test1 { public void test1() { } } Test(String s1, String s2) { } } Test(String s1, String s2) { class Test1 { public void test1() { } } Test(String s1, String s2) { } } Test(String s1, String s2) { class Test1 { public void test1() { } } Test(String s1, String s2) { } } Test(String s1, String s1, String s2) { class Test1 { public void test1() { } } Test(String s1, String s1, String s2) { } } Test(String s1, String s1, String s2) { class Test1 { public void test1() { } } Test(String s1, String s1, String s2) { } } Test(String s1, String s1, String s2) { } }
@Test public void addCreators() { class Test { public void test1() { } } class Test2 { public void test2() { } } class Test3 { public void test3() { } } class Test4 { public void test4() { } } class Test5 { public void test5() { } } class Test6 { public void test6() { } } class Test7 { public void test7() { } } class Test8 { public void test8() { } } class Test9 { public void test9(String s) { } } class Test10 { public void test10(String s, String s1, String s2, String s3, String s4, String s5, String s6, String s7, String s8) { } } class Test10 { public void test10(String s, String s1, String s2, String s3, String s4, String s5, String s6, String s7, String s8) { } } class Test10 { public void test10(String s, String s1, String s2, String s3, String s3, String s4, String s5, String s6, String s7, String s8, String s9, String s9, String s10, String s10, String s12, s131, String s12,
@Test public void _property_creator_properties() { POJOPropertyBuilder builder = new POJOPropertyBuilder(); builder.addCreators(); builder.addCreator("name", "name"); assertEquals("name", builder.getCreatorProperties().get(0)); }
@Test public void addCreators() { class Test { public void test() { POJOPropertyBuilder builder = new POJOPropertyBuilder(); builder.setCreator("name"); builder.setCreator("name"); builder.setCreator("name"); builder.setCreator("name"); builder.setCreator("name"); } } Test test = new Test(); test.addCreators(); assertEquals(1, test.getCreatorProperties().size()); assertEquals("name", test.getCreatorProperties().get(0).getCreator()); }
@Test public void testAddCreators() { Annotator c = new Annotator("name"); c.addCreator(new Creators(c)); c.addCreator(new Creators(c)); }
@Test public void _addMethods() { classUnderTest.addMethods(); }
@Test public void _addMethods() { classUnderTest.addMethods(); }
@Test public void _addMethods() { classUnderTest.addMethods(); }
@Test public void _addMethods() { AnnotatedMethod m = new AnnotatedMethod(ID, "get", String.class, null, null); classUnderTest.addMethod(m); }
@Test public void testAddMethods() { classUnderTest.addMethods(); }
@Test public void _addGetterMethod() { classUnderTest.addGetterMethod(method1, method2); classUnderTest.addGetterMethod(method3, method4); classUnderTest.addGetterMethod(method4, method5); classUnderTest.addGetterMethod(method6, method7); classUnderTest.addGetterMethod(method7, method8); classUnderTest.addGetterMethod(method9, method10); classUnderTest.addGetterMethod(method10, method11); classUnderTest.addGetterMethod(method12, method13); classUnderTest.addGetterMethod(method14, method14); classUnderTest.addGetterMethod(method15, method15); classUnderTest.addGetterMethod(method20, method21); classUnderTest.addGetterMethod(method21, method22); classUnderTest.addGetterMethod(method25, method23); classUnderTest.addGetterMethod(method25, method22); classUnderTest.addGetterMethod(method25, method23); classUnderTest.addGetterMethod(method25, method22); classUnderTest.addGetterMethod(method25, method23); classUnderTest.addGetterMethod(method25, method22); classUnderTest.addGetterMethod(method25, method23); classUnderTest.addGetterMethod(method21, method22); }
@Test public void _addMethods() { classUnderTest.addMethods(); }
@Test public void _addSetterMethod() { classUnderTest.addSetterMethod(new MethodSetter(null, "int2")); classUnderTest.addSetterMethod(new MethodSetter(null, "int3")); classUnderTest.addMethods(); }
@Test public void testAddGetterMethod() { AnnotationIntrospector mockAni = Mockito.mock(AnnotationIntrospector.class); Mockito.when(mockAni.hasGetterAnnotation(Mockito.anyGetters.get(0))).thenReturn(true); Mockito.when(mockAni.hasAsValueAnnotation(Mockito.anyGetters.get(0))).thenReturn(true); Mockito.when(mockAni.hasGetterMethod(Mockito.anyGetters.get(0))).thenReturn(true); Mockito.when(mockAni.hasGetterMethod(Mockito.anyGetters.get(0))).thenReturn(true); Mockito.when(mockAni.hasGetterMethod(Mockito.anyGetters.get(0))).thenReturn(true); Mockito.when(mockAni.hasAsValueAnnotation(Mockito.anyGetters.get(0))).thenReturn(true); Mockito.when(mockAni.hasAsValueGetters(Mockito.anyGetters.get(0))).thenReturn(true); AnnotationIntrospector mockAni2 = Mockito.mock(AnnotationIntrospector.class); Mockito.when(mockAni2.hasGetterMethod(Mockito.anyGetters
@Test public void addGetterMethod() { AnnotationIntrospector ai = Mockito.mock(AnnotationIntrospector.class); Mockito.when(ai.hasGetterAnnotation(Mockito.anyGetters.get(0))).thenReturn(true); Mockito.when(ai.hasAsValueAnnotation(Mockito.anyGetters.get(0))).thenReturn(true); Mockito.when(ai.hasGetter(Mockito.anyGetters.get(1))).thenReturn(true); Mockito.when(ai.hasGetter(Mockito.anyGetters.get(2))).thenReturn(true); Mockito.when(ai.hasAsValueAnnotation(Mockito.anyGetters.get(0))).thenReturn(true); AnnotationIntrospectorIntrospector ai2 = Mockito.mock(AnnotationIntrospector.class); Mockito.when(ai2.hasGetterAnnotation(Mockito.anyGetters.get(0))).thenReturn(true); Mockito.when(ai2.hasAsValueAnnotation(Mockito.anyGetters.get(1))).thenReturn(true); Mockito.when(ai2.hasAsValueAnnotation(Mockito.anyGetters.get(2))).thenReturn(true); Mockito.when(ai2.hasGetter(Mockito
@Test public void addGetterMethod_noGetter() { AnnotationIntrospector ai = Mockito.mock(AnnotationIntrospector.class); Mockito.when(ai.hasAnyGetterAnnotation(Mockito.anyGetters)).thenReturn(true); Mockito.when(ai.hasAsValueAnnotation(Mockito.anyGetters)).thenReturn(true); Mockito.when(ai.hasGetter(Mockito.anyGetters.get(0))).thenReturn(false); Mockito.when(ai.hasGetter(Mockito.anyGetters.get(1))).thenReturn(true); Mockito.when(ai.hasAsValueAnnotation(Mockito.anyGetters)).thenReturn(true); Mockito.when(ai.hasGetter(Mockito.anyGetters.get(2))).thenReturn(true); Mockito.when(ai.hasAsValueAnnotation(Mockito.anyGetters.get(3))).thenReturn(true); AnnotationIntrospector ai2 = Mockito.mock(AnnotationIntrospector.class); Mockito.when(ai2.hasAnyGetterAnnotation(Mockito.anyGetters)).thenReturn(true); Mockito.when(ai2.hasGetter(Mockito.anyGetters.get(2))).thenReturn(
@Test public void _addGetterMethod_noGetterAnnotation() { AnnotationIntrospector ai = Mockito.mock(AnnotationIntrospector.class); Mockito.when(ai.hasAsValueAnnotation(Mockito.anyGetters.get(AnnotatedMethod.class))).thenReturn(false); Mockito.when(ai.hasGetterAnnotation(Mockito.anyGetters.get(AnnotatedMethod.class))).thenReturn(false); Mockito.when(ai.hasAsGetterAnnotation(Mockito.anyGetters.get(AnnotatedMethod.class))).thenReturn(true); Mockito.when(ai.hasAsValueAnnotation(Mockito.anyGetters.get(AnnotatedMethod.class))).thenReturn(true); AnnotationIntrospector ai2 = Mockito.mock(AnnotationIntrospector.class); Mockito.when(ai2.hasAsGetterAnnotation(Mockito.anyGetters.get(AnnotatedMethod.class))).thenReturn(true); Mockito.when(ai2.hasAsValueAnnotation(Mockito.anyGetters.get(AnnotatedMethod.class))).thenReturn(true); Mockito.when(ai2.hasGetterAnnotation(Mockito.anyGetters.get(AnnotatedMethod.class))).thenReturn(true); Mockito.
@Test public void test_addGetterMethod_jsonValueGetters_noGetter() { AnnotationIntrospector ai = Mockito.mock(AnnotationIntrospector.class); Mockito.when(ai.hasGetterAnnotation(Mockito.anyGetterAnnotation(Mockito.anyGetterAnnotation()))).thenReturn(true); Mockito.when(ai.hasAsValueAnnotation(Mockito.anyGetterAnnotation(Mockito.anyAsValueAnnotation()))).thenReturn(true); Mockito.when(ai.hasNameForSerialization(Mockito.anyGetterName())).thenReturn(true); Mockito.when(ai.hasNameForValue(Mockito.anyGetterName())).thenReturn(true); Mockito.when(ai.hasAsValueAnnotation(Mockito.anyGetterAnnotation(Mockito.anyGetters()))).thenReturn(true); Mockito.when(ai.hasGetter(Mockito.anyGetterAnnotation(Mockito.anyGetters()))).thenReturn(true); Mockito.when(ai.hasMethod(Mockito.anyMethod())).thenReturn(true); Mockito.when(ai.hasMethod(Mockito.anyMethod())).thenReturn(true); Mockito.when(ai.hasMethod(Mockito.anyMethod())).thenReturn
@Test public void test_jsonValueGetters_noGetter() { AnnotationIntrospector mockAnno = Mockito.mock(AnnotationIntrospector.class); Mockito.when(mockAnno.hasGetterAnnotation(Mockito.anyGetters)).thenReturn(true); Mockito.when(mockAnno.hasAsValueAnnotation(Mockito.anyGetters)).thenReturn(true); Mockito.when(mockAnno.hasAsGetter(Mockito.anyGetters)).thenReturn(true); Mockito.when(mockAnno.hasAnyGetterAnnotation(Mockito.anyGetters)).thenReturn(true); Mockito.when(mockAnno.hasAsValueAnnotation(Mockito.anyGetters)).thenReturn(true); Mockito.when(mockAnno.hasAsGetter(Mockito.anyGetters)).thenReturn(true); Mockito.when(mockAnno.hasAsValueAnnotation(Mockito.anyGetters)).thenReturn(true); Mockito.when(mockAnno.hasGetter(Mockito.anyGetters.get(String.class))).thenReturn(true); Mockito.when(mockAnno.hasGetter(Mockito.anyGetters.get(Integer.
@Test public void test_addGetterMethod_noGetterAnnotation() { AnnotationIntrospector ai = Mockito.mock(AnnotationIntrospector.class); Mockito.when(ai.hasGetterAnnotation(Mockito.anyGetters.get(0))).thenReturn(true); Mockito.when(ai.hasAsValueAnnotation(Mockito.anyGetters.get(0))).thenReturn(true); Mockito.when(ai.hasNameForSerialization(Mockito.anyGetters.get(0))).thenReturn(true); Mockito.when(ai.findNameForSerialization(Mockito.anyGetters.get(0))).thenReturn(null); Mockito.when(ai.hasAsValueAnnotation(Mockito.anyGetters.get(0))).thenReturn(true); AnnotationIntrospector ai2 = Mockito.mock(AnnotationIntrospector.class); Mockito.when(ai2.hasGetterAnnotation(Mockito.anyGetters.get(0))).thenReturn(true); Mockito.when(ai2.hasNameForSerialization(Mockito.anyGetters.get(0))).thenReturn(true); Mockito.when(ai2.hasAsValueAnnotation(Mockito.anyGetters.get(0))).thenReturn(true); AnnotationIntrospector
@Test public void addGetterMethod_noGetter() { AnnotationIntrospector ai = Mockito.mock(AnnotationIntrospector.class); Mockito.when(ai.hasGetterAnnotation(Mockito.anyGetters.get(0))).thenReturn(false); Mockito.when(ai.hasAsValueAnnotation(Mockito.anyGetters.get(0))).thenReturn(false); Mockito.when(ai.hasGetter(Mockito.anyGetters.get(1))).thenReturn(true); Mockito.when(ai.hasGetter(Mockito.anyGetters.get(2))).thenReturn(true); Mockito.when(ai.hasAsValueAnnotation(Mockito.anyGetters.get(0))).thenReturn(true); AnnotationIntrospector ai2 = Mockito.mock(AnnotationIntrospector.class); Mockito.when(ai2.hasGetterAnnotation(Mockito.anyGetters.get(1))).thenReturn(true); Mockito.when(ai2.hasAsValueAnnotation(Mockito.anyGetters.get(2))).thenReturn(true); Mockito.when(ai2.hasAsValueAnnotation(Mockito.anyGetters.get(3))).thenReturn(true); Mockito.when(ai2.hasGetter(Mock
@Test public void test_addGetterMethod_noGetterAnnotation() { class Test { public void test() { } } AnnotationIntrospector ai = Mockito.mock(AnnotationIntrospector.class); Mockito.when(ai.hasGetterAnnotation(Mockito.anyGetters.get(0))).thenReturn(true); Mockito.when(ai.hasAsValueAnnotation(Mockito.anyGetters.get(0))).thenReturn(true); Mockito.when(ai.hasGetterMethod(Mockito.anyGetters.get(0))).thenReturn(true); Mockito.when(ai.hasGetterMethod(Mockito.anyGetters.get(1))).thenReturn(true); Mockito.when(ai.hasGetterMethod(Mockito.anyGetters.get(2))).thenReturn(true); Mockito.when(ai.hasGetterMethod(Mockito.anyGetters.get(3))).thenReturn(true); Mockito.when(ai.hasGetterMethod(Mockito.anyGetters.get(4))).thenReturn(true); Mockito.when(ai.hasGetterMethod(Mockito.anyGetters.get(5))).thenReturn(true); Mockito.when(ai.hasGetterMethod(Mockito.any
@Test public void test_addGetterMethod_noGetter() { AnnotationIntrospector ai = Mockito.mock(AnnotationIntrospector.class); Mockito.when(ai.hasGetterAnnotation(Mockito.anyGetters.get(0))).thenReturn(false); Mockito.when(ai.hasAsValueAnnotation(Mockito.anyGetters.get(0))).thenReturn(false); Mockito.when(ai.hasGetter(Mockito.anyGetters.get(1))).thenReturn(true); Mockito.when(ai.hasGetter(Mockito.anyGetters.get(2))).thenReturn(true); Mockito.when(ai.hasAsValueAnnotation(Mockito.anyGetters.get(0))).thenReturn(true); Mockito.when(ai.hasAsGetter(Mockito.anyGetters.get(1))).thenReturn(true); Mockito.when(ai.hasAsValueAnnotation(Mockito.anyGetters.get(2))).thenReturn(true); AnnotationIntrospector ai2 = Mockito.mock(AnnotationIntrospector.class); Mockito.when(ai2.hasGetterAnnotation(Mockito.anyGetters.get(0))).thenReturn(true); Mockito.when(ai2.hasAsValue
@Test public void testSerializeWithSimpleName() { class MyService { public void testSerializeWithSimpleName(SimpleName pn) { } } MyService service = new MyService(); service.setExportName("export-with-simple-name"); service.setExportName("export-with-simple-name"); service.setExportName("export-with-simple-name"); service.setExportName("export-with-simple-name"); service.setExportName("export-with-simple-name"); service.setExportName("export-with-simple-name"); service.setExportName("export-with-simple-name"); service.setExportName("export-with-simple-name"); PropertyName pn = (null)? null : service.findNameForSerialization(null); PropertyName export = (null)? null : service.findNameForSerialization(null); AnnotationIntrospector ai = (AnnotationIntrospector) ReflectionTestUtils.getField(service, "export"); PropertyName exportPropertyName = (null)? null : service.findNameForSerialization(export); PropertyName exportPropertyName = (null)? null : service.findNameForSerialization(export); AnnotationIntrospector ai2 = (
@Test public void addGetterMethod_nullExpName() { PropertyName pn = new PropertyName("com.example.MyImpl"); AnnotationIntrospector ai = mock(AnnotationIntrospector.class); when(ai.hasAnyGetterAnnotation(anyGetters)).thenReturn(true); when(ai.hasAsValueAnnotation(anyGetters)).thenReturn(true); AnnotationIntrospectorIntrospectorIntrospectorIntrospector ai2 = mock(AnnotationIntrospector.class); when(ai2.hasGetterMethod(anyGetters)).thenReturn(true); when(ai2.hasAsValueAnnotation(anyGetters)).thenReturn(true); when(ai2.hasGetterMethod(anyGetters)).thenReturn(true); when(ai2.hasAsValueGetter(anyGetters)).thenReturn(true); AnnotationIntrospectorIntrospector ai3 = mock(AnnotationIntrospector.class); when(ai3.hasAnyGetterAnnotation(anyGetters)).thenReturn(true); when(ai3.hasAsValueAnnotation(anyGetters)).thenReturn(true); when(ai3.hasAsValueGetter(anyGetters)).thenReturn(true); when(ai3.hasAsValueAnnotation(anyGetters)).thenReturn(true); when(ai3.hasAsValueGetter(any
@Test public void addGetterMethod_explNameIsNull() { AnnotationIntrospector mockAnno = Mockito.mock(AnnotationIntrospector.class); Mockito.when(mockAnno.hasGetterAnnotation(Mockito.anyGetters)).thenReturn(true); Mockito.when(mockAnno.hasAsValueAnnotation(Mockito.anyGetters)).thenReturn(true); Mockito.when(mockAnno.hasAsValueGetters(Mockito.anyGetters)).thenReturn(true); Mockito.when(mockAnno.hasGetterMethod(Mockito.anyGetters)).thenReturn(true); Mockito.when(mockAnno.hasAsValueGetters(Mockito.anyGetters)).thenReturn(true); Mockito.when(mockAnno.hasAsGetterMethod(Mockito.anyGetters)).thenReturn(true); Mockito.when(mockAnno.hasAsValueGetters(Mockito.anyGetters)).thenReturn(true); Mockito.when(mockAnno.hasAsGetterMethod(Mockito.anyGetters)).thenReturn(true); Mockito.when(mockAnno.hasAsValueGetters(Mockito.anyGetters)).thenReturn(
@Test public void test_getter_name_simple() { class Test implements Test { public void test() { } } Test impl = BeanUtil.okNameForGetter(Test.class.getMethod("test")); AnnotationIntrospector annotationIntrospector = BeanUtil.getAnnotationIntrospector(impl); AnnotationIntrospector[] getters = { annotationIntrospector, null, annotationIntrospector }; assertEquals(1, getters.length); assertEquals("test", getters[0].getSimpleName()); }
@Test public void addGetterMethod() { class Test implements Bean { public void test() { } } AnnotationIntrospector ai = Mockito.mock(AnnotationIntrospector.class); Mockito.when(ai.hasGetterAnnotation(Mockito.anyGetters.get(0))).thenReturn(true); Mockito.when(ai.hasAsValueAnnotation(Mockito.anyGetters.get(0))).thenReturn(true); Mockito.when(ai.hasGetterMethod(Mockito.anyGetters.get(0))).thenReturn(true); Mockito.when(ai.hasGetterMethod(Mockito.anyGetters.get(1))).thenReturn(true); Mockito.when(ai.hasGetterMethod(Mockito.anyGetters.get(2))).thenReturn(true); Mockito.when(ai.hasGetterMethod(Mockito.anyGetters.get(3))).thenReturn(true); Mockito.when(ai.hasGetterMethod(Mockito.anyGetters.get(4))).thenReturn(true); AnnotationIntrospectorIntrospector ai2 = Mockito.mock(AnnotationIntrospector.class); Mockito.when(ai2.hasGetterAnnotation(Mockito.anyGetters.get(0))).thenReturn(true);
@Test public void addGetterMethod_explNameIsNull() { AnnotationIntrospector ai = Mockito.mock(AnnotationIntrospector.class); Mockito.when(ai.hasGetterAnnotation(Mockito.anyGetterAnnotation(Mockito.anyGetterAnnotation()))).thenReturn(true); Mockito.when(ai.hasAsValueAnnotation(Mockito.anyGetterAnnotation(Mockito.anyAsValueAnnotation()))).thenReturn(true); Mockito.when(ai.hasNameForSerialization(Mockito.anyGetterName())).thenReturn(true); Mockito.when(ai.findNameForSerialization(Mockito.anyGetterName())).thenReturn(null); Mockito.when(ai.hasAsValueAnnotation(Mockito.anyGetterAnnotation(Mockito.anyGetters()))).thenReturn(true); Mockito.when(ai.hasGetter(Mockito.anyGetterAnnotation(Mockito.anyGetters()))).thenReturn(true); Mockito.when(ai.hasGetter(Mockito.anyGetterAnnotation(Mockito.anyGetters()))).thenReturn(true); Mockito.when(ai.hasMethod(Mockito.anyMethod())).thenReturn(true); Mockito.when(ai.hasMethod(Mockito.anyMethod())
@Test public void test_addGetterMethod_noGetterAnnotation_noAnyGetterAnnotation() { AnnotationIntrospector ai = Mockito.mock(AnnotationIntrospector.class); Mockito.when(ai.hasGetterAnnotation(Mockito.anyGetters.get(0))).thenReturn(false); Mockito.when(ai.hasAsValueAnnotation(Mockito.anyGetters.get(0))).thenReturn(false); Mockito.when(ai.hasAnyGetterAnnotation(Mockito.anyGetters.get(1))).thenReturn(true); Mockito.when(ai.hasAsGetterAnnotation(Mockito.anyGetters.get(2))).thenReturn(true); Mockito.when(ai.hasAsValueAnnotation(Mockito.anyGetters.get(0))).thenReturn(true); Mockito.when(ai.hasAsGetterAnnotation(Mockito.anyGetters.get(2))).thenReturn(true); Mockito.when(ai.hasAsValueGetter(Mockito.anyGetters.get(3))).thenReturn(true); AnnotationIntrospector_noGetterAnnotation = Mockito.mock(AnnotationIntrospector.class); Mockito.when(ai_noGetterAnnotation.hasAnnotation(Mockito.anyGetters.get
@Test public void testHasIgnore() { AnnotationIntrospector ai = mock(AnnotationIntrospector.class); when(ai.hasIgnoreMarker(any(AnnotatedMethod.class))).thenReturn(true); when(ai.hasAsValueAnnotation(any(AnnotatedMethod.class))).thenReturn(true); AnnotationIntrospectorIntrospectorIntrospectorIntrospectorIntrospector = mock(AnnotationIntrospectorIntrospector.class); when(ai.hasAnyGetterAnnotation(any(AnnotatedMethod.class))).thenReturn(true); when(ai.hasGetterMethod(any(AnnotatedMethod.class))).thenReturn(true); when(ai.hasAsValueAnnotation(any(AnnotatedMethod.class))).thenReturn(true); when(ai.hasJsonValueGetters(any(AnnotatedMethod.class))).thenReturn(true); when(ai.hasJsonGetters(any(AnnotatedMethod.class))).thenReturn(true); when(ai.hasGetterMethod(any(AnnotatedMethod.class))).thenReturn(true); when(ai.hasGetterMethod(any(AnnotatedMethod.class))).thenReturn(true); when(ai.hasGetterMethod(any(AnnotatedMethod.class))).thenReturn(true); when(ai.has
@Test public void test_property_explName_null() { class Test { public void test() { System.out.println("test"); } } AnnotationIntrospector annotationIntrospector = Mockito.mock(AnnotationIntrospector.class); Mockito.when(annotationIntrospector.hasGetter(Mockito.anyGetters.get(0))).thenReturn(true); Mockito.when(annotationIntrospector.hasSetter(Mockito.anyGetters.get(0))).thenReturn(true); Mockito.when(annotationIntrospector.getGetter(Mockito.anyGetters.get(1))).thenReturn(null); Mockito.when(annotationIntrospector.getSetter(Mockito.anyGetters.get(2))).thenReturn(null); Mockito.when(annotationIntrospector.getGetter(Mockito.anyGetters.get(3))).thenReturn(null); Mockito.when(annotationIntrospector.getGetter(Mockito.anyGetters.get(4))).thenReturn(null); Mockito.when(annotationIntrospector.getGetter(Mockito.anyGetters.get(5))).thenReturn(null); AnnotationIntrospector im = Mockito.mock(AnnotationIntrospector.class); Mockito.when(im.hasInterface(
@Test public void addSetterMethod_ignore() { AnnotationIntrospector ai = mock(AnnotationIntrospector.class); AnnotatedMethod m = createMethod("foo", String.class); ACCESSABLE.addSetterMethod(m, ai); assertHasSetterAnnotation(m, ACCESSABLE, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null); }
@Test public void addSetterMethod_private() { class DeclaringClass { @Setter private String m1; @Setter private String m2; } AnnotationIntrospector ai = mock(AnnotationIntrospector.class); when(ai.findNameForDeserialization(any())).thenReturn(new PropertyName("com.example.Foo")); when(ai.hasSetter(any())).thenReturn(true); when(ai.hasIgnoreMarker(any())).thenReturn(false); AnnotationIntrospector annotationIntrospector = mock(AnnotationIntrospector.class); when(annotationIntrospector.Introspect(any())).thenReturn(annotationIntrospector); AnnotatedMethod m = new AnnotatedMethod(DeclaringClass.class, "myMethod", String.class); _addSetterMethod(m, ai); AnnotationIntrospector annotationIntrospector = mock(AnnotationIntrospector.class); when(annotationIntrospector.Introspect(any())).thenReturn(annotationIntrospector); AnnotatedMethod m2 = new AnnotatedMethod(DeclaringClass.class, "myMethod2", String.class); _addSetterMethod(m2, ai); AnnotationIntrospector annotationIntrospector = mock(AnnotationIntrospector.class); when(annotationIntrospector.Introspect(any())).thenReturn(annotation
@Test public void addSetterMethod_ignore() { AnnotationIntrospector annotationIntrospector = mock(AnnotationIntrospector.class); AnnotatedMethod m = createMethod("foo", String.class); annotationIntrospector.addSetterMethod(m, annotationIntrospector); AnnotationIntrospector annotationIntrospector2 = mock(AnnotationIntrospector.class); AnnotationIntrospector annotationIntrospector3 = mock(AnnotationIntrospector.class); when(annotationIntrospector2.isSetterVisible(m)).thenReturn(true); when(annotationIntrospector3.isSetterVisible(m)).thenReturn(false); annotationIntrospector.addSetterMethod(m, annotationIntrospector2); AnnotationIntrospector annotationIntrospector3 = mock(AnnotationIntrospector.class); when(annotationIntrospector3.isSetterVisible(m)).thenReturn(true); annotationIntrospector.addSetterMethod(m, annotationIntrospector3); AnnotationIntrospector annotationIntrospector4 = mock(AnnotationIntrospector.class); when(annotationIntrospector4.isSetterVisible(m)).thenReturn(true); annotationIntrospector.addSetterMethod(m, annotationIntrospector4); AnnotationIntrospector annotationIntrospector5 = mock(AnnotationIntrospector.class); when(annotationIntrospector5.isSetterVisible(m)).thenReturn(true
@Test public void addSetterMethod_ignore() { AnnotationIntrospector mockAnno = mock(AnnotationIntrospector.class); AnnotatedMethod m = mock(AnnotatedMethod.class); when(mockAnno.findNameForDeserialization(m)).thenReturn(new PropertyName("foo")); AnnotationIntrospector.addSetterMethod(m, mockAnno); verify(mockAnno).findNameForDeserialization(m); }
@Test public void addSetterMethod_ignore() { AnnotationIntrospector annotationIntrospector = mock(AnnotationIntrospector.class); when(annotationIntrospector.isAnnotationPresent(eq(BEAN_NAME))).thenReturn(true); when(annotationIntrospector.isAnnotationPresent(eq(BEAN_NAME))).thenReturn(false); AnnotatedMethod m = createMethod("foo"); _addSetterMethod(m, annotationIntrospector); AnnotationIntrospector annotationIntrospector2 = mock(AnnotationIntrospector.class); when(annotationIntrospector2.isAnnotationPresent(eq(BEAN_NAME))).thenReturn(true); when(annotationIntrospector2.isAnnotationPresent(eq(BEAN_NAME))).thenReturn(false); AnnotatedMethod m2 = createMethod("foo"); _addSetterMethod(m2, annotationIntrospector2); AnnotationIntrospector annotationIntrospector3 = mock(AnnotationIntrospector.class); when(annotationIntrospector3.isAnnotationPresent(eq(BEAN_NAME))).thenReturn(true); when(annotationIntrospector3.isAnnotationPresent(eq(BEAN_NAME))).thenReturn(false); when(annotationIntrospector3.isAnnotationPresent(eq(BEAN_NAME))).thenReturn(true); AnnotatedMethod m3 = createMethod("foo
@Test public void addSetterMethod_explNameIsNull() { AnnotationIntrospector annotationIntrospector = mock(AnnotationIntrospector.class); AnnotatedMethod m = mock(AnnotatedMethod.class); when(m.getName()).thenReturn(null); when(annotationIntrospector.isAnnotationPresent(eq(Method.class))).thenReturn(true); when(m.getAnnotation(AnnotatedMethod.class)).thenReturn(annotationIntrospector); _adder.addSetterMethod(m, annotationIntrospector); verify(annotationIntrospector).isAnnotationPresent(eq(Method.class)); }
@Test public void testAddSetterMethod() { AnnotationIntrospector ai = Mockito.mock(AnnotationIntrospector.class); Mockito.when(ai.findNameForDeserialization(Mockito.any())).thenReturn(new PropertyName("com.example.Foo")); Mockito.when(ai.hasIgnoreMar()).thenReturn(false); Mockito.when(ai.isSetterVisible(Mockito.any())).thenReturn(true); Mockito.when(mockAnnotationIntrospector.introspectorFor(Mockito.any())).thenReturn(ai); AnnotatedMethod m = Mockito.mock(AnnotatedMethod.class); Mockito.when(m.getName()).thenReturn("com.example.Foo"); Mockito.when(m.getAnnotation(Annotation.class)).thenReturn(new PropertyName("com.example.Foo")); Mockito.when(m.isVisible()).thenReturn(true); Mockito.when(m.getDeclaredMethod(Mockito.anyString())).thenReturn(m); AnnotationIntrospector ai2 = Mockito.mock(AnnotationIntrospector.class); Mockito.when(ai2.findNameForDeserialization(Mockito.any())).thenReturn(new PropertyName("com.example.Foo")); Mockito.when(ai2.getAnnotation(Annotation
@Test public void addSetterMethod_ignore() { AnnotationIntrospector annotationIntrospector = mock(AnnotationIntrospector.class); when(annotationIntrospector.isAnnotationPresent(eq(Method.class))).thenReturn(true); when(annotationIntrospector.getAnnotationIntrospector(eq(Method.class))).thenReturn(annotationIntrospector); AnnotatedMethod m = mock(AnnotatedMethod.class); when(m.getName()).thenReturn("myMethod"); when(m.getAnnotationIntrospector(eq(AnnotationIntrospector.class))).thenReturn(annotationIntrospector); when(annotationIntrospector.isAnnotationPresent(eq(Method.class))).thenReturn(true); when(annotationIntrospector.getAnnotationIntrospector(eq(Method.class))).thenReturn(annotationIntrospector); when(annotationIntrospector.hasSetter(m)).thenReturn(true); _adder.addSetterMethod(m, annotationIntrospector); AnnotationIntrospector annotationIntrospector2 = mock(AnnotationIntrospector.class); when(annotationIntrospector2.isAnnotationPresent(eq(Method.class))).thenReturn(true); when(annotationIntrospector2.getAnnotationIntrospector(eq(Method.class))).thenReturn(annotationIntrospector2); _adder.add
@Test public void setter_visible_is_set() { VisibilityChecker visChecker = new VisibilityChecker(); AnnotatedMethod setter = createMethod("set", String.class); visChecker.addSetterMethod(setter, visChecker); AnnotationIntrospector annotationIntrospector = visChecker.Introspector(setter); AnnotationIntrospector annotationIntrospector2 = visChecker.Introspector(setter); AnnotationIntrospector annotationIntrospector3 = visChecker.Introspector(setter); assertEquals("visible", annotationIntrospector.getAnnotation(Visible.class).getName()); assertEquals("set", annotationIntrospector2.getAnnotation(Visible.class).getName()); assertEquals("", annotationIntrospector3.getAnnotation(Visible.class).getName()); }
@Test public void testAddSetterMethod_ignore() { AnnotationIntrospector annotationIntrospector = mock(AnnotationIntrospector.class); when(annotationIntrospector.introspect(any(Method.class))).thenReturn(annotationIntrospector); AnnotatedMethod m = createMethod("ignore", "foo"); _addSetterMethod(m, annotationIntrospector); verify(annotationIntrospector).introspect(m); }
@Test public void addSetterMethod_propertyName() { class Mock { public void m() { } } AnnotationIntrospector annotationIntrospector = mock(AnnotationIntrospector.class); new Mock(annotationIntrospector).addSetterMethod(mock(AnnotatedMethod.class), annotationIntrospector); }
@Test public void testAddInjectables() { classUnderTest.addInjectables(); classUnderTest.addInjectables(); classUnderTest.addInjectables(); classUnderTest.addInjectables(); }
@Test public void _addInjectables() { classUnderTest.addInjectables(); assertEquals(1, classUnderTest.getInjectables().size()); }
@Test public void _addInjectables() { classUnderTest.addInjectables(); classUnderTest.addInjectables(); }
@Test public void _addInjectables() { class Test { public void testAddInjectables() { } } class Test2 extends Test { public void testAddInjectables() { } } class Test3 extends Test { public void testAddInjectables() { } } class Test4 extends Test { public void testAddInjectables() { } } Test4 class Test5 extends Test { public void testAddInjectables() { } } Test4 class Test6 extends Test { public void testAddInjectables() { } } Test4 class Test7 extends Test { public void testAddInjectables() { } } Test4 class Test8 extends Test { public void testAddInjectables() { } } Test4 class9 extends Test { public void testAddInjectables() { } } Test4 class10 = new Test4(); class1.addInjectables(); Test4 class11 = new Test4(); class1.addInjectables(); assertEquals(class1.getInjectables(), class10.getInjectables()); assertEquals(class1.getInjectables(), class10.getInjectables()); assertEquals(class1.getInjectables(), class10.getInjectables()); assertEquals(class1.getInjectables(), class10.getInjectables()); }
@Test public void _addInjectables() { classUnderTest.addInjectables(); }
@Test public void _addInjectables() { classUnderTest.addInjectables(); }
@Test public void testAddInjectables() { class Test { public void test1() { } } class Test2 extends Test { public void test2() { } } class Test3 extends Test { public void test3() { } } class Test4 extends Test { public void test4() { } } class Test5 extends Test { public void test5() { } } class Test6 extends Test { public void test6() { } } class Test7 extends Test { public void test7() { } } class Test8 extends Test { public void test8() { } } class Test9 extends Test { public void test9() { } } class Test10 extends Test { public void test10() { } } class Test11 extends Test { public void test11() { } } } Test4 test1 = new Test1(); new POJOPropertiesCollector(config, false, JavaType.BOOLEAN, classTest.getClassDef(), null).addInjectables(); new POJOPropertiesCollector(config, false, JavaType.BOOLEAN, classTest.getClassDef(), null).addInjectables(); new POJOPropertiesCollector(config, false, JavaType.BOOLEAN, classTest.getClassDef(), null).addInjectables(); new POJOPropertiesCollector(config, false, Java
@Test public void addInjectable() { classUnderTest.addInjectable(id1, id2); assertEquals("Injectable1ValueId1ValueId2", classUnderTest.injectable(id1, id2)); }
@Test public void _doAddInjectable() { class Test { public void test() { } } Test.injectables.put("test", new Test()); _doAddInjectable("test", new Test()); }
@Test public void _doAddInjectable_nullId() { new Expectations() { { null.doAddInjectable(null, null); } }; }
@Test public void _doAddInjectable() { MapperConfig.Builder builder = MapperConfig.builder(); builder.addInjectable("foo", new AnnotatedMember()); builder.addInjectable("bar", new AnnotatedMember()); MapperConfig.Builder builder2 = MapperConfig.builder(); builder2.addInjectable("foo", new AnnotatedMember()); builder2.addInjectable("bar", new AnnotatedMember()); MapperConfig.Builder builder3 = MapperConfig.builder(); builder3.addInjectable("foo", new AnnotatedMember()); builder3.addInjectable("bar", new AnnotatedMember()); builder3.addInjectable("bar", new AnnotatedMember()); try { builder2.doAddInjectable("foo", null); fail("Should throw IllegalArgumentException"); } catch (IllegalArgumentException e) { } }
@Test public void removeUnwantedProperties() { TestConfig config = new TestConfig(); config.setProperty(MapperFeature.INFER_PROPERTY_MUTATORS, "true"); config.setProperty(MapperFeature.INFER_PROPERTY_SCANNERS, "true"); config.setProperty(MapperFeature.INFER_PROPERTY_SCANNERS_SCANNERS, "true"); config.setProperty(MapperFeature.INFER_PROPERTY_SCANNERS_SCANNERS, "false"); config.setProperty(MapperFeature.INFER_PROPERTY_SCANNERS_SCANNERS, "false"); config.setProperty(MapperFeature.INFER_PROPERTY_SCANNERS_SCANNERS, "false"); config.setProperty(MapperFeature.INFER_PROPERTY_SCANNERS_SCANNERS, "false"); config.setProperty(MapperFeature.INFER_PROPERTY_SCANNERS_SCANNERS, "true"); config.setProperty(MapperFeature.INFER_PROPERTY_SCANNERS_SCANNERS, "false"); config.setProperty(MapperFeature.INFER_PROPERTY_SCANNERS_SCANNERS, "false"); config.setProperty(MapperFeature.INFER_PROPERTY_SCANNER
@Test public void testRemoveUnwantedProperties() { Map<String, POJOPropertyBuilder> properties = new HashMap<String, POJOPropertyBuilder>(); properties.put("foo", new POJOPropertyBuilder("foo", "bar")); properties.put("bar", new POJOPropertyBuilder("bar", "baz")); properties.put("foo", new POJOPropertyBuilder("foo", "bar")); properties.put("bar", new POJOPropertyBuilder("bar", "baz")); Iterator<Map.Entry<String, POJOPropertyBuilder>> it = properties.entrySet().iterator(); [LINE] void _removeUnwantedProperties(boolean forceNonVisibleRemoval) { if (forceNonVisibleRemoval) it.next().removeUnwantedProperties(); } }
@Test public void removeUnwantedProperties() { final Map<String, POJOPropertyBuilder> properties = new HashMap<>(); properties.put("foo", new POJOPropertyBuilder("foo", "bar")); properties.put("foo.bar", new POJOPropertyBuilder("foo.bar", "baz")); properties.put("foo.bar.baz", new POJOPropertyBuilder("foo.bar.baz", "baz")); properties.put("foo.bar.baz", new POJOPropertyBuilder("foo.bar.baz", "baz")); final Map<String, POJOPropertyBuilder> mutations = new HashMap<>(); mutations.put("foo", new POJOPropertyBuilder("foo", "bar")); mutations.put("foo.bar.baz", new POJOPropertyBuilder("foo.bar.baz", "baz")); mutations.put("foo.bar.baz", new POJOPropertyBuilder("foo.bar.baz", "baz")); mutations.put("foo.bar.baz", new POJOPropertyBuilder("foo.bar.baz", "baz")); mutations.put("foo.bar.baz", new POJOPropertyBuilder("foo.bar.baz", "baz")); mutations.put("foo.bar.baz", new POJOPropertyBuilder
@Test public void testRemoveUnwantedProperties() { final Configuration config = new Configuration(); config.setProperty(MapperFeature.CONFIG_PROPERTY_MUTATORS, "true"); config.setProperty(MapperFeature.CONFIG_PROPERTY_EXPANDED_PROPERTY_MUTATORS, "true"); config.setProperty(MapperFeature.CONFIG_PROPERTY_EXPANDED_EXPANDED_PROPERTY_EXPANDED_PROPERTY_MUTATORS, "true"); config.setProperty(MapperFeature.CONFIG_PROPERTY_EXPANDED_EXPANDED_PROPERTY_MUTATORS, "false"); config.setProperty(MapperFeature.CONFIG_PROPERTY_EXPANDED_PROPERTY_MUTATORS, "false"); config.setProperty(MapperFeature.CONFIG_PROPERTY_EXPANDED_PROPERTY_MUTATORS, "true"); config.setProperty(MapperFeature.CONFIG_PROPERTY_EXPANDED_PROPERTY_MUTATORS, "false"); config.setProperty(MapperFeature.CONFIG_PROPERTY_EXPANDED_PROPERTY_EXPANDED_PROPERTY_MUTATORS, "true"); config.setProperty(MapperFeature.CONFIG_PROPERTY_EXPANDED_PROPERTY_EXPANDED_PROPERTY_M
@Test public void removeUnwantedProperties() { TestConfig config = new TestConfig(); config.setEnabled(MapperFeature.INFER_PROPERTY_MUTATORS, "true"); config.setEnabled(MapperFeature.INFER_PROPERTY_EXPANDED_EXPANDED_EXPANDED_EXPANDED_EXPANDED_EXPANDED_EXPANDED_EXPANDED_EXPANDED_EXPANDED_EXPANDED_EXPANDED_EXPANDED_EXPANDED_EXPANDED_EXPANDED_EXPANDED_EXPANDED_EXPANDED_EXPANDED_EXPANDED_EXPANDED_EXPANDED_EXPANDED_EXPANDED_EXPANDED_EXPANDED_EXPANDED_EXPANDED_EXPANDED_EXPANDED_EXPANDED_EXPANDED_EXPANDED_EXPANDED_EXPANDED_EXPANDED_EXPANDED_EXPANDED_EXPANDED_EXPANDED_EXPANDED_EXPANDED_EXPANDED_EXPANDED_EXPANDED_EXPANDED_EXPANDED_EXPANDED_EXPANDED_EXPANDED
@Test public void removeUnwantedProperties() { new Expectations() {{ mockConfig.isEnabled(MapperFeature.INFER_PROPERTY_MUTATORS); [LINE] POJOPropertyBuilder builder = new POJOPropertyBuilder("foo", null); }}; { new POJOPropertyBuilder("foo", null); } { new POJOPropertyBuilder("foo", null); } { new POJOPropertyBuilder("foo", null); } { new POJOPropertyBuilder("foo", null); } { new POJOPropertyBuilder("foo", null); } { new POJOPropertyBuilder("foo", null); } { new POJOPropertyBuilder("foo", null); } { new POJOPropertyBuilder("foo", null); } { new POJOPropertyBuilder("foo", null); } { new POJOPropertyBuilder("foo", null); } { new POJOPropertyBuilder("foo", null); } { new POJOPropertyBuilder("foo", null); } { new POJOPropertyBuilder("foo", null); } { new POJOPropertyBuilder("foo", null); } { new POJOPropertyBuilder("foo", null); } { new POJOPropertyBuilder("foo", null); } { new POJOPropertyBuilder("foo", null); } { new POJOPropertyBuilder("foo", null); } }
@Test public void removeUnwantedProperties() { final Map<String, POJOPropertyBuilder> properties = new HashMap<>(); properties.put("foo", new POJOPropertyBuilder("foo", "bar")); properties.put("bar", new POJOPropertyBuilder("bar", "baz")); properties.put("foo.bar", new POJOPropertyBuilder("foo.bar", "baz")); _config.setProperty(MapperFeature.METRICS_PREFIX + "foo.bar", "foo.bar"); _config.setProperty(MapperFeature.METRICS_PREFIX + "foo.bar", "foo.bar"); _config.setProperty(MapperFeature.METRICS_PREFIX + "foo.bar", "foo.bar"); _config.setProperty(MapperFeature.METRICS_PREFIX + "foo.bar", "foo.bar"); _config.setProperty(MapperFeature.METRICS_PREFIX + "foo.bar", "foo.bar"); _config.setProperty(MapperFeature.METRICS_PREFIX + "foo.bar", "foo.bar"); _config.setProperty(MapperFeature.METRICS_PREFIX + "foo.bar", "foo.bar"); _config.setProperty(MapperFeature.METRICS_PREFIX + "foo.bar",
protected void _removeUnwantedProperties() { new Expectations() {{ props.iterator(); result = new IteratorEnumeration<>(Collections.singletonList(new POJOPropertyBuilder("foo", "bar")))); }}; new Expectations() {{ props.iterator(); result = new IteratorEnumeration<>(Collections.singletonList(new POJOPropertyBuilder("foo", "bar")))); }}; new MockUp<MapperFeature>() { @Mock void _config(final Map<String, POJOPropertyBuilder> properties) { properties.forEach(prop -> { try { properties.remove(prop); } catch (Exception e) { e.printStackTrace(); } }); } }; new MockUp<Property>() { @Mock void _config(final Map<String, POJOPropertyBuilder> properties) { properties.forEach(prop -> { try { properties.remove(prop); } catch (Exception e) { e.printStackTrace(); } }); } }; new MockUp<Property>() { @Mock void _config(final Map<String, POJOPropertyBuilder> properties) { properties.forEach(prop -> { try { properties.remove(prop); } catch (Exception e) { e.printStackTrace(); } }); } }; new MockUp<Property>() { @Mock void _config(final
@Test public void removeNonVisibleRemovesProperties() { final Map<String, POJOPropertyBuilder> properties = new HashMap<>(); properties.put("foo", new POJOPropertyBuilder("foo", "bar")); properties.put("bar", new POJOPropertyBuilder("bar", "baz")); properties.put("foo.bar", new POJOPropertyBuilder("foo.bar", "baz")); _mapper.config.setEnabled(MapperFeature.METRICS_ENABLED); _mapper.config.setEnabled(MapperFeature.METRICS_METRICS); _mapper.removeNonVisible(true); }
@Test public void testRenameProperties() { [LINE] classUnderTest = new classUnderTest(); classUnderTest.renameProperties(); assertEquals("properties", classUnderTest.getProperties()); }
@Test public void testRenameProperties() { Map<String, POJOPropertyBuilder> properties = new HashMap<String, POJOPropertyBuilder>(); properties.put("prop1", new POJOPropertyBuilder("prop1", "value1")); properties.put("prop2", new POJOPropertyBuilder("prop2", "value2")); properties.put("prop3", new POJOPropertyBuilder("prop3", "value3")); properties.put("prop4", new POJOPropertyBuilder("prop4", "value4")); Iterator<Map.Entry<String, POJOPropertyBuilder>> it = properties.entrySet().iterator(); [LINE] public void _renameProperties() { try { it.next(); } catch (NoSuchElementException e) { fail(); } } { try { it.next(); } catch (NoSuchElementException e) { fail(); } } { try { it.next(); } catch (NoSuchElementException e) { fail(); } } }
@Test public void testRenameProperties() { LinkedList<POJOPropertyBuilder> properties = new LinkedList<POJOPropertyBuilder>(); properties.put("foo", new POJOPropertyBuilder("foo", "bar")); properties.put("foo2", new POJOPropertyBuilder("foo2", "bar")); properties.put("foo3", new POJOPropertyBuilder("foo3", "bar")); _properties = properties; _renameProperties(); assertEquals("foo", properties.get("foo")); assertEquals("bar", properties.get("foo2")); assertEquals("bar", properties.get("foo3")); }
@Test public void testRenameProperties() { new MockUp<Properties>() { @Mock private Map<String, POJOPropertyBuilder> properties; @Mock private void renameProperties(Map<String, POJOPropertyBuilder> properties) { this.properties = properties; } }; new MockUp<RenameProperties>() { @Mock private void renameProperties(Map<String, POJOPropertyBuilder> properties) { this.renameProperties(properties); } }; }
@Test public void testRenameProperties() { new MockUp<Person>() { @Mock private Person person; @Mock private String name; @Mock private String age; @Mock private String name2; @Mock private String age; }; Person p = new Person(); p.setName("John"); p.setAge(1234); p.setAge(45); p.setAge(45); p.setName("Mickey"); p.setAge(45); p.setAge(45); p.setAge(45); p.setName("Mickey"); p.setAge(45); p.setAge(45); p.setName("Mickey2"); p.setAge(45); _renameProperties(); assertEquals("John", p.getName()); assertEquals("Mickey2", p.getName()); assertEquals("Mickey2", p.getName()); assertEquals("Mickey2", p.getName()); assertEquals("Mickey2", p.getName()); assertEquals("Mickey2", p.getName()); assertEquals("Mickey2", p.getName()); assertEquals("Mickey2", p.getName()); assertEquals("Mickey2", p.getName()); assertEquals("Mickey2", p.getName()); assertEquals("Mic
@Test public void testRenameProperties() { new MockUp<PojoBuilder>() { @Mock private Map<String, POJOPropertyBuilder> properties; @Mock private void _renameProperties(Object value) { properties = (Map<String, POJOPropertyBuilder>) value; } }; MockUp<PojoBuilder>() { new MockUp<PojoBuilder>() { @Mock private Map<String, POJOPropertyBuilder> properties; }; new MockUp<POJOPropertyBuilder>() { @Mock private String findNewName(); }; }; new MockUp<POJOPropertyBuilder>() { @Mock private String withName(String name) { return name; } }; new MockUp<POJOPropertyBuilder>() { @Mock private Map<String, POJOPropertyBuilder> properties; }; new MockUp<POJOPropertyBuilder>() { @Mock private String withName(String name) { return name; } }; new MockUp<POJOPropertyBuilder>() { @Mock private String withName(String newName) { return newName; } }; new MockUp<POJOPropertyBuilder>() { @Mock private Map<String, POJOPropertyBuilder> properties; }; new MockUp<POJOPropertyBuilder>() { @Mock private String withRename(String newName) { return newName
@Test public void testRenameProperties() { [LINE] prop = new TestProperty("name"); Mockito.when(prop.findNewName()).thenReturn("name"); Mockito.when(prop.withName("name")).thenReturn(null); Mockito.when(prop.withName("name")).thenReturn(null); _manager.setProperty("name", "name"); _manager.renameProperties(); Mockito.verify(prop).withName("name"); Mockito.verify(prop).withName("name"); Mockito.verify(prop).withName("name"); Mockito.verify(prop).withName("name"); Mockito.verify(prop).withName("name"); Mockito.verify(prop).withName("name"); Mockito.verify(prop).withName("name"); Mockito.verify(prop).withName("name"); Mockito.verify(prop).withName("name"); Mockito.verify(prop).withName("name"); Mockito.verify(prop).withName("name"); Mockito.verify(prop).withName("name"); Mockito.verify(prop).withName("name"); Mockito.verify(prop).withName("name"); }
@Test public void testRenameProperties() { new MockUp<Properties>() { @Mock private Map<String, POJOPropertyBuilder> properties; @Mock private void _renameProperties(Map<String, POJOPropertyBuilder> properties) { this.properties = properties; } }; new MockUp<RenameProperties>() { @Mock private void _renameProperties(Map<String, POJOPropertyBuilder> properties) { this.properties = properties; } }; new MockUp<RenameProperties>() { @Mock private void _renameProperties(Map<String, POJOPropertyBuilder> properties) { this.properties = properties; } }; new MockUp<RenameProperties>() { @Mock private void _renameProperties(Map<String, POJOPropertyBuilder> properties) { this.properties = properties; } }; new MockUp<RenameProperties>() { @Mock private void _renameProperties(Map<String, POJOPropertyBuilder> properties) { this.properties = properties; } }; new MockUp<RenameProperties>() { @Mock private void _renameProperties(Map<String, POJOPropertyBuilder> properties) { this.properties = properties; } }; new MockUp<RenameProperties>() { @Mock private void _renameProperties(Map<String, POJOPropertyBuilder>
@Test public void testRenameProperties() { new MockUp<Properties>() { @Mock private Map<String, POJOPropertyBuilder> properties; @Mock private void renameProperties(Map<String, POJOPropertyBuilder> properties) { this.properties = properties; } }; new MockUp<RenameProperties>() { @Mock private void renameProperties(Map<String, POJOPropertyBuilder> properties) { this.renameProperties(null); } }; new MockUp<RenameProperties>() { @Mock private void renameProperties(Map<String, POJOPropertyBuilder> properties) { this.properties = properties; } }; new MockUp<RenameProperties>() { @Mock private void renameProperties(Map<String, POJOPropertyBuilder> properties) { this.renameProperties(null); } }; new MockUp<RenameProperties>() { @Mock private void renameProperties(Map<String, POJOPropertyBuilder> properties) { this.renameProperties(null); } }; new MockUp<RenameProperties>() { @Mock private void renameProperties(Map<String, POJOPropertyBuilder> properties) { this.renameProperties(null); } }; new MockUp<RenameProperties>() { @Mock private void renameProperties(List<POJOPropertyBuilder> properties) { this
@Test public void testRenameProperties() { List<POJOPropertyBuilder> properties = new ArrayList<POJOPropertyBuilder>(); properties.add(new POJOPropertyBuilder("foo", "bar")); properties.add(new POJOPropertyBuilder("foo", "baz")); properties.add(new POJOPropertyBuilder("foo", "bar")); _properties.put("foo", new POJOPropertyBuilder("foo", "bar")); _renameProperties(); assertEquals(properties, new LinkedList<POJOPropertyBuilder>()); }
@Test public void testRenameProperties() { [LINE] prop = new TestPojoBuilder().withName("name").withType("string").build(); [LINE] prop.renameProperties(); assertEquals("name", prop.findNewName()); assertEquals("string", prop.withType("string").withName("name")); }
@Test public void testRenameProperties() { MockBar bar = new MockBar(); bar.addProperty("foo", "bar"); bar.addProperty("foo2", "bar2"); MockBar baz = new MockBar(); baz.addProperty("foo3", "baz"); baz.addProperty("foo4", "baz"); _properties.put("foo", bar); _renameProperties(); assertEquals(bar.getProperties().size(), 3); assertEquals(bar.getProperties().get("foo"), bar); assertEquals(baz.getProperties().get("foo2"), bar); assertEquals(baz.getProperties().get("foo3"), bar); }
@Test public void testRenameProperties() { TestPojo pojo = new TestPojo(); pojo.addProperty("name", "value"); pojo.addProperty("age", 10); pojo.addProperty("name2", "value2"); _manager.addPojo(pojo); _renameProperties(); assertEquals("value", pojo.get("name")); assertEquals("value2", pojo.get("age")); }
@Test public void testRenameProperties() { new MockUp<Properties>() { @Mock private Map<String, POJOPropertyBuilder> properties; @Mock private void renameProperties(Map<String, POJOPropertyBuilder> properties) { this.properties = properties; } }; new MockUp<RenameProperties>() { @Mock private void renameProperties(Map<String, POJOPropertyBuilder> properties) { this.renameProperties(properties); } }; new MockUp<RenameProperties>() { @Mock private void renameProperties(Map<String, POJOPropertyBuilder> properties) { this.properties = properties; } }; new MockUp<RenameProperties>() { @Mock private void renameProperties(Map<String, POJOPropertyBuilder> properties) { this.renameProperties(properties); } }; new MockUp<RenameProperties>() { @Mock private void renameProperties(Map<String, POJOPropertyBuilder> properties) { this.renameProperties(properties); } }; new MockUp<RenameProperties>() { @Mock private void renameProperties(Map<String, POJOPropertyBuilder> properties) { this.renameProperties(properties); } }; new MockUp<RenameProperties>() { @Mock private void renameProperties(Map<String, POJOPropertyBuilder> properties) {
@Test public void testRenameProperties() { new MockUp<POJOPropertyBuilder>() { @Mock private Map<String, POJOPropertyBuilder> properties; @Mock private String findNewName(); @Mock private String renameName(); @Mock private String renameName(); }; new MockUp<POJOPropertyBuilder>() { @Mock private Map<String, POJOPropertyBuilder> properties; public void _renameProperties() { properties = new HashMap<String, POJOPropertyBuilder>(); properties.put("foo", new POJOPropertyBuilder("bar", "baz")); } }; new MockUp<POJOPropertyBuilder>() { @Mock private Map<String, POJOPropertyBuilder> properties; public void _renameProperties() { properties = new HashMap<String, POJOPropertyBuilder>(); properties.put("foo", new POJOPropertyBuilder("bar", "baz")); } }; new MockUp<POJOPropertyBuilder>() { @Mock private Map<String, POJOPropertyBuilder> properties; public void _renameProperties() { properties = new HashMap<String, POJOPropertyBuilder>(); properties.put("foo", new POJOPropertyBuilder("bar", "baz")); } }; new MockUp<POJOPropertyBuilder>() { @Mock private Map<String, POJOPropertyBuilder> properties2;
@Test public void testRenameProperties() { [LINE] prop = new TestPojoBuilder("name", "value", "type", "string", "string", "string", "string", "string", "string", "string", "string", "string", "string", "string", "string", "string", "string", "string", "string", "string", "string", "string", "string", "string", "string", "string", "string", "string", "string", "string", "string", "string", "string", "string", "string", "string", "string", "string", "string", "string", "string", "string", "string", "string", "string", "string", "string", "string", "string", "string", "string", "string", "string", "string", "string", "string", "string", "string", "string", "string", "string", "string", "string", "string", "string", "string", "string", "string", "string", "string", "string", "string", "string", "string", "string", "string", "string", "string", "string",
@Test public void testRenameProperties() { POJOPropertyBuilder builder = new POJOPropertyBuilder("name", "value"); _properties.put("name", builder); _renameProperties(); assertEquals("name", builder.get("name")); assertEquals("value", builder.getValue()); }
@Test public void testRenameProperties() { [LINE] public void _renameProperties() { new MockUp<Object>() { @Mock private Map<String, POJOPropertyBuilder> properties = new HashMap<String, POJOPropertyBuilder>(); properties.put("foo", new POJOPropertyBuilder("bar", "baz")); return properties; } }; new MockUp<Object>() { @Mock private Map<String, POJOPropertyBuilder> properties = new HashMap<String, POJOPropertyBuilder>(); properties.put("foo", new POJOPropertyBuilder("bar", "baz")); return properties; } new MockUp<Object>() { @Mock private Map<String, POJOPropertyBuilder> properties = new HashMap<String, POJOPropertyBuilder>(); properties.put("foo", new POJOPropertyBuilder("bar", "baz")); return properties; } new MockUp<Object>() { @Mock private Map<String, POJOPropertyBuilder> properties = new HashMap<String, POJOPropertyBuilder>(); properties.put("foo", new POJOPropertyBuilder("bar", "baz")); return properties; } new MockUp<Object>() { @Mock private Map<String, POJOPropertyBuilder> properties = new HashMap<String, POJOPropertyBuilder>(); properties.put("foo", new POJOPropertyBuilder
@Test public void testRenameProperties() { new MockUp<Properties>() { @Mock public void add(Properties properties) { properties.put("name", "value"); } }; new MockUp<Properties>() { @Mock public void add(Properties properties) { properties.put("name", "value"); } }; new MockUp<RenameProperties>() { @Mock public void rename(RenamingProperties props) { properties.remove("name"); } }; new MockUp<RenameProperties>() { @Mock public void rename(RenamingProperties props) { properties.remove("name"); } }; new MockUp<RenameProperties>() { @Mock public void rename(RenamingProperties props) { properties.remove("name"); } }; new MockUp<RenameProperties>() { @Mock public void rename(RenamingProperties props) { properties.remove("name"); } }; new MockUp<RenameProperties>() { @Mock public void rename(RenamingProperties props) { properties.remove("name"); } }; new MockUp<RenameProperties>() { @Mock public void rename(RenamingProperties props) { properties.remove("name"); } }; new MockUp<RenameProperties>() { @Mock public void rename(RenamingProperties props) { properties.
@Test public void testRenameProperties() { TestPojoCreatorProperties creatorProperties = new TestPojoCreatorProperties(); creatorProperties.addProperty("name", "value"); creatorProperties.addProperty("age", "42"); creatorProperties.addProperty("name2", "value2"); TestPojoCreatorProperties props = new TestPojoCreatorProperties(); props.addProperty("name", "value"); props.addProperty("age", "42"); creatorProperties.addProperty("name2", "value2"); TestPojoCreatorProperties newProps = new TestPojoCreatorProperties(); newProps.addProperty("name", "value"); newProps.addProperty("age", "42"); creatorProperties.addProperty("name2", "value2"); props.addProperty("name2", "value2"); _creatorProperties = creatorProperties; _renameProperties(); assertEquals("value", newProps.get("name")); assertEquals("42", newProps.get("age")); assertEquals("42", newProps.get("name2")); assertEquals("42", newProps.get("age2")); }
public void testRenameUsingGetter() { PropertyNamingStrategy mockNamingStrategy = mock(PropertyNamingStrategy.class); when(mockNamingStrategy.getNameForGetterMethod(any(Config.class), any(String.class))).thenReturn("getGetterMethod"); _config.renameUsing(mockNamingStrategy); verify(mockNamingStrategy).getNameForGetterMethod(any(Config.class), any(String.class)); }
@Test public void renameWithGetter() { PropertyNamingStrategy mockNamingStrategy = mock(PropertyNamingStrategy.class); when(mockNamingStrategy.nameForGetterMethod(_config, _getter, _fieldName)).thenReturn("get"); when(mockNamingStrategy.nameForGetter(eq(_config), any(), any())).thenReturn("get"); _renameUsing(mockNamingStrategy); verify(mockNamingStrategy).nameForGetterMethod(_config, _getter, _fieldName); }
@Test public void rename_properties() { TestConfig config = new TestConfig(); config.addPropertyNamingStrategy(new PropertyNamingStrategy(NamingStrategy.DEFAULT_NAME, "foo")); TestPropertyNamingStrategy naming = new TestPropertyNamingStrategy(NamingStrategy.DEFAULT_NAME, "bar"); config.addPropertyNamingStrategy(naming); TestPropertyNamingStrategy rename = new TestPropertyNamingStrategy(NamingStrategy.DEFAULT_NAME, "foo"); config.addPropertyNamingStrategy(rename); TestPropertyNamingStrategy rename1 = new TestPropertyNamingStrategy(NamingStrategy.DEFAULT_NAME, "bar"); config.addPropertyNamingStrategy(rename1); TestPropertyNamingStrategy rename2 = new TestPropertyNamingStrategy(NamingStrategy.DEFAULT_NAME, "bar"); config.addPropertyNamingStrategy(rename2); TestPropertyNamingStrategy rename3 = new TestPropertyNamingStrategy(NamingStrategy.DEFAULT_NAME, "bar"); config.addPropertyNamingStrategy(rename3); TestPropertyNamingStrategy rename4 = new TestPropertyNamingStrategy(NamingStrategy.DEFAULT_NAME, "bar"); config.addPropertyNamingStrategy(rename4); TestPropertyNamingStrategy rename5 = new TestPropertyNamingStrategy(NamingStrategy.DEFAULT_NAME, "bar"); config.
@Test public void _property() { POJOPropertyBuilder builder = POJOPropertyBuilder.builder().property("stringProperty").forSerialization(true).property("stringProperty", "stringValue").build(); assertEquals("stringProperty", builder.property("stringProperty").value()); assertEquals("stringValue", builder.property("stringProperty").value()); }
@Test public void _property() { POJOPropertyBuilder builder = POJOPropertyBuilder.builder().implName("MyBean").property("stringProperty").build(); POJOPropertyBuilder result = builder.property("stringProperty"); assertEquals("MyBean", result.implName); assertEquals(2, result.properties.size()); }
@Test public void _property() { POJOPropertyBuilder builder = POJOPropertyBuilder.builder("foo").annotationIntrospector(AnnotationIntrospector.DEFAULT).build(); POJOPropertyBuilder result = (PojoPropertyBuilder) builder.property("foo").build(); assertEquals("foo", result.getImplName()); assertEquals(1, result.getProps().size()); assertEquals(1, result.getProps().get("foo").getAnnotations().size()); assertEquals(1, result.getProps().get("foo").getAnnotations().size()); assertEquals(1, result.getProps().get("foo").getAnnotations().size()); assertEquals(1, result.getProps().get("foo").getAnnotations().size()); assertEquals(1, result.getProps().get("foo").getAnnotations().size()); assertEquals(1, result.getProps().get("foo").getAnnotations().size()); assertEquals(1, result.getProps().get("foo").getAnnotations().size()); }
@Test public void _property() { POJOPropertyBuilder builder = POJOPropertyBuilder.class.getDeclaredMethod("property").getGenericReturnType(); POJOPropertyBuilder. POJOProperty prop = builder.property("property"); assertEquals("property", prop.implName()); assertEquals(Introspector.FIELD, prop.annotationIntrospector()); assertEquals(true, prop.forSerialization()); builder = POJOPropertyBuilder.class.getDeclaredMethod("property").getGenericReturnType(); prop = builder.property("property"); assertEquals("property", prop.implName()); assertEquals(Introspector.FIELD, prop.annotationIntrospector()); assertEquals(true, prop.forSerialization()); builder = POJOPropertyBuilder.class.getDeclaredMethod("property").getGenericReturnType(); prop = builder.property("property").getGenericReturnType(); assertEquals("property", prop.implName()); assertEquals(Introspector.FIELD, prop.annotationIntrospector()); assertEquals(true, prop.forSerialization()); }
@Test public void _property() { POJOPropertyBuilder builder = POJOPropertyBuilder.builder("test").property("string").build(); POJOPropertyBuilder result = (PojoPropertyBuilder) builder.property("string").build(); assertEquals("string", result.stringValue()); assertEquals("string", result.stringValue()); }
@Test public void test_property() { POJOPropertyBuilder builder = POJOPropertyBuilder.builder().implName("com.example.Foo").annotationIntrospector(AnnotationIntrospector.DEFAULT).forSerialization(true).build(); POJOPropertyBuilder result = builder.property("com.example.Foo"); assertEquals("com.example.Foo", result.implName); assertEquals(1, result.properties.size()); assertEquals("com.example.Foo", result.properties.get("com.example.Foo").value); }
@Test public void findNamingStrategy() { AnnotationIntrospector annotationIntrospector = Mockito.mock(AnnotationIntrospector.class); Mockito.when(annotationIntrospector.findNamingStrategy(_classDef)).thenReturn(MockNamingStrategy.class); Mockito.when(annotationIntrospector.findNamingStrategy(_annotationIntrospector)).thenReturn(MockNamingStrategy.class); PropertyNamingStrategy actual = _findNamingStrategy(); Assert.assertEquals(MockNamingStrategy.class, actual); }
Mockito.when(_config.getPropertyNamingStrategy()).thenReturn(PropertyNamingStrategy.STRING_VALUE); Mockito.when(_annotationIntrospector.findNamingStrategy(_classDef)).thenReturn(Mockito.mock(AnnotationIntrospector.class)); Mockito.when(_annotationIntrospector.findNamingStrategy(_annotationIntrospector)).thenReturn(Mockito.mock(AnnotationIntrospector.class)); Mockito.when(_annotationIntrospector.findNamingStrategy(_annotationIntrospector)).thenReturn(Mockito.mock(PropertyNamingStrategy.class)); try { new AnnotationIntrospector(null, null).findNamingStrategy(_config); fail(); } catch (IllegalStateException expected) { } Mockito.verify(annotationIntrospector, Mockito.never()).findNamingStrategy(_classDef); Mockito.verify(annotationIntrospector, Mockito.never()).findNamingStrategy(_annotationIntrospector); }
@Test public void annotationIntrospector_findNamingStrategy() { AnnotationIntrospector annotationIntrospector = Mockito.mock(AnnotationIntrospector.class); Mockito.when(annotationIntrospector.findNamingStrategy(_classDef)).thenReturn(Mockito.mock(PropertyNamingStrategy.class)); Mockito.when(annotationIntrospector.findNamingStrategy(_annotationIntrospector)).thenReturn(Mockito.mock(PropertyNamingStrategy.class)); AnnotationConfig config = new AnnotationConfig(); config.setPropertyNamingStrategy(PropertyNamingStrategy.class); AnnotationIntrospector annotationIntrospector = Mockito.mock(AnnotationIntrospector.class); Mockito.when(annotationIntrospector.findNamingStrategy(_annotationIntrospector)).thenReturn(Mockito.mock(PropertyNamingStrategy.class)); try { AnnotationIntrospector.findNamingStrategy(_config); fail(); } catch (IllegalStateException expected) { } }
Mockito.when(_config.getPropertyNamingStrategy()).thenReturn(PropertyNamingStrategy.STRING_VALUE); Mockito.when(_annotationIntrospector.findNamingStrategy(_classDef)).thenReturn(PropertyNamingStrategy.STRING_VALUE); Mockito.when(_annotationIntrospector.findNamingStrategy(_annotationIntrospector)).thenReturn(PropertyNamingStrategy.STRING_VALUE); Assert.assertEquals(PropertyNamingStrategy.STRING_VALUE, _config.getPropertyNamingStrategy()); Mockito.verify(_annotationIntrospector).findNamingStrategy(_classDef); Mockito.verifyNoMoreInteractions(_annotationIntrospector); }
@Test public void _deserializeIfNatural_null() throws IOException, JsonProcessingException { Mockito.when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NULL); Mockito.when(jp.getText()).thenReturn(null); assertEquals(null, _deserializeIfNatural(jp, null)); }
@Test public void testInjectableValues() { class TestReader extends ObjectReader { @InjectableValues(InjectableValues.class) public void writeValueTo(Object value) { } } TestReader testReader = new TestReader(ObjectMapperMapper.DEFAULT, DeserializationConfig.DEFAULT); DeserializationConfig config = DeserializationConfig.DEFAULT; ObjectReader testObjectReader = new ObjectReader(testReader, config); ObjectReader testObjectReader2 = new ObjectReader(ObjectMapperMapper.DEFAULT, config); ObjectReader testObjectReader3 = new ObjectReader(ObjectMapperMapper.DEFAULT, config); ObjectReader testObjectReader4 = new ObjectReader(ObjectMapperMapper.DEFAULT, config); ObjectReader testObjectReader5 = new ObjectReader(ObjectMapperMapper.DEFAULT, config); ObjectReader testObjectReader6 = new ObjectReader(ObjectMapperMapper.DEFAULT, config); ObjectReader testObjectReader7 = new ObjectReader(ObjectMapperMapper.DEFAULT, config); ObjectReader testObjectReader8 = new ObjectReader(ObjectMapperMapper.DEFAULT, config); ObjectReader testObjectReader9 = new ObjectReader(ObjectMapperMapper.DEFAULT, config); ObjectReader testObjectReader10 = new ObjectReader(ObjectMapperMapper.DEFAULT, config); ObjectReader testObjectReader11 = new ObjectReader(ObjectMapperMapper.DEFAULT, config); Object
@Test public void testRootDeserializer() { DeserializationConfig config = mock(DeserializationConfig.class); ObjectReader reader = new ObjectReader(mapper, config); assertThat(reader.getConfig(), is(config)); assertThat(reader.getRootDeserializer(), is(nullValue())); assertThat(reader.getRootDeserializer(), is(nullValue())); assertThat(reader.getRootNames(), is(nullValue())); assertThat(reader.getSchema(), is(nullValue())); assertThat(reader.useRootWrapping(), is(true)); assertThat(reader.getRootDeserializers(), is(nullValue())); assertThat(reader.getRootNames(), is(nullValue())); assertThat(reader.getSchema().getRootDeserializer(), is(nullValue())); assertThat(reader.getRootNames(), is(nullValue())); assertThat(reader.getSchema().getRootDeserializer(), is(nullValue())); assertThat(reader.getSchema().getRootNames(), is(nullValue())); assertThat(reader.getSchema().getRootDeserializer(), is(nullValue())); assertThat(reader.getSchema().getRootDeserializer(), is(nullValue())); assertThat(reader.getSchema().getRootDeserializer(), is(nullValue())); assertThat(reader.getSchema().getRoot
@Test public void testReaderWithContext() { class MyDeserializer extends ObjectReader { @SuppressWarnings("unchecked") private DeserializationConfig context = mock(DeserializationConfig.class); @Override public <T> T deserialize(Class<T> type, DeserializationConfig context) { return new MyDeserializer(); } } MyDeserializer rootDeserializer = new MyDeserializer(); MyDeserializer innerDeserializer = new MyDeserializer(); ObjectReader reader = new ObjectReader(reader, DeserializationConfig.DEFAULT); reader.context = context.inner(); reader.inner(); assertEquals(rootDeserializer, innerDeserializer); }
@Test public void testRootDeserializers() { ObjectReader reader = new ObjectReader(new ObjectMapper(), DeserializationConfig.DEFAULT); DeserializationConfig confi = mock(DeserializationConfig.class); when(confi.useRootWrapping()).thenReturn(true); ObjectReader deseriReader = new ObjectReader(reader, confi); verify(reader, times(1)).rootDeserializers(); verify(reader, times(1)).jsonFactory(); verify(reader, times(1)).rootNames(); verify(reader, times(1)).valueType(); verify(reader, times(1)).rootDeserializer(); verify(reader, times(1)).valueToUpdate(); verify(reader, times(1)).schema(); verify(reader, times(1)).unwrapRoot(); verify(reader, times(1)).dataFormatReaders(); verify(reader, times(1)).dataFormatReaders(); verify(reader, times(1)).dataFormatReaders(any(JsonFactory.class)); verify(reader, times(1)).jsonFactory(); verify(reader, times(1)).rootNames(); verify(reader, times(1)).valueType(); verify(reader, times(1)).rootDeserializer(); verify(reader, times(1)).valueToUpdate(); verify(reader, times(1)).schema();
@Test public void testJsonFactory() { JsonFactory factory = new JsonFactory(); ObjectReader reader = new ObjectReader(factory, DeserializationConfig.DEFAULT); JsonFactory jsonFactory = factory.getJsonFactory(); assertThat(reader, instanceOf(JsonFactory.class)); assertThat(reader.jsonFactory, instanceOf(factory)); }
@Test public void testRootNames() { SerializationConfig config = new SerializationConfig(); ObjectReader reader = new ObjectReader(mapper, config); reader.rootNames = "foo"; verify(reader, times(1)).rootNames(); }
@Test public void testValueType() { class MyDeserializer extends ObjectReader { @SuppressWarnings("unchecked") private DeserializationConfig config; @Override public DeserializationConfig getContext() { return this.config; } @Override public List<Deserializer<?>> getRootDeserializers() { return ImmutableList.of(new MyDeserializer()); } @Override public JsonFactory jsonFactory() { return new JsonFactory(); } @Override public ObjectReader deserialize(ObjectMapper mapper, DeserializationConfig config) throws IOException { return new MyReader(mapper, config); } @Override public ObjectReader deserialize(ObjectMapper mapper, DeserializationConfig config) throws IOException { return new MyReader(mapper, config); } @Override public List<Deserializer<?>> getRootDeserializers() { return ImmutableList.of(new MyDeserializer()); } @Override public JsonFactory jsonFactory() { return new JsonFactory(); } @Override public ObjectReader deserialize(ObjectMapper mapper, DeserializationConfig config) throws IOException { return new MyReader(mapper, config); } @Override public List<Deserializer<?>> getRootDeserializers() { return ImmutableList.of(new MyDeserializer()); } @Override public ObjectReader deserialize(ObjectMapper mapper, DeserializationConfig config) throws IOException { return new MyReader(mapper, config);
@Test public void testRootDeserializer() { DeserializationConfig config = new DeserializationConfig() { @Override public boolean useRootWrapping() { return true; } }; ObjectReader reader = new ObjectReader(mapper, config); assertThat(reader.getRootDeserializer(), instanceOf(RootDeserializer.class)); assertThat(reader.getRootDeserializer(), instanceOf(RootDeserializer.class)); assertThat(reader.getRootDeserializers(), instanceOf(RootDeserializers.class)); assertThat(reader.getObjectMapper(), instanceOf(ObjectMapper.class)); assertThat(reader.getObjectMapper(), instanceOf(ObjectMapper.class)); assertThat(reader.getObjectMapper(), instanceOf(ObjectMapper.class)); assertThat(reader.getObjectMapper(), instanceOf(ObjectMapper.class)); assertThat(reader.getObjectMapper(), instanceOf(ObjectMapper.class)); assertThat(reader.getObjectMapper(), instanceOf(ObjectMapper.class)); assertThat(reader.getObjectMapper(), instanceOf(ObjectMapper.class)); assertThat(reader.getObjectMapper(), instanceOf(ObjectMapper.class)); assertThat(reader.getObjectMapper(), instanceOf(ObjectMapper.class)); assertThat(reader.getObjectMapper(), instanceOf(ObjectMapper.class)); assertThat(reader.getObjectMapper(), instanceOf(ObjectMapper.class)); assertThat(reader.getObjectMapper(), instanceOf(ObjectMapper.class)); assertThat(reader
@Test public void deserializeWithInjectableValues() { DeserializationConfig config = new DeserializationConfig() { @Override public boolean useRootWrapping() { return true; } @Override public List<Deserializer<?>> getRootDeserializerializers() { return ImmutableList.of(deserializeRootDeserializer(JavaType.INT)); } @Override public FormatSchema schema() { return new JsonSchema(); } @Override public InjectableValues injectableValues() { return new InjectableValues(); } }; ObjectReader reader = new ObjectReader(mapper, DeserializationConfig.DEFAULT); Object value = new Object(); Object valueToUpdate = new Object(); ObjectReader deserializedReader = new ObjectReader(reader, config, JavaType.INT, valueToUpdate, JsonFactory.JSON_FACTORY, injectableValues); Assert.assertEquals(value, deserializedReader.deserialize(valueToUpdate)); Assert.assertEquals(valueToUpdate, deserializedReader.deserialize(valueToUpdate)); }
@Test public void testSchema() { class MyDeserializer extends JsonDeserializer<MyEnum> { @JsonSchema(schema = Schema.STRING_SCHEMA) public JsonSchema schema() { return new JsonSchema(); } } MyReader reader = new MyReader(ObjectMapperBuilder.build().reader(), DeserializationConfig.DEFAULT); Assert.assertEquals(reader.schema(), JsonSchema.STRING_SCHEMA); Assert.assertEquals(reader.valueType(), MyEnum.class); Assert.assertEquals(reader.rootDeserializer(), JsonSchema.STRING_DESERIALIZER); Assert.assertEquals(reader.valueToUpdate, MyEnum.class); }
@Test public void testInjectableValues() { InjectableValues injectableValues = new InjectableValues() { @Override public void add(ObjectReader reader) { super.add(reader); } }; ObjectReader reader = new ObjectReader(ObjectMapperBuilder.build().mapper("json.factory").build(), DeserializationConfig.DEFAULT, JavaType.INT, null, FormatSchema.EMPTY, injectableValues); assertEquals(JavaType.INT, reader.get(_type).valueType()); assertEquals(JavaType.INT, reader.get(_valueToUpdate).valueType()); assertEquals(JsonSchema.EMPTY, reader.get(_schema).schema()); assertEquals(InjectableValues.EMPTY, reader.get(_injectableValues).injectableValues); }
@Test public void testRootDeserializer() { JsonFactory jsonFactory = new JsonFactory(); ObjectReader reader = new ObjectReader(jsonFactory, DeserializationConfig.JSON_FACTORY); DeserializationConfig config = new DefaultDeserializationConfig(ObjectMapperBuilder.DEFAULT); ObjectReader wrappedReader = new ObjectReader(reader, config); assertThat(wrappedReader.unwrapRoot(), is(true)); assertThat(wrappedReader.getRootDeserializers(), hasSize(2)); assertThat(wrappedReader.getRootNames(), hasSize(2)); assertThat(wrappedReader.getRootDeserializer(), instanceOf(RootDeserializer.class)); assertThat(wrappedReader.getRootDeserializer().deserialize(Json.class), instanceOf(RootDeserializer.class)); assertThat(wrappedReader.getSchema(), instanceOf(Json.class)); }
@Test public void testSerializationConfig() { SerializationConfig config = new SerializationConfig(); ObjectReader reader = new ObjectReader(ObjectMapperMapper.DEFAULT, config); reader.dataFormatReaders = new ObjectReader(reader, config); verify(reader, times(1)).dataFormatReaders(any()); }
@Test public void testWithHandler() { final ObjectReader baseReader = new ObjectReader(mapper, DeserializationConfig.EMPTY); final DeserializationProblemHandler handler = mock(DeserializationProblemHandler.class); final ObjectReader newReader = baseReader.withHandler(handler); newReader.withHandler(handler); verify(config).withHandler(handler); verify(mapper).withMapping(eq(Foo.class.getName()), eq(Foo.class.getName())); verify(mapper).withMapping(eq(Bar.class.getName()), eq(Bar.class.getName())); }
@Test public void testWithHandler() { final List<DeserializationProblemHandler> handlers = new ArrayList<DeserializationProblemHandler>() {{ add(new MyDeserializationProblemHandler()); }}; ObjectReader r = new ObjectReader(mapper, DeserializationConfig.DEFAULT).withHandler(new MyDeserializationProblemHandler()).with(new MyDeserializationProblemHandler()).with(new MyDeserializationProblemHandler()); assertEquals(r, new ObjectReader(mapper, DeserializationConfig.DEFAULT).withHandler(new MyDeserializationProblemHandler()).with(new MyDeserializationProblemHandler()).with(new MyDeserializationProblemHandler()).with(new MyDeserializationProblemHandler()).with(new MyDeserializationProblemHandler()).with(new MyDeserializationProblemHandler()).with(new MyDeserializationProblemHandler()).with(new MyDeserializationProblemHandler()).with(new MyDeserializationProblemHandler()).with(new MyDeserializationProblemHandler()).with(new MyDeserializationProblemHandler()).with(new MyDeserializationProblemHandler()).with(new MyDeserializationProblemHandler()).with(new MyDeserializationProblemHandler()).with(new MyDeserializationProblemHandler()).with(
@Test public void readValue_with_default_reader_does_not_report_unhandled_exception() throws IOException, JsonProcessingException { final JsonFactory f = mock(JsonFactory.class); final ObjectReader r = new ObjectReader(f, null); try { r.readValue(new StringReader("foo")); fail("Expected exception to be thrown"); } catch (JsonProcessingException e) { } }
@Test public void readValueWithCustomFormat() throws IOException, JsonProcessingException { String input = "{\"foo\": \"bar\"}"; JsonFactory factory = mock(JsonFactory.class); when(factory.createParser(any(Reader.class))).thenReturn(mock(Parser.class)); ObjectReader reader = new ObjectReader(factory, null); reader.readValue(new StringReader(input)); verify(factory).createParser(any(Reader.class)); verify(reader).readValue(any(Reader.class)); }
@Test public void testDeserializeEnumWithReader() throws IOException, JsonProcessingException { final String expected = "EnumValue"; final JsonFactory jsonFactory = mock(JsonFactory.class); final ObjectReader reader = new ObjectReader(jsonFactory, null, null, null, null, null); final DeserializationConfig config = mock(DeserializationConfig.class); final Object readValue = reader.readValue(new StringReader(expected)); assertEquals(expected, readValue); verify(config, times(1)).getDeserializer(eq(expected), eq(null)); verify(mapper, times(1)).readValue(eq(expected)); verify(mapper, times(1)).readValue(eq(expected)); verify(mapper, times(1)).readValue(eq(expected)); verify(mapper, times(1)).readValue(eq(expected)); }
@Test public void bindAndClose_schemaIsNull() throws IOException, JsonParseException, JsonMappingException { new Expectations() { { jp.setSchema(null); } }; try { new MockedJsonMapper().bindAndClose(jp, null); fail("Expected JsonParseException"); } catch (JsonParseException e) { } }
@Test public void bindAndClose_deserialize_withSchema() throws IOException, JsonMappingException { final JsonParser jp = mock(JsonParser.class); final DeserializationContext ctxt = mock(DeserializationContext.class); final JsonDeser deser = mock(JsonDeser.class); when(jp.getSchema()).thenReturn(null); when(decer.deserialize(jp, ctxt, null)).thenReturn(null); Object result = deser.deserialize(jp, ctxt, null); verify(jp).setSchema(null); verify(decer).setSchema(null); verify(jp).end(); }
@Test public void bindAndClose_nullValue() throws IOException, JsonParseException, JsonMappingException { JsonParser jp = mock(JsonParser.class); when(jp.getSchema()).thenReturn(null); Object result = _bindAndClose(jp, null); assertEquals(null, result); }
@Test public void testWith() { ObjectReader reader = new ObjectReader(mapper, null, null, null, null, null); DeserializationConfig newConfig = mock(DeserializationConfig.class); reader._with(config); verify(reader, times(1)).with(config); verify(reader, times(1)).withFormatDetection(null); verify(reader, times(1)).with(newConfig); }
@Test public void test_with_null() { DeserializationConfig config = mock(DeserializationConfig.class); ObjectReader reader = new ObjectReader(null, config); assertWithMessage("null", reader).that(reader).isInstanceOf(ObjectReader.class); }
@Test public void test_with_null() { ObjectReader reader = new ObjectReader(null, null); try { reader.with(null); fail(); } catch (IllegalArgumentException expected) { } }
@Test public void testDeserializeWithCustomDeserializer() { JsonDeserializer<Object> mockRootDeser = mock(JsonDeserializer.class); JsonDeserializer<Object> mockDeserializer = mock(JsonDeserializer.class); ObjectReader reader = new ObjectReader(mockRootDeser, mockDeserializationConfig); DeserializationConfig mockConfig = mock(DeserializationConfig.class); ObjectReader reader2 = new ObjectReader(reader, mockConfig); verify(mockRootDeser, times(1)).deserialize(any(Class.class), any(Object.class)); verify(mockDeserializer, times(1)).deserialize(any(Class.class), any(Object.class)); verify(mockConfig, times(1)).withFormatDetection(any(Class.class)); verify(mockReader, times(1)).withFormatDetection(any(Class.class)); verify(mockReader2, times(1)).withFormatDetection(any(Class.class)); }
@Test public void testContainTypeCount() { assertEquals(1,.lang.String.getContainTypeCount()); }
@Test public void testContainmentTypeCount() { assertEquals(1, list.containmentTypeCount()); }
@Test public void testBuildCanonicalName() { assertEquals("collection", new CollectionLikeType(Collection.class, null, null, null, false).buildCanonicalName()); assertEquals("collection<>", new CollectionLikeType(Collection.class, null, null, null, false).buildCanonicalName()); assertEquals("collection<>", new CollectionLikeType(Collection.class, null, null, null, false).buildCanonicalName()); assertEquals("collection<null>", new CollectionLikeType(Collection.class, null, null, null, false).buildCanonicalName()); assertEquals("collection<null>", new CollectionLikeType(Collection.class, null, null, null, false).buildCanonicalName()); assertEquals("collection<null>", new CollectionLikeType(Collection.class, null, null, null, false).buildCanonicalName()); assertEquals("collection<null>", new CollectionLikeType(Collection.class, null, null, null, false).buildCanonicalName()); assertEquals("collection<null>", new CollectionLikeType(Collection.class, null, null, null, false).buildCanonicalName()); assertEquals("collection<null>", new CollectionLikeType(Collection.class, null, null, null, false).buildCanonicalName()); assertEquals("collection<null>",
@Test public void testBuildCanonicalName() { String s = new StringBuilder().append(_String.class.getName()).append('>'); [EOL] assertEquals(s, new StringBuilder().toString()); }
@Test public void testBuildCanonicalName() { String actual = new CollectionLikeType(String.class, null, null, null, false).buildCanonicalName(); assertEquals("Collection<String>", actual); actual = new CollectionLikeType(String.class, null, null, null, false).buildCanonicalName(); assertEquals("Collection<null>", actual); actual = new CollectionLikeType(String.class, null, null, null, false).buildCanonicalName(); assertEquals("Collection<null>", actual); actual = new CollectionLikeType(String.class, null, null, null, false).buildCanonicalName(); assertEquals("Collection<null>", actual); actual = new CollectionLikeType(String.class, null, null, null, false).buildCanonicalName(); assertEquals("Collection<null>", actual); actual = new CollectionLikeType(String.class, null, null, null, false).buildCanonicalName(); assertEquals("Collection<null>", actual); actual = new CollectionLikeType(String.class, null, null, null, false).buildCanonicalName(); assertEquals("Collection<null>", actual); }
@Test public void testBuildCanonicalName() { CollectionLikeType type = CollectionLikeType.construct(String.class, null, null, false); assertEquals("collection<>", type.buildCanonicalName()); }
@Test public void testBuildCanonicalName() { String s = new StringBuilder().append('<').append('>'); assertEquals(s, CollectionLikeType._narrow(String.class).buildCanonicalName()); }
@Test public void testBuildCanonicalName() { String s = new StringBuilder().append(_collectionType.getCanonical()).append(">"); assertEquals(s, CollectionLikeType._narrow(String.class).buildCanonicalName()); }
@Test public void testBuildCanonicalName() { assertEquals("collection<foo>>"); assertEquals("collection<foo>", CollectionLikeType._narrow(String.class).buildCanonicalName()); assertEquals("collection<foo>>"); assertEquals("collection<foo>>"); assertEquals("collection<foo>>(); assertEquals("collection<foo>>(); assertEquals("collection<foo>>(); assertEquals("collection<foo>>(); assertEquals("collection<foo>>(); assertEquals("collection<foo>>(); assertEquals("collection<foo>>(); assertEquals("collection<foo>>(); assertEquals("collection<foo>; assertEquals("collection<foo>; assertEquals("collection<foo>; assertEquals("collection<foo>; assertEquals("collection<foo>; assertEquals("collection<foo>; assertEquals("collection<foo>; assertEquals("collection<foo>; assertEquals("collection<foo>; assertEquals("collection<foo>; assertEquals("collection<foo>; assertEquals("collection<foo>; assertEquals("collection<foo>; assertEquals("collection<foo>; assertEquals("collection<foo>; assertEquals("collection<foo>; assertEquals("collection<foo>; assertEquals("collection<foo>; assertEquals("collection<foo>; assertEquals("collection<foo>; assertEquals("collection<foo>; assertEquals("collection<foo>; assertEquals("collection<foo>; assertEquals("collection<foo>; assertEquals("collection
@Test public void testBuildCanonicalName() { assertEquals("collection", CollectionLikeType._narrow(String.class).buildCanonicalName()); assertEquals("collection<a>", CollectionLikeType._narrow(String.class).buildCanonicalName()); assertEquals("collection<a>", CollectionLikeType._narrow(String.class).buildCanonicalName()); }
@Test public void serialize() throws IOException { String type = String.class.getName(); TypeSerializerProvider provider = new TypeSerializerProvider() { @Override public TypeSerializer<String> getSerializer(Class type) { return new SimpleSerializer(); } }; String result = new String(type); new TypeTester().test(result).serialize(); }
@Test public void serialize_type_in_correct_order() throws IOException { TypeSerializerProvider provider = new TypeSerializerProvider() { @Override public void serialize(JsonGenerator jgen, SerializerProvider provider) throws IOException { } }; String result = _typeSignature(provider).toCanonical(); jgen.flush(); assertThat(result).isEqualTo(".util.List<.lang.String>"); }
@Test public void testSerializationConfig() { final ObjectWriter writer = new ObjectWriter(mapper, _serializationConfig); final SerializationConfig config = new SerializationConfig(SerializationConfig.DEFAULT); config.with(TimeZone.getTimeZone("GMT")); writer.with(TimeZone.getTimeZone("GMT+1")); try { writer.with(TimeZone.getTimeZone("GMT+2")); fail("Expected IllegalStateException"); } catch (IllegalStateException e) { } try { writer.with(TimeZone.getTimeZone("GMT-300")); fail("Expected IllegalStateException"); } catch (IllegalStateException e) { } try { writer.with(TimeZone.getTimeZone("GMT-300")); fail("Expected IllegalStateException"); } catch (IllegalStateException e) { } }
@Test public void testSerializationConfigWithTimeZone() { ObjectWriter writer = new ObjectWriter(mapper, _serializationConfig); SerializationConfig config = _mapper.getSerializationConfig(); config.with(TimeZone.getTimeZone("UTC")); SerializationConfig newConfig = config.with(TimeZone.getTimeZone("UTC")); assertEquals(newConfig, writer); }
@Test public void testSerializationConfig() { final ObjectWriter writer = new ObjectWriter(mapper, SerializationConfig.DEFAULT); SerializationConfig config = new SerializationConfig(SerializationConfig.DEFAULT); writer.with(TimeZone.getTimeZone("GMT-04:00")); SerializationConfig newConfig = new SerializationConfig(SerializationConfig.DEFAULT); newConfig.with(TimeZone.getTimeZone("GMT-04:00")); SerializationConfig newConfig2 = new SerializationConfig(SerializationConfig.DEFAULT); newConfig2.with(TimeZone.getTimeZone("GMT-04:00")); SerializationConfig newConfig3 = new SerializationConfig(SerializationConfig.DEFAULT); newConfig3.with(TimeZone.getTimeZone("GMT-04:00")); SerializationConfig newConfig4 = new SerializationConfig(SerializationConfig.DEFAULT); newConfig4.with(TimeZone.getTimeZone("GMT-04:00")); SerializationConfig newConfig5.with(TimeZone.getTimeZone("GMT-04:00")); SerializationConfig newConfig6.with(TimeZone.getTimeZone("GMT-04:00")); SerializationConfig new7.with(TimeZone.getTimeZone("GMT-04:00")); SerializationConfig new8 = new SerializationConfig(SerializationConfig.DEFAULT); newWriter.with(SerializationFeature.WRAPPER); newWriter.with(SerializationFeature.WRAPPER); newWriter.with(Serialization
@Test public void writeValueAsString() throws Exception { Assert.assertEquals("foo", _writer.writeValueAsString(new Integer(0))); Assert.assertEquals("foo", _writer.writeValueAsString(new Double(0))); Assert.assertEquals("bar", _writer.writeValueAsString(new Double(42))); }
@Test public void writeValueAsBytes() throws JsonProcessingException { ObjectWriter writer = new ObjectWriter(null, null, null); writer.writeValueAsBytes(new Object()); }
@Test public void writeValueAsBytes() throws JsonProcessingException { _thrown.expect(JsonMappingException.class); _thrown.expectMessage("Unexpected IOE"); _objectWriter.writeValueAsBytes(new Object()); }
@Test public void testWriteValueAsBytes() throws IOException { ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectWriter writer = new ObjectWriter(baos); writer.writeValueAsBytes(new Object()); baos.close(); }
@Test public void writeValueAsBytes() throws IOException { ByteArrayOutputStream baos = new ByteArrayOutputStream(); JsonFactory factory = new JsonFactory(); ObjectWriter writer = factory.createObjectWriter(baos); writer.writeObject(new Object()); writer.writeObject(new Object()); writer.writeObject(new Object()); writer.writeObject(new Object()); writer.writeObject(new Object()); writer.writeObject(new Object()); }
@Test public void writeValueAsBytes() throws JsonProcessingException { byte[] bytes = new byte[20]; new Random().nextBytes(bytes); new Random().nextBytes(bytes); new Random().nextBytes(bytes); new Random().nextBytes(bytes); new Random().nextBytes(bytes); new Random().nextBytes(bytes); new Random().nextBytes(bytes); new Random().nextBytes(bytes); new Random().nextBytes(bytes); new Random().nextBytes(bytes); new Random().nextBytes(bytes); new Random().nextBytes(bytes); new Random().nextBytes(bytes); new Random().nextBytes(bytes); new Random().nextBytes(bytes); new Random().nextBytes(bytes); new Random().nextBytes(bytes); new Random().nextBytes(bytes); new Random().nextBytes(bytes); new Random().nextBytes(bytes); new Random().nextBytes(bytes); }
@Test public void testWriteValueAsBytes() throws JsonProcessingException { final ByteArrayOutputStream bb = new ByteArrayOutputStream(); new ObjectWriter(new JsonFactory(), null).writeValueAsBytes(new Object()); new ObjectWriter(new JsonFactory(), null).writeValueAsBytes(new Object()); new ObjectWriter(new JsonFactory(), null).writeValueAsBytes(new Object()); }
@Test public void testWriteValueAsBytes() throws JsonProcessingException { byte[] bytes = new byte[100]; new Random().nextBytes(bytes); new Random().nextBytes(bytes); new Random().nextBytes(bytes); new Random().nextBytes(bytes); new Random().nextBytes(bytes); new Random().nextBytes(bytes); byte[] actual = _writer.writeValueAsBytes(new Object()); assertArrayEquals(bytes, actual); }
@Test public void testConfigAndWriteValue() throws IOException, JsonGenerationException, JsonMappingException { TestConfig config = new TestConfig(); config.setEnabled(SerializationFeature.CLOSE_CLOSE_CLOSEABLE, false); config.setEnabled(SerializationFeature.CLOSE_CLOSE_CLOSE_CLOSEABLE, true); TestCloseable inner = new TestCloseable(); StringWriter writer = new StringWriter(); new ObjectWriter(writer)._configAndWriteValue(jgen, inner); assertEquals(inner, writer.toString()); }
@Test public void _configAndWriteValue_readFromCloseable() throws IOException, JsonMappingException { when(_config.isEnabled(SerializationFeature.CLOSE_CLOSE_CLOSEABLE)).thenReturn(true); _inner.close(); _configAndWriteValue(_jgen, null); verify(_jgen).close(); }
@Test public void testFindValue() { assertEquals(null, nc.findValue("foo")); assertEquals(null, nc.findValue("bar")); assertEquals(null, nc.findValue("baz")); assertEquals(null, nc.findValue("foo")); assertEquals(null, nc.findValue("bar.bar.baz")); assertEquals(null, nc.findValue("bar.bar.baz.bar")); assertEquals(null, nc.findValue("bar.bar.baz.bar")); assertEquals(null, nc.findValue("bar.bar.baz.bar")); assertEquals(null, nc.findValue("bar.bar.baz.bar.bar")); assertEquals(null, nc.findValue("bar.bar.baz.bar.bar.baz")); assertEquals(null, nc.findValue("bar.bar.baz.bar.bar.baz.bar")); }
@Test public void testFindParent() { ObjectNode parent = new ObjectNode(JsonNodeFactory.instance); parent.set("foo", "bar"); parent.set("baz", "qux"); Assert.assertEquals(null, parent.findParent("foo")); Assert.assertEquals(null, parent.findParent("baz")); Assert.assertEquals(null, parent.findParent("qux")); Assert.assertEquals(null, parent.findParent("baz")); Assert.assertEquals(null, parent.findParent("qux")); Assert.assertEquals(null, parent.findParent("qux")); Assert.assertEquals(null, parent.findParent("qux")); Assert.assertEquals(null, parent.findParent("qux")); Assert.assertEquals(null, parent.findParent("qux")); Assert.assertEquals(null, parent.findParent("qux")); Assert.assertEquals(null, parent.findParent("qux")); Assert.assertEquals(null, parent.findParent("qux")); Assert.assertEquals(null, parent.findParent("qux")); Assert.assertEquals(null, parent.findParent("qux")); Assert.assertEquals(null, parent.
@Test public void testDeserializationByMap() throws Exception { Class<?> type = conv.getInputType(typeFactory); expect(ctxt.getConfig()).andReturn(config).anyTimes(); expect(ctxt.getDeserializer(type)).andReturn(null); expect(ctxt.getDeserializer(type)).andReturn(new JsonDeserializer<Object>() { @Override public Object read(JsonMappingContext ctx, Class<?> type) throws JsonMappingException { return null; } }); expect(ctxt.getDeserializer(type)).andReturn(new JsonDeserializer<Object>() { @Override public Object read(JsonMappingContext ctx, Class<?> type) throws JsonMappingException { return null; } }); expect(ctxt.getConfig()).andReturn(config).anyTimes(); expect(config.introspect(type)).andReturn(beanDesc); expect(beanDesc.fi(type)).andReturn(beanDesc); expect(beanDesc.introspect(beanDesc.fi(String.class)).andReturn(beanDesc); expect(beanDesc.introspect(beanDesc.fi(Object.class)).andReturn(beanDesc)); expect(beanDesc.introspect(beanDesc.fi(Object.class)).andReturn(bean
@Test public void testDeser() throws Exception { JsonDeserializer<Object> deser = _deser.deserialize(new StringReader("{\"foo\":\"bar\"}")); assertThat(deser, is(notNullValue())); assertThat(deser.deser(Foo.class), is(notNullValue())); }
@Test public void testTree() throws Exception { MockDeserializerFactory factory = new MockDeserializerFactory(); MockDeserializer deserializer = factory.createTreeDeserializer(ctxt, type, beanDesc); assertThat(deserializer.getClass(), is(Tree.class)); assertThat(deserializer.getOrder(), is(0)); }
@Test public void testModifyTypeByAnnotation() throws JsonMappingException { Annotated a = Annotated.builder().method(Annotated.class.getMethod("method")).build(); try { JavaType type = modifyTypeByAnnotation(new JsonDeserializationContext(), a, JavaType.of(JavaType.of(String.class))); Assert.assertEquals(JavaType.of(String.class), type); } catch (JsonMappingException e) { Assert.fail(); } }
@Test public void testNarrowBy() { Annotated a = Annotated.of(String.class, String.class, String.class); Class<?> c = new Class<?>[] {String.class, String.class}; new Expectations() { { a.narrowContentsBy(cc); result = c; } }; }
@Test public void testModifyTypeByAnnotation() throws JsonMappingException { Annotated<?> a = Annotated.class.getDeclaredMethod("modifyTypeByAnnotation", Object.class, Object.class); Mockito.when(context.getAnnotationIntrospector()).thenReturn(Introspector.NO_ANNOTATION); Mockito.when(context.getDeserializationKeyType(a, Object.class)).thenReturn(null); Mockito.when(context.getDeserializationSecretType(a, Object.class)).thenReturn(null); try { JsonDeserializer<?> cd = null; JsonDeserializer<?> cd2 = null; cd = modifyTypeByAnnotation(context, a, JavaType.of(Object.class)); Assert.fail(); } catch (JsonMappingException e) { Assert.assertTrue(e.getMessage().contains("Illeg to method modifyTypeByAnnotation")); } Mockito.verify(context, Mockito.times(1)).getAnnotationIntrospector(); Mockito.verify(context, Mockito.times(1)).findDeserializationKeyType(a, Object.class); Mockito.verify(context, Mockito.times(1)).getDeserializationSecretType(a, Object.class); Mockito.verify(context, Mockito.times(1)).getDeserializationSecretType
@Test public void testDeserializationWithMapLikeType() { JsonDeserializer<MapLikeType> d = new JsonDeserializer<MapLikeType>() { @Override public MapLikeType mapLikeType() { return new MapLikeType(); } }; d.setMapper(new TestMapper()); d.setDeserialize(new MapLikeType()); try { d.init(); fail(); } catch (JsonMappingException e) { assertTrue(e.getMessage().contains("Failed to narrow type MapLikeType with concrete-type annotation (value MapLikeType), method'mapLikeType':")); } }
@Test public void test_findContentDeserializer_none() { class ContentDeserializer implements Annotated { public void findContentDeserializer(Class<?> cdDef) { } } Class<?> cdClass = _verifyAsClass(_def, "findContentDeserializer", JsonDeserializer.None.class); assertThat(cdClass).isEqualTo(ContentDeserializer.class); }
@Test public void testModifyTypeByAnnotation() throws JsonMappingException { Annotated type = AnnotatedType.class.getMethod("methodWithMap", Map.class); Assert.assertEquals(Map.class, type.getDeclaringClass()); Assert.assertEquals(Map.class, type.getDeclaringMethodReturnType()); Assert.assertEquals(Map.class, type.getDeclaringClass()); Assert.assertEquals(Map.class, type.getDeclaringClass()); Assert.assertEquals(Map.class, type.getDeclaringClass()); Assert.assertEquals(Map.class, type.getDeclaringClass()); Assert.assertEquals(Map.class, type.getDeclaringClass()); Assert.assertEquals(Map.class, type.getDeclaringClass()); }
@Test public void testDeserializationContextDeserializationContextWithMapWithMapWithKey() throws JsonMappingException { @SuppressWarnings("unchecked") Annotated<String, String> Annotated a = mock(Annotated.class); when(a.isContainerType()).thenReturn(true); when(a.getKeyType()).thenReturn(String.class); when(a.getKeyType()).thenReturn(String.class); when(context.deserializerInstance(a, JavaType.class)).thenReturn(Map.class); try { modifyTypeByAnnotation(context, a, JavaType.class); fail(); } catch (JsonMappingException expected) { } }
@Test public void testModifyTypeByAnnotation() throws JsonMappingException { Annotated type = AnnotatedType.class.getMethod("methodWithMap", Map.class); Assert.assertEquals(type, modifyTypeByAnnotation(new DeserializationContext(), type, Map.class)); Assert.assertEquals(type, modifyTypeByAnnotation(new DeserializationContext(), type, JavaType.class)); Assert.assertEquals(type, modifyTypeByAnnotation(new DeserializationContext(), type, JavaType.class)); Assert.assertEquals(type, modifyTypeByAnnotation(new DeserializationContext(), type, JavaType.class)); Assert.assertEquals(type, modifyTypeByAnnotation(new DeserializationContext(), type, JavaType.class)); Assert.assertEquals(type, modifyTypeByAnnotation(new DeserializationContext(), type, JavaType.class)); Assert.assertEquals(type, modifyTypeByAnnotation(new DeserializationContext(), type, JavaType.class)); Assert.assertEquals(type, modifyTypeByAnnotation(new DeserializationContext(), type, JavaType.class)); Assert.assertEquals(type, modifyTypeByAnnotation(new DeserializationContext(), type, JavaType.class)); Assert.assertEquals(type
@Test public void testTypeWithContentValueHandler() throws JsonMappingException { Annotated a = Annotated.class.getDeclaredMethod("methodWithContentValueHandler", String.class, String.class); Annotated b = Annotated.class.getDeclaredMethod("methodWithContentValueHandler", String.class, String.class); expect(cd.withContentValueHandler(a)).andReturn(b); expect(b.withContentValueHandler(cd)).andReturn(null); replay(ab, c); JavaType type = modifyTypeByAnnotation(cd, a, JavaType.of(String.class, String.class)); verify(ab, c); }
@Test public void testVerifyAsClass() { Class<?> val = _verifyAsClass(new Object(), "foo", NoClass.class); assertEquals(val, NoClass.class); val = _verifyAsClass(new Object(), "foo", NoClass.class); assertEquals(val, NoClass.class); val = _verifyAsClass(new Object(), "foo", NoClass.class); assertEquals(val, NoClass.class); }
@Test public void verifyAsClass() { Class<?> noneClass = NoClass.class; Class<?> sourceClass = null; Class<?> result = _verifyAsClass(sourceClass, "method", noneClass); assertEquals(sourceClass, result); }
@Test public void testVerifyAsClass() { Class<?> src = NoClass.class; Class<?> noneClass = NoClass.class; try { Class<?> result = _verifyAsClass(src, "method", noneClass); } catch (IllegalStateException e) { assertTrue(e.getMessage().contains("AnnotationIntrospector.method(")); } }
@Test public void testVerifyAsClass() { Class<?> cls = (Class<?>) null; try { Class<?> result = _verifyAsClass(null, "method", NoClass.class); fail(); } catch (IllegalStateException expected) { } try { Class<?> result = _verifyAsClass(new Object(), "method", NoClass.class); fail(); } catch (IllegalStateException expected) { } try { Class<?> result = _verifyAsClass(new Object(), "method", NoClass.class); fail(); } catch (IllegalStateException expected) { } try { Class<?> result = _verifyAsClass(new Object(), "method", NoClass.class); fail(); } catch (IllegalStateException expected) { } Class<?> result = _verifyAsClass(new Object(), "method", NoClass.class); assertEquals(result, result); }
@Test public void verifyAsClass_whenNoClass() { Class<?> src = NoClass.class; Class<?> noneClass = null; Class<?> result = _verifyAsClass(src, "method", noneClass); assertEquals(result, noneClass); }
@Test public void testVerifyAsClass() { Class<?> src = NoClass.class; Class<?> none = NoClass.class; Class<?> result = _verifyAsClass(src, "method", none); assertEquals(result, src); }
@Test public void testIterator() { JsonParser jp = mock(JsonParser.class); JsonDeserializer<String> deser = mock(JsonDeserializer.class); when(deser.deserialize(any(JsonEntity.class))).thenReturn(mock(JsonEntity.class)); MappingIterator<String, String> it = new MappingIterator<String, String>(String.class, jp, null, deser, false, null); assertEquals(null, it.next()); assertEquals(null, it.next()); assertEquals(null, it.next()); assertEquals(null, it.next()); assertEquals(null, it.next()); assertEquals(null, it.next()); assertEquals(null, it.next()); assertEquals(null, it.next()); assertEquals(null, it.next()); assertEquals(null, it.next()); assertEquals(null, it.next()); assertFalse(jp.isClosed()); }
@Test public void testIterator() { JsonParser jp = mock(JsonParser.class); JsonDeserializer<String> deser = mock(JsonDeserializer.class); when(deser.deserialize(any(Json.class), any(Class.class), any(Object.class))).thenReturn(new String[]{"one", "two", "three"}); MappingIterator<String, String> it = new MappingIterator<String, String>(JavaType.STRING, jp, null, deser, false, "one"); assertEquals("one", it.next()); assertEquals("two", it.next()); assertEquals("three", it.next()); assertEquals("three", it.next()); assertFalse(jp.isClosed()); }
@Test public void testIterator() { JsonParser jp = mock(JsonParser.class); JsonDeserializer<String> deser = mock(JsonDeserializer.class); when(deserializer.deserialize(any(JsonEntity.class))).thenReturn(new StringEntity("value")); MappingIterator<String, String> it = new MappingIterator<String, String>(String.class, jp, null, deser, false, "value"); assertEquals("value", it.next()); assertEquals("value", it.next()); assertEquals("value", it.next()); assertFalse(jp.isClosed()); assertNull(it.next()); assertFalse(jp.isClosed()); }
@Test public void testIterator() { JsonParser jp = mock(JsonParser.class); DeserializationContext context = mock(DeserializationContext.class); JsonDeserializer<String> deser = mock(JsonDeserializer.class); when(jp.getCurrentToken()).thenReturn(JsonToken.START_ARRAY); when(deserializer.deserialize(any(Class.class), any(Class.class), any(Object.class), anyBoolean())).thenReturn(new Integer(1), new Integer(2)); MappingIterator<String, String> it = new MappingIterator<String, String>(type, jp, context, deser, false, "one"); it.next(); assertEquals("one", it.next()); assertEquals("two", it.next()); assertEquals("three", it.next()); }
@Test public void testIterator() { JsonDeserializer<String> mockDeserializer = mock(JsonDeserializer.class); when(mockDeserializer.deserialize(any(Json.class))).thenReturn(mockDeserializer); JsonParser jp = mock(JsonParser.class); DeserializationContext ctxt = mock(DeserializationContext.class); JsonDeserializer<String> mockDeserializer2 = mock(JsonDeserializer.class); when(jp.getCurrentToken()).thenReturn(JsonToken.START_ARRAY); when(jp.getCurrentToken()).thenReturn(JsonToken.START_ARRAY); MappingIterator<String> iterator = new MappingIterator<String>(String.class, jp, ctxt, mockDeserializer, false, null); iterator.next(); verify(mockDeserializer, times(1)).deserialize(any(Json.class)); verify(jp, times(1)).clearCurrentToken(); }
@Test public void testCloseParser() { JsonParser jp = mock(JsonParser.class); JsonDeserializer<String> deser = mock(JsonDeserializer.class); when(deserializer.deserialize(any(JsonEntity.class))).thenReturn(new StringEntity("value")); MappingIterator<String, String> it = new MappingIterator<String, String>(String.class, jp, null, deser, false, "value"); it.next(); verify(jp).closeToken(); verify(jp).nextToken(); verify(jp).clearCurrentToken(); }
@Test public void testIteratorWithNullValueToUpdate() { new Expectations() { { jp.getCurrentToken(); result = JsonToken.START_ARRAY; jp.nextToken(); result = jp; jp.clearCurrentToken(); result = null; } }; MappingIterator<Integer> it = new MappingIterator<Integer>(Integer.class, jp, null, null, false, null); assertEquals(null, it.next()); assertEquals(null, it.next()); assertEquals(null, it.next()); assertEquals(null, it.next()); assertEquals(null, it.next()); assertEquals(null, it.next()); assertEquals(null, it.next()); assertEquals(null, it.next()); assertEquals(null, it.next()); assertEquals(null, it.next()); assertEquals(null, it.next()); assertEquals(null, it.next()); assertEquals(null, it.next()); assertEquals(null, it.next()); assertEquals(null, it.next()); assertEquals(null, it.next()); assertEquals(null, it.next()); assertEquals(null, it.next()); assertEquals(null, it.next()); assertEquals(null, it.next()); assertEquals(null, it.next()); assertEquals(null, it.next());
@Test public void testIterator() { mapper.setPrettyPrint(true); mapper.setPrettyPrint(false); mapper.setPrettyPrint(true); mapper.setPrettyPrint(false); mapper.setPrettyPrint(true); mapper.setPrettyPrint(false); mapper.setPrettyPrint(true); mapper.setPrettyPrint(false); mapper.setPrettyPrint(false); mapper.setPrettyPrint(true); mapper.setPrettyPrint(false); mapper.setPrettyPrint(true); mapper.setPrettyPrint(false); mapper.setPrettyPrint(true); mapper.setPrettyPrint(false); mapper.setPrettyPrint(true); mapper.setPrettyPrint(false); mapper.setPrettyPrint(true); mapper.setPrettyPrint(true); mapper.setPrettyPrint(false); mapper.setPrettyPrint(true); mapper.setPrettyPrint(false); mapper.setPrettyPrint(true); mapper.setPrettyPrint(false); mapper.setPrettyPrint(true); mapper.setPrettyPrint(true); mapper.setPrettyPrint(false); mapper.setPrettyPrint(true); mapper.setPrettyPrint(true); mapper.setPrettyPrint(false); mapper.setPrettyPrint(true
@Test public void testUpdateValue() { new EqualsTester() { @Override protected void testEquals(Object valueToUpdate) throws Exception { new EqualsTester() { @Override protected void testEquals(Object valueToUpdate) throws Exception { new EqualsTester() { @Override protected void testEquals(Object valueToUpdate) throws Exception { new EqualsTester() { @Override protected void testEquals(Object valueToUpdate) throws Exception { new EqualsTester() { @Override protected void testEquals(Object valueToUpdate) throws Exception { new EqualsTester() { @Override protected void testEquals(Object valueToUpdate) throws Exception { new EqualsTester() { { @Override protected void testEquals(Object valueToUpdate) throws Exception { { new EqualsTester() { { @Override protected void testEquals(Object value) throws Exception { { new EqualsTester() { { { @Override public void testEquals(Object value) throws Exception { { new EqualsTester() { { { new EqualsTester() { { defaultEquals(new ElementMatchers.same(value) { { new ElementMatchers.same(value) { { new ElementMatchers.same(value) { { new ElementMatchers.same(value) { { new ElementMatchers.same(value) { { new ElementMatchers.same
@Test public void testStringIterator() { JsonParser jp = mock(JsonParser.class); JsonDeserializer<String[]> deser = mock(JsonDeserializer.class); when(jp.getCurrentToken()).thenReturn(JsonToken.START_ARRAY); when(jp.getCurrentToken()).thenReturn(JsonToken.START_ARRAY); MappingIterator<String[]> listIterator = new MappingIterator<String[]>(JavaType.STRING_ARRAY, jp, null, deser, false, null); listIterator.next(); verify(jp).clearCurrentToken(); verify(deserializer).deserialize(eq(String[].class), eq(null), eq(null), eq(null)); }
@Test public void testHasNext() throws IOException { MappingIterator<String> it = MappingIterator.emptyIterator(); assertTrue(it.hasNext()); it.next(); assertFalse(it.hasNext()); }
@Test public void testHasNext() throws IOException { List<String> resultList = new ArrayList<String>(); resultList.add("one"); resultList.add("two"); resultList.add("three"); MappingIterator<String> emptyIterator = MappingIterator.emptyIterator(); assertFalse(emptyIterator.hasNext()); assertFalse(emptyIterator.hasNext()); assertFalse(emptyIterator.hasNextValue()); }
@Test public void testHasNext() throws Exception { publ.readAll(List.of("one", "two", "three")); assertThat(publ.hasNext()).isTrue(); assertThat(publ.hasNext()).isFalse(); assertThat(publ.hasNext()).isTrue(); assertThat(publ.hasNext()).isFalse(); }
@Test public void next() throws IOException { List<Integer> resultList = new ArrayList<Integer>(); resultList.add(1); resultList.add(2); resultList.add(3); resultList.add(4); MappingIterator<Integer> it = MappingIterator.emptyIterator(); assertEquals(1, it.hasNextValue()); assertEquals(2, it.nextValue()); assertEquals(3, it.nextValue()); assertEquals(4, it.nextValue()); assertEquals(5, it.nextValue()); assertEquals(6, it.nextValue()); assertEquals(7, it.nextValue()); }
@Test public void testNext() throws IOException { List<Integer> resultList = new ArrayList<Integer>(); resultList.add(1); resultList.add(2); resultList.add(3); resultList.add(4); MappingIterator<Integer> it = MappingIterator.emptyIterator(); assertEquals(1, it.hasNextValue()); assertEquals(2, it.nextValue()); assertEquals(3, it.nextValue()); assertEquals(4, it.nextValue()); assertEquals(5, it.nextValue()); assertEquals(6, it.nextValue()); assertEquals(7, it.nextValue()); assertEquals(8, it.nextValue()); }
@Test public void nextValue() throws IOException { List<Integer> resultList = new ArrayList<Integer>(); resultList.add(1); resultList.add(2); resultList.add(3); resultList.add(4); resultList.add(5); MappingIterator<Integer> it = MappingIterator.emptyIterator(); assertEquals(1, it.hasNextValue()); assertEquals(2, it.nextValue()); assertEquals(3, it.nextValue()); assertEquals(4, it.nextValue()); assertEquals(5, it.nextValue()); assertEquals(6, it.nextValue()); assertEquals(7, it.nextValue()); assertEquals(8, it.nextValue()); }
@Test public void testHasNextValue() throws IOException { assertTrue(iterator.hasNextValue()); assertTrue(iterator.hasNextValue()); assertFalse(iterator.hasNextValue()); }
@Test public void testHasNextValue() throws IOException { JsonParser jp = mock(JsonParser.class); JsonParserDeserializer mock = mock(JsonParserDeserializer.class); when(jp.getCurrentToken()).thenReturn(JsonToken.END_ARRAY); when(mock.nextToken()).thenReturn(JsonToken.END_ARRAY); when(mock.closeParser()).thenReturn(false); MappingIterator iter = new MappingIterator(JavaType.getActualType(String.class), jp, mock, mock, false); assertFalse(iter.hasNextValue()); }
@Test public void testHasNextValue() throws IOException { JsonParser jp = mock(JsonParser.class); JsonParserDeserializer mock = mock(JsonParserDeserializer.class); when(jp.getCurrentToken()).thenReturn(JsonToken.END_ARRAY); when(mock.nextToken()).thenReturn(JsonToken.END_ARRAY); MappingIterator mappingIterator = new MappingIterator(JavaType.getActualType(String.class), jp, mock, null, false, null); assertTrue(mappingIterator.hasNextValue()); }
@Test public void testHasNextValue() throws IOException { JsonParser jp = mock(JsonParser.class); JsonToken t = mock(JsonToken.class); when(jp.getCurrentToken()).thenReturn(t); when(t.isNull()).thenReturn(false); when(t.nextToken()).thenReturn(JsonToken.END_ARRAY); when(jp.nextToken()).thenReturn(null); assertFalse(iterator.hasNextValue()); }
@Test public void testHasNextValue() throws IOException { assertTrue(iterator.hasNextValue()); }
@Test public void testHasNextValue() throws IOException { JsonParser jp = mock(JsonParser.class); JsonToken[] tokens = new JsonToken[] { JsonToken.END_ARRAY, JsonToken.END_OBJECT }; when(jp.nextToken()).thenReturn(tokens[0]); when(jp.getCurrentToken()).thenReturn(JsonToken.END_ARRAY); MappingIterator mappingIterator = new MappingIterator(JavaType.getActualType(String.class), jp, null, null, false); assertTrue(mappingIterator.hasNextValue()); }
@Test public void hasNextValue() throws IOException { JsonParser jp = mock(JsonParser.class); when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); when(jp.nextToken()).thenReturn(JsonToken.END_OBJECT); when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); assertTrue(iterator.hasNextValue()); when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); assertFalse(iterator.hasNextValue()); when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); assertFalse(iterator.hasNextValue()); when(jp.close()).thenReturn(true); assertFalse(iterator.hasNextValue()); }
@Test public void testHasNextValue() throws IOException { JsonParser jp = mock(JsonParser.class); JsonToken[] tokens = new JsonToken[] { JsonToken.END_ARRAY }; when(jp.nextToken()).thenReturn(tokens); when(jp.getCurrentToken()).thenReturn(JsonToken.END_ARRAY); MappingIterator mappingIterator = new MappingIterator(JavaType.getActualType(String.class), jp, null, null, false, false); assertTrue(mappingIterator.hasNextValue()); }
@Test public void hasNextValue() throws IOException { JsonParser jp = mock(JsonParser.class); when(jp.nextValue()).thenReturn(true); when(mapper.nextToken()).thenReturn(JsonToken.END_ARRAY); assertTrue(jp.hasNextValue()); }
@Test public void testHasNextValue() throws IOException { JsonParser jp = mock(JsonParser.class); JsonParserDeserializer mock = mock(JsonParserDeserializer.class); when(jp.getCurrentToken()).thenReturn(JsonToken.END_ARRAY); when(mock.nextToken()).thenReturn(JsonToken.END_ARRAY); when(mock.closeParser()).thenReturn(true); assertFalse(iterator.hasNextValue()); when(mock.nextToken()).thenReturn(JsonToken.END_ARRAY); assertFalse(iterator.hasNextValue()); when(mock.nextToken()).thenReturn(JsonToken.END_ARRAY); assertFalse(iterator.hasNextValue()); when(mock.nextToken()).thenReturn(JsonToken.END_ARRAY); assertFalse(iterator.hasNextValue()); when(mock.nextToken()).thenReturn(JsonToken.END_ARRAY); assertFalse(iterator.hasNextValue()); when(mock.nextToken()).thenReturn(JsonToken.END_ARRAY); assertFalse(iterator.hasNextValue()); when(mock.nextToken()).thenReturn(JsonToken.END_ARRAY); assertFalse(iterator.hasNextValue()); when(mock.nextToken()).thenReturn(JsonToken.END_ARRAY); assertFalse(iterator.hasNextValue()); when(mock.nextToken()).thenReturn
@Test public void testHasNextValue() throws IOException { JsonParser jp = mock(JsonParser.class); JsonToken[] tokens = new JsonToken[] { JsonToken.END_ARRAY, JsonToken.END_OBJECT }; when(jp.getCurrentToken()).thenReturn(tokens); when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); when(mapper.nextToken()).thenReturn(JsonToken.END_OBJECT); assertFalse(prt.hasNextValue()); when(mapper.nextToken()).thenReturn(JsonToken.END_ARRAY); assertFalse(prt.hasNextValue()); when(mapper.nextToken()).thenReturn(JsonToken.END_OBJECT); assertFalse(prt.hasNextValue()); when(mapper.nextToken()).thenReturn(JsonToken.END_ARRAY); assertFalse(prt.hasNextValue()); }
@Test public void hasNextValue() throws IOException { new Expectations() { { jp.close(); } }; }
@Test public void hasNextValue() throws IOException { assertFalse(iterator.hasNextValue()); }
@Test public void hasNextValue() throws IOException { assertTrue(iterator.hasNextValue()); }
@Test public void nextValue() throws IOException { new MockDeserializer().deserialize(null, null, null); new MockDeserializer().deserialize(null, null, null); new MockDeserializer().deserialize(null, null, null); new MockDeserializer().deserialize(null, null, null); new MockDeserializer().deserialize(null, null, null); new MockDeserializer().deserialize(null, null, null); new MockDeserializer().deserialize(null, null, null); new MockDeserializer().deserialize(null, null, null); new MockDeserializer().deserialize(null, null, null); new MockDeserializer().deserialize(null, null, null); new MockDeserializer().deserialize(null, null, null); new MockDeserializer().deserialize(null, null, null); new MockDeserializer().deserialize(null, null, null); new MockDeserializer().deserialize(null, null, null); new MockDeserializer().deserialize(null, null, null); new MockDeserializer().deserialize(null, null, null); new MockDeserializer().deserialize(null, null, null); new MockDeserializer().deserialize(null, null, null); new MockDeserializer().deserialize(null, null, null); new MockDeserializer().deserialize(null, null, null); new MockDeserializer().deserialize
@Test public void nextValue() throws IOException { new MockUp<String>() { @Mock public String nextValue() throws IOException { return null; } }.test(); }
@Test public void nextValue() throws IOException { JsonParser jp = mock(JsonParser.class); DeserializationContext ctxt = mock(DeserializationContext.class); JsonDeserializer<Object> deser = mock(JsonDeserializer.class); when(deserializer.deserialize(jp, ctxt, null)).thenReturn(null); when(deserializer.deserialize(jp, ctxt, "foo")).thenReturn("bar"); assertEquals("bar", mapper.nextValue()); verify(parser).nextValue(); verify(parser).clearCurrentToken(); }
@Test public void nextValue() throws IOException { new MockDeserializer().deserialize( jp, context, null); new MockDeserializer().deserialize( jp, context, null); new MockDeserializer().deserialize( jp, context, "foo"); assertEquals("foo", mapper.nextValue()); assertEquals("foo", mapper.nextValue()); }
@Test public void nextValue() throws IOException { MappingIterator<String> it = MappingIterator.create(String.class, jp, context, deser); assertEquals("value", it.nextValue()); assertEquals("value", it.nextValue()); assertEquals("value", it.nextValue()); assertEquals("value", it.nextValue()); assertEquals("value", it.nextValue()); try { it.nextValue(); fail(); } catch (NoSuchElementException e) { } try { it.nextValue(); fail(); } catch (NoSuchElementException e) { } }
@Test public void nextValue() throws IOException { new MockDeserializer().nextValue(); }
@Test public void testNextValue() throws IOException { new MockDeserializer().deserialize(null, null, null); new MockDeserializer().deserialize(null, null, null); new MockDeserializer().deserialize(null, null, null); new MockDeserializer().deserialize(null, null, null); new MockDeserializer().deserialize(null, null, null); new MockDeserializer().deserialize(null, null, null); new MockDeserializer().deserialize(null, null, null); new MockDeserializer().deserialize(null, null, null); new MockDeserializer().deserialize(null, null, null); new MockDeserializer().deserialize(null, null, null); new MockDeserializer().deserialize(null, null, null); new MockDeserializer().deserialize(null, null, null); new MockDeserializer().deserialize(null, null, null); new MockDeserializer().deserialize(null, null, null); new MockDeserializer().deserialize(null, null, null); new MockDeserializer().deserialize(null, null, null); new MockDeserializer().deserialize(null, null, null); new MockDeserializer().deserialize(null, null, null); new MockDeserializer().deserialize(null, null, null); new MockDeserializer().deserialize(null, null, null); new MockDeserializer().
@Test public void nextValue() throws IOException { new MockDeserializer().deserialize(mapper, jp, context, mapper.toJson(new Object())); new MockDeserializer().deserialize(mapper, jp, context, mapper.toJson(new Object())); new MockDeserializer().deserialize(mapper, jp, context, mapper.toJson(new Object())); new MockDeserializer().deserialize(mapper, jp, context, mapper.toJson(new Object())); new MockDeserializer().deserialize(mapper, jp, context, mapper.toJson(new Object())); new MockDeserializer().deserialize(mapper, jp, context, mapper.toJson(new Object())); new MockDeserializer().deserialize(mapper, jp, context, mapper.toJson(new Object())); new MockDeserializer().deserialize(mapper, jp, context, mapper.toJson(new Object())); new MockDeserializer().deserialize(mapper, jp, context, mapper.toJson(new Object())); new MockDeserializer().deserialize(mapper, jp, context, mapper.toJson(new Object())); new MockDeserializer().deserialize(mapper, jp, context, mapper.toJson(new Object())); new MockDeserializer().deserialize(mapper, jp, context, mapper.toJson(new Object())); new MockDeserializer().deserialize
@Test public void testNextValue() throws IOException { new MockDeserializer().deserialize(null, null, null); new MockDeserializer().deserialize(null, null, null); new MockDeserializer().deserialize(null, null, null); new MockDeserializer().deserialize(null, null, null); new MockDeserializer().deserialize(null, null, null); new MockDeserializer().deserialize(null, null, null); new MockDeserializer().deserialize(null, null, null); new MockDeserializer().deserialize(null, null, null); new MockDeserializer().deserialize(null, null, null); new MockDeserializer().deserialize(null, null, null); new MockDeserializer().deserialize(null, null, null); new MockDeserializer().deserialize(null, null, null); new MockDeserializer().deserialize(null, null, null); new MockDeserializer().deserialize(null, null, null); new MockDeserializer().deserialize(null, null, null); new MockDeserializer().deserialize(null, null, null); new MockDeserializer().deserialize(null, null, null); new MockDeserializer().deserialize(null, null, null); new MockDeserializer().deserialize(null, null, null); new MockDeserializer().deserialize(null, null, null); new MockDeserializer().
@Test public void nextValue() throws IOException { MappingIterator<String> it = MappingIterator.create(String.class, jp, context, deser); assertEquals("value", it.nextValue()); assertEquals("value", it.nextValue()); assertEquals("value", it.nextValue()); assertEquals("value", it.nextValue()); assertEquals("value", it.nextValue()); assertEquals("value", it.nextValue()); assertEquals("value", it.nextValue()); assertEquals("value", it.nextValue()); assertEquals("value", it.nextValue()); assertEquals("value", it.nextValue()); try { it.nextValue(); fail("Expected NoSuchElementException"); } catch (NoSuchElementException e) { } try { it.nextValue(); fail("Expected NoSuchElementException"); } catch (NoSuchElementException e) { } }
@Test public void serialize() throws IOException, JsonProcessingException { byte[] bytes = "Hello, world!".getBytes(); JsonNodeFactory factory = new DefaultJsonFactory(); JsonNode config = factory.parseJson(bytes); SerializationProvider provider = new DefaultSerializationProvider(); new BinaryNode(bytes).serialize(provider, provider); Assert.assertEquals(bytes, provider.getConfig().getBase64Variant()); }
@Test public void serialize() throws IOException, JsonProcessingException { String v = "Hello, world!"; JsonSerializerProvider provider = new JsonSerializerProvider(); provider.setConfig(new JsonConfig(v)); new MockUp<JsonGenerator>() { @Mock public void serialize(JsonGenerator jg, SerializerProvider provider) throws IOException, JsonProcessingException { jg.writeBinary(provider.getConfig().getBase64Variant(), v.getBytes()); } }; new MockUp<JsonNode>() { @Mock public BinaryNode valueOf(byte[] v) { return new BinaryNode(v); } }; new MockUp<JsonNode>() { @Mock public BinaryNode valueOf(byte[] v, int offset, int length) { return new BinaryNode(v); } }; new MockUp<JsonNode>() { @Mock public BinaryNode valueOf(byte[] v, int offset, int length) { return new BinaryNode(v); } }; new MockUp<JsonNode>() { @Mock public BinaryNode valueOf(byte[] v, int offset, int length) { return new BinaryNode(v); } }; new MockUp<JsonNode>() { @Mock public BinaryNode valueOf(byte[] v, int offset, int length) {
@Test public void testInitialCapacity() { ObjectBuffer node = new ObjectBuffer(); node.initialCapacity(); node.appendCompletedChunk(new Object[] { "a", "b" }); node.appendCompletedChunk(new Object[] { "c", "d" }); node.initialCapacity(); assertEquals(0, node.initialCapacity()); node.appendCompletedChunk(new Object[] { "a", "b" }); node.initialCapacity(); assertEquals(0, node.initialCapacity()); node.appendCompletedChunk(new Object[] { "a", "b" }); node.initialCapacity(); assertEquals(0, node.initialCapacity()); node.appendCompletedChunk(new Object[] { "a", "b" }); node.initialCapacity(); assertEquals(0, node.initialCapacity()); node.appendCompletedChunk(new Object[] { "a", "b" }); node.initialCapacity(); assertEquals(0, node.initialCapacity()); node.appendCompletedChunk(new Object[] { "a", "b" }); node.initialCapacity(); assertEquals(0, node.initialCapacity()); node.appendCompletedChunk(new Object[] { "a", "b" }); node.initialCapacity(); assertEquals(0, node.initialCapacity()); }
@Test public void testInitialCapacity() { Object[] data=new Object[] { null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null,
@Test public void shouldDeserializeNull() throws Exception { Mockito.when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); Mockito.when(jp.getEmbeddedObject()).thenReturn(null); Mockito.when(jp.getToken()).thenReturn(JsonToken.VALUE_NULL); Assert.assertEquals(null, deserialize(jp, ctxt)); }
@Test public void deserializeInteger() throws Exception { Mockito.when(jp.getCurrentToken()).thenReturn(DeserializationFeature.VALUE_NUMBER_INT); Mockito.when(jp.getNumberValue()).thenReturn(1234); Assert.assertEquals(1234, mapper.deserialize(jp, ctxt)); }
@Test public void mapArrayToArray() throws IOException, JsonProcessingException { final ArrayList expectedResult = new ArrayList<Object>(); final ArrayList<Object> expectedResult2 = new ArrayList<Object>(); final ArrayList<Object> expectedResult3 = new ArrayList<Object>(); final JsonParser jp = mock(JsonParser.class); when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); when(jp.nextToken()).thenReturn(JsonToken.START_ARRAY); when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); when
@Test public void mapObject() throws IOException, JsonProcessingException { Mockito.when(jp.getText()).thenReturn("a,b,c,d,e,f,g"); Mockito.when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); Mockito.when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); Mockito.when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); Mockito.when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); Mockito.when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); Mockito.when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); Mockito.when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); Mockito.when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); Mockito.when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); Object result = mapObject(jp, null); Assert.assertNotNull(result); Assert.assertTrue(result instanceof LinkedHashMap); Assert.assertEquals("a", (String) result.get("a")); Assert.assertEquals("b", (Object) result.get
@Test public void testMapObject() throws IOException, JsonProcessingException { Mockito.when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); Mockito.when(jp.getText()).thenReturn("a"); Mockito.when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); Mockito.when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); Mockito.when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); Mockito.when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); Mockito.when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); Object result = mapObject(jp, null); Assert.assertNotNull(result); Assert.assertTrue(result instanceof LinkedHashMap); Assert.assertEquals("a", ((Map<String, Object>) result).get("a")); }
@Test public void testMapObject() throws IOException, JsonProcessingException { final Linkeke Linkeke = new Linke(); final JsonParser jp = mock(JsonParser.class); when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.getText()).thenReturn("field1"); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME
@Test public void mapObject() throws IOException, JsonProcessingException { final JsonParser jp = mock(JsonParser.class); when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); when(jp.getText()).thenReturn("field1 value"); when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); when(jp.nextToken()).thenReturn(
public void mapObject() throws IOException, JsonProcessingException { final String expected = "{\"key1\":\"value1\",\"key2\":\"value2\"}"; final JsonParser jp = mock(JsonParser.class); when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.getText()).thenReturn(expected); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); when(jp.nextToken
@Test public void testMapObject() throws IOException, JsonProcessingException { Mockito.when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); Mockito.when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); Mockito.when(jp.getText()).thenReturn("field1 value1"); Mockito.when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); Mockito.when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); Mockito.when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); Mockito.when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); Mockito.when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); Mockito.when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); Mockito.when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); Object result = mapObject(jp, ctxt); Assert.assertEquals("value1", result); }
@Test public void testMapObject() throws IOException, JsonProcessingException { Mockito.when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); Mockito.when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); Mockito.when(jp.getText()).thenReturn("field1 value1"); Mockito.when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); Mockito.when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); Mockito.when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); Mockito.when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); Mockito.when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); Mockito.when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); Mockito.when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); Object result = mapObject(jp, ctxt); Assert.assertEquals("value1", result.get("field1")); Assert.assertEquals("value2", result.get("field2")); Mockito.verify(jp, Mockito.times(1)).nextToken(); Mockito.verify(jp, Mockito.times(1)).nextToken
@Test public void testMapObject() throws IOException, JsonProcessingException { final ObjectMapper mapper = new ObjectMapper(); final String map = "{\"a\":1,\"b\":2,\"c\":3}"; final JsonParser jp = mapper.createParser(map); jp.setCurrentToken(JsonToken.START_OBJECT); Mockito.when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); Mockito.when(jp.getText()).thenReturn("a"); Mockito.when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); Mockito.when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); Mockito.when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); final Object result = mapper.mapObject(jp, null); Assert.assertEquals("a", result); }
@Test public void mapObject() throws IOException, JsonProcessingException { Mockito.when(jp.getText()).thenReturn("field"); Mockito.when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); Mockito.when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); Mockito.when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); Mockito.when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); Mockito.when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); Mockito.when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); Mockito.when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); Mockito.when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); LinkedHashMap<String, Object> result = (LinkedHashMol) mapObject(jp, null); Assert.assertEquals("value", result.get("field")); Mockito.verify(jp, Mockito.times(1)).getText(); Mockito.verify(jp, Mockito.times(1)).nextToken(); Mockito.verify(jp, Mockito.times(1)).nextToken(); Mockito.verify(jp, Mockito.times(1)
@Test public void testMapObject() throws IOException, JsonProcessingException { Mockito.when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); Mockito.when(jp.getText()).thenReturn("a"); Mockito.when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); Mockito.when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); Mockito.when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); Mockito.when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); Mockito.when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); Object result = mapObject(jp, null); Assert.assertNotNull(result); Assert.assertTrue(result instanceof LinkedHashMap); Assert.assertEquals("a", ((Map<String, Object>) result).get("a")); }
@Test public void testMapObject() throws IOException, JsonProcessingException { Mockito.when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); Mockito.when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); Mockito.when(jp.getText()).thenReturn(FIELD_NAME); Mockito.when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); Mockito.when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); Mockito.when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); Mockito.when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); Mockito.when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); Mockito.when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); Mockito.when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); Mockito.when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); Mockito.when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); Mockito.when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); Mockito.when(jp.nextToken()).thenReturn(
@Test public void testMapObject() throws IOException, JsonProcessingException { Mockito.when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); Mockito.when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); Mockito.when(jp.getText()).thenReturn("a"); Mockito.when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); Mockito.when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); Mockito.when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); Object result = mapObject(jp, null); Assert.assertNotNull(result); Assert.assertTrue(result instanceof LinkedHashMap); LinkedHashMap<String, Object> expected = new LinkedHashMap<String, Object>(); expected.put("a", "a"); expected.put("b", "b"); expected.put("c", "c"); Assert.assertEquals(expected, result); }
@Test public void mapArrayToArray() throws IOException, JsonProcessingException { final byte[] bytes = new byte[] {1, 2, 3, 4}; final JsonParser jp = mock(JsonParser.class); when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); when(ctxt.leaseObjectBuffer()).thenReturn(objectBuffer); when(context.leaseObjectBuffer()).thenReturn(objectBuffer); when(jp.nextToken()).thenReturn(JsonToken.START_ARRAY); when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); Object[] result = deserializer.mapArrayToArray(jp, ctxt); assertArrayEquals(bytes, result); }
@Test public void mapArrayToArray() throws IOException, JsonProcessingException { final ObjectBuffer buffer = new ObjectBuffer(); final JsonParser jp = mock(JsonParser.class); when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); Object[] actual = deserializer.mapArrayToArray(jp, mock(DeserializationContext.class)); assertArrayEquals(new Object[]{"a", "b", "c"}, actual); }
@Test public void mapArrayToArray() throws IOException, JsonProcessingException { ObjectBuffer buffer = mock(ObjectBuffer.class); when(mockContext.leaseObjectBuffer()).thenReturn(buffer); when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); when(buffer.appendCompletedChunk(any(Object[].class))).thenReturn(new Object[] { 1, 2, 3 }); Object[] actual = deserializer.mapArrayToArray(jp, mockContext); assertArrayEquals(new Object[] { 1, 2, 3 }, actual); }
@Test public void testMapArrayToArray() throws IOException, JsonProcessingException { final ObjectBuffer buffer = new ObjectBuffer(); final JsonParser jp = mock(JsonParser.class); when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); when(ctxt.leaseObjectBuffer()).thenReturn(buffer); when(jp.nextAndStart()).thenReturn(0); when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); Object[] actual = deserializer.mapArrayToArray(jp, ctxt); assertArrayEquals(new Object[]{"a", "b", "c"}, actual); }
@Test public void testMapArrayToArray() throws IOException, JsonProcessingException { final ObjectBuffer buffer = new ObjectBuffer(); final DeserializationContext ctxt = mock(DeserializationContext.class); when(ctxt.leaseObjectBuffer()).thenReturn(buffer); when(ctxt.nextToken()).thenReturn(JsonToken.END_ARRAY); when(ctxt.nextToken()).thenReturn(JsonToken.END_ARRAY); Object[] values = new Object[] { "a", "b" }; Object[] actual = deserializer.mapArrayToArray(jp, ctxt); assertArrayEquals(new Object[] { "a", "b" }, actual); }
@Test public void testMapArrayToArray() throws IOException, JsonProcessingException { final byte[] bytes = new byte[] {1, 2, 3, 4}; final ObjectBuffer buffer = new ObjectBuffer(); Mockito.when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); Mockito.when(ctxt.leaseObjectBuffer()).thenReturn(buffer); Mockito.when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); Mockito.when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); Object[] result = deserializer.mapArrayToArray(jp, ctxt); Assert.assertEquals(bytes, result); Mockito.verify(jp).nextToken(); Mockito.verify(ctxt).leaseObjectBuffer(); Mockito.verify(jp).nextToken(); Mockito.verify(jp).nextToken(); Mockito.verify(ctxt).leaseObjectBuffer(); Mockito.verify(jp).nextToken(); Mockito.verify(jp).nextToken(); Mockito.verify(ctxt).appendCompletedChunk(bytes); Mockito.verify(jp).endToken(); }
@Test public void mapArrayToArray() throws IOException, JsonProcessingException { final byte[] bytes = new byte[] { 1, 2, 3, 4 }; final JsonParser jp = mock(JsonParser.class); when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); when(ctxt.leaseObjectBuffer()).thenReturn(objectBuffer); when(ctxt.deserializeObjectBuffer()).thenReturn(new ObjectBuffer(bytes)); Object[] actual = (Object[]) deserializer.deserialize(jp, ctxt); assertArrayEquals(bytes, actual); }
@Test public void mapArrayToArray() throws IOException, JsonProcessingException { final byte[] bytes = new byte[] {1, 2, 3, 4}; final ObjectBuffer buffer = mock(ObjectBuffer.class); when(buffer.appendCompletedChunk(any(Object[].class))).thenReturn(new ObjectBuffer().addObject(bytes)); when(context.leaseObjectBuffer()).thenReturn(buffer); when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); when(ctxt.leaseObjectBuffer()).thenReturn(buffer); when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); Object[] actual = deserializer.mapArrayToArray(jp, ctxt); assertArrayEquals(bytes, actual); }
@Test public void testMapArrayToArray() throws IOException, JsonProcessingException { final ObjectBuffer buffer = new ObjectBuffer(); final JsonParser jp = mock(JsonParser.class); when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); when(ctxt.leaseObjectBuffer()).thenReturn(buffer); when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); when(ctxt.leaseObjectBuffer()).thenReturn(buffer); Object[] actualArray = deserializer.mapArrayToArray(jp, ctxt); assertArrayEquals(new Object[]{"a", "b", "c"}, actualArray); }
@Test public void mapArrayToArray() throws IOException, JsonProcessingException { ObjectBuffer buffer = new ObjectBuffer(); JsonParser jp = mock(JsonParser.class); when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); when(ctxt.leaseObjectBuffer()).thenReturn(buffer); when(ctxt.leaseObjectBuffer()).thenReturn(null); Object[] actual = deserializer.mapArrayToArray(jp, ctxt); verify(buffer).completeAndClearBuffer(eq(ARRAY_ARRAY_ARRAY_ARRAY_ARRAY_END), eq(0)); verify(buffer).appendCompletedChunk(eq(ARRAY_ARRAY_END)); verify(buffer).appendCompletedChunk(eq(OBJECT_ARRAY_END)); }
@Test public void testJackson() { JsonDeserializer<?> deserializer = find(DateDeserializer.class, ".util.Date"); assertThat(deserializer).isInstanceOf(DateDeserializer.class); JsonDeserializer<?> deserializer2 = find(DateDeserializer.class, ".util.Date"); assertThat(deserializer2).isInstanceOf(DateDeserializer.class); JsonDeserializer<?> deserializer3 = find(DateDeserializer.class, ".util.Date"); assertThat(deserializer3).isInstanceOf(DateDeserializer.class); JsonDeserializer<?> deserializer4 = find(DateDeserializer.class, ".util.Date"); assertThat(deserializer4).isInstanceOf(DateDeserializer.class); JsonDeserializer<?> deserializer5 = find(DateDeserializer.class, ".util.Date"); assertThat(deserializer5).isInstanceOf(DateDeserializer.class); JsonDeserializer<?> deserializer6 = find(DateDeserializer.class, ".util.Date"); assertThat(deserializer6).isInstanceOf(DateDeserializer.class); JsonDeserializer<?> deserializer7 = find(DateDeserializer.class, ".util.Date"); assertThat(deserializer7).isInstanceOf(DateDeserializer.class); JsonDeserializer<?> deserializer8 = find(DateDeserializer.class,
@Test public void should_return_DateDeserializer_for_Date() { JsonDeserializer<?> deserializer = find(DateDeserializer.class, ".util.Date"); assertThat(deserializer).isInstanceOf(SqlDateDeserializer.class); }
@Test public void should_return_null_when_raw_type_is_not_Timestamp() { JsonDeserializer<?> deserializer = find(Timestamp.class, "rawType"); assertThat(deserializer).isNull(); }
@Test public void testJackson() { JsonDeserializer deserializer = Deserializer.find(Timestamp.class, ".util.Date"); assertThat(deserializer).isInstanceOf(TimestampDeserializer.class); }
@Test public void shouldFindDeserializerForDate() { JsonDeserializer<?> deserializer = find(DateDeserializer.class, ".util.Date"); assertThat(deserializer).isInstanceOf(DateDeserializer.class); }
@Test public void testJacksonDeserializer() { JsonDeserializer<?> deserializer = Deserializer.find(Date.class, ".util.Date"); assertThat(deserializer).isInstanceOf(DateDeserializer.class); assertThat(deserializer.getClass()).isEqualTo(DateDeserializer.class); assertThat(deserializer.matches(DateDeserializer.class)).isTrue(); assertThat(deserializer.matches(SqlDateDeserializer.class)).isTrue(); assertThat(deserializer.matches(TimestampDeserializer.class)).isTrue(); assertThat(deserializer.matches(TimeZoneDeserializer.class)).isTrue(); assertThat(deserializer.matches(TimeZone.class)).isTrue(); }
@Test public void testDateBasedDeserializer() throws Exception { DateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS"); DateBasedDeserializer<Object> deserializer = new DateBasedDeserializer(Object.class); Date date = deserializer.fromString("2011-01-11 11:00:00"); assertEquals(date, deserializer.fromString("2011-01-11 11:00:00")); assertEquals(df.format(date), deserializer.df.format(date)); }
@Test public void testDateBasedDeserializer() throws Exception { DateBasedDeserializer<TestData> deserializer = new DateBasedDeserializer<TestData>(TestData.class); DateFormat format = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS"); String formatString = "yyyy-MM-dd HH:mm:ss.SSS"; Date date = deserializer.deserialize(new StringReader(formatString)); assertEquals(date, deserializer.from_value()); assertEquals(format.format(null), deserializer.from_value()); assertEquals(format.format(null), deserializer.from_value()); assertEquals(format.format(null), deserializer.from_value()); assertEquals(format.format(null), deserializer.from_value()); assertEquals(format.format(null), deserializer.from_value()); assertEquals(format.format(null), deserializer.from_value()); assertEquals(format.format(null), deserializer.from_value()); assertEquals(format.format(null), deserializer.from_value()); assertEquals(format.format(null), deserializer.from_value()); assertEquals(format.format(null), deserializer.from_value()); assertEquals(format.format(null), deserializer.from_value()); assertEquals(format.format(null
@Test public void testDateBasedDeserializer() throws Exception { DateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS"); DateBasedDeserializer<Object> deserializer = new DateBasedDeserializer<Object>(Object.class); Date date = deserializer.fromString("2011-01-11 11:00:00"); Date date2 = deserializer.fromString("2011-01-11 11:00:00"); assertEquals(date, date2); assertEquals("2011-01-11 11:00:00", df.format(date)); assertEquals("2011-01-11 11:00:00", df.format(date2)); }
@Test public void testDateBasedDeserializer() throws Exception { DateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS"); DateBasedDeserializer<Foo> deserializer = new DateBasedDeserializer<Foo>(Foo.class); DateFormat format = df.getFormat(); String formatString = "yyyy-MM-dd HH:mm:ss.SSS"; DateBasedDeserializer<Foo> base = new DateBasedDeserializer<Foo>(Foo.class); assertEquals(format, deserializer.get_formatString()); assertEquals(format, deserializer.get_customFormat()); assertEquals(format, deserializer.get_formatString()); }
@Test public void should_set_time_zone_in_classpath() throws Exception { ClassPathResource resource = ClassPathResource.fromClassPathResource("classpath:org/apache/cxf/jaxrs/server/json/SimpleDateFormat.class"); BeanProperty beanProperty = beanProperty("dateTimeZone", "UTC"); DeserializationContext ctxt = mock(DeserializationContext.class); when(ctxt.getAnnotationIntrospector()).thenReturn(new AnnotationIntrospectorImpl()); when(ctxt.getTimeZone()).thenReturn(TimeZone.getTimeZone("GMT")); JsonDeserializer<?> d = d.createContextual(ctxt, beanProperty); assertThat(d.getClass().getSimpleName()).isEqualTo("org.apache.cxf.jaxrs.server.json.SimpleDateFormat"); assertThat(d.getTimeZone()).isEqualTo(TimeZone.getTimeZone("GMT")); }
@Test public void shouldCreateContextualWithPattern() throws JsonMappingException { BeanProperty property = new BeanProperty(TestBean.class.getDeclaredField("format").getGenericType()); JsonDeserializer<?> context = mock(JsonDeserializer.class); when(context.getAnnotationIntrospector()).thenReturn(new AnnotationIntrospectorImpl()); when(context.getAnnotation(JsonFormat.class)).thenReturn(new JsonFormat.Value(new BigDecimal("123456.789"))); when(context.getAnnotation(JsonFormat.Value.class)).thenReturn(new JsonFormat.Value(new BigDecimal("123456.789"))); when(context.getDeserializer(BeanProperty.class)).thenReturn(context); JsonDeserializer<?> contextual = this.deco.createContextual(context, property); assertThat(contextual).isNotNull(); assertThat(contextual.getDeserializer(BeanProperty.class)).isInstanceOf(DateDeserializer.class); }
@Test public void shouldCreateContextualWithPattern() throws JsonMappingException { BeanProperty property = new BeanProperty(TestBean.class.getDeclaredField("pattern").getGenericType()); JsonDeserializer<?> contextual = mock(JsonDeserializer.class); when(contextual.create(any(Class.class), any(Class.class))).thenReturn(null); JsonDeserializer<?> contextual2 = mock(JsonDeserializer.class); when(contextual2.create(any(Class.class), any(Class.class))).thenReturn(contextual2); JsonDeserializer<?> contextual3 = mock(JsonDeserializer.class); when(contextual3.create(any(Class.class), any(Class.class))).thenAnswer(new Answer<Object>() { @Override public Object answer(InvocationOnMock invocation) throws Throwable { Object[] args = invocation.getArguments(); ((Class<?>) args[0]).setAccessible(true); return (Class) args[0]; } }); JsonDeserializer<?> contextual4 = mock(JsonDeserializer.class); when(context4.create(any(Class.class), any(Class.class))).thenAnswer(new Answer<Object>() { @Override public Object answer(InvocationOnMock invocation) throws
@Test public void shouldCreateContextualWithLocale() throws JsonMappingException { BeanProperty property = new BeanProperty(TestBean.class.getDeclaredField("format")); JsonDeserializer<?> context = mock(JsonDeserializer.class); when(context.getAnnotationIntrospector()).thenReturn(new AnnotationIntrospector()); when(context.getAnnotation(TestBean.class)).thenReturn(new JsonFormat.Value(new BigDecimal("3.141592653589793"))); when(context.getLocale()).thenReturn(Locale.US); when(context.getTimeZone()).thenReturn(TimeZone.getTimeZone("UTC")); JsonDeserializer<?> d = deserializer.createContextual(context, property); assertThat(d).isNotNull(); assertThat(d.getClass().getSimpleName()).isEqualTo("org.apache.cxf.tools.fortest.Date"); assertThat(d.getLocale()).isEqualTo(Locale.US); }
@Test public void createContextual_locIsNull() throws JsonMappingException { BeanProperty property = new BeanProperty(TestBean.class.getDeclaredField("loc")); JsonDeserializer<?> d = deserializer.createContextual(null, property); assertNotNull(d); }
@Test public void should_create_contextual_with_locale() throws JsonMappingException { BeanProperty property = new BeanProperty(TestBean.class.getDeclaredField("locale")); JsonDeserializer<?> context = mock(JsonDeserializer.class); when(context.getLocale()).thenReturn(Locale.US); when(context.getAnnotationIntrospector()).thenReturn(new AnnotationIntrospector()); when(context.getAnnotation(TestBean.class)).thenReturn(new SimpleDateFormat("yyyy-MM-dd")); JsonDeserializer<?> contextual = _underTest.createContextual(context, property); assertThat(contextual).isNotNull(); assertThat(contextual.get(property)).isEqualTo(new Locale("US")); }
@Test public void createContextual_null() throws JsonMappingException { final String pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"; final Locale loc = new Locale("zh"); final BeanProperty property = new BeanProperty(null, "dateFormat"); final DeserializationContext ctxt = mock(DeserializationContext.class); when(ctxt.getAnnotationIntrospector()).thenReturn(new AnnotationIntrospector()); when(ctxt.getLocale()).thenReturn(loc); when(ctxt.getTimeZone()).thenReturn(null); when(ctxt.getAnnotationIntrospector()).thenReturn(new AnnotationIntrospector()); final JsonDeserializer<?> result = new TestDeserializationContext(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null,
@Test public void createContextual_null() throws JsonMappingException { BeanProperty property = new BeanProperty(null, "tz"); JsonDeserializer<?> d = deserializer.createContextual(context, property); assertNotNull(d); }
@Test public void should_create_contextual_with_time_zone_given_property() throws JsonMappingException { BeanProperty property = new BeanProperty(Annotated.class, "zh"); JsonDeserializer<?> contextual = mock(JsonDeserializer.class); when(context.getTimeZone()).thenReturn(null); when(context.getAnnotationIntrospector()).thenReturn(new AnnotationIntrospector()); JsonDeserializer<?> contextual2 = mock(JsonDeserializer.class); when(context.getAnnotationIntrospector()).thenReturn(new AnnotationIntrospector()); when(context.getAnnotation(Annotated.class)).thenReturn(new AnnotationIntrospector()); when(context.getAnnotation(Annotated.class)).thenReturn(new AnnotationIntrospector()); when(context.getAnnotation(Annotated.class)).thenReturn(new AnnotationIntrospector()); when(context.getAnnotation(Annotated.class)).thenReturn(new AnnotationIntrospector()); when(context.get(Annotated.class)).thenReturn(new AnnotationIntrospector()); when(context.get(Annotated.class)).thenReturn(new AnnotationIntrospector()); when(context.get(Annotated.class)).thenReturn(new AnnotationIntrospector()); when(context.getTimeZone()).thenReturn(null); JsonDeserializer<?> contextual2 = mock(
@Test public void setTimeZone() throws Exception { BeanProperty property = new BeanProperty(TestBean.class.getDeclaredField("df")); property.set(TestBean.class, new SimpleDateFormat("yyyy-MM-dd")); JsonDeserializer<?> dt = deserializer.createContextual(context, property); TimeZone.setDefault(TimeZone.getTimeZone("GMT")); assertThat(dt.getTimeZone()).isEqualTo(TimeZone.getTimeZone("GMT")); }
@Test public void shouldCreateContextualWithDateFormat() throws Exception { final SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS"); final DeserializationContext ctxt = mock(DeserializationContext.class); when(ctxt.getAnnotationIntrospector()).thenReturn(new AnnotationIntrospector()); when(ctxt.getFormat(beanProperty)).thenReturn(new JsonFormat.Value(new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS").getTimeZone())); when(ctxt.getLocale()).thenReturn(Locale.US); when(ctxt.getTimeZone()).thenReturn(TimeZone.getTimeZone("GMT")); when(ctxt.getLocale()).thenReturn(Locale.US); when(ctxt.getLocale().getTimeZone()).thenReturn(TimeZone.getTimeZone("GMT")); final JsonDeserializer<?> d = new JsonDeserializer() { @Override protected void createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException { SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS"); Date date = new Date(); df.setTimeZone(TimeZone.getTimeZone("GMT")); return d; } }; final JsonDeserializer<?> d2 = new JsonDeserializer
@Test public void testParseDate_trim() throws Exception { Mockito.when(jp.getText()).thenReturn("2011-12-03"); Mockito.when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); Mockito.when(jp.getText()).thenReturn("2011-12-03"); Date date = _dateBasedDeserializer.parseDate(jp, null); Assert.assertEquals("2011-12-03", date.toString()); Mockito.verify(base, Mockito.never()).parse(Mockito.anyString()); }
@Test public void testParseDateWithEmptyString() throws Exception { final SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"); final JsonParser jp = mock(JsonParser.class); when(jp.getText()).thenReturn(""); when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); when(jp.getToken()).thenReturn(JsonToken.VALUE_STRING); final Date date = _dateBasedDeserializer.parseDate(jp, null); assertEquals(date, new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'")); }
@Test public void testParseDateWithEmptyString() throws IOException, JsonProcessingException { MockDeserializer mock = new MockDeserializer(); final DateFormat format = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS"); final String emptyString = " "; final JsonParser jp = mock.getParser(); mock.setCurrentToken(JsonToken.VALUE_STRING); mock.setText(emptyString); try { new DateBasedDeserializer<>() { @Override protected.util.Date _parseDate(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { return new.util.Date(); } }.parseDate(jp, mock.getDeserializationContext()); } catch (Exception e) { fail("Unexpected exception: " + e); } }
@Test public void testParseDateWithCustomFormat() throws ParseException { final SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"); final JsonParser jp = mock(JsonParser.class); when(jp.getText()).thenReturn("2011-12-03"); final DeserializationContext ctxt = mock(DeserializationContext.class); when(ctxt.getMapper()).thenReturn(mock(Mapper.class)); try { new DateBasedDeserializer<DateBasedDeserializer<DateBasedDeserializerTest>>(DateBasedDeserializerTest.class) { @Override protected DateBasedDeserializer<DateBasedDeserializerTest> _parseDate(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { return new SimpleDateBasedDeserializer<DateBasedDeserializerTest>(DateBasedDeserializerTest.class) { @Override protected.util.Date _parseDate(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { return new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'").parse("2011-12-03"); } }; } }.parse("2011-12-03"); } finally { jp.close(); } }
@Test public void testParseDateWithCustomFormat() throws ParseException { DateFormat customFormat = mock(DateFormat.class); when(customFormat.parse("yyyy-MM-dd'T'HH:mm:ss.SSS")).thenReturn(customFormat); Date date = _dateBasedDeserializer.parseDate(_mapper.createParser("yyyy-MM-dd'T'HH:mm:ss.SSS"), null); assertThat(date, is(notNullValue())); assertThat(date, is(customFormat.parse("yyyy-MM-dd'T'HH:mm:ss.SSS"))); }
@Test public void testDateDeserializer() throws Exception { DateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS"); DateDeserializer deserializer = new DateDeserializer(); SqlDateDeserializer deserializer1 = new SqlDateDeserializer(); SqlDateDeserializer deserializer2 = new SqlDateDeserializer(); Date date1 = deserializer1.deserialize(new StringReader(SQL_DATE_WITH_TIME)); Date date2 = deserializer2.deserialize(new StringReader(SQL_DATE_WITH_TIME)); assertEquals(date1, date2); assertEquals(date2, deserializer1.deserialize(new StringReader(SQL_DATE_WITH_TIMESTAMP))); assertEquals(date1, deserializer1.deserialize(new StringReader(SQL_TIMESTAMP_WITH_TIMESTAMP))); assertEquals(date2, deserializer2.deserialize(new StringReader(SQL_TIMESTAMP_WITH_TIMESTAMP))); assertEquals(date1, deserializer1.deserialize(new StringReader(SQL_TIMESTAMP_WITH_TIMESTAMP))); assertEquals(date2, deserializer2.deserialize(new StringReader(SQL_TIMESTAMP_WITH_TIMESTAMP))); assertEquals(date1, deserializer1.deserialize(new StringReader(SQL_TIMESTAMP_WITH_TIMESTAMP))); assertEquals(date2, deserializer2.deserialize(new StringReader(SQL_TIMESTAMP_WITH_TIMESTAMP))); assertEquals(date1, deserializer1.deserialize(new StringReader(SQL_TIMESTAMP_WITH
@Test public void testDateDeserializer() throws Exception { DateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS"); DateDeserializer deserializer = new DateDeserializer(); deserializer.setRawType(Date.class); Date date = deserializer.deserialize(new StringReader(raw), df, "yyyy-MM-dd HH:mm:ss.SSS"); assertEquals(date, deserializer.getRawType()); assertEquals(Date.class, deserializer.getRawType()); assertEquals(Date.class, deserializer.getRawType()); assertEquals(Date.class, deserializer.getRawType()); assertEquals(Date.class, deserializer.getRawType()); assertEquals(Date.class, deserializer.getRawType()); assertEquals(Date.class, deserializer.getRawType()); assertEquals(Date.class, deserializer.getRawType()); assertEquals(Date.class, deserializer.getRawType()); assertEquals(Date.class, deserializer.getRawType()); assertEquals(Date.class, deserializer.getRawType()); assertEquals(Date.class, deserializer.getRawType()); assertEquals(Date.class, deserializer.getRawType()); assertEquals(Date.class, deserializer.getRawType()); assertEquals(Date.class, deserializer.getRaw
@Test public void test_withDateFormat() throws Exception { DateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS"); DateDeserializer deserializer = new DateDeserializer(null, df, "yyyy-MM-dd HH:mm:ss.SSS"); Date date = deserializer.withDateFormat(df, "yyyy-MM-dd HH:mm:ss.SSS"); assertEquals("yyyy-MM-dd HH:mm:ss.SSS", date.toString()); }
@Test public void test_deserialize() throws Exception { DateDeserializer deserializer = new DateDeserializer(); Date base = deserializer.withDateFormat(df, "yyyy-MM-dd HH:mm:ss.SSS"); Date expected = new Date(base.getTime()); assertEquals(expected, deserializer.deserialize(base)); }
@Test public void testTimestampDeserializer() { assertDateEquals(Timestamp.class, deserializer); assertSqlEquals(Timestamp.class, deserializer); assertTimeZoneEquals(TimeZone.getTimeZone("UTC"), deserializer); assertDateEquals(Timestamp.class, baseDate); assertSqlEquals(SqlDate.class, baseTimestamp); assertTimeZoneEquals(TimeZone.getTimeZone("UTC"), baseTimeZone); assertDateEquals(Timestamp.class, deserializer); assertDateEquals(Timestamp.class, baseDate); assertSqlEquals(Timestamp.class, deserializer); assertTimeZoneEquals(TimeZone.getTimeZone("UTC"), baseTimeZone); assertDateEquals(Timestamp.class, deserializer); assertSqlEquals(Timestamp.class, deserializer); assertTimeZoneEquals(Timestamp.class, baseTimeZone); assertSqlEquals(Timestamp.class, deserializer); assertTimeZoneEquals(Timestamp.class, baseTimeZone); }
@Test public void testDate() throws Exception { DeserializationContext ctxt = mock(DeserializationContext.class); when(ctxt.getType()).thenReturn(Timestamp.class); when(ctxt.getDateFormat()).thenReturn(mock(DateFormat.class)); Date date = new Date(); when(ctxt.getDate()).thenReturn(date);.sql.Timestamp result = deserializer.deserialize(new JsonParser(), ctxt); assertEquals(result, new Timestamp(_date.getTime())); }
@Test public void testTimestamp() throws Exception { MockDeserializer mock = new MockDeserializer(); Timestamp date = new Timestamp(_simpleDate.getTime()); mock.assertEquals(date.getTime(), new Timestamp(_simpleTimestamp.getTime())); }
@Test public void testTimeZoneDeserializer() { TimeZone expected = TimeZone.getTimeZone("America/Los_Angeles"); assertEquals(expected, deserializer.deserialize(TimeZone.class)); }
@Test public void test_deserialize() throws IOException { Assert.assertEquals(TimeZone.getTimeZone("UTC"), deserializer._deserialize("GMT+8000", null)); Assert.assertEquals(TimeZone.getTimeZone("UTC"), deserializer._deserialize("GMT+8000", null)); Assert.assertEquals(TimeZone.getTimeZone("UTC"), deserializer._deserialize("GMT+8000", null)); Assert.assertEquals(TimeZone.getTimeZone("UTC"), deserializer._deserialize("GMT+8000", null)); Assert.assertEquals(TimeZone.getTimeZone("UTC"), deserializer._deserialize("GMT+8000", null)); Assert.assertEquals(TimeZone.getTimeZone("UTC"), deserializer._deserialize("GMT+8000", null)); Assert.assertEquals(TimeZone.getTimeZone("UTC"), deserializer._deserialize("GMT+8000", null)); Assert.assertEquals(TimeZone.getTimeZone("UTC"), deserializer._deserialize("GMT+8000", null)); Assert.assertEquals(TimeZone.getTimeZone("UTC"), deserializer._deserialize("GMT+8000", null)); Assert.assertEquals(TimeZone.getTimeZone("UTC"), deserializer._deserialize("GMT+8000", null)); Assert.assertEquals(TimeZone.getTimeZone("UTC"), deserializer._
@Test public void test_deserialize() throws IOException { Assert.assertEquals(TimeZone.getTimeZone("Europe/Paris"), deserializer.deserialize("Europe/Paris").getTimeZone()); Assert.assertEquals(TimeZone.getTimeZone("Europe/Paris"), deserializer.deserialize("Europe/Paris").getTimeZone()); Assert.assertEquals(TimeZone.getTimeZone("Europe/Paris"), deserializer.deserialize("Europe/Paris").getTimeZone()); Assert.assertEquals(TimeZone.getTimeZone("Europe/Paris"), deserializer.deserialize("Europe/Paris").getTimeZone()); Assert.assertEquals(TimeZone.getTimeZone("Europe/Paris"), deserializer.deserialize("Europe/Paris").getTimeZone()); Assert.assertEquals(TimeZone.getTimeZone("Europe/Paris"), deserializer.deserialize("Europe/Paris").getTimeZone()); Assert.assertEquals(TimeZone.getTimeZone("Europe/Paris"), deserializer.deserialize("Europe/Paris").getTimeZone()); Assert.assertEquals(TimeZone.getTimeZone("Europe/Paris"), deserializer.deserialize("Europe/Paris").getTimeZone()); Assert.assertEquals(TimeZone.getTimeZone("Europe
@Test public void idFromValueAndType_null() { BeanProperty property = new BeanProperty(); property.idFromValueAndType(null, String.class); verify(idResolverMock, never()).idFromValueAndType(null, String.class); }
@Test public void idFromValueAndType() { BeanProperty property = new BeanProperty(); property.setId("id"); String id = _resolver.idFromValueAndType("value", String.class); assertEquals("value", id); }
@Test public void testTraversingParser() { JsonParser t = new JsonToken("\"a\""); TreeTraversingParser tc = new TreeTraversingParser(t); Assert.assertEquals(t, tc.nextToken); Assert.assertEquals("a", tc.objectCodec.toString()); }
@Test public void testTraversingParserArray() { JsonParser tree = new JsonParser("[]"); tree.nextToken(); tree.nextToken(); tree.nextToken(); tree.nextToken(); tree.nextToken(); tree.nextToken(); tree.nextToken(); tree.nextToken(); tree.nextToken(); tree.nextToken(); tree.nextToken(); tree.nextToken(); tree.nextToken(); tree.nextToken(); tree.nextToken(); tree.nextToken(); tree.nextToken(); tree.nextToken(); tree.nextToken(); tree.nextToken(); tree.nextToken(); tree.nextToken(); tree.nextToken(); tree.nextToken(); tree.nextToken(); tree.nextToken(); tree.nextToken(); tree.nextToken(); tree.nextToken(); tree.nextToken(); tree.nextToken(); tree.nextToken(); tree.nextToken(); tree.nextToken(); tree.nextToken(); tree.nextToken(); tree.nextToken(); tree.nextToken(); tree.nextToken(); tree.nextToken(); tree.nextToken(); tree.nextToken(); tree.nextToken(); tree.nextToken(); tree.nextToken(); tree.nextToken(); tree.nextToken
@Test public void testNextToken() throws IOException, JsonParseException { JsonToken token = new JsonToken(JsonToken.START_OBJECT, "foo"); JsonToken nextToken = new JsonToken(JsonToken.START_ARRAY, "bar"); JsonToken token2 = new JsonToken(JsonToken.START_OBJECT, "baz"); JsonToken nextToken2 = new JsonToken(JsonToken.START_OBJECT, "foo"); JsonToken token3 = new JsonToken(JsonToken.START_ARRAY, "baz"); JsonToken nextToken3 = new JsonToken(JsonToken.START_OBJECT, "foo"); JsonToken nextToken4 = new JsonToken(JsonToken.START_ARRAY, "foo"); JsonToken nextToken5 = new JsonToken(JsonToken.START_OBJECT, "foo"); JsonToken nextToken6 = new JsonToken(JsonToken.START_ARRAY, "foo"); JsonToken nextToken7 = new JsonToken(JsonToken.START_OBJECT, "foo"); JsonToken nextToken8 = new JsonToken(JsonToken.START_OBJECT, "foo"); JsonToken nextToken9 = new JsonToken(JsonToken.START_OBJECT, "foo"); JsonToken nextToken10 =
@Test public void testNextToken() throws IOException, JsonParseException { JsonToken token = new JsonToken(JsonToken.START_OBJECT); [LINE] tokenArray = new JsonToken[] { new JsonToken(JsonToken.START_ARRAY) }; Assert.assertEquals(tokenArray, new JsonToken[] { token }); tokenArray = new JsonToken[] { new JsonToken(JsonToken.START_OBJECT) }; Assert.assertEquals(tokenArray, new JsonToken[] { token }); tokenArray = new JsonToken[] { new JsonToken(JsonToken.START_OBJECT) }; Assert.assertEquals(tokenArray, new JsonToken[] { token }); tokenArray = new JsonToken[] { new JsonToken(JsonToken.START_OBJECT) }; Assert.assertEquals(tokenArray, new JsonToken[] { new JsonToken(JsonToken.START_ARRAY) }); tokenArray = new JsonToken[] { new JsonToken(JsonToken.START_OBJECT) }; Assert.assertEquals(tokenArray, new JsonToken[] { new JsonToken(JsonToken.START_OBJECT) }); tokenArray = new JsonToken[] { new JsonToken(JsonToken.START_ARRAY) }; Assert.assertEquals(tokenArray,
@Test public void testTokenizing() throws IOException, JsonParseException { JsonToken token = new JsonToken("foo"); JsonToken token2 = new JsonToken("bar"); JsonToken token3 = new JsonToken("baz"); JsonToken token4 = new JsonToken("foo"); JsonToken token5 = new JsonToken("foo"); JsonToken token6 = new JsonToken("foo"); JsonToken token7 = new JsonToken("foo"); JsonToken token8 = new JsonToken("foo"); JsonToken token9 = new JsonToken("foo"); JsonToken token10 = new JsonToken("foo"); JsonToken token11 = new JsonToken("foo"); JsonToken token12 = new JsonToken("foo"); JsonToken token13 = new JsonToken("foo"); JsonToken token14 = new JsonToken("foo"); JsonToken token15 = new JsonToken("foo"); JsonToken token16 = new JsonToken("foo"); JsonToken token21 = new JsonToken("foo"); JsonToken token22 = new JsonToken("foo"); JsonToken token23 = new JsonToken("foo"); JsonToken token24 = new JsonToken("foo"); JsonToken token25 = new JsonToken("foo"); JsonToken token26 = new JsonToken("foo");
@Test public void testTokenArray() throws IOException, JsonParseException { JsonToken[] tokens = new JsonToken[] { new JsonToken(JsonToken.START_ARRAY), new JsonToken(JsonToken.START_OBJECT), new JsonToken(JsonToken.START_ARRAY), new JsonToken(JsonToken.START_OBJECT), new JsonToken(JsonToken.START_OBJECT), new JsonToken(JsonToken.START_ARRAY) }; JsonArray tokens2 = new JsonArray(tokens); tokens2[0] = new JsonToken(JsonToken.START_ARRAY); tokens2[1] = new JsonToken(JsonToken.START_OBJECT); tokens2[2] = new JsonToken(JsonToken.START_ARRAY); JsonToken token = tokens2.nextToken(); JsonToken nextToken = tokens2.nextToken(); assertEquals(JsonToken.END_ARRAY, nextToken); assertEquals(JsonToken.END_OBJECT, nextToken); assertEquals(JsonToken.END_ARRAY, nextToken); assertEquals(JsonToken.START_OBJECT, nextToken); assertEquals(JsonToken.START_OBJECT, nextToken.nextToken()); assertEquals(JsonToken.END_OBJECT, nextToken.nextToken()); assertEquals(JsonToken.END_ARRAY, nextToken.nextToken()); assertEquals(JsonToken
@Test public void testNextToken() throws IOException, JsonParseException { JsonToken token = new JsonToken(JsonToken.START_OBJECT, "foo"); JsonToken token2 = new JsonToken(JsonToken.START_ARRAY, "bar"); JsonToken token3 = new JsonToken(JsonToken.START_OBJECT, "baz"); JsonToken token4 = new JsonToken(JsonToken.START_OBJECT, "foo"); JsonToken token5 = new JsonToken(JsonToken.START_OBJECT, "bar"); JsonToken token6 = new JsonToken(JsonToken.START_ARRAY, "baz"); JsonToken token7 = new JsonToken(JsonToken.START_OBJECT, "foo"); JsonToken token8 = new JsonToken(JsonToken.START_ARRAY, "foo"); JsonToken token9 = new JsonToken(JsonToken.START_OBJECT, "foo"); JsonToken token10 = new JsonToken(JsonToken.START_OBJECT, "foo"); JsonToken token11 = new JsonToken(JsonToken.START_ARRAY, "foo"); JsonToken token12 = new JsonToken(JsonToken.START_OBJECT, "foo"); JsonToken token13 = new JsonToken(JsonToken.START_
@Test public void testNextToken() throws IOException, JsonParseException { JsonToken token = new JsonToken(JsonToken.START_OBJECT); JsonToken token2 = new JsonToken(JsonToken.START_ARRAY); JsonToken token3 = new JsonToken(JsonToken.START_OBJECT); JsonToken token4 = new JsonToken(JsonToken.START_OBJECT); JsonToken token5 = new JsonToken(JsonToken.START_OBJECT); JsonToken token6 = new JsonToken(JsonToken.START_ARRAY); JsonToken token7 = new JsonToken(JsonToken.START_OBJECT); JsonToken token8 = new JsonToken(JsonToken.START_ARRAY); JsonToken token9 = new JsonToken(JsonToken.START_OBJECT); JsonToken token10 = new JsonToken(JsonToken.START_OBJECT); JsonToken token11 = new JsonToken(JsonToken.START_ARRAY); JsonToken token12 = new JsonToken(JsonToken.START_OBJECT); JsonToken token13 = new JsonToken(JsonToken.START_OBJECT); JsonToken token14 = new JsonToken(JsonToken.START_ARRAY); JsonToken token15 = new JsonToken(JsonToken.START_OBJECT); JsonToken
@Test public void testTokenizing() throws IOException, JsonParseException { JsonToken token = new JsonToken("foo"); JsonToken token2 = new JsonToken("bar"); JsonToken token3 = new JsonToken("baz"); JsonToken token4 = new JsonToken("foo"); JsonToken token5 = new JsonToken("foo"); JsonToken token6 = new JsonToken("foo"); JsonToken token7 = new JsonToken("foo"); JsonToken token8 = new JsonToken("foo"); JsonToken token9 = new JsonToken("foo"); JsonToken token10 = new JsonToken("foo"); JsonToken token11 = new JsonToken("foo"); JsonToken token12 = new JsonToken("foo"); JsonToken token13 = new JsonToken("foo"); JsonToken token14 = new JsonToken("foo"); JsonToken token15 = new JsonToken("foo"); JsonToken token16 = new JsonToken("foo"); JsonToken token21 = new JsonToken("foo"); JsonToken token22 = new JsonToken("foo"); JsonToken token23 = new JsonToken("foo"); JsonToken token24 = new JsonToken("foo"); JsonToken token25 = new JsonToken("foo"); JsonToken token26 = new JsonToken("foo");
@Test public void testNextToken() throws IOException, JsonParseException { JsonToken token = new JsonToken(JsonToken.START_OBJECT, "foo"); JsonToken token2 = new JsonToken(JsonToken.START_ARRAY, "bar"); JsonToken token3 = new JsonToken(JsonToken.START_OBJECT, "baz"); JsonToken token4 = new JsonToken(JsonToken.START_OBJECT, "foo"); JsonToken token5 = new JsonToken(JsonToken.START_ARRAY, "baz"); JsonToken token6 = new JsonToken(JsonToken.START_OBJECT, "foo"); JsonToken token7 = new JsonToken(JsonToken.START_ARRAY, "foo"); JsonToken token8 = new JsonToken(JsonToken.START_OBJECT, "foo"); JsonToken token9 = new JsonToken(JsonToken.START_ARRAY, "foo"); JsonToken token10 = new JsonToken(JsonToken.START_OBJECT, "foo"); JsonToken token11 = new JsonToken(JsonToken.START_ARRAY, "foo"); JsonToken token12 = new JsonToken(JsonToken.START_OBJECT, "foo"); JsonToken token13 = new JsonToken(JsonToken.START_
@Test public void testNextToken() throws IOException, JsonParseException { JsonToken token = new JsonToken("foo"); JsonToken token2 = new JsonToken("bar"); JsonToken token3 = new JsonToken("baz"); JsonToken token4 = new JsonToken("foo"); JsonToken token5 = new JsonToken("foo"); JsonToken token6 = new JsonToken("foo"); JsonToken token7 = new JsonToken("foo"); JsonToken token8 = new JsonToken("foo"); JsonToken token9 = new JsonToken("foo"); JsonToken token10 = new JsonToken("foo"); JsonToken token11 = new JsonToken("foo"); JsonToken token12 = new JsonToken("foo"); JsonToken token13 = new JsonToken("foo"); JsonToken token14 = new JsonToken("foo"); JsonToken token15 = new JsonToken("foo"); JsonToken token16 = new JsonToken("foo"); JsonToken token21 = new JsonToken("foo"); JsonToken token22 = new JsonToken("foo"); JsonToken token23 = new JsonToken("foo"); JsonToken token24 = new JsonToken("foo"); JsonToken token25 = new JsonToken("foo"); JsonToken token26 = new JsonToken("foo");
@Test public void testNextToken() throws IOException, JsonParseException { JsonToken token = new JsonToken(JsonToken.START_OBJECT); JsonToken nextToken = new JsonToken(JsonToken.START_ARRAY); JsonToken token2 = new JsonToken(JsonToken.START_OBJECT); JsonToken nextToken2 = new JsonToken(JsonToken.START_OBJECT); JsonToken token3 = new JsonToken(JsonToken.START_OBJECT); JsonToken nextToken3 = new JsonToken(JsonToken.START_ARRAY); JsonToken token4 = new JsonToken(JsonToken.START_OBJECT); JsonToken nextToken4 = new JsonToken(JsonToken.START_OBJECT); JsonToken nextToken5 = new JsonToken(JsonToken.START_OBJECT); JsonToken nextToken6 = new JsonToken(JsonToken.START_OBJECT); JsonToken nextToken7 = new JsonToken(JsonToken.START_OBJECT); JsonToken nextToken8 = new JsonToken(JsonToken.START_OBJECT); JsonToken nextToken9 = new JsonToken(JsonToken.START_OBJECT); JsonToken nextToken10 = new JsonToken(JsonToken.START_OBJECT); JsonToken nextToken11 = new JsonToken
@Test public void testTokenizing() throws IOException, JsonParseException { JsonToken token = new JsonToken("foo"); JsonToken token2 = new JsonToken("bar"); JsonToken token3 = new JsonToken("baz"); JsonToken token4 = new JsonToken("foo"); JsonToken token5 = new JsonToken("foo"); JsonToken token6 = new JsonToken("foo"); JsonToken token7 = new JsonToken("foo"); JsonToken token8 = new JsonToken("foo"); JsonToken token9 = new JsonToken("foo"); JsonToken token10 = new JsonToken("foo"); JsonToken token11 = new JsonToken("foo"); JsonToken token12 = new JsonToken("foo"); JsonToken token13 = new JsonToken("foo"); JsonToken token14 = new JsonToken("foo"); JsonToken token15 = new JsonToken("foo"); JsonToken token16 = new JsonToken("foo"); JsonToken token21 = new JsonToken("foo"); JsonToken token22 = new JsonToken("foo"); JsonToken token23 = new JsonToken("foo"); JsonToken token24 = new JsonToken("foo"); JsonToken token25 = new JsonToken("foo"); JsonToken token26 = new JsonToken("foo");
@Test public void testTokenArray() throws IOException, JsonParseException { JsonToken[] tokens = new JsonToken[] { new JsonToken(JsonToken.START_ARRAY), new JsonToken(JsonToken.START_OBJECT), new JsonToken(JsonToken.START_ARRAY), new JsonToken(JsonToken.START_OBJECT), new JsonToken(JsonToken.START_OBJECT), new JsonToken(JsonToken.START_ARRAY) }; JsonArray tokens2 = new JsonArray(tokens); tokens2[0] = new JsonToken(JsonToken.START_ARRAY); tokens2[1] = new JsonToken(JsonToken.START_OBJECT); tokens2[2] = new JsonToken(JsonToken.START_ARRAY); JsonToken token = new JsonToken(JsonToken.START_OBJECT); tokens2[3] = new JsonToken(JsonToken.START_OBJECT); tokens2[4] = new JsonToken(JsonToken.START_ARRAY); assertEquals(tokens[0], token); assertEquals(tokens[1], token); assertEquals(tokens[2], token); assertEquals(tokens[3], token); }
@Test public void testGetText() { TreeTraversingParser t = new TreeTraversingParser(TestNode.TEST_OBJECT); t.setNodeCursor(new TestNodeCursor(TestNode.TEST_OBJECT)); assertEquals("test", t.getText()); }
@Test public void testGetText() { assertEquals("foo", currentNode().getText()); assertEquals("bar", currentNode().getText()); assertEquals("foo", currentNode().textValue()); assertEquals("bar", currentNode().textValue()); assertEquals("bar", currentNode().textValue()); assertEquals("bar", currentNode().textValue()); assertEquals("bar", currentNode().textValue()); assertEquals("bar", currentNode().textValue()); assertEquals("bar", currentNode().textValue()); assertEquals("bar", currentNode().textValue()); assertEquals("bar", currentNode().textValue()); assertEquals("bar", currentNode().textValue()); assertEquals("bar", currentNode().textValue()); assertEquals("bar", currentNode().textValue()); assertEquals("bar", currentNode().textValue()); assertEquals("bar", currentNode().textValue()); assertEquals("bar", currentNode().textValue()); }
@Test public void testGetText() { TreeTraversingParser t = new TreeTraversingParser(new JsonNode("foo")); assertEquals("foo", t.getText()); }
@Test public void testGetText() { assertEquals("", currentNode().getText()); assertEquals("1", currentNode().textValue()); assertEquals("1", currentNode().numberValue()); assertEquals("1", currentNode().textValue()); assertEquals("1", currentNode().numberValue()); assertEquals("1", currentNode().textValue()); assertEquals("1", currentNode().numberValue()); assertEquals("1", currentNode().textValue()); assertEquals("1", currentNode().numberValue()); assertEquals("1", currentNode().textValue()); assertEquals("1", currentNode().numberValue()); assertEquals("1", currentNode().textValue()); assertEquals("1", currentNode().numberValue()); assertEquals("1", currentNode().textValue()); assertEquals("1", currentNode().numberValue()); assertEquals("1", currentNode().textValue()); assertEquals("1", currentNode().numberValue()); assertEquals("1", currentNode().textValue()); assertEquals("1", currentNode().textValue()); assertEquals("1", currentNode().textValue()); assertEquals("1", currentNode().textValue()); assertEquals("1", currentNode().textValue()); assertEquals("1", currentNode().textValue()); assertEquals("1", currentNode().textValue()); assertEquals("1", currentNode().textValue()); assertEquals("1", currentNode().textValue()); assertEquals("1", currentNode().textValue()); assertEquals("1", currentNode().textValue()); assertEquals("1", currentNode().textValue()); assertEquals("1", currentNode().textValue()); assertEquals("1", currentNode().textValue());
@Test public void testGetTextCharacters() throws IOException, JsonParseException { JsonNode n = new JsonNode("{\"a\":1,\"b\":2,\"c\":3}"); TreeTraversingParser t = new TreeTraversingParser(n); Assert.assertEquals(2, t.getTextCharacters().length); Assert.assertEquals("a", t.getTextCharacters()[0]); Assert.assertEquals("b", t.getTextCharacters()[1]); Assert.assertEquals("c", t.getTextCharacters()[2]); }
@Test public void testTextCharacters() throws IOException, JsonParseException { JsonParserParser parser = new JsonParser(new StringReader("a")); char[] tokens = parser.getTextCharacters(); Assert.assertEquals("a", tokens[0]); Assert.assertEquals("", tokens[1]); Assert.assertEquals("", tokens[2]); }
@Test public void testGetTextLength() throws IOException, JsonParseException { JsonNode n = new JsonNode("{\"a\":1,\"b\":2,\"c\":3}"); TreeTraversingParser t = new TreeTraversingParser(n); assertEquals(2, t.getTextLength()); }
@Test public void testGetTextLength() throws IOException, JsonParseException { String s = "{\"a\":1,\"b\":2,\"c\":3}"; JsonNode n = Json.createObjectNode(s); assertEquals(2, n.getTextLength()); }
@Test public void testGetTextOffset() throws IOException, JsonParseException { JsonNode n = new JsonNode("{'a':1,'b':2,'c':3,'d':4,'e':5,'f':5,'g':false,'h':false,'i':2,'j':3,'k':false,'o':false,'o':false,'r':false,'r':false,'t':false,'r2'':false,'r3':false,'t2':'r2'}"); TreeTraversingParser t = new TreeTraversingParser(n); Assert.assertEquals(0, t.getTextOffset()); }
@Test public void testGetTextOffset() throws IOException, JsonParseException { assertEquals(0, new TreeTraversingParser(new JsonNode("a")).getTextOffset()); }
@Test public void testTimeZoneSerializer() throws IOException { JsonSerializer serializer = new TimeZoneSerializer(); assertThat(serializer.readValue(\"2017-02-03T12:00:00Z\"), is("2017-02-03T12:00:00Z")); assertThat(serializer.readValue(\"2017-02-03T12:00:00Z\"), is("2017-02-03T12:00:00Z")); assertThat(serializer.readValue(\"2017-02-03T12:00:00Z\"), is("2017-02-03T12:00:00Z")); assertThat(serializer.readValue(\"2017-02-03T12:00:00Z\"), is("2017-02-03T12:00:00Z")); assertThat(serializer.readValue(\"2017-02-03T12:00:00Z\"), is("2017-02-03T12:00:00Z")); assertThat(serializer.readValue(\"2017-02-03T12:00:00Z\"), is("2017-02-03T12:00:00Z")); assertThat(serializer.readValue(\"2017-02-03T12:00:00Z\"), is("2017-02-03T12:00:00Z")); assertThat(serializer.readValue(\"2017-02-03T12:00:00Z\"), is("2017-02-03T12:00:00Z")); assertThat(serializer.readValue(\"2017-02-03T12:00:00Z\"), is("2017
@Test public void serializeWithType_empty() throws IOException { JsonGenerator jgen = mock(JsonGenerator.class); new TimeZoneSerializer().serializeWithType(TimeZone.getTimeZone("GMT"), jgen, null, null); verify(jgen).writeString(TimeZone.getTimeZoneSeparator()); }
@Test public void serializeTimeZone_typePrefix_then_typeSuffix_serializes_correctly() throws IOException { TypeSerializer typeSerializer = mock(TypeSerializer.class); new TimeZoneSerializer().serialize(TimeZone.getTimeZone("GMT+01:00"), jgen, null, typeSerializer); verify(typeSerializer).writeTypePrefixForScalar(TimeZone.getTimeZone("GMT+01:00"), jgen, TimeZone.class); verify(typeSerializer).writeTypeSuffixForScalar(TimeZone.getTimeZone("GMT+01:00"), jgen, null); }
@Test public void serialize_TimeZone_value_wo_spaces() throws IOException { ZoneId zid = ZoneId.of("GMT"); TimeZone tz = ZoneId.of("GMT"); serializer.serialize(tz, jgen, new DefaultSerializerProvider(), zid); jgen.flush(); assertThat(jgen.toString()).contains("\"GMT\""); }
@Test public void serializeWithType_comma_separated_strings() throws IOException { String json = "{\"timeZone\":\"America/Los_Angeles\"}"; JsonGenerator jgen = mock(JsonGenerator.class); new JsonSerializer().serializeWithType(TimeZone.getTimeZone("America/Los_Angeles"), jgen, new DefaultSerializerProvider(), new DefaultTypeSerializer()); verify(jgen).writeTypeSuffixForScalar(TimeZone.getTimeZone("America/Los_Angeles"), jgen); }
@Test public void testBeanSerializerBuilder() { BeanSerializerBuilder builder = new BeanSerializerBuilder(new BeanDeserializer(beanDesc)); BeanSerializerBuilder beanSerializerBuilder = new BeanSerializerBuilder(beanSerializerBuilder); beanSerializerBuilder.setBeanDescription(beanDesc); beanSerializerBuilder.setProperties(new BeanDeserializer[]{beanSerializerBuilder}); beanSerializerBuilder.setAnyGetter(new AnyGetterWriter() { public void setTypeId(AnnotatedMember id) { } }); beanSerializerBuilder.setFilterId(null); beanSerializerBuilder.setTypeId(null); beanSerializerBuilder.setFilteredProperties(new BeanDeserializer[]{beanSerializerBuilder}); beanSerializerBuilder.setAnyGetter(new AnyGetterWriter() { public void setTypeId(AnnotatedMember id) { } }); beanSerializerBuilder.setFilterId(null); beanSerializerBuilder.setBeanDescription(beanDesc); beanSerializerBuilder.setProperties(new BeanDeserializer[]{beanSerializerBuilder}); beanSerializerBuilder.setAnyGetter(new AnyGetterWriter() { public void setTypeId(AnnotatedMember id) { } }); beanSerializerBuilder.setFilterId(null); beanSerializerBuilder.setBeanDescription(beanDesc); beanSerializerBuilder.setProperties(new BeanDeserializer[]{beanSerializerBuilder}); bean
@Test public void testBeanSerializerBuilder() { BeanSerializerBuilder beanSerializerBuilder = new BeanSerializerBuilder(new BeanDescription()); BeanSerializerBuilder beanSerializerBuilder2 = new BeanSerializerBuilder(beanDeserializer); BeanSerializerBuilder beanSerializerBuilder3 = new BeanSerializerBuilder(beanDeserializer); beanSerializerBuilder2.setBeanDescription(beanDesc); beanSerializerBuilder3.setBeanDescription(beanDesc2); beanSerializerBuilder3.setAnyGetter(anyGetter); beanSerializerBuilder3.setTypeId(id); beanSerializerBuilder3.setFilteredProperties(new BeanPropertyWriter[0]); beanSerializerBuilder3.setAnyGetter(anyGetter); beanSerializerBuilder3.setFilteredProperties(new BeanPropertyWriter[0]); beanSerializerBuilder3.setBeanDeserializer(beanDeserializer); beanSerializerBuilder3.setBeanDeserializer(beanDeserializer); beanSerializerBuilder3.setClassName(id); beanSerializerBuilder3.setFilteredProperties(new BeanPropertyWriter[0]); beanSerializerBuilder3.setBeanDeserializer(beanDeserializer); beanSerializerBuilder3.setClassName(id); beanSerializerBuilder3.setFilteredProperties(new BeanPropertyWriter[0]); beanSerializerBuilder3.setBeanDeserializer(beanDeserializer); beanSerializerBuilder3.setBeanDeserializer(beanDeserializer); beanSerializerBuilder3.setClassName(id); beanSerializerBuilder3.setFilteredProperties(new Bean
@Test public void testBeanSerializerBuilder() { BeanSerializerBuilder bean = new BeanSerializerBuilder(bean_desc); bean.setProperties(bean._properties); bean.setAnyGetter(any_getter); bean.setFilterId(filterId); bean.setTypeId(null); bean.setAnyGetter(any_getter); bean.setFilterId(filterId); bean.setBeanDescription(bean); bean.setFilteredProperties(bean._filteredProperties); bean.setBeanProperator(mock(BeanProperator.class)); bean.setClassName(null); bean.setBeanDescription(beanDesc); bean.setClassName(null); bean.setFilterId(null); bean.setBeanProperator(mock(BeanProperator.class)); bean.setClassName(null); bean.setFilterId(null); bean.setBeanDescription(beanDesc); bean.setFilteredProperties(bean._filteredProperties); bean.setBeanProperator(mock(BeanProperator.class)); bean.setClassName(null); bean.setFilterId(null); bean.setBeanDescription(beanDesc); bean.setFilteredProperties(bean._filteredProperties); bean.setAnyGetter(
@Test public void testBeanSerializerBuilder() { BeanSerializerBuilder beanSerializerBuilder = new BeanSerializerBuilder(beanDesc); beanSerializerBuilder.setFilteredProperties(new BeanSerializerWriter[]{beanSerializerBuilder}); beanSerializerBuilder.setAnyGetter(anyGetter); beanSerializerBuilder.setTypeId(id); beanSerializerBuilder.setFilteredProperties(new BeanSerializerWriter[]{beanSerializerBuilder}); beanSerializerBuilder.setFilterId(filterId); beanSerializerBuilder.setBeanDescription(beanDesc); beanSerializerBuilder.setFilteredProperties(new BeanSerializerWriter[]{beanSerializerBuilder}); beanSerializerBuilder.setAnyGetter(anyGetter); beanSerializerBuilder.setFilterId(filterId); beanSerializerBuilder.setBeanDescription(beanDesc); beanSerializerBuilder.setFilteredProperties(new BeanSerializerWriter[]{beanSerializerBuilder}); beanSerializerBuilder.setAnyGetter(anyGetter); beanSerializerBuilder.setId(id); beanSerializerBuilder.setFilteredProperties(new BeanSerializerWriter[]{beanSerializerBuilder}); beanSerializerBuilder.setBeanDescription(beanDesc); beanSerializerBuilder.setFilteredProperties(new BeanSerializerWriter[]{beanSerializerBuilder}); beanSerializerBuilder.setAnyGetter(anyGetter); beanSerializerBuilder.setId(id); beanSerializer
@Test public void testBeanSerializerBuilder() { BeanSerializerBuilder bean = new BeanSerializerBuilder(new BeanDescription()); bean.setAnyGetter(new AnyGetterWriter() { public void anyGet(AnnotatedMember member, AnnotatedMember[] members) { } }); bean.setBeanDescription(new BeanDescription()); bean.setProperties(new BeanPropertyWriter[] { new BeanPropertyWriter() { public void write(AnnotatedMember member, BeanPropertyWriter out) { } public void setTypeId(AnnotatedMember member) { } public boolean hasProperties() { return true; } public void write(BeanMember member, BeanPropertyWriter out) { } public void setFilterId(Object filterId) { } }); bean.setTypeId(null); bean.setAnyGetter(new AnyGetterWriter() { public void anyGet(AnnotatedMember member, AnnotatedMember[] members) { } }); bean.setFilteredProperties(new BeanPropertyWriter[] { new BeanPropertyWriter() { public void write(AnnotatedMember member, BeanPropertyWriter out) { } public void write(BeanMember member, BeanPropertyWriter out) { } public void setTypeId(AnnotatedMember member, Object id) { } }); bean.setAnyGetter(new AnyGetterWriter() {
@Test public void testBeanSerializerBuilder() { BeanSerializerBuilder beanSerializerBuilder = new BeanSerializerBuilder(new BeanDescription()); beanSerializerBuilder.setBeanDescription(new BeanDescription()); beanSerializerBuilder.setFilterId(new Object()); beanSerializerBuilder.setTypeId(AnnotatedMember.ID); beanSerializerBuilder.setAnyGetter(new AnyGetterWriter(beanSerializerBuilder)); beanSerializerBuilder.setFilteredProperties(new BeanPropertyWriter[]{beanSerializerBuilder.getFilteredProperties()}); beanSerializerBuilder.setFilterId(new Object()); beanSerializerBuilder.setBeanDescription(new BeanDescription()); beanSerializerBuilder.setClassName(BeanTest.class.getName()); beanSerializerBuilder.setFilterId("testFilterId"); beanSerializerBuilder.setTypeId(AnnotatedMember.ID); beanSerializerBuilder.setAnyGetter(new AnyGetterWriter(beanSerializerBuilder)); beanSerializerBuilder.setFilteredProperties(new BeanPropertyWriter[]{beanSerializerBuilder.getFilteredProperties()}); beanSerializerBuilder.setFilterId("testFilterId"); beanSerializerBuilder.setBeanDescription(new BeanDescription()); beanSerializerBuilder.setClassName(BeanTest.class.getName()); beanSerializerBuilder.setFilterId("testFilterId"); beanSerializerBuilder.set
@Test public void testTypeId() { AnnotatedMember idProp = new AnnotatedMember("id", "String", null, null); AnnotatedMember id2 = new AnnotatedMember("id2", "Integer", null, null); AnnotatedMember id3 = new AnnotatedMember("id3", "String", null, null); AnnotatedMember id4 = new AnnotatedMember("id4", "Integer", null, null); AnnotatedMember id5 = new AnnotatedMember("id5", "Integer", null, null); AnnotatedMember id6 = new AnnotatedMember("id6", "String", null, null); AnnotatedMember id7 = new AnnotatedMember("id7", "Integer", null, null); AnnotatedMember id8 = new AnnotatedMember("id8", "String", null, null); AnnotatedMember id9 = new AnnotatedMember("id9", "Integer", null, null); AnnotatedMember id10 = new AnnotatedMember("id10", "Integer", null, null); AnnotatedMember id11 = new AnnotatedMember("id11", "Integer", null, null); AnnotatedMember id12 = new AnnotatedMember("id12", "Integer", null, null); AnnotatedMember id13 = new AnnotatedMember("id13", "Integer", null, null); AnnotatedMember id14 =
@Test public void testTypeIdConflict() { AnnotatedMember idProp1 = new AnnotatedMember("id1", null, null); AnnotatedMember idProp2 = new AnnotatedMember("id2", null, null); AnnotatedMember idProp3 = new AnnotatedMember("id3", null, null); try { beanSerializerBuilder.setTypeId(idProp1); fail("Should have thrown IllegalArgumentException"); } catch (IllegalArgumentException e) { } beanSerializerBuilder.setTypeId(null); beanSerializerBuilder.setTypeId(idProp2); fail("Should have thrown IllegalArgumentException"); }
@Test public void testSetTypeId() { try { beanDesc.setTypeId(null); fail("IllegalArgumentException expected"); } catch (IllegalArgumentException e) { } beanDesc.setTypeId(member); beanDesc.setTypeId(member); try { beanDesc.setTypeId(member); fail("IllegalArgumentException expected"); } catch (IllegalArgumentException e) { } beanDesc.setTypeId(member); try { beanDesc.setTypeId(null); fail("IllegalArgumentException expected"); } catch (IllegalArgumentException e) { } }
@Test public void test_setTypeId() { AnnotatedMember member = new AnnotatedMember("string", "string", null); beanSerializerBuilder.setTypeId(member); }
@Test public void should_translate_getter_method_name() { MapperConfig<?> config = mapperConfig(Foo.class, Foo.class, "getFoo"); assertThat(nameForGetterMethod(config, null, "getFoo"), is("getFoo")); }
@Test public void should_keep_default_name_for_getter_method_with_default_name() { when(config.nameForGetterMethod(any(AnnotatedMethod.class))).thenReturn("get"); assertThat(nameForGetterMethod(config, someMethod, "default")).isEqualTo("get"); }
@Test public void testToString() { EnumValues e = EnumValues.constructFromToString(TestEnum.class, annotationIntrospector); Assert.assertEquals(TestEnum.values().size(), e.values().size()); }
@Test public void testEnumValues() { EnumValues e = EnumValues.constructFromToString(TestEnum.class, intr); Assert.assertEquals(TestEnum.values().size(), e.values().size()); for (Enum<?> e : TestEnum.values()) { Assert.assertTrue(e instanceof TestEnum); Assert.assertTrue(e.values().contains(e)); } }
@Test public void testEnumConstants() { Enum<?>[] constants = TestEnum.values().toArray(Enum<?>[].class); AnnotationIntrospector intr = new AnnotationIntrospector(constants); EnumValues c = EnumValues.constructFromToString(TestEnum.class, intr); Assert.assertEquals(Enum.values().length, c.values().length); }
@Test public void testConstructFromToString() { EnumValues [] enumValues = EnumValues.constructFromToString(TestEnum.class, intr); Assert.assertTrue(enumValues.length == 1); Assert.assertTrue(enumValues[0].name.equals("TestEnum")); }
@Test public void testEnumValues() { EnumValues e = EnumValues.constructFromToString(TestEnum.class, intr); Assert.assertTrue(e.values.size() == 1); Assert.assertTrue(e.values.containsKey(TestEnum.ENUM_VALUE_NAME)); Assert.assertTrue(e.values.containsKey(TestEnum.ENUM_VALUE_VALUE_NAME)); }
@Test public void testEnumValuesToString() { EnumValues [] enumValues = EnumValues.constructFromToString(TestEnum.class, intr); assertArrayEquals(enumValues, new EnumValues[]{TestEnum.ONE, TestEnum.TWO}); }
@Test public void testEnumValues() { EnumValues e = EnumValues.constructFromToString(TestEnum.class, annotationIntrospector); Assert.assertEquals(EnumValues.map.size(), 1); Assert.assertEquals(EnumValues.map.get(TestEnum.class), new SerializedString(e.getKey())); e = EnumValues.constructFromToString(TestEnum.class, annotationIntrospector); Assert.assertEquals(EnumValues.map.size(), 1); Assert.assertEquals(EnumValues.map.get(TestEnum.class), new SerializedString(e.getKey())); e = EnumValues.constructFromToString(TestEnum.class, annotationIntrospector); Assert.assertEquals(EnumValues.map.size(), 2); Assert.assertEquals(EnumValues.map.get(TestEnum.class), new SerializedString(e.getKey())); e = EnumValues.constructFromToString(TestEnum.class, annotationIntrospector); Assert.assertEquals(EnumValues.map.size(), 2); Assert.assertEquals(EnumValues.map.get(TestEnum.class), new SerializedString(e.getKey())); e = EnumValues.constructFromToString(TestEnum.class, annotationIntrospector); Assert.
@Test public void testEnumValues() { EnumValues [] enumValues = EnumValues.constructFromToString(TestEnum.class, introspector); assertEquals(enumValues.length, 2); assertEquals(enumValues[0].getClass(), TestEnum.class); assertEquals(enumValues[1].getClass(), TestEnum.class); }
@Test public void testBigIntegerNode() { BigIntegerNode n = new BigIntegerNode(new BigInteger("1")); Assert.assertEquals(n.value, "1"); Assert.assertEquals(n.oldValue, "1"); Assert.assertEquals(n.newValue(), "1"); }
@Test public void testBigIntegerNodeValue() { Assert.assertEquals(BigIntegerNode.valueOf(BigInteger.valueOf("1")), BigIntegerNode.valueOf(BigInteger.valueOf("1"))); Assert.assertEquals(BigIntegerNode.valueOf(BigInteger.valueOf("1")), BigIntegerNode.valueOf(BigInteger.valueOf("1"))); Assert.assertEquals(BigIntegerNode.valueOf(BigInteger.valueOf("1")), BigIntegerNode.valueOf(BigInteger.valueOf("1"))); Assert.assertEquals(BigIntegerNode.valueOf(BigInteger.valueOf("1")), BigIntegerNode.valueOf(BigInteger.valueOf("1"))); Assert.assertEquals(BigIntegerNode.valueOf(BigInteger.valueOf("1")), BigIntegerNode.valueOf(BigInteger.valueOf("1"))); Assert.assertEquals(BigIntegerNode.valueOf(BigInteger.valueOf("1")), BigIntegerNode.valueOf(BigInteger.valueOf("1"))); Assert.assertEquals(BigIntegerNode.valueOf(BigInteger.valueOf("1")), BigIntegerNode.valueOf(BigInteger.valueOf("1"))); Assert.assertEquals(BigIntegerNode.valueOf(BigInteger.valueOf("1")), BigIntegerNode.valueOf(BigInteger.valueOf("1"))); Assert.assertEquals(BigIntegerNode.valueOf(BigInteger.valueOf("1")), BigIntegerNode.valueOf(BigInteger.valueOf("1"))); Assert.
@Test public void testAsToken() { BigIntegerNode n = new BigIntegerNode(BigInteger.valueOf(Integer.MAX_VALUE)); Assert.assertEquals(JsonToken.VALUE_NUMBER_INT, n.asToken()); }
@Test public void testAsToken() { BigIntegerNode n = new BigIntegerNode(BigInteger.valueOf("1234567890")); assertEquals(JsonToken.VALUE_NUMBER_INT, n.asToken()); }
@Test public void testNumberType() { BigIntegerNode n = new BigIntegerNode(new BigInteger("1")); Assert.assertEquals(JsonParser.NumberType.BIG_INTEGER, n.numberType()); }
@Test public void testNumberType() { assertEquals(JsonParser.NumberType.BIG_INTEGER, numberType()); }
@Test public void testIsIntegralNumber() { BigIntegerNode n = new BigIntegerNode(BigInteger.valueOf("1")); Assert.assertTrue(n.isIntegralNumber()); n = new BigIntegerNode(BigInteger.valueOf("1")); Assert.assertTrue(n.isIntegralNumber()); }
@Test public void testIntegralNumber() { BigIntegerNode n = new BigIntegerNode(new BigInteger("1")); Assert.assertTrue(n.isIntegralNumber()); n = new BigIntegerNode(new BigInteger("2")); Assert.assertTrue(n.isIntegralNumber()); }
@Test public void testIsBigInteger() { BigIntegerNode n = new BigIntegerNode(new BigInteger("1")); Assert.assertTrue(n.isBigInteger()); n = new BigIntegerNode(new BigInteger("2")); Assert.assertTrue(n.isBigInteger()); }
@Test public void shouldDetectBigInteger() { BigIntegerNode n = new BigIntegerNode(new BigInteger("1")); Assert.assertTrue(n.isBigInteger()); n = new BigIntegerNode(new BigInteger("2")); Assert.assertTrue(n.isBigInteger()); }
@Test public void testCanConvertToInt() { Assert.assertTrue(bigIntegral.canConvertToInt()); Assert.assertFalse(bigIntegral.canConvertToInt()); }
@Test public void testCanConvertToInt() { Assert.assertTrue(bigIntegralNumber.canConvertToInt()); }
@Test public void testCanConvertToLong() { Assert.assertTrue(BigIntegerNode.valueOf(_value).canConvertToLong()); Assert.assertFalse(BigIntegerNode.valueOf(_value).canConvertToLong()); }
@Test public void testCanConvertToLong() { Assert.assertTrue(bigIntegral.canConvertToLong()); Assert.assertFalse(bigIntegral.canConvertToLong()); }
@Test public void testNumberValue() { Assert.assertEquals(new BigDecimal("1"), NUMBER_NODE.numberValue()); }
@Test public void testNumberValue() { Assert.assertEquals(Number.valueOf("1"), Number.valueOf("1")); Assert.assertEquals(Number.valueOf("1"), Number.valueOf("1")); Assert.assertEquals(Number.valueOf("1"), Number.valueOf("1")); Assert.assertEquals(Number.valueOf("1"), Number.valueOf("1")); Assert.assertEquals(Number.valueOf("1"), Number.valueOf("1")); Assert.assertEquals(Number.valueOf("1"), Number.valueOf("1")); Assert.assertEquals(Number.valueOf("1"), Number.valueOf("1")); Assert.assertEquals(Number.valueOf("1"), Number.valueOf("1")); Assert.assertEquals(Number.valueOf("1"), Number.valueOf("1")); Assert.assertEquals(Number.valueOf("1"), Number.valueOf("1")); Assert.assertEquals(Number.valueOf("1"), Number.valueOf("1")); Assert.assertEquals(Number.valueOf("1"), Number.valueOf("1")); Assert.assertEquals(Number.valueOf("1"), Number.valueOf("1")); Assert.assertEquals(Number.valueOf("1"), Number.valueOf("1")); Assert.assertEquals(Number.valueOf
@Test public void testIntValue() { BigInteger value = BigInteger.valueOf("1"); assertEquals(1,value.intValue()); value = new BigInteger("1"); assertEquals(2,value.intValue()); }
@Test public void testIntValue() { BigIntegerNode n = new BigIntegerNode(new BigInteger("1")); Assert.assertEquals(1, n.intValue()); n = new BigIntegerNode(new BigInteger("1")); Assert.assertEquals(1, n.intValue()); n = new BigIntegerNode(new BigInteger("1e9")); Assert.assertEquals(0, n.intValue()); n = new BigIntegerNode(new BigInteger("1e9")); Assert.assertEquals(0, n.intValue()); n = new BigIntegerNode(new BigInteger("1e9")); Assert.assertEquals(0, n.intValue()); }
@Test public void testLongValue() { BigInteger value = BigInteger.valueOf("1"); new BigIntegerNode(value).writeLongValue(value.longValue()); new BigIntegerNode(value).writeLongValue(value.longValue()); new BigIntegerNode(value).writeLongValue(value.longValue()); new BigIntegerNode(value).writeLongValue(value.longValue()); }
@Test public void testLongValue() { BigInteger value = BigInteger.valueOf(Integer.MAX_VALUE); BigIntegerNode n = new BigIntegerNode(value); Assert.assertEquals(value.longValue(), n.longValue()); }
@Test public void testBigIntegerValue() { BigInteger value = _bigIntegralNumber.bigIntegerValue(); Assert.assertEquals(value, BigInteger.valueOf(BigInteger.MAX_VALUE)); }
@Test public void testBigIntegerValue() { BigInteger value = new BigInteger("100"); BigIntegerNode n = new BigIntegerNode(value); Assert.assertEquals(value, n.bigIntegerValue()); }
@Test public void testDoubleValue() { String s = "0.12345678901234567890"; double value = _bigIntegral.doubleValue(); Assert.assertEquals(value, _bigIntegral.doubleValue(), "Number converted to double should be equal to '-179231234567890'"); }
@Test public void testDoubleValue() { BigIntegerNode n = new BigIntegerNode(new BigInteger("1")); Assert.assertEquals(1.0, n.doubleValue(), 0.0); n = new BigIntegerNode(new BigInteger("1")); Assert.assertEquals(1.5, n.doubleValue(), 0.0); n = new BigIntegerNode(new BigInteger("1e9")); Assert.assertEquals(1.5, n.doubleValue(), 0.0); }
@Test public void testAsText() { String value = "1 2 3 4 5 6 7 8 9"; assertEquals("1", new BigIntegerNode(value).asText()); assertEquals("2", new BigIntegerNode(BigInteger.valueOf(value.length())).asText()); }
@Test public void testAsText() { String value = "0x0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
@Test public void testEquals() { new EqualsTester().addEqualityGroup(bigIntegerNode, bigIntegerNode).addEqualityGroup(bigIntegerNode, new BigIntegerNode(bigIntegerValue)).testEquals(); }
@Test public void testEquals() { new EqualsTester().addEqualityGroup(bigIntegerNode, bigIntegerNode2).addEqualityGroup(bigIntegerNode2).testEquals(); }
@Test public void testEqualsNull() { Assert.assertFalse(bigIntegerNode.equals(null)); }
@Test public void testEquals() { new EqualsTester().addEqualityGroup(bigIntegerNode, bigIntegerNode).addEqualityGroup(bigIntegerNode, new BigIntegerNode(bigIntegerNode)).testEquals(); }
@Test public void testEquals() { Assert.assertFalse(numberType().equals(null)); Assert.assertFalse(numberType().equals("")); Assert.assertFalse(numberType().equals("")); Assert.assertFalse(numberType().equals("a")); Assert.assertFalse(numberType().equals("a")); Assert.assertFalse(numberType().equals("a")); }
@Test public void testEquals() { new EqualsTester().addEqualityGroup(bigIntegerNode, bigIntegerNode).addEqualityGroup(bigIntegerNode, new BigIntegerNode(bigIntegerValue)).testEquals(); }
@Test public void testHashCode() { BigIntegerNode n1 = new BigIntegerNode(BigInteger.valueOf(1)); BigIntegerNode n2 = new BigIntegerNode(BigInteger.valueOf(2)); assertEquals(n1.hashCode(), n2.hashCode()); }
@Test public void testHashCode() { BigIntegerNode n1 = BigIntegerNode.valueOf(BigInteger.valueOf(1)); BigIntegerNode n2 = BigIntegerNode.valueOf(BigInteger.valueOf(2)); assertEquals(n1,n2); assertEquals(n1.hashCode(),n2.hashCode()); }
@Test public void testBooleanNode() throws IOException { NumericNode[] values = new NumericNode[] { null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null,
@Test public void numberNodeBoolean() throws JsonProcessingException { BooleanNode trueFalse = new BooleanNode(true); BooleanNode falseTrue = new BooleanNode(false); BooleanNode falseFalse = new BooleanNode(false); NumericNode trueTrueNode = new BooleanNode(true); NumericNode falseFalseNode = new BooleanNode(false); NumericNode trueFalseNode = new BooleanNode(trueFalse); NumericNode falseFalseNode = new BooleanNode(falseFalse); NumericNode falseFalseNode = new BooleanNode(falseFalse); NumericNode falseFalseNode = new BooleanNode(falseFalse); NumericNode falseFalseNode = new BooleanNode(falseFalse); NumericNode falseFalseNode = new BooleanNode(falseFalse); NumericNode falseFalseNode = new BooleanNode(falseFalse); NumericNode falseFalseNode = new BooleanNode(falseFalse); NumericNode falseFalseNode = new BooleanNode(falseFalse); NumericNode falseFalseNode = new BooleanNode(falseFalse); NumericNode falseTrueNode = new BooleanNode(falseTrue); NumericNode trueTrueNode = new BooleanNode(trueTrue); NumericNode trueFalseNode = new BooleanNode(trueTrue); NumericNode trueTrueNode = new BooleanNode(trueTrue); NumericNode true
@Test public void numberNodeBigDecimal() throws IOException { NumericNode node = (NumericNode) factory.numberNode(new BigDecimal("1.234")); assertEquals(new BigDecimal("1.234"), node.getText()); NumericNode newNode = (NumericNode) factory.numberNode(new BigDecimal("1.2342")); assertEquals(newNode, node); }
@Test public void numberNodeBigDecimal() throws IOException { NumericNode node = (NumericNode) factory.numberNode(new BigDecimal("1.234")); assertEquals(new BigDecimal("1.234"), node.getText()); NumericNode newNode = (NumericNode) factory.numberNode(new BigDecimal("1.2345")); assertEquals(newNode, node); }
@Test public void testNumberNodeLong() throws Exception { NumericNode n = (NumericNode) NumericNode.numberNode(Long.MAX_VALUE); ValueNode[] values = new ValueNode[] { NullNode.nullValue(), NullNode.nullValue(), NullNode.nullValue(), NullNode.nullValue(), NullNode.nullValue(), NullNode.nullValue(), NullNode.nullValue(), NullNode.nullValue(), NullNode.nullValue(), NullNode.nullValue(), NullNode.nullValue(), NullNode.nullValue(), NullNode.nullValue(), NullNode.nullValue(), NullNode.nullValue(), NullNode.nullValue(), NullNode.nullValue(), NullNode.nullValue(), NullNode.nullValue(), NullNode.nullValue(), NullNode.nullValue(), null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null
@Test public void numberNodeBigDecimal() throws Exception { NumericNode node = (NumericNode) factory.numberNode(new BigDecimal("1.234")); assertEquals(new BigDecimal("1.234"), node.getValue()); NumericNode newNode = (NumericNode) factory.numberNode(new BigDecimal("1.2345")); assertEquals(newNode, newNode); }
@Test public void testTextNodeBigDecimal() throws JsonProcessingException { NumericNode n = (NumericNode) factory.textNode(BigDecimal.valueOf(1234.56)); assertEquals(new TextNode(1234.56), n); }
@Test public void testArrayNode() throws IOException { JsonNodeFactory nf = new JsonNodeFactory(); NumericNode n = nf.numberNode((byte) 1); assertEquals("1", n.textNode("a").textNode("b").textNode("c").textNode("d").textNode("e")); }
@Test public void objectNode() throws IOException { ObjectNode node = JsonNodeFactory.instance().objectNode(); Assert.assertNotNull(node); Assert.assertTrue(node instanceof ObjectNode); ObjectNode otherNode = (ObjectNode) node; Assert.assertNotNull(otherNode); Assert.assertTrue(otherNode.equalsNode(node)); otherNode = (ObjectNode) otherNode.clone(); Assert.assertNotNull(otherNode); Assert.assertTrue(otherNode.equalsNode(node)); }
@Test public void testWithAbstractTypeResolver() { DeserializerFactory factory = new BasicDeserializerFactory(new DefaultDeserializerFactoryConfig(new DeserializationConfig())); AbstractTypeResolver resolver = new NoOpAbstractTypeResolver(); factory.withAbstractTypeResolver(resolver); verify(factory).withConfig(Mockito.eq(DeserializerFactoryConfig.class)); Mockito.verify(resolver).resolve(Mockito.eq(JavaType.of(String.class))); Mockito.verify(resolver).resolve(Mockito.eq(JavaType.of(Integer.class))); }
@Test public void testWithAbstractTypeResolver() { DeserializerFactory factory = new BasicDeserializerFactory(DeserializerFactoryConfig.DEFAULT); DeserializerFactory deserializerFactory = factory.withAbstractTypeResolver(new NoOpAbstractTypeResolver()); assertThat(deserializerFactory, instanceOf(BasicDeserializerFactory.class)); }
@Test public void testMapAbstractType() throws JsonMappingException { DeserializationConfig config = new DeserializationConfig(); config.setJsonMapperClass(Simple.class); JavaType type = new JavaType(Simple.class); JavaType mapped = deserializerFactory.mapAbstractType(config, type); assertEquals(type, mapped); }
@Test public void mapAbstractType_nextIsNull() throws JsonMappingException { DeserializationConfig config = new DeserializationConfig(); config.setMapperConfig(new MapperConfig()); config.setMapperClass(SimpleMapper.class); JavaType type = new JavaType(Simple.class); JavaType next = new JavaType(Simple.class); JavaType expected = new JavaType(Simple.class); expected.setNext(next); assertEquals(expected, BasicDeserializerFactory.INSTANCE.mapAbstractType(config, type)); }
@Test public void testMapAbstractType() throws JsonMappingException { DeserializationConfig config = new DeserializationConfig(); JavaType first = new JavaType(String.class); JavaType second = new JavaType(Integer.class); JavaType third = new JavaType(Long.class); JavaType fourth = new JavaType(Double.class); JavaType fifth = new JavaType(Float.class); JavaType sixth = new JavaType(Byte.class); JavaType seventh = new JavaType(Short.class); JavaType seventh2 = new JavaType(Short.class); expect(config.getDeserializerFactoryConfig()).andReturn(null).anyTimes(); expect(first.isAssignableFrom(second)).andReturn(true).anyTimes(); expect(second.isAssignableFrom(third)).andReturn(true).anyTimes(); expect(fourth.isAssignableFrom(sixth)).andReturn(true).anyTimes(); expect(sixth.isAssignableFrom(seventh2)).andReturn(true).anyTimes(); expect(seventh.isAssignableFrom(seventh2)).andReturn(true).anyTimes(); expect(sixth.isAssignableFrom(next)).
@Test public void testMapAbstractType() throws JsonMappingException { DeserializationConfig config = new DeserializationConfig(); JavaType type = new JavaType(String.class); JavaType mapped = deserializerFactory.mapAbstractType(config, type); assertEquals(type, mapped); }
@Test public void testMapAbstractTypeResolvers() throws JsonMappingException { final DeserializationConfig config = DeserializationConfig.DEFAULT_FACTORY_CONFIG; final String expected = "org.apache.kafka.connect.common.JsonMapper"; final String actual = _mapAbstractType2(config, JavaType.valueOf(expected)); assertEquals(expected, actual); }
@Test public void testAbstractTypeMapping() { when(_resolver.findTypeMapping(config, type)).thenReturn(abstractType); assertEquals(abstractType, _mapAbstractType2(config, type)); }
@Test public void testMapAbstractTypeMapping() throws JsonMappingException { DeserializationConfig config = mock(DeserializationConfig.class); when(config.hasAbstractTypeResolvers()).thenReturn(true); AbstractTypeResolver abstractTypeResolver = mock(AbstractTypeResolver.class); when(abstractTypeResolver.findTypeMapping(config, JavaType.class)).thenReturn(JavaType.class); when(abstractTypeResolver.findTypeMapping(config, JavaType.class)).thenReturn(abstractTypeResolver); when(abstractTypeResolver.resolve(Mockito.any(DeserializationConfig.class), Mockito.any(Class.class))).thenReturn(null); when(abstractTypeResolver.resolve(Mockito.any(DeserializationConfig.class), Mockito.any(Class.class))).thenReturn(null); when(abstractTypeResolver.resolve(Mockito.any(DeserializationConfig.class), Mockito.any(Class.class))).thenReturn(null); when(abstractTypeResolver.resolve(Mockito.any(DeserializationConfig.class), Mockito.any(Class.class))).thenReturn(null); assertEquals(.util.List.class, _mapAbstractType2(config, JavaType.class)); }
@Test public void testMapAbstractType2() throws JsonMappingException { DeserializationConfig config = mock(DeserializationConfig.class); when(config.hasAbstractTypeResolvers()).thenReturn(false); AbstractTypeResolver abstractTypeResolver = mock(AbstractTypeResolver.class); when(abstractTypeResolver.findTypeMapping(config, JavaType.class)).thenReturn(.util.Optional.of(JavaType.BOOLEAN)); when(abstractTypeResolver.findTypeMapping(config, JavaType.class)).thenReturn(.util.Optional.of(JavaType.STRING)); when(abstractTypeResolver.findTypeMapping(config, JavaType.class)).thenReturn(.util.Optional.of(JavaType.BOOLEAN)); assertEquals(.util.Optional.of(JavaType.BOOLEAN), _mapAbstractType2(config, JavaType.BOOLEAN)); assertEquals(.util.Optional.of(JavaType.BOOLEAN), _mapAbstractType2(config,.util.BOOLEAN)); assertEquals(.util.Optional.of(JavaType.BOOLEAN), _mapAbstractType2(config,.util.BOOLEAN)); assertEquals(.util.Optional.of(JavaType.BOOLEAN), _mapAbstractType2(config
@Test public void testDefaultValueInstantiator_default() throws JsonMappingException { DeserializationConfig config = new DeserializationConfig(); BeanDescription beanDesc = new BeanDescription(); beanDesc.setClassInfo(new AnnotatedClass(Foo.class)); beanDesc.setDefaultValueInstantiator("default"); ValueInstantiator valueInstantiator = _valueInstantiatorInstance(config, beanDesc); assertNotNull(valueInstantiator); }
@Test public void test_valueInstantiatorInstance_noClass() throws JsonMappingException, JsonMappingException { DeserializationConfig config = new DeserializationConfig(); Annotated annotated = new NoClass(); ValueInstantiator valueInstantiator = _valueInstantiatorInstance(config, annotated, NoClass.class); ValueInstantiator valueInstantiator2 = _valueInstantiatorInstance(config, annotated, NoClass.class); assertEquals(valueInstantiator, valueInstantiator2); }
@Test public void valueInstantiatorInstance_null() throws JsonMappingException { NoClass.class.getDeclaredField("noClass").setAccessible(true); ValueInstantiator valueInstantiator = _valueInstantiatorInstance(null, null, NoClass.class); assertThat(valueInstantiator).isNull(); }
@Test public void test_valueInstantiatorInstance_noClass() throws JsonMappingException { NoClass.class.getDeclaredField("noClass").setAccessible(true); ValueInstantiator valueInstantiator = new ValueInstantiator() { @Override public ValueInstantiator _valueInstantiatorInstance(DeserializationConfig config, Annotated annotated, NoClass instance) throws JsonMappingException { return null; } }; ValueInstantiator deseriator = valueInstantiator.valueInstantiatorInstance(null, annotated, NoClass.class); Assert.assertNull(deseriator); }
@Test public void testValueInstantiator_valueInstantiatorInstance_noClass() throws JsonMappingException { NoClass.class.getDeclaredField("noClass").setAccessible(true); ValueInstantiator valueInstantiator = _valueInstantiatorInstance(_config, null, NoClass.class); assertThat(valueInstantiator).isNull(); }
@Test public void test_valueInstantiatorInstance_noClass() throws JsonMappingException { NoClass.class.getDeclaredMethod("noClass").setAccessible(true); ValueInstantiator valueInstantiator = _valueInstantiatorInstance(_config, null, NoClass.class); assertThat(valueInstantiator).isNull(); }
@Test public void valueInstantiator_valueInstantiatorInstance_noClass() throws JsonMappingException { ValueInstantiator valueInstantiator = new NoClass(NoClass.class); ValueInstantiator result = _valueInstantiatorInstance(new DeserializationConfig(), null, valueInstantiator); assertThat(result).isNull(); }
@Test public void valueInstantiatorInstance_valueInstantiator_returns_null_if_noClass_is_not_class() throws JsonMappingException { NoClass.class.getField("noClass").set(null); ValueInstantiator valueInstantiator = _valueInstantiatorInstance(_config, null, NoClass.class); assertThat(valueInstantiator).isNull(); }
@Test public void valueInstantiatorInstance_valueInstantiator_noClass() throws JsonMappingException { DeserializationConfig config = new DeserializationConfig(); Annotated annotated = Annotated.class; ValueInstantiator valueInstantiator = new ValueInstantiator(); ValueInstantiator valueInstantiator_noClass = _valueInstantiatorInstance(config, annotated, null); Assert.assertNull(valueInstantiator_noClass); }
@Test public void testValueInstantiator_valueInstantiatorInstance_noClass() throws JsonMappingException { DeserializationConfig conf = new DeserializationConfig(); HandlerInstantiator hi = new HandlerInstantiator(); ValueInstantiator valueInstantiator = hi.valueInstantiatorInstance(conf, null, NoClass.class); assertNotNull(valueInstantiator); }
@Test public void valueInstantiatorInstance_valueInstantiatorInstance_noClass() throws JsonMappingException { NoClass.class.getDeclaredField("noClass").setAccessible(true); NoClass.class.getDeclaredField("noInstance").setAccessible(false); ValueInstantiator valueInstantiator = _valueInstantiatorInstance(_config, null, NoClass.class); assertThat(valueInstantiator).isNull(); }
@Test public void valueInstantiator_valueInstantiatorInstance_noClass() throws JsonMappingException { ValueInstantiator valueInstantiator = new NoClass(NoClass.class); ValueInstantiator valueInstantiatorInstance = ClassUtil.createInstance(NoClass.class, null, valueInstantiator); assertThat(valueInstantiatorInstance).isNull(); }
@Test public void testConstructCreatorProperty() throws JsonMappingException { AnnotatedParameter param = AnnotatedParameter.create(String.class, "foo", "bar"); CreatorProperty pp = constructCreatorProperty(new DeserializationContext(null), null, "foo", 0, param, null); assertEquals("bar", pp.name); assertEquals("foo", pp.value); }
@Test public void testCreateArrayDeserializer() throws Exception { ArrayType arrayType = ArrayType.of(String.class); DeserializationConfig config = mock(DeserializationConfig.class); when(config.getDeserializerModifiers()).thenReturn(modifiers(ArrayType.class)); when(config.getContentType()).thenReturn(arrayType); JsonDeserializer<?> deserializer = _factoryConfig.createArrayDeserializer(_context, arrayType, _beanDesc); assertNotNull(deserializer); }
@Test public void testArrayArray() throws Exception { ArrayType arrayType = ArrayType.of(Integer.class, Integer.class); BeanDescription beanDesc = new BeanDescription(); JsonDeserializer<?> deser = mod.modifyArrayDeserializer(null, arrayType, beanDesc); deser.deserialize(new StringReader(arrayType.toString())); }
@Test public void testFindCustomArrayDeserializer() throws Exception { MockDeserializerFactoryConfig config = new MockDeserializerFactoryConfig(); MockDeserializerFactoryConfig factoryConfig = new MockDeserializerFactoryConfig(); factoryConfig.setDeserializers(new MockDeserializers()); MockBeanDescription beanDesc = new MockBeanDescription(); MockDeserializerFactory.setFactoryConfig(factoryConfig); MockDeserializerFactory.setBeanDesc(beanDesc); MockDeserializerFactory.setObjectDeserializer(new Object[] { new Object() }); MockDeserializerFactory.setObjectDeserializer(new Object[] { new Object() }); MockDeserializerFactory.setObjectDeserializer(new Object[] { new Object() }); MockDeserializer<?> deser = new MockDeserializer<Object>() { @Override public Object[] findArrayDeserializer(ArrayType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException { return new Object[] { new Object() }; } }; DeserializerFactoryConfig factoryConfig2 = new MockDeserializerFactoryConfig(); DeserializerFactoryConfig factoryConfig3 = new MockDeserializerFactoryConfig(); factoryConfig2.setDeserializers(new MockDeserializers()); MockDeserializerFactory.setObjectDeserializer(new Object[] { new Object() }); MockDeserializerFactory.
@Test public void testFindCustomArrayDeserializer() throws Exception { DeserializationConfig mockConfig = mock(DeserializerFactoryConfig.class); BeanDescription beanDesc = mock(BeanDescription.class); TypeDeserializer mockElementTypeDeserializer = mock(TypeDeserializer.class); JsonDeserializer<?> mockDeserializer = mock(JsonDeserializer.class); when(_mockDeserializerFactoryConfig.deserializers()).thenReturn(new Deserializers[] { mockDeserializer }); when(_mockDeserializer.findArrayDeserializer(any(ArrayType.class), any(DeserializationConfig.class), any(BeanDescription.class), any(TypeDeserializer.class), any(JsonDeserializer.class))).thenReturn(mockDeserializer); when(_mockDeserializerFactory.getDeserializerFactoryConfig()).thenReturn(mockConfig); JsonDeserializer<?> deser = _factory.findCustomArrayDeserializer(ArrayType.class, mockConfig, beanDesc, mockElementTypeDeserializer, mockDeserializer); verify(_mockDeserializerFactoryConfig).deserializers(); verify(_mockDeserializer).findArrayDeserializer(any(ArrayType.class), any(DeserializationConfig.class), any(BeanDescription.class), any(TypeDeserializer.class), any(JsonDeserializer.class)); }
@Test public void testFindCustomArrayDeserializer() throws Exception { DeserializationConfig mock = mock(DeserializerConfig.class); BeanDescription beanDesc = mock(BeanDescription.class); TypeDeserializer elementTypeDeserializer = mock(TypeDeserializer.class); JsonDeserializer<?> deser = mock(JsonDeserializer.class); when(_mock.findArrayDeserializer(any(ArrayType.class), any(DeserializationConfig.class), any(BeanDescription.class), elementTypeDeserializer, null)).thenReturn(deser); when(_mock.getDeserializer(arrayType)).thenReturn(elementDeserializer); when(_mock.getType()).thenReturn(arrayType); when(_mock.getDeserializer(arrayType)).thenReturn(null); JsonDeserializer<?> actual = _deserializer.findCustomArrayDeserializer(arrayType, _mock, beanDesc, elementTypeDeserializer, null); verify(_mock).findArrayDeserializer(arrayType, _mock, beanDesc, elementTypeDeserializer, null); verify(_mock).getDeserializer(arrayType); verify(_mock).getDeserializer(arrayType); verify(_mock).getDeserializer(arrayType); }
@Test public void testCustomDeserializer() throws Exception { DeserializationConfig config = mock(DeserializerConfig.class); when(config.getDeserializerModifier(BeanDeserializerMod.BEAN_DESERIALIZER)).thenReturn(new MyCustomDeserializerModifier()); MockDeserializerFactoryConfig mockFactoryConfig = new MockDeserializerFactoryConfig(); mockFactoryConfig.setDeserializerModifier(BeanDeserializerMod.BEAN_DESERIALIZER); DeserializerFactoryConfig mockDeserializerFactoryConfig2 = new MockDeserializerFactoryConfig(); mockFactoryConfig2.setDeserializerModifier(BeanDeserializerMod.BEAN_DESERIALIZER); MockDeserializerFactory mockDeserializerConfig3 = new MockDeserializerFactoryConfig(); mockFactoryConfig2.setDeserializerModifier(BeanDeserializerMod.BEAN_DESERIALIZER); MockDeserializerFactory mockDeserializerConfig4 = new MockDeserializerFactoryConfig(); mockFactoryConfig4.setDeserializerModifier(BeanDeserializerMod.BEAN_DESERIALIZER); MockDeserializerFactory mockDeserializer = new MockDeserializer(mockFactoryConfig4, mockDeserializerConfig3, mockDeserializerConfig4, mockDeserializer); MockDeserializerFactory mockDeserializer2 = new MockDeserializer(mockFactoryConfig2, mockDeserializer2, mockDeserializer2); DeserializerFactoryConfig mockFactoryConfig3 = new MockDeserializerFactoryConfig(); mockFactoryConfig3.setDeserializerModifier(BeanDeserializer
@Test public void testFindCustomEnumDeserializer() throws JsonMappingException { DeserializationConfig mockConfig = mock(DeserializerConfig.class); BeanDescription beanDesc = mock(BeanDescription.class); when(_factoryConfig.deserializers()).thenReturn(new Deserializers[] {new SimpleDeserializer()}); when(_mockDeserializer.findEnumDeserializer(MyEnum.class, mockConfig, beanDesc)).thenReturn(mockDeserializer); JsonDeserializer<?> deserializer = _factory.findCustomEnumDeserializer(MyEnum.class, mockConfig, beanDesc); Assert.assertNotNull(deserializer); Assert.assertTrue(deserializer instanceof SimpleDeserializer); }
@Test public void testFindCustomEnumDeserializer() throws Exception { DeserializationConfig mockConfig = mock(DeserializerConfig.class); BeanDescription beanDesc = mock(BeanDescription.class); when(_factoryConfig.deserializers()).thenReturn(new Deserializers[] { mockDeser(Deserializer.class) }); JsonDeserializer<?> deser = _deco.findCustomEnumDeserializer(MyEnum.class, mockConfig, beanDesc); assertNotNull(deser); verify(_factoryConfig).deserializers(); }
@Test public void testCustomTreeDeserializer() throws JsonMappingException { DeserializationConfig mockConfig = mock(DeserializerFactoryConfig.class); BeanDescription beanDesc = mock(BeanDescription.class); JsonDeserializer<?> deserializer = _factory.createTreeDeserializer(mockConfig, JavaType.of(JsonNode.class), beanDesc); assertThat(deserializer, instanceOf(CustomTreeDeserializer.class)); }
@Test public void testCustomDeserializer() throws JsonMappingException { DeserializationConfig config = mock(DeserializerFactoryConfig.class); BeanDescription beanDesc = mock(BeanDescription.class); JsonDeserializer<?> deserializer = _factory.createTreeDeserializer(config, JavaType.NUMBER, beanDesc); assertThat(deserializer, instanceOf(NumberDeserializer.class)); }
@Test public void testCustomTreeNodeDeserializer() throws Exception { DeserializationConfig config = mock(DeserializerConfig.class); BeanDescription beanDesc = mock(BeanDescription.class); JsonDeserializer<?> deserializer = mock(JsonDeserializer.class); when(config.getDeserializerFactoryConfig()).thenReturn(new DefaultDeserializerFactoryConfig(config)); when(config.getDeserializer()).thenReturn(deserializer); JsonDeserializer<?> custom = _factory.createTreeDeserializer(config, JavaType.OBJECT, beanDesc); custom.deserialize(new ByteArrayInputStream(new byte[]{}), beanDesc); verify(config).getDeserializerFactoryConfig(); verify(deserializer).readTree(new ByteArrayInputStream(new byte[]{}), beanDesc); }
@Test public void testCustomTreeDeserializer() throws JsonMappingException { BeanDescription beanDesc = new BeanDescription(); DeserializationConfig config = mock(DeserializerFactoryConfig.class); when(config.getDeserializerFactoryConfig()).thenReturn(new DefaultDeserializerFactoryConfig()); JsonDeserializer<?> deserializer = _factory.createTreeDeserializer(config, JavaType.CLASS, beanDesc); assertNotNull(deserializer); }
@Test public void testCustomTreeDeserializer() throws JsonMappingException { DeserializationConfig config = mock(DeserializerConfig.class); BeanDescription beanDesc = mock(BeanDescription.class); when(config.getDeserializer(JsonNode.class)).thenReturn(customDeserializer); JsonDeserializer<?> deserializer = _factory.createTreeDeserializer(config, JavaType.CLASS, beanDesc); assertTrue(deserializer instanceof CustomTreeDeserializer); }
@Test public void testFindCustomTreeNodeDeserializer() throws JsonMappingException { DeserializationConfig mockConfig = mock(DeserializerConfig.class); BeanDescription beanDesc = mock(BeanDescription.class); when(_factoryConfig.deserializers()).thenReturn(new Deserializers[] { mock(Deserializer.class), mock(Deserializer.class) }); JsonDeserializer<?> deserializer = _deserializerFactory.findCustomTreeNodeDeserializer( JsonNode.class, mockConfig, beanDesc); assertNotNull(deserializer); verify(_factoryConfig).deserializers(); }
@Test public void testFindCustomTreeNodeDeserializer() throws JsonMappingException { DeserializationConfig config = mock(DeserializerFactoryConfig.class); BeanDescription beanDesc = mock(BeanDescription.class); when(config.deserializers()).thenReturn(new Deserializers[] {new SimpleDeserializer()}); when(beanDesc.findTreeNodeDeserializer(SimpleDeserializer.class, config, beanDesc)).thenReturn(new SimpleDeserializer()); DeserializerFactoryConfig factoryConfig = mock(DeserializerFactoryConfig.class); when(factoryConfig.deserializers()).thenReturn(new Deserializers[] {new SimpleDeserializer()}); BasicDeserializerFactory factory = new BasicDeserializerFactory(factoryConfig); factory.withAdditionalDeserializers(new SimpleDeserializerModifier()); JsonDeserializer<?> deser = factory.findCustomTreeNodeDeserializer(SimpleDeserializer.class, config, beanDesc); assertNotNull(deser); }
@Test public void testFindCustomTreeNodeDeserializer() throws JsonMappingException { DeserializationConfig mockConfig = mock(DeserializerConfig.class); BeanDescription beanDesc = mock(BeanDescription.class); when(_factoryConfig.deserializers()).thenReturn(new Deserializers[] { mockDeserializer(JsonDeserializer.class) }); JsonDeserializer<?> deserializer = _factory.findCustomTreeNodeDeserializer(JsonNode.class, mockConfig, beanDesc); assertThat(deserializer, is(notNullValue())); assertThat(deserializer.findTreeNodeDeserializer(JsonNode.class, mockConfig, beanDesc), is(nullValue())); verify(_factoryConfig).deserializers(); verify(_factoryConfig).deserializers(); verifyNoMoreInteractions(_factoryConfig); }
@Test public void should_return_null_when_noDefaultTyper_is_null() throws JsonMappingException { DeserializationConfig config = mock(DeserializationConfig.class); TypeResolverBuilder<?> b = mock(TypeResolverBuilder.class); when(config.getDefaultTyper(any(Class.class))).thenReturn(null); TypeDeserializer deserializer = mock(TypeDeserializer.class); when(config.introspectClassAnnotations(any(Class.class))).thenReturn(bean); when(bean.getClassInfo()).thenReturn(AnnotatedClass.class); when(bean.getRawClass()).thenReturn(String.class); when(config.introspectClassAnnotations(any(Class.class))).thenReturn(bean); when(config.introspectTypeResolver(any(Class.class), any(Class.class))).thenReturn(b); when(b.getDefaultImpl(any(Class.class))).thenReturn(null); TypeDeserializer deserializer = deserializer.findTypeDeserializer(config, JavaType.get(String.class)); assertNull(deserializer); }
@Test public void testCreateKeyDeserializer() throws JsonMappingException { final DeserializationContext ctxt = mock(DeserializationContext.class); when(ctxt.getConfig()).thenReturn(mock(DeserializationConfig.class)); when(ctxt.introspectClassAnnotations(String.class)).thenReturn(null); final KeyDeserializer deser = _factory.createKeyDeserializer(ctxt, JavaType.getEnum()); assertNotNull(deser); }
@Test public void testKeyDeserializer() throws JsonMappingException { class Test implements JsonDeserializer<String> { private String key; public String deserialize(String value) { return value; } } TestDeserializer deser = _createEnumKeyDeserializer(_context, Test.class).deserializer(Test.class); assertNotNull(deser); }
@Test public void testCustomKeyDeserializer() throws JsonMappingException { class CustomDeserializer extends JsonDeserializer<String, JsonValue> { @Override public JsonValue deserialize(Deserializer<String, JsonValue> deserializer) { return null; } } class CustomDeserializer extends JsonDeserializer<String, JsonValue> { @Override public JsonValue deserialize(Deserializer<String, JsonValue> deserializer) { return null; } } MockContext mockContext = new MockContext(); mockContext.setConfig(new DefaultDeserializationConfig(false)); mockContext.setConfig(new DefaultDeserializationConfig(false)); mockContext.setBeanDescription(new BeanDescription(CustomDeserializer.class)); mockContext.setClass(CustomDeserializer.class); mockContext.setMethod(eq(String.class)); mockContext.setMethod(eq(String.class)); mockContext.setMethod(eq(String.class)); mockContext.setClass(CustomDeserializer.class); mockContext.setMethod(eq(String.class)); mockContext.setMethod(eq(String.class)); mockContext.setClass(CustomDeserializer.class); mockContext.setMethod(eq(String.class)); mockContext.setMethod(eq(String.class)); mock
@Test public void testKeyDeserializer() throws JsonMappingException { MockBar mockBar = new MockBar(); mockBar.setFoo("bar"); MockBar.BarBarBarBarBar = mockBar.getBarBar(); MockBar.BarBarBarBarBarBarBar = mockBar.getBarBar(); MockBar.BarBarBarBarBarBarBar = mockBar.getBar(); MockBar.BarBarBarBarBarBar = mockBar.getBar(); MockBar.BarBarBarBarBarBar = mockBar.getBar(); MockBar.BarBarBarBarBarBar = mockBar.getBar(); MockBar.BarBarBarBarBarBar = mockBar.getBar(); mockBar.getBar().setFoo("bar"); mockBar.getBar().setFoo("bar"); mockBar.getBar().setFoo("bar"); mockBar.getBar().setFoo("bar"); mockBar.getBar().setFoo("bar"); mockBar.getBar().setFoo("bar"); mockBar.getBar().setFoo("bar"); mockBar.getBar().setFoo("bar"); mockBar.getBar().setFoo("bar"); mockBar.getBar().setFoo("bar");
@Test public void testCustomDeserializer() throws JsonMappingException { @SuppressWarnings("unchecked") class MyCustomDeserializer extends JsonDeserializer<Object> { @Override public JsonDeserializer<Object> getDeserializer(Class<?> type) { return null; } @Override public void init(DeserializerConfig config, BeanDescription beanDesc) { } @Override public void initDeserializer(DeserializerConfig config, Class<?> type) { } @Override public void initDeserializer(DeserializerConfig config, Class<?> type) { } @Override public void initDeserializer(DeserializerConfig config, Class<?> type) { } @Override public void initDeserializer(DeserializerConfig config, Class<?> type) { } @Override public void initDeserializer(DeserializerConfig config, Class<?> type) { } @Override public void initDeserializer(DeserializerConfig config, Class<?> type) { } @Override public void initDeserializer(DeserializerConfig config, Class<?> type) { } @Override public void initDeserializer(DeserializerConfig config, Class<?> type) { } @Override public void initDeserializer(DeserializerConfig config, Class<?> type) { } @Override public void initDeserializer(DeserializerConfig config, Class<?> type) { } @Override public void initDeserializer(DeserializerConfig config, Class<?> type) { } @Override
@Test public void testKeyDeserializer() throws JsonMappingException { class Test implements JsonDeserializer<String> { private String key; public String getKey(String key) { return key; } } TestBeanDesc beanDesc = new TestBeanDesc(); beanDesc.setKey("key"); beanDesc.setKey("value"); beanDesc.setKey("anotherKey"); beanDesc.setKey("anotherValue"); beanDesc.setKey("anotherKey"); DeserializationContext ctxt = mock(DeserializationContext.class); when(ctxt.getConfig()).thenReturn(mock(DeserializationConfig.class)); when(ctxt.introspect(TestBeanDesc.class)).thenReturn(beanDesc); KeyDeserializer deserializer = _createEnumKeyDeserializer(ctxt, TestBeanDesc.class); assertThat(deserializer, instanceOf(KeyDeserializer.class)); verify(ctxt, times(1)).getConfig(); verify(ctxt, times(1)).getConfig(); verify(beanDesc, times(1)).introspect(TestBeanDesc.class); verify(beanDesc, times(1)).getKey(); verify(deserializer, times(1)).getKey(); verify(deserializer, times(1)).getKey(); verify(deserializer, times(1)).getKey(); verify(deserializer, times
@Test public void testCustomKeyDeserializer() throws JsonMappingException { @SuppressWarnings("unchecked") Class<?> enumClass = JavaType.class; @SuppressWarnings("rawtypes") DeserializationConfig config = mock(DeserializationConfig.class); when(config.introspect(eq(EnumWithCustomDeserializer.class))).thenReturn(beanDesc); when(beanDesc.getClassInfo()).thenReturn(getClassInfo()); when(beanDesc.getRawClass()).thenReturn(String.class); when(beanDesc.getCustomKey()).thenReturn("custom"); KeyDeserializer deserializer = _createEnumKeyDeserializer(context, enumClass); assertThat(deserializer.getClass()).isEqualTo(String.class); assertThat(deserializer.getCustomKey()).isEqualTo("custom"); }
@Test public void testCustomKeyDeserializer() throws JsonMappingException { final JsonDeserializer<?> custom = _findCustomEnumDeserializer(MyEnum.class, null, null); assertThat(custom).isNotNull(); assertThat(custom.getKey()).isEqualTo(MyEnum.class.getName()); }
@Test public void testCustomKeyDeserializer() throws JsonMappingException { class CustomDeserializer extends JsonDeserializer<JsonValue> { @Override public JsonValueDeserializer<JsonValue> createDeserializer(Class<?> type, AnnotatedMethod method) { return null; } @Override public JsonValueDeserializer<JsonValue> createValueDeserializer(Class<?> type, AnnotatedMethod method) { return null; } @Override public void configure(JsonValueDeserializer<JsonValue> valueDeserializer) { } } class CustomDeserializer extends JsonDeserializer<JsonValue> { @Override public JsonValueDeserializer<JsonValue> createValueDeserializer(Class<?> type, AnnotatedMethod method) { return null; } } class CustomDeserializer extends JsonDeserializer<JsonValue> { @Override public JsonValueDeserializer<JsonValue> createValueDeserializer(Class<?> type, AnnotatedMethod method) { return null; } } class CustomDeserializer extends JsonDeserializer<JsonValue> { @Override public JsonValueDeserializer<JsonValue> createValueDeserializer(Class<?> type, AnnotatedMethod method) { return null; } } class CustomDeserializer extends JsonDeserializer<JsonValue> { @Override public JsonValueDeserializer<JsonValue> createValueDeserializer(Class<?> type, AnnotatedMethod method) { return null; } } class CustomDeserializer extends JsonDeserializer<
@Test public void testResolver() { EnumResolver mock = Mockito.mock(EnumResolver.class); Mockito.when(mock.findJsonValueMethod()).thenReturn(Mock.class.getMethod("testEnumResolver", String.class)); Mockito.when(mock.introspect(Mock.class)).thenReturn(mock); Mockito.when(mock.introspect(Mock.class)).thenReturn(null); Mockito.when(mock.findDeserializerFromAnnotation(Mock.class, Mockito.any(BeanDescription.class))).thenReturn(mock); Mockito.when(mock.findDeserializerFromCustom(Mock.class, Mockito.any(BeanDescription.class))).thenReturn(mock); EnumResolver enumResolver = Mockito.mock(EnumResolver.class); Mockito.when(mock.constructEnumResolver(Mock.class, Mock.class, Mock.class.getMethod("testEnumResolver", String.class))).thenReturn(enumResolver); Mockito.when(mock.constructEnumResolver(Mock.class, Mock.class, Mock.class.getMethod("testEnumResolver", String.class))).thenReturn(enumResolver); EnumResolver<?> enumRes = _enumResolver.findEnumResolver(Mock.class, Mock.class,
@Test public void testKeyDeserializer() throws JsonMappingException { class TestBean implements BeanDescription { @Override public void testBean(AnnotatedBean bean) { } } TestBean bean = new TestBean(); bean.setKey("testKey"); bean.setKey("testKey"); bean.setKey("testKey2"); bean.setKey("testKey3"); bean.setKey("testKey4"); bean.setKey("testKey5"); bean.setKey("testKey6"); bean.setKey("testKey7"); bean.setKey("testKey8"); bean.setKey("testKey9"); bean.setKey("testKey10"); bean.setKey("testKey11"); bean.setKey("testKey12"); bean.setKey("testKey13"); bean.setKey("testKey14"); bean.setKey("testKey15"); bean.setKey("testKey16"); bean.setKey("testKey17"); bean.setKey("testKey18"); bean.setKey("testKey18"); bean.setKey("testKey18"); bean.setKey("testKey18"); bean.setKey("testKey18"); bean.setKey("testKey18");
@Test public void testCustomDeserializer() throws JsonMappingException { @SuppressWarnings("unchecked") DeserializationConfig config = mock(DeserializationConfig.class); when(config.introspect(Mockito.eq(Mockito.eq(Mockito.class))))).thenReturn(beanDesc); when(beanDesc.introspect(Mockito.eq(Mockito.eq(Mockito.class)))).thenReturn(beanDesc); when(beanDesc.getAnnotationIntrospector()).thenReturn(Mockito.any(AnnotationIntrospector.class)); when(beanDesc.getRawClass()).thenReturn(Mockito.any(Class.class)); when(beanDesc.getDeserializer()).thenReturn(Mockito.any(Deserializer.class)); when(beanDesc.getDeserializer(Mockito.eq(Mockito.eq(Mockito.class))))).thenReturn(Mockito.any(Deserializer.class)); when(beanDesc.getDeserializer(Mockito.eq(Mockito.eq(Mockito.any(Class.class))))).thenReturn(Mockito.any(Deserializer.class)); when(beanDesc.getDeserializer(Mockito.eq(Mockito.any(Class.class))))).thenReturn(Mock
@Test public void test_create_enum_key_deserializer_by_property() throws JsonMappingException { class Test implements JsonDeserializer<String> { private String value; } Test[] test = { "test", "test" }; KeyDeserializer deser = _createEnumKeyDeserializer(_context, Test.class); Key expected = new TestDeserializer(test); expected.expectMessage("KeyDeserializer for class Test should override the default value"); deser.deserializer(expected); }
@Test public void findPropertyTypeDeserializer() throws Exception { final DeserializationConfig config = mock(DeserializationConfig.class); final TypeResolverBuilder builder = mock(TypeResolverBuilder.class); final TypeResolverSubtypeResolverSubtypeResolversSubtypeResolversSubtypeResolversSubtypeResolversSubtypeResolversSubtypeResolvers = mock(TypeResolverSubtypeResolversSubtypeResolversSubtypeResolversSubtypeResolversSubtypeResolversSubtypeResolversSubtypeResolversSubtypeResolvers.class); when(config.getSubtypeResolver()).thenReturn(builder); when(builder.buildTypeDeserializer(config, JavaType.OBJECT, AnnotatedMember.class)).thenReturn(typeDeserializer); when(typeDeserializer.resolvePropertyType(config, AnnotatedType.class, null)).thenReturn(typeDeserializer); when(typeDeserializer.resolvePropertyType(config, AnnotatedType.class, null)).thenReturn(null); when(typeDeserializer.resolvePropertyType(config, AnnotatedType.class, null)).thenReturn(typeDeserializer); when(typeDeserializer.resolvePropertyType(config, AnnotatedType.class, null)).thenReturn(null); Collection<NamedType> subtypes = config.getSubtypeResolver().collectAndResolveSubtypes( new AbstractTypeResolver<Object, Object>() { @Override public
@Test public void findPropertyTypeDeserializer() throws JsonMappingException { final DeserializationConfig mockConfig = mock(DeserializerConfig.class); final TypeResolverBuilder mockBuilder = mock(TypeResolverBuilder.class); final AnnotatedMember annotated = mock(AnnotatedMember.class); final DeserializationConfig mockConfigWithSubtypes = mock(DeserializationConfig.class); when(mockConfigWithSubtypes.findPropertyTypeResolver(mockConfig, annotated, baseType)).thenReturn(mockBuilder); when(mockBuilder.buildTypeDeserializer(mockConfig, baseType, null)).thenReturn(mockType); final TypeDeserializer deserializer = new BasicDeserializerFactory(mockConfig).findPropertyTypeDeserializer(mockConfig, baseType, annotated); assertEquals(mockType, deserializer); }
@Test public void testModifyTypeByAnnotation() throws JsonMappingException { Annotated a = Annotated.class.getMethod("foo", String.class); try { new JsonMappingDecorator(context).modifyTypeByAnnotation(context, a, a); fail(); } catch (JsonMappingException expected) { } }
@Test public void testNarrowByMapLikeType() throws JsonMappingException { Annotated type = Annotated.class.getDeclaredMethod("put", Object.class); MapLikeType map = new MapLikeType(type, new Object()); MapLikeType newtype = (MapLikeType) map.modifyTypeByAnnotation(new DeserializationContext(), type, map); assertEquals(map, newtype); }
@Test public void testNarrowBy() throws JsonMappingException { Annotated a = context.mock(Annotated.class); expect(a.narrowBy(String.class)).andReturn("string"); expect(a.isContainerType()).andReturn(true); expect(a.isNumberType()).andReturn(true); expect(a.isDateType()).andReturn(true); expect(a.getTimeType()).andReturn(Date.class); expect(a.getTimeDate()).andReturn(Date.class); expect(a.getTimeTime()).andReturn(Date.class); expect(a.getTimeTime()).andReturn(Date.class); expect(a.getTimeTime()).andReturn(Date.class); expect(a.getTimeTime()).andReturn(Date.class); expect(a.getTimeTime()).andReturn(Date.class); expect(a.getTimeTime()).andReturn(Date.class); expect(a.getTimeTime()).andReturn(Date.class); expect(a.getTimeTime()).andReturn(Date.class); expect(a.getTimeTime()).andReturn(Date.class); expect(a.getTimeTime()).andReturn(Date.class); expect(a.getTimeTime
@Test public void resolveType_mapWithTypeHandler_returnsMapWithType() throws JsonMappingException { AnnotatedMember member = mock(AnnotatedMember.class); when(type.isContainerType()).thenReturn(true); when(type.getKeyType()).thenReturn(String.class); when(type.getValueType()).thenReturn(Integer.class); when(context.deserializerInstance(eq(member), eq(String.class))).thenReturn(new Object()); Map<String, String> map = new LinkedHashMap<>(); map.put("key", "value"); map.put("key2", "value2"); JavaType type = ((MapLikeType) type).withTypeHandler(valueTypeDeser); assertThat(map).isEqualTo(type); }
@Test public void serializeNullValue() throws IOException, JsonGenerationException { JavaType type = JavaType.OBJECT; _config.setEnabled(SerializationFeature.WRAP_ROOT_VALUE, true); _lines.writeIncompatibleRootType(null, type); _lines.writeIncompatibleRootType(null, type); _lines.writeIncompatibleRootType(null, null); _lines.writeIncompatibleRootType(null, null); _lines.writeIncompatibleRootType(null, null); _lines.writeIncompatibleRootType(null, null); _lines.writeIncompatibleRootType(null, null); _lines.writeIncompatibleRootType(null, null); _lines.writeIncompatibleRootType(null, null); _lines.writeIncompatibleRootType(null, null); _lines.writeIncompatibleRootType(null, null); _lines.writeIncompatibleRootType(null, null); _lines.writeIncompatibleRootType(null, null); _config.setEnabled(SerializationFeature.WRAP_ROOT_VALUE, true); _lines.writeIncompatibleRootType(null, null); _config.setEnabled(SerializationFeature.NO_FIELD_SERIALIZER, true); _lines.writeIncompatibleRootType(null,
@Test public void deserializeWithObjectId() throws IOException, JsonProcessingException { final String json = "{\"id\": \"id\", \"name\": \"name\"}"; when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); when(jp.getCurrentToken()).thenReturn(JsonToken.START_STRING); when(mapper.readValue(json, String.class)).thenReturn("id"); BeanDeserializer<Object> vanilla = new BeanDeserializer<Object>() { @Override protected Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { return vanilla.deserialize(jp, ctxt); } }; assertEquals("id", vanilla.deserialize(jp, null).getId()); assertEquals("name", vanilla.deserialize(jp, null).getName()); assertEquals("name", vanilla.deserialize(jp, null).getName()); }
@Test public void deserializeOther() throws IOException, JsonProcessingException { Mockito.when(jp.getToken(JsonToken.VALUE_STRING)).thenReturn(null); Mockito.when(jp.getToken(JsonToken.VALUE_NUMBER_INT)).thenReturn(null); Mockito.when(jp.getToken(JsonToken.VALUE_NUMBER_FLOAT)).thenReturn(null); Mockito.when(jp.getEmbeddedObject()).thenReturn(new Object()); Mockito.when(jp.getArray()).thenReturn(Arrays.asList(new Object[] { Boolean.TRUE, Boolean.FALSE})); Mockito.when(ctx.getObjectMapper()).thenReturn(mapper); Mockito.when(mapper.readValue(jp, MockedDeserializationContext.class)).thenReturn(new Object[] { Boolean.TRUE, Boolean.FALSE }); Mockito.when(mapper.readValue(jp, MockedDeserializationContext.class)).thenReturn(new Object[] { Boolean.TRUE, Boolean.FALSE }); Mockito.when(mapper.readValue(jp, MockedDeserializationContext.class)).thenReturn(new Object[] { Boolean.TRUE, Boolean.FALSE }); Mockito.when(mapper.readValue(jp, MockedDeserializationContext.class)).thenReturn(new
@Test public void deserializeOther() throws IOException, JsonProcessingException { Mockito.when(jp.getEmbeddedObject()).thenReturn(new Object()); Mockito.when(jp.getToken(JsonToken.VALUE_STRING)).thenReturn(null); Mockito.when(jp.getToken(JsonToken.VALUE_NUMBER_INT)).thenReturn(null); Mockito.when(jp.getToken(JsonToken.VALUE_NUMBER_FLOAT)).thenReturn(null); Mockito.when(jp.getEmbeddedObject()).thenReturn(new Object()); Mockito.when(jp.getToken(JsonToken.VALUE_EMBEDDED_OBJECT)).thenReturn(Boolean.TRUE); Mockito.when(jp.getToken(JsonToken.VALUE_TRUE)).thenReturn(Boolean.FALSE); Mockito.when(jp.getToken(JsonToken.VALUE_NUMBER_FLOAT)).thenReturn(null); Mockito.when(jp.getToken(JsonToken.VALUE_NUMBER_DOUBLE)).thenReturn(null); Mockito.when(jp.getToken(JsonToken.VALUE_NUMBER_FLOAT)).thenReturn(null); Mockito.when(jp.getToken(JsonToken.VALUE_EMBEDDED_OBJECT)).thenReturn(Boolean.TRUE); Mockito.when(jp
@Test public void deserializeOther() throws IOException { Mockito.when(jp.getEmbeddedObject()).thenReturn(new TestEmbeddedObject()); Mockito.when(jp.getToken()).thenReturn(JsonToken.VALUE_BOOLEAN); Mockito.when(jp.getEmbeddedObjectId()).thenReturn(new ObjectId(null, null)); Mockito.when(jp.getTokenString()).thenReturn(null); Mockito.when(jp.getTokenString()).thenReturn(null); Mockito.when(jp.getTokenString()).thenReturn(null); TestEmbeddedObject actual = (TestEmbeddedObject) _deserializeOther(jp, jp, ctxt, null); Assert.assertEquals(actual, Boolean.TRUE); Mockito.verify(jp, Mockito.times(1)).getEmbeddedObject(); Mockito.verify(jp, Mockito.times(1)).getTokenString(); Mockito.verify(jp, Mockito.times(1)).getTokenString(); Mockito.verify(jp, Mockito.times(1)).getTokenString(); }
@Test public void deserializeOther() throws IOException { when(jp.getEmbeddedObject()).thenReturn(embeddedObject); when(jp.getToken(JsonToken.VALUE_BOOLEAN)).thenReturn(Boolean.TRUE); when(jp.getToken(JsonToken.VALUE_STRING)).thenReturn(null); when(jp.getToken(JsonToken.VALUE_NUMBER_INT)).thenReturn(Number.valueOf(1234)); when(jp.getToken(JsonToken.VALUE_NUMBER_FLOAT)).thenReturn(Number.valueOf(1234.54)); when(jp.getEmbeddedObject()).thenReturn(embeddedObject); when(jp.getToken(JsonToken.VALUE_EMBEDDED_OBJECT)).thenReturn(Boolean.TRUE); when(jp.getToken(JsonToken.VALUE_TRUE)).thenReturn(Boolean.FALSE); when(jp.getToken(JsonToken.VALUE_FALSE)).thenReturn(Boolean.TRUE); when(jp.getByteArray(null)).thenReturn(null); when(jp.getByteArray(null)).thenReturn("".getBytes()); when(jp.getToken(JsonToken.VALUE_STRING)).thenReturn(null); when(jp.getToken(JsonToken.VALUE_NUMBER_INT)).thenReturn(Number.valueOf
@Test public void testDeserializationFromObjectUsingNonDefault() throws IOException, JsonProcessingException { DeserializationContext ctxt = mock(DeserializationContext.class); when(ctxt.getActiveView()).thenReturn(String.class); when(ctxt.getSerializable(String.class)).thenReturn(new Object()); when(ctxt.getSerializable(String.class)).thenReturn(new Object()); when(ctxt.getSerializable(String.class)).thenReturn(new Object()); when(ctxt.getSerializable(String.class)).thenReturn(new Object()); when(ctxt.getSerializable(String.class)).thenReturn(new Object()); Object deserialize = _deserializeFromObject(jp, ctxt); assertEquals(deserialize, new Object()); }
@Test public void testDeserializeFromObject_nonStandardCreation() throws IOException, JsonProcessingException { DeserializationContext ctxt = mock(DeserializationContext.class); when(ctxt.getActiveView()).thenReturn(String.class); when(ctxt.getObject()).thenReturn(new Object()); when(ctxt.getBean()).thenReturn(new Object()); when(ctxt.getBean("string")).thenReturn("value"); when(ctxt.getBean("string")).thenReturn("value"); Object deserialized = _objectMapper.deserializeFromObject(jp, ctxt); assertEquals(deserialized, bean); }
@Test public void testDeserializeFromObjectUsingNonDefault() throws IOException, JsonProcessingException { DeserializationContext ctxt = mock(DeserializationContext.class); when(ctxt.getActiveView()).thenReturn(String.class); when(ctxt.getRawType()).thenReturn(String.class); when(ctxt.getSerializable()).thenReturn(true); when(ctxt.getSerializable()).thenReturn(false); when(ctxt.getSerializable()).thenReturn(new Object()); when(ctxt.getSerializable()).thenReturn(new Object()); when(ctxt.getSerializable()).thenReturn(true); when(ctxt.getSerializable()).thenReturn(false); when(ctxt.getSerializable()).thenReturn(new Object()); when(ctxt.getSerializable()).thenReturn(new Object()); when(ctxt.getSerializable()).thenReturn(new Object()); when(jp.getCurves()).thenReturn(new Object[] { new Object() }); handleUnknownProperty(jp, ctxt, bean, "foo"); verify(bean, never()).foo(); verify(bean, never()).bar(); }
@Test public void _deserializeUsingPropertyBased() throws IOException, JsonProcessingException { final SettableBeanProperty bean = new SettableBeanProperty(); bean.setCreatorIndex(1); bean.setCreatorType("string"); bean.setCreator("string"); bean.setCreator("string"); bean.setCreatorIndex(2); bean.setBean("string"); bean.setBean("string"); bean.setBean("string"); bean.setBean("string"); bean.setBean("string"); bean.setBean("string"); bean.setBean("string"); bean.setBean("string"); bean.setBean("string"); final JsonParser jp = mock(JsonParser.class); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.
@Test public void testDeserializeUsingPropertyBasedWithExternalTypeId() throws IOException, JsonProcessingException { Mock mock = new Mock(new MockDeserializer<String>() { @Override protected String deserializeUsingPropertyBasedWithExternalTypeId(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { return "foo"; } }); new Mock(mock.getExternalTypeIdHandler()).setExternalTypeIdHandler(mock); String json = "{\"foo\": \"bar\"}"; MockMapper mapper = new MockMapper(); MockDeserializationContext ctxt = new MockDeserializationContext(json); String actual = mapper.deserializeUsingPropertyBasedWithExternalTypeId(jp, ctxt); assertEquals("bar", actual); }
@Test public void testDeserializeUsingPropertyBasedWithExternalTypeId() throws IOException, JsonProcessingException { final String json = "{\"id\":\"id\",\"name\":\"name\",\"type\":\"string\"}"; final MockPropertyValueBasedCreator mockBasedCreator = new MockPropertyValueBasedCreator(); final MockExternalTypeHandler mockExternalTypeIdHandler = new MockExternalTypeHandler(); final JsonParser jp = mock(JsonParser.class); Mockito.when(jp.getCodec()).thenReturn(mockedCodec); Mockito.when(mockedExternalTypeIdHandler.start()).thenReturn(mockedCreator); Mockito.when(mockedCreator.startBuilding(jp, ctxt, _objectIdReader)).thenReturn(mockedPropertyValueBuffer); Mockito.when(mockedPropertyValueBuffer.readObjectValue()).thenReturn(json); Mockito.when(mockedExternalTypeIdHandler.handlePropertyValue(jp, ctxt, "id", mockedPropertyValueBuffer)).thenReturn(true); Mockito.when(mockedExternalTypeIdHandler.handleExternalTypeId(jp, ctxt, "name", mockedExternalTypeIdHandler)).thenReturn(true); Mockito.when(mockedExternalTypeIdHandler.handleExternalTypeId(jp, ctxt, "type", mockExternalTypeIdHandler)).thenReturn(true); new Mock
@Test public void testReadPropertyBasedWithExternalTypeId() throws IOException, JsonProcessingException { MockPropertyValueBuffer buffer = new MockPropertyValueBuffer(); Mockito.when(buffer.readIdProperty("property")).thenReturn(true); Mockito.when(buffer.startBuilding(Mockito.eq(jp), Mockito.eq(null), Mockito.any(Reader.class))).thenReturn(buffer); Mockito.when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); Mockito.when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); Mockito.when(buffer.readIdProperty("property")).thenReturn(false); Mockito.when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); Mockito.when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); Mockito.when(buffer.readIdProperty("property")).thenReturn(true); new Assert.assertEquals(new Object(), buffer.deserializeUsingPropertyBasedWithExternalTypeId(jp, null)); Mockito.verify(buffer).readIdProperty("property"); Mockito.verify(buffer).startBuilding(jp, Mockito.eq(null), Mockito.any(Reader.class)); Mockito.verify(jp, Mockito.atLeastOnce()).
@Test public void testDeserializeUsingPropertyBasedWithExternalTypeId() throws IOException, JsonProcessingException { final String id = "id"; final String name = "name"; final String id2 = "id2"; final String id3 = "id3"; final String name2 = "name2"; final String id3 = "id3"; final String name2 = "name2"; final String id2 = "id22"; final String id3 = "id3"; final String name3 = "name3"; final String id4 = "id4"; final PropertyBasedCreator creator = mock(PropertyBasedCreator.class); when(creator.startBuilding(jp, _context, _objectIdReader)).thenReturn(new PropertyValueBuffer(id, name, id2, id3)); when(creator.findCreatorProperty(id)).thenReturn(null); when(creator.startBuilding(jp, _context, _objectIdReader)).thenReturn(new PropertyValueBuffer(id, name, id3, id4)); when(propertyBasedCreator.handlePropertyValue(jp, _context, id2, (PropertyValueBuffer) isNull())).thenReturn(true); when(propertyBasedCreator.handlePropertyValue(jp, _context, id3, (
@Test public void testDeserializeUsingPropertyBasedWithExternalTypeId() throws IOException, JsonProcessingException { String json = "{\"id\":\"1\",\"name\":\"test\"}"; MockJParser jp = new MockJParser(json); jp.setCodec(mockCodec); jp.nextToken(); new SettableBeanProperty(null, "id").setId("1"); new SettableBeanProperty(null, "name").setId("2"); new SettableBeanProperty(null, "name").setId("3"); new SettableBeanProperty(null, "name").setId("4"); new SettableBeanProperty(null, "name").setId("5"); new SettableBeanProperty(null, "name").setId("6"); new SettableBeanProperty(null, "name").setId("7"); new SettableBeanProperty(null, "name").setId("8"); new SettableBeanProperty(null, "name").setId("9"); new SettableBeanProperty(null, "name").setId("10"); new SettableBeanProperty(null, "name").setId("11"); new SettableBeanProperty(null, "name").setId("12"); new SettableBean
@Test public void testHandlePropertyValue() throws IOException, JsonProcessingException { final String propertyValue = "someString"; final String propertyValue2 = "someOtherString"; final String propertyValue3 = "someOtherString"; final String propertyValue4 = "someOtherString"; final String propertyValue5 = "someOtherString"; final String propertyValue6 = "someOtherString"; final String propertyValue7 = "someOtherString"; final String propertyValue8 = "someOtherString"; final String propertyValue9 = "someOtherString"; final String propertyValue10 = "someOtherString"; final String propertyValue11 = "someOtherString"; final String propertyValue12 = "someOtherString"; final String propertyValue13 = "someOtherString"; final String propertyValue220 = "someOtherString"; final String propertyValue21 = "someOtherString"; final String propertyValue22 = "someOtherString"; final String propertyValue223 = "someOtherString"; final String propertyValue23 = "someOtherString"; final String propertyValue24 = "someOtherString"; final String propertyValue23 = "someOtherString"; final String propertyValue242 = "someOtherString"; final String propertyValue231 = "someOtherString"; final String propertyValue2223 = "someOtherString"; final String propertyValue232 =
@Test public void testDeserializeUsingPropertyBasedWithExternalTypeId() throws IOException, JsonProcessingException { final String json = "{\"id\":\"id\",\"name\":\"name\",\"type\":\"string\"}"; final MockPropertyValueBasedCreator mockBasedCreator = new MockPropertyValueBasedCreator(); final MockExternalTypeHandler mockExternalTypeIdHandler = new MockExternalTypeHandler(); final JsonParser jp = mock(JsonParser.class); Mockito.when(jp.getCodec()).thenReturn(mockedCodec); Mockito.when(mockedExternalTypeIdHandler.start()).thenReturn(mockedCreator); Mockito.when(mockedCreator.startBuilding(jp, ctxt, _objectIdReader)).thenReturn(mockedPropertyValueBuffer); Mockito.when(mockedPropertyValueBuffer.readObjectValue()).thenReturn(json); Mockito.when(mockedExternalTypeIdHandler.handlePropertyValue(jp, ctxt, "id", mockedPropertyValueBuffer)).thenReturn(true); Mockito.when(mockedExternalTypeIdHandler.handleExternalTypeId(jp, ctxt, "name", mockedExternalTypeIdHandler)).thenReturn(true); Mockito.when(mockedExternalTypeIdHandler.handleExternalTypeId(jp, ctxt, "type", mockExternalTypeIdHandler)).thenReturn(true); new Mock
@Test public void testDeserializeUsingPropertyBasedWithExternalTypeId() throws IOException, JsonProcessingException { String json = "{\"id\":\"123\",\"name\":\"test\"}"; MockJParser jp = new MockJParser(new StringReader(json)); try { new MockExternalTypeHandler().deserializeUsingPropertyBasedWithExternalTypeId(jp, null); Assert.fail(); } catch (JsonProcessingException e) { } }
@Test public void testComplete() throws IOException, JsonProcessingException { MockExternalTypeHandler ext = new MockExternalTypeHandler(); MockPropertyBasedCreator creator = new MockPropertyBasedCreator(); MockPropertyValueBuffer buffer = new MockPropertyValueBuffer(); jp.setCodec(codec); ext.complete(jp, ctxt, buffer, creator); Mockito.verify(propertyBasedCreator).startBuilding(jp, ctxt, buffer); }
@Test public void testCreateContextual() throws Exception { AnnotationValues v = new AnnotationValues(); v.setValues(Arrays.asList(new String[] {"one", "two"}, new String[] {"three", "four"})); v.setShapeWrittenUsingIndex(String.class, true); BeanProperty property = new BeanProperty(v, "values", null); JsonSerializer<?> contextual = v.createContextual(null, property); JsonReader reader = new JsonReader(new StringReader(v.toJson())); JsonReader.next(); assertTrue(reader.next()); assertTrue(reader.next()); assertTrue(reader.next()); assertTrue(reader.next()); assertTrue(reader.next()); assertTrue(reader.next()); }
@Test public void createContextual() throws Exception { AnnotationConfig.Builder builder = AnnotationConfig.builder(TestBean.class); TestBean bean = new TestBean(); bean.setEnum("FOO"); bean.setEnum("BAR"); bean.setEnum("FOO_BAR"); bean.setEnum("BAR_BAR"); bean.setEnum("FOO_BAR_BAR"); bean.setEnum("BAR_BAR_BAR"); bean.setEnum("BAR_BAR_BAR"); bean.setEnum("FOO_BAR_BAR"); bean.setEnum("BAR_BAR_BAR"); bean.setEnum("BAR_BAR_BAR_BAR"); bean.setEnum("FOO_BAR_BAR"); bean.setEnum("BAR_BAR_BAR"); bean.setEnum("BAR_BAR_BAR"); bean.setEnum("BAR_BAR_BAR"); bean.setEnum("BAR_BAR_BAR"); bean.setEnum("BAR_BAR_BAR"); bean.setEnum("FOO_BAR_BAR"); bean.setEnum("BAR_BAR_BAR"); bean.setEnum("BAR_BAR_BAR"); bean.setEnum("FOO_BAR_BAR"); bean.set
@Test public void testCreateContextual() throws Exception { AnnotationConfig.Builder builder = AnnotationConfig.builder(TestBean.class).bean(TestBean.class).property("enum", "foo").property("enum", "bar").build(); TestBean bean = new TestBean(); bean.setEnum("foo"); JsonSerializer serializer = new EnumSerializer(new EnumValues(Enum.values()), true); assertEquals(TestBean.class, serializer.createContextual(null, bean).getClass()); }
@Test public void testEnumValues() { EnumSerializer.Value enumNode = new EnumSerializer.Value(EnumValues.values()); JsonNode schema = _serialiser.getSchema(_provider, null); JsonNode expectedNode = Json.createObjectNode(); expectedNode.add("enum", enumNode); assertEquals(expectedNode, schema); }
@Test public void testEnumSerializer() { EnumSerializer v = new EnumSerializer(EnumValues.values()); JavaType type = provider.constructType(EnumValues.class); JsonNode schema = v.getSchema(provider, type); assertEquals("object", schema.get("string").asText()); }
@Test public void testEnumValues() { EnumSerializer.instance(EnumValues.values(), false); assertJson("{\"enum\":[\"one\",\"two\"]}", createSchemaNode("string", true)); assertJson("{\"enum\":[\"one\",\"two\"]}", createSchemaNode("string", false)); assertJson("{\"enum\":[\"one\",\"two\"]}", createSchemaNode("string", false)); assertJson("{\"enum\":[\"one\",\"two\"]}", createSchemaNode("string", false)); assertJson("{\"enum\":[\"one\",\"two\"]}", createSchemaNode("string", false)); assertJson("{\"enum\":[\"one\",\"two\"]}", createSchemaNode("string", false)); assertJson("{\"enum\":[\"one\",\"two\"]}", createSchemaNode("string", false)); assertJson("{\"enum\":[\"one\",\"two\"]}", createSchemaNode("string", false)); assertJson("{\"enum\":[\"one\",\"two\"]}", createSchemaNode("string", false)); assertJson("{\"enum\":[\"one\",\"two\"]}", createSchemaNode("string", false)); assertJson("{\"enum\":[\"one\",\"two\"]}",
@Test public void testEnum() { EnumSerializer serializer = new EnumSerializer(EnumValues.values()); JsonNode schema = serializer.getSchema(null, null); JsonNode expected = mapper.readTree("{\"enum\":[\"A\", \"B\", \"C\"]}"); assertEquals(expected, schema); }
@Test public void testEnumValues() { EnumSerializer v = new EnumSerializer(EnumValues.values()); JsonNode schemaNode = v.getSchema(new SimpleSerializerProvider(), JavaTypes.enumType(EnumValues.values())); JsonNode expected = Json.createObjectNode("object"); assertEquals(expected, schemaNode); }
@Test public void testSerializeAsIndex() throws IOException { SerializationConfig config = new SerializationConfig(); config.setSerializeAsIndex(true); TestEnumValues v = new TestEnumValues(); EnumSerializer serializer = TestEnumSerializer.construct(TestEnumValues.class, config, null); serializer.serialize(Enum.ONE, jgen, new DefaultSerializerProvider()); jgen.flush(); Assert.assertTrue(TestEnumSerializer.isTestEnum()); Assert.assertTrue(TestEnumSerializer.isTestEnum()); }
@Test public void testIsShapeWrittenUsingIndex() { { { new EnumSerializer(_isShapeWrittenUsingIndex(EnhancedEnum.class, JsonFormat.VALUE_STRING, false), null).assertTrue(); new EnumSerializer(_isShapeWrittenUsingIndex(EnhancedEnum.class, JsonFormat.VALUE_STRING, true), null).assertTrue(); new EnumSerializer(_isShapeWrittenUsingIndex(EnhancedEnum.class, JsonFormat.VALUE_STRING, true), null).assertTrue(); new EnumSerializer(_isShapeWrittenUsingIndex(EnhancedEnum.class, JsonFormat.VALUE_STRING, true), null).assertTrue(); new EnumSerializer(_isShapeWrittenUsingIndex(EnhancedEnum.class, JsonFormat.VALUE_STRING, true), null).assertTrue(); new EnumSerializer(_isShapeWrittenUsingIndex(EnhancedEnum.class, JsonFormat.VALUE_STRING, true), null).assertTrue(); new EnumSerializer(_isShapeWrittenUsingIndex(EnhancedEnum.class, JsonFormat.VALUE_STRING, true), null).assertTrue(); new EnumSerializer(_isShapeWrittenUsingIndex(EnhancedEnum.class, JsonFormat.VALUE_STRING, true), null).assertTrue(); new Enum
@Test public void testIsShapeWrittenUsingIndex() { JsonFormat.Shape string = JsonFormat.STRING; JsonFormat.Value number = JsonFormat.NUMBER; Boolean isShapeWrittenUsingIndex = _isShapeWrittenUsingIndex(Enum.class, string, false); Assert.assertTrue(isShapeWrittenUsingIndex); Assert.assertNull(isShapeWrittenUsingIndex); Assert.assertNull(isShapeWrittenUsingIndex); Assert.assertNull(isShapeWrittenUsingIndex); Assert.assertNull(isShapeWrittenUsingIndex); Assert.assertNull(isShapeWrittenUsingIndex(Enum.class, string, false)); Assert.assertTrue(isShapeWrittenUsingIndex); Assert.assertTrue(isShapeWrittenUsingIndex(Enum.class, number, false)); Assert.assertTrue(isShapeWrittenUsingIndex(Enum.class, number, true)); Assert.assertTrue(isShapeWrittenUsingIndex(Enum.class, number, false)); Assert.assertNull(isShapeWrittenUsingIndex); }
public void testIsShapeWrittenUsingIndex() { JsonFormat.Value format = JsonFormat.Value.STRING; Boolean fromClass = true; Boolean expected = Boolean.TRUE; assertEquals(expected, _isShapeWrittenUsingIndex(Enum.class, format, fromClass)); assertEquals(expected, _isShapeWrittenUsingIndex(Enum.class, format, fromClass)); assertEquals(expected, _isShapeWrittenUsingIndex(Enum.class, format, fromClass)); assertEquals(expected, _isShapeWrittenUsingIndex(Enum.class, format, fromClass)); assertEquals(expected, _isShapeWrittenUsingIndex(Enum.class, format, fromClass)); assertEquals(expected, _isShapeWrittenUsingIndex(Enum.class, format, fromClass)); assertEquals(expected, _isShapeWrittenUsingIndex(Enum.class, format, fromClass)); assertEquals(expected, _isShapeWrittenUsingIndex(Enum.class, format, fromClass)); assertEquals(expected, _isShapeWrittenUsingIndex(Enum.class, format, fromClass)); assertEquals(expected, _isShapeWrittenUsingIndex(Enum.class, format, fromClass)); assertEquals(expected, _isShapeWrittenUsingIndex(Enum.class, format, fromClass));
@Test public void testIsShapeWrittenUsingIndex() { assertShapeWrittenUsingIndex(Enum.class, JsonFormat.STRING, false); assertShapeWrittenUsingIndex(Enum.class, JsonFormat.STRING, true); assertShapeWrittenUsingIndex(Enum.class, JsonFormat.STRING, false); assertShapeWrittenUsingIndex(Enum.class, JsonFormat.STRING, true); assertShapeWrittenUsingIndex(Enum.class, JsonFormat.STRING, false); assertShapeWrittenUsingIndex(Enum.class, JsonFormat.STRING, true); assertShapeWrittenUsingIndex(Enum.class, JsonFormat.STRING, true); assertShapeWrittenUsingIndex(Enum.class, JsonFormat.STRING, false); assertShapeWrittenUsingIndex(Enum.class, JsonFormat.STRING, true); assertShapeWrittenUsingIndex(Enum.class, JsonFormat.STRING, true); assertShapeWrittenUsingIndex(Enum.class, JsonFormat.STRING, true); assertShapeWrittenUsingIndex(Enum.class, JsonFormat.STRING, true); assertShapeWrittenUsingIndex(Enum.class, JsonFormat.STRING, true); assertShapeWrittenUsingIndex(Enum.class, JsonFormat.STRING, true); assertShapeWrittenUsingIndex(
@Test public void testResetTyped() throws Exception { JsonSerializer<Object> ser = new JsonSerializer<Object>(); [LINE] serializerCache = new SerializerCache(); serializerCache.addTypedSerializer(JavaType.getAnonymousType(), ser); serializerCache.addTypedSerializer(JavaType.getAnonymousType(), ser); serializerCache.addTypedSerializer(JavaType.getAnonymousType(), ser); serializerCache.addAndResolveNonTypedSerializer(JavaType.getAnonymousType(), ser, null); Assert.assertEquals(SER.hashCode(), serializerCache.hashCode()); serializerCache.resetTyped(JavaType.getAnonymousType()); Assert.assertEquals(SER.hashCode(), serializerCache.hashCode()); }
@Test public void testResetTyped() throws Exception { JsonSerializer<Object> ser = new JsonSerializer<Object>(); ser.addTypedSerializer(JavaType.getAnonymousType(), ser); JsonSerializer<Object> ser2 = new JsonSerializer<Object>(); ser2.addTypedSerializer(JavaType.getAnonymousType(), ser2); Assert.assertEquals(Serie.class, ser2.getClass()); Assert.assertEquals(Serie.class, ser2.getClass()); Assert.assertEquals(Serie.hashCode(), ser2.hashCode()); ser.resetTyped(MyBean.class); Assert.assertEquals(Serie.class, ser2.getClass()); Assert.assertEquals(Serie.class, ser2.getClass()); Assert.assertEquals(Serie.hashCode(), ser2.hashCode()); }
@Test public void testResetTyped() throws Exception { JsonSerializer<Object> ser = new JsonSerializer<Object>(); ser.addTypedSerializer(JavaType.BOOLEAN, true); ser.addTypedSerializer(JavaType.BOOLEAN, true); ser.addTypedSerializer(JavaType.BOOLEAN, true); ser.addTypedSerializer(JavaType.BOOLEAN, true); ser.addTypedSerializer(JavaType.BOOLEAN, true); ser.addTypedSerializer(JavaType.BOOLEAN, true); ser.addTypedSerializer(JavaType.BOOLEAN, true); ser.addAndResolveNonTypedSeri(JavaType.BOOLEAN, ser, new DefaultSerializerProvider()); assertEquals(Serie.class, ser.getWrapper().getWrapperClass()); assertEquals(Serie.class, ser.getWrapper().getWrapperClass()); }
@Test public void testResetTyped() throws Exception { JsonSerializer<Object> ser = new JsonSerializer<Object>(); ser.addTypedSerializer(JavaType.BOOLEAN, true); ser.addTypedSerializer(JavaType.BOOLEAN, true); ser.addTypedSerializer(JavaType.BOOLEAN, true); ser.addTypedSerializer(JavaType.BOOLEAN, true); ser.addTypedSerializer(JavaType.BOOLEAN, true); ser.addTypedSerializer(JavaType.BOOLEAN, true); ser.addTypedSerializer(JavaType.BOOLEAN, true); ser.addTypedSerializer(JavaType.BOOLEAN, true); ser.addTypedSerializer(JavaType.BOOLEAN, true); ser.addTypedSerializer(JavaType.BOOLEAN, true); ser.addTypedSerializer(JavaType.BOOLEAN, true); ser.addTypedSerializer(JavaType.BOOLEAN, true); ser.addTypedSerializer(JavaType.BOOLEAN, true); JsonSerializer<Object> ser2 = new JsonSerializer<Object>(); ser2.addTypedSerializer(JavaType.BOOLEAN, true); ser2.addTypedSerializer(JavaType.BOOLEAN, true); JsonSerializer<Object> ser3 = new JsonSerializer<Object>(); ser3.addTypedSerializer(JavaType
@Test public void testHash() throws Exception { JsonSerializer<Object> ser1 = new JsonSerializer<Object>(); ser1.addTypedSerializer(JavaType.BOOLEAN, Boolean.TRUE); ser1.addAndResolveNonTypedSerializer(JavaType.BOOLEAN, Boolean.TRUE, new MockSerializerProvider()); JsonSerializer<Object> ser2 = new JsonSerializer<Object>(); ser2.addTypedSerializer(JavaType.BOOLEAN, Boolean.TRUE); ser2.addAndResolveNonTypedSerializer(JavaType.BOOLEAN, Boolean.TRUE, new MockSerializerProvider()); JsonSerializer<Object> ser3 = new JsonSerializer<Object>(); ser3.addTypedSerializer(JavaType.BOOLEAN, Boolean.TRUE); ser3.addAndResolveNonTypedSerializer(JavaType.BOOLEAN, Boolean.TRUE, new MockSerializerProvider()); JsonSerializer<Object> ser4 = new JsonSerializer<Object>(); ser4.addTypedSerializer(JavaType.BOOLEAN, Boolean.TRUE); ser4.addAndResolveNonTypedSerializer(JavaType.BOOLEAN, Boolean.TRUE, new MockSerializerProvider()); JsonSerializer<Object> ser5 = new JsonSerializer<Object>(); ser5.addTypedSerializer(JavaType.BOOLEAN, Boolean.TRUE); ser5.addAndResolveNonTypedSerializer
@Test public void testResetTyped() throws Exception { new Expectations() { { [LINE].lang.String type; [LINE].lang.Object obj; [LINE].lang.String result; [LINE].resetTyped(type); result = "hello"; } }; }
@Test public void testResetTyped() throws Exception { JsonSerializer<Object> ser = new JsonSerializer<Object>(); ser.addTypedSerializer(JavaType.getAnonymousType(), ser); JsonSerializer<Object> ser2 = new JsonSerializer<Object>(); ser2.addTypedSerializer(JavaType.getAnonymousType(), ser2); assertEquals(SerType.class, ser2.getClass()); assertEquals(SerType.class, ser2.getClass()); assertEquals(SerType.getAnonymousType(), ser2.getAnonymousType()); ser.resetTyped(JavaType.getAnonymousType()); assertEquals(SerType.class, ser2.getClass()); assertEquals(SerType.class, ser2.getClass()); assertEquals(SerType.getAnonymousType(), ser2.getClass()); assertEquals(SerType.hashCode(), ser2.hashCode()); }
@Test public void testResetTyped() throws Exception { JsonSerializer<Object> ser = new JsonSerializer<Object>(); ser.addTypedSerializer(JavaTypes.BOOLEAN.getType()); ser.addAndResolveNonTypedSerializer(JavaTypes.BOOLEAN.getType(), ser, new DefaultSerializerProvider()); assertEquals(Serializers.BOOLEAN, ser.readAsBoolean()); ser.resetTyped(JavaTypes.BOOLEAN.getType()); assertEquals(Serializers.BOOLEAN, ser.readAsBoolean()); assertEquals(Serializers.BOOLEAN, ser.readAsBoolean()); }
@Test public void testResetTyped() throws Exception { JsonSerializer<Object> ser = new JsonSerializer<Object>(); ser.addTypedSerializer(JavaTypes.BOOLEAN, ser); JsonSerializer<Object> ser2 = new JsonSerializer<Object>(); ser2.addTypedSerializer(JavaTypes.BOOLEAN, ser2); JsonSerializer<Object> ser3 = new JsonSerializer<Object>(); ser3.addTypedSerializer(JavaTypes.BOOLEAN, ser3); JsonSerializer<Object> ser4 = new JsonSerializer<Object>(); ser4.addTypedSerializer(JavaTypes.BOOLEAN, ser4); ser4.addAndResolveNonTypedSerializer(JavaTypes.BOOLEAN, ser3, new DefaultSerializerProvider()); assertEquals(SerConstants.BOOLEAN, ser2.get_type()); assertEquals(SerConstants.BOOLEAN, ser3.get_type()); assertEquals(SerConstants.BOOLEAN, ser4.get_class()); assertEquals(SerConstants.BOOLEAN, ser4.get_isTyped()); assertEquals(SerConstants.BOOLEAN, ser4.get_hashCode()); }
@Test public void testResetTyped() throws Exception { TypeKey ts = new TypeKey(JavaTypes.getAnonymousClass(), false); assertEquals(ts.hashCode(), ts.hashCode()); ts.resetTyped(JavaTypes.getAnonymousClass()); assertEquals(ts.hashCode(), ts.hashCode()); }
@Test public void testRenameAll() { BeanPropertyMap properties = beanProps.renameAll(NameTransformer.NOP); assertEquals(properties.size(), 3); assertEquals(properties.get("a"), "a"); assertEquals(properties.get("b"), "b"); assertEquals(properties.get("c"), "c"); assertEquals(properties.get("d"), "d"); assertEquals(properties.get("e"), "e"); assertEquals(properties.get("f"), "f"); assertEquals(properties.get("g"), "g"); assertEquals(properties.get("h"), "h"); assertEquals(properties.get("i"), "i"); assertEquals(properties.get("j"), "j"); assertEquals(properties.get("k"), "k"); assertEquals(properties.get("l"), "l"); assertEquals(properties.get("l"), "k"); assertEquals(properties.get("k"), "k"); assertEquals(properties.get("k"), "k"); assertEquals(properties.get("k"), "k"); assertEquals(properties.get("k"), "k"); assertEquals(properties.get("k"), "k"); assertEquals(properties.get("k"), "k"); assertEquals(properties.get("k"), "k"); assertEquals
@Test public void renameAll() { BeanPropertyMap map = beanProps.renameAll(nameTransformer); assertEquals(map.size(), 3); assertEquals(map.get("a"), "a"); assertEquals(map.get("b"), "b"); assertEquals(map.get("c"), "c"); assertEquals(map.get("d"), "d"); assertEquals(map.get("e"), "e"); assertEquals(map.get("f"), "f"); assertEquals(map.get("g"), "g"); assertEquals(map.get("h"), "h"); assertEquals(map.get("i"), "i"); assertEquals(map.get("j"), "j"); assertEquals(map.get("k"), "k"); assertEquals(map.get("l"), "l"); assertEquals(map.get("k"), "k"); assertEquals(map.get("l"), "l"); }
@Test public void renameAll() throws IOException { BeanPropertyMap map = new BeanPropertyMap(); map.add(new SimpleBeanProperty("a", "aValue")); map.add(new SimpleBeanProperty("b", "bValue")); map.add(new SimpleBeanProperty("c", "cValue")); map.renameAll(NameTransformer.NOP); assertEquals(2, map.size()); assertEquals("a", map.get("a")); assertEquals("b", map.get("b")); assertEquals("c", map.get("c")); }
@Test public void renameAll() { BeanPropertyMap properties = beanProps.renameAll(NameTransformer.NOP); assertEquals(properties.size(), 3); assertEquals(properties.get("a"), "a"); assertEquals(properties.get("b"), "b"); assertEquals(properties.get("c"), "c"); assertEquals(properties.get("d"), "d"); assertEquals(properties.get("e"), "e"); assertEquals(properties.get("f"), "f"); assertEquals(properties.get("g"), "g"); assertEquals(properties.get("h"), "h"); assertEquals(properties.get("i"), "i"); assertEquals(properties.get("j"), "j"); assertEquals(properties.get("k"), "k"); assertEquals(properties.get("l"), "l"); assertEquals(properties.get("l"), "k"); assertEquals(properties.get("k"), "k"); assertEquals(properties.get("k"), "k"); assertEquals(properties.get("k"), "k"); assertEquals(properties.get("k"), "k"); assertEquals(properties.get("k"), "k"); assertEquals(properties.get("k"), "k"); assertEquals(properties.get("k"), "k"); assertEquals(
@Test public void renameAll() { BeanPropertyMap map = new BeanPropertyMap(); map.add("a").add("b").add("c"); map.renameAll(NameTransformer.NOP); assertEquals("a", map.get("a")); assertEquals("b", map.get("b")); assertEquals("c", map.get("c")); }
@Test public void renameAll() { BeanPropertyMap properties = beanProps.withName("prop").withValue("value").renameAll(NameTransformer.NOP); assertEquals("prop", properties.get("prop")); assertEquals("value", properties.get("value")); }
@Test public void testRenameAll() throws Exception { Mock mock = new Mock(); MockNameTransformer mockNameTransformer = new MockNameTransformer(); MockBeanProperty mockProp = new MockBeanProperty(); MockBeanProperty mockNewProp = new MockBeanProperty(); MockBeanProperty mockNewNewNewProp = new MockBeanProperty(); MockBeanProperty mockNewNewProp2 = new MockBeanProperty(); MockBeanProperty mockNewNewProp3 = new MockBeanProperty(); MockBeanProperty mockNewProps = new MockBeanProperty(); MockBeanPropertyMap mockProps = mock(MockBeanPropertyMap.class); mockProps.add(mockNewProps); mockProps.add(mockNewProps); mockProps.add(mockNewNewProps); mockProps.add(mockNewNewProps); mockProps.add(mockNewNewProps); mockProps.add(mockNewNewProps); mockProps.add(mockNewNewProps); mock.renameAll(mockNameTransformer); MockBeanPropertyMap mock = new MockBeanPropertyMap(); mock.add(mockNewProps); mock.renameAll(mockNameTransformer); mock.renameAll(mockNewNameTransformer); assertEquals(mockProps, mock.asMap()); }
@Test public void renameAll() { BeanPropertyMap props = beanProps.renameAll(NameTransformer.NOP); assertEquals(props.size(), 3); assertEquals(props.get("a"), "a"); assertEquals(props.get("b"), "b"); assertEquals(props.get("c"), "c"); assertEquals(props.get("d"), "d"); assertEquals(props.get("e"), "e"); assertEquals(props.get("f"), "f"); assertEquals(props.get("g"), "g"); assertEquals(props.get("h"), "h"); assertEquals(props.get("i"), "i"); assertEquals(props.get("j"), "j"); assertEquals(props.get("k"), "k"); assertEquals(props.get("l"), "l"); assertEquals(props.get("k"), "k"); assertEquals(props.get("l"), "l"); assertEquals(props.get("k"), "k"); assertEquals(props.get("k"), "k"); assertEquals(props.get("k"), "k"); assertEquals(props.get("k"), "k"); assertEquals(props.get("k"), "k"); assertEquals(props.get("k"), "k"); assertEquals(
@Test public void renameAll() { BeanPropertyMap map = beanPropertyMap.renameAll(NameTransformer.NOP); assertEquals(map.size(), 3); }
@Test public void renameAll() { BeanPropertyMap m = beanProps.renameAll(NameTransformer.NOP); assertEquals("a", m.get("a")); assertEquals("b", m.get("b")); assertEquals("c", m.get("c")); }
@Test public void renameAll() { BeanPropertyMap props = beanProps("a").renameAll(NameTransformer.NOP); assertEquals(1, props.size()); assertEquals("a", props.get("a")); }
@Test public void testRenameAll() throws Exception { BeanPropertyMap m = new BeanPropertyMap(new ArrayList<SettableBeanProperty>()); m.renameAll(NameTransformer.NOP); assertEquals(m, new BeanPropertyMap(new ArrayList<SettableBeanProperty>())); }
@Test public void test() { Bucket[] buckets = new Bucket[2]; buckets[0] = new Bucket(new Bucket("a"), "b", 1); buckets[1] = new Bucket(new Bucket("c"), "d", 2); buckets[2] = new Bucket(new Bucket("d"), "e", 3); List<SettableBeanProperty> properties = new ArrayList<SettableBeanProperty>(); properties.add(new SettableBeanProperty("a", "a")); properties.add(new SettableBeanProperty("b", "b")); properties.add(new SettableBeanProperty("c", "c")); BeanPropertyMap map = new BeanPropertyMap(properties); try { map.remove(new SettableBeanProperty("a")); fail("Expected NoSuchElementException"); } catch (NoSuchElementException e) { } try { map.remove(new SettableBeanProperty("a", "a")); fail("Expected NoSuchElementException"); } catch (NoSuchElementException e) { } try { map.remove(new SettableBeanProperty("b", "b")); fail("Expected NoSuchElementException"); } catch (NoSuchElementException e) { } try { map.remove(new SettableBeanProperty("c", "d")); fail("Expected NoSuchElementException"); } catch (NoSuch
@Test public void testIntDeser() { JsonDeserializer<Int> deser = forType(int.class); assertTrue(deser.deser(int.class).isInt()); }
@Test public void deserializeWithType() throws Exception { TypeDeserializer<Boolean[]> typeDeserializer = mock(TypeDeserializer.class); when(typeDeserializer.deserializeTypedFromArray(jp, ctxt)).thenReturn(new boolean[0]); Boolean[] actual = (Boolean[]) unit.deserializeWithType(jp, ctxt, typeDeserializer); assertArrayEquals(new boolean[0], actual); }
@Test public void deserializeWithType() throws Exception { when(typeDeserializer.deserializeTypedFromArray(jp, ctxt)).thenReturn(new boolean[] { true, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true,
@Test public void testIntDeser() { Assert.assertEquals(new Int[] {10}, new IntDeser().deserializeWithType( jp, null, int[].class)); }
@Test public void deserialize_emptyArray() throws IOException, JsonProcessingException { final JsonParser jp = mock(JsonParser.class); when(jp.isExpectedStartArrayToken()).thenReturn(true); when(jp.isExpectedStartArrayToken()).thenReturn(false); when(jp.isExpectedStartObjectToken()).thenReturn(true); when(jp.isExpectedStartObjectToken()).thenReturn(false); when(jp.isExpectedArrayToken()).thenReturn(false); when(jp.isExpectedEndArrayToken()).thenReturn(true); when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); final int[] ints = new int[] {0, 1, 2, 3}; Deser desered = deserializer.deserialize(jp, ctxt); assertEquals(ints.length, 1); assertEquals(ints[0], 1); assertEquals(ints[1], 3); }
@Test public void deserializeStartArrayTokenReturnsCorrectValue() throws IOException, JsonProcessingException { when(jp.isExpectedStartArrayToken()).thenReturn(true); when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); when(jp.isExpectedStartArrayToken()).thenReturn(false); when(jp.isExpectedStartArrayToken()).thenReturn(true); when(jp.isExpectedStartArrayToken()).thenReturn(false); when(jp.isExpectedStartArrayToken()).thenReturn(true); when(jp.isExpectedStartArrayToken()).thenReturn(false); when(jp.isExpectedStartArrayToken()).thenReturn(false); when(jp.isExpectedStartArrayToken()).thenReturn(true); when(jp.isExpectedStartArrayToken()).thenReturn(false); when(jp.isExpectedStartArrayToken()).thenReturn(false); when(jp.isExpectedStartArrayToken()).thenReturn(false); when(jp.isExpectedStartArrayToken()).thenReturn(false); when(jp.isExpectedStartArrayToken()).thenReturn(false); int[] actual = deser.deserialize(jp, ctxt); assertEquals(0, actual.length); }
@Test public void deserialize_empty() throws IOException, JsonProcessingException { when(jp.isExpectedStartArrayToken()).thenReturn(true); when(jp.isExpectedStartArrayToken()).thenReturn(false); when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); ArrayBuilders.IntBuilder builder = ctxt.getArrayBuilders(); when(arrayBuilders.getIntBuilder()).thenReturn(builder); new ArrayDeser().deserialize(jp, ctxt); verify(builder).completeAndClearBuffer(0, 0); }
@Test public void deserialize_empty() throws IOException, JsonProcessingException { final ArrayBuilders.IntBuilder builder = ctxt.arrayBuilders().getIntBuilder(); final String json = "{\"chunk\":2}"; final JsonParser jp = mock(JsonParser.class); when(jp.isExpectedStartArrayToken()).thenReturn(true); when(jp.isExpectedStartObjectToken()).thenReturn(false); when(jp.isExpectedStartObjectToken()).thenReturn(true); when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); when(jp.isExpectedEndArrayToken()).thenReturn(false); when(jp.isExpectedStartArrayToken()).thenReturn(true); when(jp.isExpectedEndObjectToken()).thenReturn(false); when(jp.isExpectedEndArrayToken()).thenReturn(true); when(jp.isExpectedStartObjectToken()).thenReturn(false); when(jp.isExpectedEndObjectToken()).thenReturn(false); when(jp.isExpectedEndObjectToken()).thenReturn(false); final int[] actual = builder.resetAndStart(); new Assert.assertEquals(new int[] {}, actual); }
@Test public void deserialize_empty() throws IOException, JsonProcessingException { DeserializationContext ctxt = mock(DeserializationContext.class); when(jp.isExpectedStartArrayToken()).thenReturn(true); when(jp.isExpectedStartArrayToken()).thenReturn(false); when(jp.isExpectedStartObjectToken()).thenReturn(true); when(jp.isExpectedStartObjectToken()).thenReturn(false); when(jp.isExpectedStartObjectToken()).thenReturn(false); when(jp.isExpectedStartObjectToken()).thenReturn(false); when(jp.isExpectedStartObjectToken()).thenReturn(false); when(jp.isExpectedStartObjectToken()).thenReturn(false); when(jp.isExpectedStartObjectToken()).thenReturn(false); when(jp.isExpectedStartObjectToken()).thenReturn(false); when(jp.isExpectedStartObjectToken()).thenReturn(false); when(jp.isExpectedStartObjectToken()).thenReturn(false); when(jp.isExpectedStartObjectToken()).thenReturn(false); when(jp.isExpectedStartObjectToken()).thenReturn(false); when(jp.isExpectedStartObjectToken()).thenReturn(false); when(jp.isExpectedStartObjectToken()).thenReturn(false); when(jp
@Test public void deserialize_emptyArray() throws IOException, JsonProcessingException { final JsonParser jp = mock(JsonParser.class); when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); when(jp.isExpectedStartArrayToken()).thenReturn(true); when(jp.isExpectedStartObjectToken()).thenReturn(false); when(jp.isExpectedStartObjectToken()).thenReturn(true); when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); when(jp.isExpectedStartArrayToken()).thenReturn(false); when(jp.isExpectedStartObjectToken()).thenReturn(true); when(jp.isExpectedStartArrayToken()).thenReturn(false); when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); ArrayBuilders.IntBuilder builder = mock(ArrayBuilders.IntBuilder.class); when(ctx.getArrayBuilders()).thenReturn(builder); when(builder.resetAndStart()).thenReturn(1); when(builder.appendCompletedChunk(eq(0), eq(1)).thenReturn(1); when(builder.completeAndClearBuffer(eq(1), eq(0))).thenReturn(2); when(builder.completeAndClearBuffer(eq(1), eq(2))).thenReturn(3); new ArrayDeser<Integer
@Test public void testIntegerDeser() throws IOException, JsonProcessingException { final String str = "23"; final DeserializationContext ctxt = mock(DeserializationContext.class); when(ctxt.getArrayBuilders().getIntBuilder()).thenReturn(new ArrayBuilders.IntBuilder().set(str.length()).build()); when(jp.isExpectedStartArrayToken()).thenReturn(true); when(jp.isExpectedStartObjectToken()).thenReturn(false); when(jp.isExpectedStartObjectToken()).thenReturn(true); when(jp.isExpectedStartObjectToken()).thenReturn(false); when(jp.isExpectedStartObjectToken()).thenReturn(true); when(jp.isExpectedStartObjectToken()).thenReturn(false); when(jp.isExpectedStartObjectToken()).thenReturn(true); when(jp.isExpectedStartObjectToken()).thenReturn(false); when(jp.isExpectedStartObjectToken()).thenReturn(false); when(jp.isExpectedStartObjectToken()).thenReturn(true); when(jp.isExpectedStartObjectToken()).thenReturn(false); when(jp.isExpectedStartObjectToken()).thenReturn(false); when(jp.isExpectedStartObjectToken()).thenReturn(false); when(jp.isExpectedStartObject
@Test public void deserialize_empty() throws IOException, JsonProcessingException { final int[] expected = new int[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
@Test public void deserialize_empty() throws IOException, JsonProcessingException { DeserializationContext ctxt = mock(DeserializationContext.class); when(ctxt.getArrayBuilders()).thenReturn(ArrayBuilders.createIntBuilder().build()); when(ctxt.getStartArrayToken()).thenReturn(true); when(ctxt.getEndArrayToken()).thenReturn(false); when(jp.isExpectedStartArrayToken()).thenReturn(true); when(jp.isExpectedStartArrayToken()).thenReturn(false); when(jp.isExpectedStartToken()).thenReturn(false); when(jp.isExpectedStartArrayToken()).thenReturn(false); when(jp.isExpectedStartArrayToken()).thenReturn(true); when(jp.isExpectedStartArrayToken()).thenReturn(false); when(jp.isExpectedStartArrayToken()).thenReturn(false); when(jp.isExpectedStartArrayToken()).thenReturn(false); when(jp.isExpectedStartArrayToken()).thenReturn(false); when(jp.isExpectedStartArrayToken()).thenReturn(false); when(jp.isExpectedStartArrayToken()).thenReturn(true); when(jp.isExpectedStartArrayToken()).thenReturn(false); when(jp.isExpectedStartArrayToken()).thenReturn(false); when
@Test public void deserialize_empty() throws IOException, JsonProcessingException { new ByteDeser().deserialize(jp, ctxt); Mockito.verify(decor, Mockito.times(0)).clearCompletedChunk(Mockito.anyInt(), Mockito.anyInt()); }
@Test public void deserialize_empty() throws IOException, JsonProcessingException { new ByteDeser().deserialize(jp, ctxt); Mockito.verify(builder).appendCompletedChunk(eq(0), eq(0)); Mockito.verify(builder).completeAndClearBuffer(eq(0), eq(0)); }
@Test public void deserialize_emptyArray() throws IOException, JsonProcessingException { final DeserializationContext ctxt = mock(DeserializationContext.class); final String json = "{\"chunk\":0,\"ix\":0}"; final ArrayBuilders arrayBuilder = mock(ArrayBuilders.class); final DeserializationContext[] context = new DeserializationContext[8]; when(jp.isExpectedStartArrayToken()).thenReturn(true); when(jp.isExpectedStartArrayToken()).thenReturn(false); when(jp.isExpectedStartObjectToken()).thenReturn(true); when(jp.isExpectedStartObjectToken()).thenReturn(false); when(jp.isExpectedStartObjectToken()).thenReturn(false); when(jp.isExpectedStartObjectToken()).thenReturn(true); when(jp.isExpectedStartObjectToken()).thenReturn(false); when(jp.isExpectedArrayToken()).thenReturn(true); when(jp.isExpectedArrayToken()).thenReturn(false); when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); when(ctx.getArrayBuilders()).thenReturn(arrayBuilder); when(arrayBuilder.completeAndClearBuffer(eq(0L), eq(0L))).thenReturn(1); when(arrayBuilder.completeAndClearBuffer(
@Test public void testPropertyValueBuffer() throws IOException { JsonParser jp = mock(JsonParser.class); DeserializationContext ctxt = mock(DeserializationContext.class); int paramCount = 2; ObjectIdReader oir = mock(ObjectIdReader.class); new PropertyValueBuffer(jp, ctxt, paramCount, oir).bufferProperty(paramCount, "test"); verify(ctxt).readIdValue(null); verify(oir).readIdValue(null); }
@Test public void testPropertyValueBuffer() throws IOException { JsonParser jp = new JsonParser(); { new PropertyValueBuffer(jp, null, 0, null); } { new PropertyValueBuffer(jp, null, 0, null); } { new PropertyValueBuffer(jp, null, 0, null); } { new PropertyValueBuffer(jp, null, 0, null); } { new PropertyValueBuffer(jp, null, 0, null); } { new PropertyValueBuffer(jp, null, 0, null); } { new PropertyValueBuffer(jp, null, 0, null); } { new PropertyValueBuffer(jp, null, 0, null); } { new PropertyValueBuffer(jp, null, 0, null); } }
@Test public void testPropertyValueBuffer() throws IOException { JsonParser jp = mock(JsonParser.class); DeserializationContext ctxt = mock(DeserializationContext.class); int paramCount = 2; ObjectIdReader oir = mock(ObjectIdReader.class); PropertyValueBuffer pvBuffer = new PropertyValueBuffer(jp, ctxt, paramCount, oir); verify(ctxt).addParameter("buffer", "foo"); verify(oir).readIdValue("foo"); verify(ctxt).addParameter("bufferAny", "bar"); }
@Test public void testPropertyValueBuffer() { TestMapper mapper = new TestMapper(); TestDeserializationContext ctxt = new TestDeserializationContext(); TestDeserializationContext deserCtx = new TestDeserializationContext(); ObjectIdReader oir = new TestObjectIdReader(); PropertyValueBuffer pvBuffer = mapper.createPropertyValueBuffer(jp, ctxt, 2, oir); assertEquals("buffer", pvBuffer.readIdProperty("buffer").toString()); assertEquals("buffer", pvBuffer.assignParameter(0, "foo")); assertEquals("foo", pvBuffer.bufferAnyProperty(null, "bar").toString()); assertEquals("bar", pvBuffer.readIdProperty("bufferAny").toString()); assertEquals("bar", pvBuffer.bufferAnyProperty(null, "foo").toString()); assertEquals("bar", pvBuffer.bufferAnyProperty(null, "bar").toString()); }
@Test public void testPropertyValueBuffer() { ObjectIdReader oir = new ObjectIdReader(); JsonParser jp = mock(JsonParser.class); DeserializationContext ctxt = mock(DeserializationContext.class); int paramCount = 2; ObjectIdReader oir = mock(ObjectIdReader.class); PropertyValueBuffer pvBuffer = new PropertyValueBuffer(jp, ctxt, paramCount, oir); assertSame(jp, pvBuffer.getParser()); assertSame(ctxt, pvBuffer.getContext()); assertSame(objReader, pvBuffer.objectIdReader); }
@Test public void testPropertyValueBuffer() { JsonParser jp = mock(JsonParser.class); DeserializationContext ctxt = mock(DeserializationContext.class); int paramCount = 2; ObjectIdReader oir = mock(ObjectIdReader.class); PropertyValueBuffer pvBuffer = new PropertyValueBuffer(jp, ctxt, paramCount, oir); assertEquals(jp, pvBuffer.getParser()); assertEquals(ctxt, pvBuffer.getContext()); assertEquals(paramCount, pvBuffer.getParameters(new Object[]{}).length); assertEquals(objIdReader, pvBuffer.getObjectIdReader()); }
@Test public void testGetParameters() { class Test { public void test() { } } Test(String param1, String param2, String param3, String param4, String param5, String param6, String param7, String param8, String param9, String param10, String param11, String param12, String param13, String param14, String param15, String param16, String param21, String param22, String param23, String param24, String param31, String param31, String param32, String param31_2, String param32_2, String param23_2, String param24_2_2 ); Test(String param1, String param2, String param3, String param14, String param21, String param22, String param23_2, String param24_2, String param31_2, String param32_2, String param24_2, String param31_2 ); Test(String param1, String param2, String param3, String param4, String param14, String param31_2, String param32_2, String param23_2, String param24_2, String param24_2 ); Test(String param1, String param2, String param3, String param31, String param32_3, String param24_2, String param31_2 );
@Test public void getParameters() { new Expectations() { { new Object[] { null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null,
@Test public void testGetParameters() { TestStream ts = new TestStream(); TestStream.test(ts, "setParameters", new String[] {"foo", "bar", "baz", "qux", "qux", "qux", "qux", "qux", "qux", "qux", "qux", "qux", "qux", "qux", "qux", "qux", "qux", "qux", "qux", "qux", "qux", "qux", "qux", "qux", "qux", "qux", "qux", "qux", "qux", "qux", "qux", "qux", "qux", "qux", "qux", "qux", "qux", "qux", "qux", "qux", "qux", "qux", "qux", "qux", "qux", "qux", "qux", "qux", "qux", "qux", "qux", "qux", "qux", "qux", "qux", "qux", "qux",
@Test public void testGetParameters() { new Expectations() { { new Getter(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null
@Test public void testGetParameters() { String[] params = new String[] { "a", "b", "c" }; Object[] defaults = new Object[] { params }; assertArrayEquals(params, getParameters(null)); assertArrayEquals(params, getParameters(new Object[] { null })); assertArrayEquals(params, getParameters(new Object[] { params })); }
@Test public void testReadIdProperty() throws IOException { new Expectations() { { DeserializerDeserializer deserializer = mock(DeserializerDeserializerDeserializer.class); when(deserializer.deserialize(null, context)).thenReturn(null); new ObjectIdReader(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null,
@Test public void testReadIdProperty() throws IOException { new Expectations() { { new ObjectIdReader(null); { new Deserializer( jp, context, new Class[]{String.class}, new JsonDeserializer( jp, context, new TypeHint<SettableBeanProperty[]>(){}) ); } }; new Expectations() { { new ObjectIdReader(jp, context, new Class[]{String.class}, new JsonDeserializer( jp, context, new TypeHint<SettableBeanProperty[]>(){}) ); } }; new Expectations() { { new ObjectMapper() { @Override public String deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException { return jp.getJsonContent().toString(); } }; } }; new PropertyValueBuffer(jp, context, 2, oir); new Expectations() { { new ObjectMapper() { @Override public String deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException { return jp.getJsonContent().toString(); } }; }; new Expectations() { { new ObjectMapper() { @Override public String deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException { return jp.getJsonContent().toString(); } }; } }; new Expectations() { { new ObjectMapper() { @Override public String deserialize(
@Test public void testHandleIdValue() throws IOException { class TestBean implements Bean { public void testBean() { } } TestBean bean = new TestBean(); bean.setFoo("bar"); bean.setBar("baz"); bean.setBar("quux"); bean.setBar("quux"); bean.setBar("quux"); DeserializationContext ctxt = mock(DeserializationContext.class); when(ctxt.findObjectId(bean.getBar(), null)).thenReturn(new ReadableObjectId("foo", null)); Object oir = mock(Object.class); when(ctxt.findObjectId(bean.getBar(), null)).thenReturn(new ReadableObjectId("foo", null)); Object oirVal = oir.handleIdValue(ctxt, bean); assertEquals("bar", oirVal); }
@Test public void testHandleIdValue() throws IOException { class TestBean implements Bean { public void test() { } } TestBean bean = new TestBean(); bean.setFoo("bar"); bean.setBar("baz"); bean.setBar("quux"); bean.setBar("quux"); DeserializationContext ctxt = mock(DeserializationContext.class); ObjectIdReader oir = mock(ObjectIdReader.class); when(ctxt.findObjectId(bean.getFoo(), bean.getBar())).thenReturn(bean); when(ctxt.bindItem(bean)).thenReturn(bean); when(oir.readIdProperty("bar")).thenReturn(bean); assertEquals("bar", bean.foo); assertEquals("baz", bean.bar); verify(ctxt).findObjectId(bean.getFoo(), bean.getBar()); verify(oir).bindItem(bean); }
@Test public void testHandleIdValue() throws IOException { Observation bean = mock(Observation.class); ObjectId reader = mock(ObjectId.class); when(context.findObjectId(anyString(), any(String.class))).thenReturn(reader); when(reader.bindItem(bean)).thenReturn(bean); assertEquals(bean, _cut.handleIdValue(_mockDeserializationContext, bean)); verify(context).findObjectId(eq(bean), any(String.class)); verify(reader).bindItem(bean); }
@Test public void testReadIdValue() throws IOException { MockDeserializationContext ctxt = new MockDeserializationContext(); ObjectId reader = mock(ObjectId.class); when(ctxt.findObjectId(bean.getId(), reader)).thenReturn(reader); when(ctxt.findObjectId(bean.getId(), reader)).thenReturn(bean); ReadableObjectId roid = mock(ReadableObjectId.class); when(ctxt.findObjectId(bean.getId(), reader)).thenReturn(roid); when(oir.bindItem(bean)).thenReturn(bean); when(oir.readIdProperty("id")).thenReturn(bean); assertEquals(bean, oir.handleIdValue(ctxt, bean)); }
@Test public void testBind() throws IOException { TestBean bean = new TestBean(); ObjectId roid = mock(ObjectId.class); when(context.findObjectId(bean.getId(), null)).thenReturn(roid); when(roid.bindItem(bean)).thenReturn(bean); assertEquals(bean, _cut.handleIdValue(_mockDeserializationContext, bean)); verify(context).findObjectId(bean.getId(), null); verify(roid).bindItem(bean); }
@Test public void testHandleIdValue() throws IOException { ObjectIdReader oir = mock(ObjectIdReader.class); when(oir.findObjectId(anyString(), any(String.class))).thenReturn(null); when(oir.bindItem(anyObject())).thenReturn(new SettableBeanProperty("id")); DeserializationContext ctxt = mock(DeserializationContext.class); when(ctxt.findObjectId(anyString(), any(String.class))).thenReturn(null); when(ctxt.findObjectId(anyString(), any(String.class))).thenReturn(new ReadableObjectId("id")); when(ctxt.findObjectId(anyString(), any(String.class))).thenReturn(new ReadableObjectId("id")); PropertyValueBuffer pv = new PropertyValueBuffer(jp, ctxt, 0, oir); assertEquals("id", pv.handleIdValue(ctxt, new Object())); }
@Test public void testHandleIdValue() throws IOException { class TestBean implements Bean { public void testBean() { } } TestBean bean = new TestBean(); bean.setFoo("bar"); bean.setBar("baz"); bean.setBar("quux"); DeserializationContext ctxt = mock(DeserializationContext.class); ObjectIdReader oir = mock(ObjectIdReader.class); when(ctxt.findObjectId(bean.getFoo(), bean.getBar())).thenReturn(bean); when(ctxt.bindItem(bean)).thenReturn(bean); when(oir.readIdProperty("bar")).thenReturn(true); Object oidValue = bean.handleIdValue(ctxt, bean); assertEquals("bar", oidValue); verify(ctxt).findObjectId(bean.getFoo(), bean.getBar()); verify(oir).bindItem(bean); }
@Test public void testHandleIdValue() throws IOException { TestBean bean = new TestBean(); bean.readIdProperty("name"); assertEquals("name", bean.name); bean.readIdValue(null, bean); bean.readIdProperty("age"); assertEquals("age", bean.age); bean.readIdValue(null, bean); bean.readIdValue(null, bean); bean.readIdValue(null, bean); bean.readIdValue(null, bean); bean.readIdValue(null, bean); bean.readIdValue(null, bean); bean.readIdValue(null, bean); bean.readIdValue(null, bean); bean.readIdValue(null, bean); bean.readIdValue(null, bean); bean.readIdValue(null, bean); bean.readIdValue(null, bean); bean.readIdValue(null, bean); bean.readIdValue(null, bean); bean.readIdValue(null, bean); bean.readIdValue(null, bean); bean.readIdValue(null, bean); bean.readIdValue(null, bean); bean.readIdValue(null, bean); }
@Test public void testBuffered() { assertEquals(PropertyValue.of("buffer", "foo"), propertyValueBuffer.buffered()); }
@Test public void testAssignParameter() { new Expectations() { { new JsonParser( jp ).assignParameter(0, "foo"); new JsonParser( jp ).assignParameter(0, "bar"); new JsonParser( jp ).assignParameter(0, "baz"); new JsonParser( jp ).assignParameter(0, "baz"); new JsonParser( jp ).assignParameter(0, "bar"); new JsonParser( jp ).assignParameter(0, "baz"); new JsonParser( jp ).assignParameter(0, "baz"); new JsonParser( jp ).assignParameter(0, "bar"); new JsonParser( jp ).assignParameter(0, "baz"); new JsonParser( jp ).assignParameter(0, "baz"); new JsonParser( jp ).assignParameter(0, "baz"); new JsonParser( jp ).assignParameter(0, "baz"); new JsonParser( jp ).assignParameter(0, "baz"); new JsonParser( jp ).assignParameter(0, "baz"); new JsonParser( jp ).assignParameter(0, "baz"); new JsonParser( jp ).assignParameter(0, "baz"); new JsonParser( jp ).assignParameter(0, "baz"); new JsonParser( jp ).assignParameter(0, "baz"); new JsonParser( jp ).assignParameter(0, "baz"); new JsonParser( jp ).assignParameter(0, "baz");
@Test public void testAssignParameter() { String s = "{\"param1\":\"value1\",\"param2\":\"value2\"}"; PropertyValueBuffer ps = new PropertyValueBuffer(null, null, 0, null); ps.assignParameter(0, s); assertEquals(s, ps.getCreatorParameters[0]); assertEquals(s, ps.getCreatorParameters[1]); }
@Test public void testAssignParameter() { String s = "{\"param1\":\"value1\",\"param2\":\"value2\"}"; PropertyValueBuffer pvBuffer = new PropertyValueBuffer(null, null, 0, null); Object oir = new StringReader(s); pvBuffer.assignParameter(0, oir); assertEquals("value1", pvBuffer.getParameters(Object[].class).[0]); assertEquals("value2", pvBuffer.getParameters(Object[].class).[1]); }
@Test public void bufferMapProperty() { class Test { public void testBufferMapProperty(Object key, Object value) { new Test(key, value); } } Test test = new Test(); class Test { public void testBufferMapProperty(Object key, Object value) { new Test(key, value); } } Test test2 = new Test(); class Test { public void testBufferMapProperty(Object key, Object value) { new Test(key, value); } } Test test3 = new Test(); class Test { public void testBufferMapProperty(Object key, Object value) { new Test(key, value); } } Test test4 = new Test(); class Test { public void testBufferMapProperty(Object key, Object value) { new Test(key, value); } } Test test5 = new Test(); class Test { public void testBufferMapProperty(Object key, Object value) { new Test(key, value); } } Test test6 = new Test(); class Test { public void testBufferMapProperty(Object key, Object value) { new Test(key, value); } } Test test7 = new Test(); class Test { public void testBufferMapProperty(Object key, Object value)
@Test public void testBufferMapProperty() { JsonParser jp = new JsonParser(); { Map<String, String> map = new HashMap<String, String>(); map.put("key", "value"); map.put("key2", "value2"); PropertyValue buffer = new PropertyValueBuffer(jp, null, 0, null); buffer.bufferMapProperty("key", map); assertEquals("value2", buffer.getValue()); } { Map<String, String> map = new HashMap<String, String>(); map.put("key", "value2"); map.put("key2", "value1"); buffer.bufferMapProperty("key", map); assertEquals("value2", buffer.getValue()); } }
@Test public void serializeContentsUsing_null() throws Exception { List<Integer> list = Arrays.asList(1, 2, null); _collection.serializeContentsUsing(list, _jgen, _provider, _jsonSerializer); verify(_provider).defaultSerializeNull(eq(_jgen)); }
@Test public void testObjectIdReader() { try { ObjectIdReader r = ObjectIdReader.construct(JavaType.OBJECT, "foo", ObjectIdGenerators.getGenerators(), null, null); fail("no exception"); } catch (Exception e) { } }
@Test public void test_construct_one_line_and_one_line_and_one_line_and_one_line_and_one_line_and_one_line_and_one_line_and_one_line_and_one_line_and_one_line_and_one_line_and_one_line_and_one_line_and_one_line_and_one_line_and_one_line_and_one_line_and_one_line_and_one_line_and_one_line_and_one_line_and_one_line_and_one_line_and_one_line_and_one_line_and_one_line_and_one_line_and_one_line_and_one_line_and_one_line_and_one_line_and_one_line_and_one_line_and_one_line_and_one_line_and_one_line_and_one_line_and_one_line_and_one_line_and_one_line_and_one_line_and_one
@Test public void test_construct_relative_path_with_line() { String path = "src/test/resources/test.xml"; ObjectIdReader r = ObjectIdReader.construct(JavaType.getAnonymousType(), "test.xml", ObjectIdGenerators.defaultOidGenerator(), null, null); assertEquals(path, r.path); }
@Test public void test_construct_file_path_relative_path() { ObjectIdReader r = construct("file:path", gen); assertEquals(gen, r.generator); assertEquals("path", r.property); assertEquals(gen, r.generator); assertEquals("path", r.path); }
@Test public void test_construct_null_null() { ObjectIdReader r = construct(JavaType.OBJECT, null, deser, null); assertNotNull(r); }
@Test public void test_construct_id_prop_is_set() { ObjectIdReader ci = construct(JavaType.INTEGER, "id", null, null, null); assertEquals(ci.idType, ObjectIdType.INTEGER); assertEquals(ci.idProperty, ObjectIdProperty.ID_PROPERTY); assertEquals(ci.generator, ObjectIdProperty.ID_GENERATOR); ci = construct(JavaType.INTEGER, "id", null, null, null); assertEquals(ci.idType, ObjectIdType.INTEGER); assertEquals(ci.idProperty, ObjectIdProperty.ID_PROPERTY); assertEquals(ci.generator, ObjectIdProperty.ID_GENERATOR); ci = construct(JavaType.INTEGER, "id", null, null, null); assertEquals(ci.idType, ObjectIdType.INTEGER); assertEquals(ci.idProperty, ObjectIdProperty.ID_PROPERTY); assertEquals(ci.generator, ObjectIdProperty.ID_GENERATOR); ci = construct(JavaType.INTEGER, "id", null, null, null); assertEquals(ci.idType, ObjectIdType.INTEGER); assertEquals(ci.idProperty, ObjectIdProperty.ID_PROPERTY); assertEquals(ci.generator, ObjectIdProperty.ID_GENERATOR); }
@Test public void testConstruct() { ObjectIdReader r = construct(JavaType.OBJECT, "foo", null, null); Assert.assertNotNull(r); Assert.assertEquals(JavaType.OBJECT, r.getJavaType()); }
@Test public void test_construct() { ObjectIdReader r = ObjectIdReader.construct(JavaType.OBJECT, "foo", null, null, null); assertNotNull(r); assertTrue(r instanceof ObjectIdReader); }
@Test public void forProperty() { new Expectations() { { new AsArrayTypeSerializer(idResolver, beanProperty); } }; beanProperty.set("array", new String[] {"string"}); new AsArrayTypeSerializer(idResolver, beanProperty); }
@Test public void writeTypePrefixForScalar_resultJsonHasType() throws IOException, JsonProcessingException { String value = "stringValue"; new AsArrayTypeSerializer(idResolver, beanProperty).forProperty(beanProperty).serialize(); mapper.writeTypePrefixForScalar(value, jgen, String.class); jgen.flush(); assertThat(writer.toString(), is(ARRAY_STRING)); }
@Test public void writeTypePrefixForScalar_value_resultJsonHasString() throws IOException, JsonProcessingException { new Expectations() { { value.getString(); result = "string"; } }; mapper.writeTypePrefixForScalar("string", jgen, String.class); }
@Test public void writeTypePrefixForScalar_valueIsNull_resultJsonHasString() throws IOException { mapper.writeString(null, type); verify(writer).writeString(idFromValueAndType(null, type)); }
@Test public void testContainerNode() { ContainerNode node = new ContainerNode(nf); NumericNode n = (NumericNode) node.get(0); assertEquals(nf, n); assertEquals(nf, n.numberNode((byte) 0)); assertEquals(nf, n.numberNode((short) 0)); assertEquals(nf, n.numberNode((long) 0)); assertEquals(nf, n.numberNode((float) 0)); assertEquals(nf, n.numberNode((double) 0)); assertEquals(nf, n.numberNode((binaryNode) null)); assertEquals(nf, n.numberNode((BinaryNode) null)); assertEquals(nf, n.numberNode((Object) null)); assertEquals(nf, n.numberNode((Object) null)); assertEquals(nf, n.numberNode((Object) null)); assertEquals(nf, n.numberNode((Object) null)); assertEquals(nf, n.numberNode((Object) null)); assertEquals(nf, n.numberNode((Object) null)); assertEquals(nf, n.numberNode((Object) null)); assertEquals(nf, n.numberNode((Object) null)); assertEquals(nf, n.numberNode((Object) null)); assertEquals(nf, n.numberNode
@Test public void testContainerNode() { ContainerNode n = new ContainerNode(nf); assertEquals(nf, n.nodeFactory); assertEquals(nf, n.objectNode()); }
@Test public void testArrayNode() { NumericNode n = _container.arrayNode(); Assert.assertEquals(n.asText(), "arrayNode"); }
@Test public void objectNode() { ObjectNode o = new ObjectNode(new byte[] { 1, 2, 3 }); new MockContainerNode(o).objectNode(); new MockContainerNode(o).objectNode(); new MockContainerNode(o).objectNode(); new MockContainerNode(o).objectNode(); new MockContainerNode(o).objectNode(); new MockContainerNode(o).objectNode(); new MockContainerNode(null).objectNode(); new MockContainerNode(null).objectNode(); new MockContainerNode(null).objectNode(); }
@Test public void should_return_string_schema() throws Exception { JsonNode schema = this.stringSerializer.getSchema(null, null); assertThat(schema, instanceOf(StringNode.class)); }
@Test public void shouldReturnSchema() { JsonNode schemaNode = this.stringSerializer.getSchema(null, null); JsonNode expectedNode = new JsonNodeFactory(null).createSchemaNode("string", true); assertEquals(expectedNode, schemaNode); }
@Test public void testObjectIdValueProperty() throws Exception { try (ObjectIdReader reader = new ObjectIdReader(propertyName, type)) { ObjectIdValueProperty src = new ObjectIdValueProperty(reader, false); assertNotNull(src); } }
@Test public void testObjectIdValueProperty() throws Exception { ObjectIdReader objectIdReader = new ObjectIdReader(); objectIdReader.propertyName = "propertyName"; objectIdReader.idType = (byte) 1; objectIdReader.deserializer = (ObjectDeserializer<Object>) mock(ObjectDeserializer.class); ObjectIdValueProperty property = new ObjectIdValueProperty(objectIdReader, true); assertEquals(property.getName(), property.getName()); assertEquals(objectIdReader.idType, property.getIdType()); assertEquals(null, property.getDeserializer()); }
@Test public void testObjectIdValueProperty() { try { new ObjectIdValueProperty(_objectIdReader, true).withValueDeserializer(deserializer); fail("Expected exception not thrown"); } catch (Exception ex) { assertTrue(ex.getMessage().contains("is required")); } }
@Test public void testObjectIdValueProperty() throws Exception { class TestObjectIdReader extends AbstractObjectIdReader { private final String propertyName; private final String valueDeserializer; public TestObjectIdReader(String propertyName, Type type, JsonDeserializer<Object> deser) { super(propertyName, type, null, null, deser); } @Override protected void init() { } @Override protected void initDeserializer() { } @Override protected void init() { } @Override protected void init() { } @Override protected void init() { } @Override protected void init() { } @Override protected void init() { } @Override protected void init() { } @Override protected void init() { } @Override protected void init() { } @Override protected void init() { } @Override protected void init() { } @Override protected void init() { } @Override protected void init() { } @Override protected void init() { } @Override protected void init() { } @Override protected void init() { } @Override protected void init() { } @Override protected void init() { } @Override protected void init() { } @Override protected void init() { } @Override protected void init() { } @Override protected void init() { } @Override protected
@Test public void getMember() { AnnotatedMember member = objectIdValueProperty.getMember(); Assert.assertNotNull(member); }
@Test public void testWithEOL() throws IOException, JsonProcessingException { final TypeDeserializer<Object> mockDeserializer = mock(TypeDeserializer.class); final JsonDeserializer<Object> mockDeserializer2 = mock(JsonDeserializer.class); final JsonParser mockJsonParser = mock(JsonParser.class); final DeserializationContext mockContext = mock(DeserializationContext.class); final Object mockedObject = mock(Object.class); when(mockDeserializer.deserialize(mockJsonParser, mockContext, mockedObject)).thenReturn(mockedObject); final Object deserializedObject = mockDeserializer.deserialize(mockJsonParser, mockContext, mockedObject); verify(mockDeserializer).deserialize(mockJsonParser, mockContext, mockedObject); verify(mockDeserializer2).deserialize(mockJsonParser, mockContext, mockedObject); verifyNoMoreInteractions(mockDeserializer); assertEquals(mockedObject, deserializedObject); }
@Test public void testWithDeserializer() throws IOException, JsonProcessingException { new Expectations() { { _deserializer.deserialize(jp, null, null); } }; }
@Test public void deserializeWithType() throws Exception { JsonParser jp = mock(JsonParser.class); TypeDeserializer typeDeserializer = mock(TypeDeserializer.class); when(typeDeserializer.deserializeTypedFromArray(jp, mock(DeserializationContext.class))).thenReturn(new Object[] { 1, 2 }); assertEquals(new Object[] { 1, 2 }, new String[] { "a", "b" }); assertEquals(new Object[] { 1, 2 }, new String[] { "a", "b" }); }
@Test public void deserializeWithType() throws Exception { final String[] expectedValues = new String[]{"1", "2", "3", "4", "5"}; final JsonParser mockParser = mock(JsonParser.class); when(mockParser.getArray()).thenReturn(expectedValues); final DeserializationContext mockDeserializationContext = mock(DeserializationContext.class); when(mockDeserializationContext.getType()).thenReturn(String.class); final TypeDeserializer mockTypeDeserializer = mock(TypeDeserializer.class); when(mockTypeDeserializer.deserializeTypedFromArray(mockParser, mockDeserializationContext)).thenReturn(mockTypeDeserializer); final Object[] actualValues = new Object[] { "2", "3", "5" }; when(mockTypeDeserializer.deserializeTypedFromArray(mockParser, mockDeserializationContext)).thenReturn(actualValues); final Object[] actualValues2 = new Object[] { "2", "3", "5" }; final Object[] actualValues3 = new Object[] { "2", "3", "5" }; when(mockTypeDeserializer.deserializeTypedFromArray(mockParser, mockDeserializationContext)).thenReturn(actualValues2); final Object[] actualValues = new Object[] { "2", "3", "5" }; when(mockTypeDeserializer.deserializeTypedFromArray(mockParser, mockDeserializationContext)).
@Test public void CreatorProperty() throws NoSuchMethodException { CreatorProperty src = new CreatorProperty(new CreatorProperty("foo", "bar"), "foo"); CreatorProperty newName = new CreatorProperty(new CreatorProperty("bar", "baz"), "bar"); TypeDeserializer typeDeser = typeDeserFor(Foo.class); CreatorProperty CreatorProperty CreatorProperty = new CreatorProperty(new CreatorProperty("foo", "bar"), "bar"); assertEquals(src, CreatorProper.wrap(src, newName)); assertEquals(src, CreatorProper.wrap(new CreatorProperty("foo", "bar"), newName)); assertEquals(src, CreatorProper.wrap(new CreatorProperty("bar", "baz"), newName)); }
@Test public void testCreatorProperty() throws NoSuchMethodException { CreatorProperty src = new CreatorProperty(new CreatorPrope("foo", "bar"), "foo"); CreatorProperty newName = new CreatorProperty(new CreatorPrope("foo", "bar"), "bar"); TypeDeserializer typeDeser = typeDeserFactory.deserializer(String.class); CreatorProperty CreatorProperty CreatorProperty2 = new CreatorProperty(new CreatorPrope("foo", "bar2"), "bar"); assertEquals(src, CreatorPrope.wrap(src, newName)); assertEquals(new CreatorPrope("foo", "bar2"), CreatorPrope.wrap(src, newName)); assertEquals(new CreatorPrope("foo", "bar2"), CreatorPrope.wrap(src, newName)); assertEquals(new CreatorPrope("foo", "bar2"), CreatorPrope.wrap(src, newName)); assertEquals(new CreatorPrope("foo", "bar2"), CreatorPrope.wrap(src, newName)); assertEquals(new CreatorPrope("foo", "bar2"), CreatorPrope.wrap(src, newName)); assertEquals(new CreatorPrope("foo", "bar2"), CreatorPrope.wrap(src, newName)); assertEquals(new CreatorPro
@Test public void testCreatorProperty() throws NoSuchMethodException, SecurityException, IllegalArgumentException, IllegalAccessException { CreatorProperty src = new CreatorProperty(new CreatorProperty("foo", "bar")); CreatorProperty newName = new CreatorProperty(src, "newName"); newName.setAnnotation(Getter.class); CreatorProperty prop = new CreatorProperty(new CreatorProperty("foo", "bar")); assertEquals(src, prop); assertEquals(newName, newName.getName()); assertEquals(src.getAnnotation(Getter.class), getter.getAnnotation(Setter.class)); assertEquals(src.getAnnotation(Setter.class), setter.getAnnotation(Setter.class)); assertEquals(src.hashCode(), prop.hashCode()); }
@Test public void testCreatorProperty() throws NoSuchMethodException, SecurityException, IllegalArgumentException, IllegalAccessException { CreatorProperty src = new CreatorProperty(new CreatorProperty("foo", "bar")); CreatorProperty newName = new CreatorProperty(src, "newName"); newName.setAnnotation(getAnnotation("foo")); CreatorProperty newProp = new CreatorProperty(new CreatorProperty("bar", "foo")); assertEquals("bar", newName.getName()); assertEquals(src, newProp); assertEquals(newProp.getAnnotation("foo"), newName.getAnnotation("bar")); assertEquals(newProp.getCreatorIndex(), newName.getCreatorIndex()); assertEquals(newProp.getInjectableValueId(), newName.getInjectableValueId()); }
@Test public void testCreatorProperty() throws Exception { CreatorProperty src = new CreatorProperty(new CreatorProperty("foo", "bar"), "foo"); CreatorProperty newName = new CreatorProperty(new CreatorProperty("foo", "bar"), "foo"); TypeDeserializer typeDeser = new TypeDeserializer(String.class); AnnotatedParameter param = new AnnotatedParameter(type, 0); CreatorProperty CreatorProperty CreatorProperty = new CreatorProperty(new CreatorProperty("foo", "bar"), "foo"); CreatorProperty property = new CreatorProperty(new CreatorProperty("foo", "bar"), "foo"); assertEquals(injectableId, property.injectableValueId); assertEquals(injectableId, property.injectableValueId); }
@Test public void testCreatorProperty() { CreatorProperty src = new CreatorProperty("foo", JavaType.OBJECT, new TypeDeserializer(DeserializationFeature.UNWRAP_NULL_TYPE), null, 0, null); CreatorProperty dest = new CreatorProperty("bar", JavaType.OBJECT, new TypeDeserializer(DeserializationFeature.UNWRAP_NULL_TYPE), null, 0, null); CreatorProperty src2 = new CreatorProperty("foo", JavaType.OBJECT, new TypeDeserializer(DeserializationFeature.UNWRAP_NULL_TYPE), null, 0, null); CreatorProperty dest2 = new CreatorProperty("bar", JavaType.OBJECT, new TypeDeserializer(DeserializationFeature.UNWRAP_NULL_TYPE), null, 0, null); CreatorProperty src3 = new CreatorProperty("foo", JavaType.OBJECT, new TypeDeserializer(DeserializationFeature.UNWRAP_NULL_TYPE), null, 0, null); CreatorProperty src4 = new CreatorProperty("foo", JavaType.OBJECT, new TypeDeserializer(DeserializationFeature.UNWRAP_NULL_TYPE), null, 0, null); CreatorProperty src5 = new CreatorProperty("foo", JavaType.OBJECT, new TypeDeserializer(DeserializationFeature.UNWRAP_NULL_TYPE), null
@Test public void testCreatorPropertyWithAnnotation() throws NoSuchMethodException { CreatorProperty orig = new CreatorProperty("foo", JavaType.OBJECT, new TypeDeserializer(DeserializationContext.class), null, 0, null); CreatorProperty CreatorProperty newName = new CreatorProperty("bar", JavaType.OBJECT, new TypeDeserializer(DeserializationContext.class), null, 0, null); CreatorProperty origWithAnnotation = new CreatorProperty("foo", JavaType.OBJECT, new TypeDeserializer(DeserializationContext.class), null, 0, null); CreatorProperty newNameWithAnnotation = new CreatorProperty("bar", JavaType.OBJECT, new TypeDeserializer(DeserializationContext.class), null, 0, null); CreatorProperty newNameWithAnnotation = new CreatorProperty("foo", JavaType.OBJECT, new TypeDeserializer(DeserializationContext.class), null, 0, null); CreatorProperty newNameWithAnnotation = new CreatorProperty("bar", JavaType.OBJECT, new TypeDeserializer(DeserializationContext.class), null, 0, null); CreatorProperty newNameWithAnnotation = new CreatorProperty("foo", JavaType.OBJECT, new TypeDeserializer(DeserializationContext.class), null, 0, null); CreatorProperty newNameWithAnnotation = new CreatorProperty("bar", JavaType.OBJECT, new Type
@Test public void testCreatorPropertyWithAnnotation() throws NoSuchMethodException, SecurityException, IllegalArgumentException, IllegalAccessException { CreatorProperty orig = new CreatorProperty("foo", JavaType.OBJECT, new TypeDeserializer(Deserializati.class), null, null, 0, null); CreatorProperty CreatorProperty newName = new CreatorProperty("bar", JavaType.OBJECT, new TypeDeserializer(Deserializati.class), null, null, 0, null); CreatorProperty CreatorProperty copy = new CreatorProperty("foo", JavaType.OBJECT, new TypeDeserializer(Deserializati.class), null, null, 0, null); CreatorProperty copy2 = new CreatorProperty("bar", JavaType.OBJECT, new TypeDeserializer(Deserializati.class), null, null, 0, null); CreatorProperty copy3 = new CreatorProperty("foo", JavaType.OBJECT, new TypeDeserializer(Deserializati.class), null, null, 0, null); CreatorProperty copy4 = new CreatorProperty("bar", JavaType.OBJECT, new TypeDeserializer(Deserializati.class), null, null, 0, null); CreatorProperty copy5 = new CreatorProperty("bar", JavaType.OBJECT, new TypeDeserializer(Des
@Test public void testCreatorPropertyWithIndexAndInjectableId() throws NoSuchMethodException, SecurityException, IllegalArgumentException, IllegalAccessException { CreatorProperty orig = new CreatorProperty("foo", Types.STRING, null, null, 0, null, false); CreatorProperty newName = new CreatorProperty("bar", Types.STRING, null, null, 0, null, false); CreatorProperty CreatorProperty newName2 = new CreatorProperty("foo2", Types.STRING, null, null, 0, null, false); CreatorProperty CreatorProperty newName3 = new CreatorProperty("bar2", Types.STRING, null, null, 0, null, false); CreatorProperty CreatorProperty CreatorProperty CreatorProperty = new CreatorProperty("foo3", Types.STRING, null, null, 0, null, false); CreatorProperty newWrapper = new CreatorProperty("foo2", Types.STRING, null, null, 0, null, false); CreatorProperty newWrapper2 = new CreatorProperty("bar2", Types.STRING, null, null, 0, null, false); CreatorProperty newWrapper3 = new CreatorProperty("foo3", Types.STRING, null, null, 0, null, false); CreatorProperty newWrapper3 = new CreatorProperty("bar2", Types.STRING, null, null, 0, null, false); CreatorProperty new
@Test public void testCreatorPropertyInjectableValId() { CreatorProperty orig = new CreatorProperty("orig", JavaType.OBJECT, null, null, 0, "newVal"); CreatorProperty newName = new CreatorProperty("newName", JavaType.OBJECT, null, null, 0, "newVal"); CreatorProperty copy = new CreatorProperty(orig, newName); assertEquals(orig.getInjectableVal(), copy.getInjectableVal()); }
@Test public void testWithValueDeserializer() throws Exception { CreatorProperty property = new CreatorProperty(NAME, type, typeDeser, contextAnnotations, null, 0, null); CreatorProperty property2 = property.withValueDeserializer(typeDeser); assertEquals(property, property2); }
@Test public void testWithValueDeserializer() throws Exception { CreatorProperty src = new CreatorProperty(new CreatorProperty("foo", STRING_TYPE, null, null, 0, null), "bar"); CreatorProperty dest = new CreatorProperty(src, "foo"); new EqualsTester().addEqualityGroup(dest, src.withValueDeserializer(new JsonDeserializer<String>() { @Override public String deserialize(String json) throws IOException { return json; } })); }
@Test public void testGetAnnotation() { Annotation annotation = mock(Annotation.class); when(annotation.getType()).thenReturn(String.class); when(annotation.getAnnotation(String.class)).thenReturn(annotation); assertEquals(annotation, CreatorPropertyTest.getAnnotation(String.class)); }
@Test public void testGetAnnotation() { CreatorProperty prop = new CreatorProperty("foo", JavaType.OBJECT, null, null, null, 0, null); Annotation annotation = prop.getAnnotation(CreatorProperty.class); assertEquals(Annotation.class, annotation.getType()); assertEquals("foo", annotation.getName()); assertEquals(null, annotation.getAnnotation(String.class)); }
@Test public void testGetAnnotation() { Annotation annotation = mock(Annotation.class); when(annotation.getAnnotation(String.class)).thenReturn("foo"); assertEquals(annotation, CreatorPropertyTest.class.getAnnotation(String.class)); }
@Test public void testGetMember() throws NoSuchMethodException { assertEquals(MEMBER1, property1.getMember()); }
@Test public void testGetCreatorIndex() throws Exception { CreatorProperty prop = new CreatorProperty(NAME, INT_TYPE, null, null, 0, null); assertEquals(1, prop.getCreatorIndex()); prop = new CreatorProperty(NAME, STRING_TYPE, null, null, 0, null); assertEquals(2, prop.getCreatorIndex()); }
@Test public void testGetCreatorIndex() throws Exception { CreatorProperty CreatorProperty CreatorProperty = CreatorProperty.withName("foo"); assertEquals(1, CreatorProperty.getCreatorIndex()); CreatorProperty CreatorProperty = CreatorProperty.withName("bar"); assertEquals(2, CreatorProperty.getCreatorIndex()); CreatorProperty withoutCreator = CreatorProperty.withName("foo"); assertEquals(0, withoutCreator.getCreatorIndex()); CreatorProperty withoutWrapper = CreatorProperty.withWrapperName("bar"); assertEquals(0, withoutWrapper.getCreatorIndex()); CreatorProperty withoutWrapper = CreatorProperty.withWrapperName("foo"); assertEquals(0, withoutWrapper.getCreatorIndex()); }
@Test public void testGetInjectableValueId() throws Exception { CreatorProperty property = new CreatorProperty(NAME, type, null, null, 0, null); Object injectableValueId = "fooBar"; assertEquals(injectableValueId, property.getInjectableValueId()); }
@Test public void testGetInjectableValueId() throws Exception { CreatorProperty property = new CreatorProperty(TEST_PROPERTY_NAME, type, null, null, 0, null); assertEquals(TEST_PROPERTY_NAME, property.getInjectableValueId()); }
@Test public void testNamedType() { new NamedType(NamedTypeTest.class).setName("name"); new NamedType(NamedTypeTest.class, "name").setName("name"); new NamedType(NamedTypeTest.class, "name").setName("name"); new NamedType(NamedTypeTest.class, "name").setName("name"); new NamedType(NamedTypeTest.class, "name").setName("name"); new NamedType(NamedTypeTest.class, "name").setName("name"); new NamedType(NamedTypeTest.class, "name").setName("name"); new NamedType(NamedTypeTest.class, "name").setName("name"); new NamedType(NamedTypeTest.class, "name").setName("name"); new NamedType(NamedTypeTest.class, "name").setName("name"); new NamedType(NamedTypeTest.class, "name").setName("name"); new NamedType(NamedTypeTest.class, "name").setName("name"); new NamedType(NamedTypeTest.class, "name").setName("name"); new NamedType(NamedTypeTest.class, "name").setName("name"); new Named
@Test public void getSchema_withArray() throws Exception { TestSerializerProvider provider = new TestSerializerProvider(); Type typeHint = null; JsonNode schemaNode = _underTest.getSchema(provider, typeHint); Assert.assertTrue(schemaNode instanceof ArrayNode); Assert.assertEquals(schemaNode.get("items"), "foo"); }
@Test public void testGetSchema() throws Exception { String json = "{\"items\":[{\"name\":\"a\",\"type\":\"int\"}]}"; JsonSerializerProvider<Object> f = new JsonSerializerProvider<Object>() { @Override public <T> T get(Class<T> type, String property) { return new T("a"); } }; JsonSchema schema = new JsonSchema(ObjectMapperBuilder.DEFAULT); JsonNode schemaNode = schema.getSchema(f, Object.class); assertNotNull(schemaNode); assertEquals(2, schemaNode.get("items").asInt()); assertEquals(2, schemaNode.get("items").asInt()); assertEquals(2, schemaNode.get("items").asInt()); assertEquals(2, schemaNode.get("items").asInt()); assertEquals(2, schemaNode.get("items").asInt()); assertEquals(2, schemaNode.get("items").asInt()); assertEquals(2, schemaNode.get("items").asInt()); assertEquals(2, schema.get("items").asInt()); }
@Test public void getSchema_withTypeHint_shouldReturnSchemaNode() throws Exception { class TestSerializer implements JsonSerializer { public void defineSchema(JsonSchema schema) throws IOException { } } TestSerializer provider = new TestSerializer(); JsonNode schemaNode = provider.getSchema(provider, null); assertThat(schemaNode, instanceOf(JsonSchema.class)); }
@Test public void testGetSchema() throws Exception { Type typeHint = new TypeToken<List<Integer>>() {}.getType(); JsonSerializerProvider provider = mock(JsonSerializerProvider.class); when(provider.findValueSerializer(typeHint, "number")).thenReturn(new JsonSerializer<Integer>() { @Override public JsonNode get(JsonPath path, boolean bool) throws JsonMappingException { return null; } }); JsonNode schemaNode = _mapper.readTree( "{\"number\":1,\"items\":[{\"type\":\"number\"}]}"); assertEquals(schemaNode, new ArrayNode(true, true, true, true, true)); }
@Test public void testGetSchema_Array() throws JsonMappingException { Type typeHint = new TypeToken<List<Integer>>() { }.getType(); JsonNode schemaNode = mock(JsonNode.class); when(provider.findValueSerializer(typeHint, "array")).thenReturn(new SimpleSerializer()); when(provider.constructType(typeHint)).thenReturn(typeHint); when(provider.getSchema(provider, null)).thenReturn(schemaNode); JsonNode actual = _mapper.getSchema(provider, typeHint); assertEquals(expectedJson, actual); }
@Test public void testGetSchema() throws Exception { JsonSerializerProvider provider = createMock(JsonSerializerProvider.class); Type typeHint = new TypeToken<Object>() { }; expect(provider.constructType(typeHint)).andReturn(JavaType.OBJECT); Capture<JsonNode> o = new Capture<JsonNode>(); expect(provider.findValueSerializer(JavaType.OBJECT, typeHint)).andReturn(new JsonSerializer<Object>() { @Override public JsonNode get(JsonNode item, boolean b) { return item; } }); expect(provider.getSchema(typeHint, null)).andReturn(o); replay(provider); JsonSchema schema = new JsonSchema(); schema.get("items"); verify(provider); }
@Test public void testGetSchema() throws JsonMappingException { class Test implements JsonSerializer { public void test(JsonSerializer<? extends Object> serializer) throws JsonMappingException { serializer.serialize("test"); } } Test service = new Test(); service.set("test", service); JsonNode schema = service.getSchema(new DefaultSerializerProvider(), Test.class); assertNotNull(schema); assertEquals("test", schema.get("items").asText()); }
@Test public void testSchema() throws JsonMappingException { TestSerializerProvider provider = new TestSerializerProvider(); TestSerializerProvider provider2 = new TestSerializerProvider(); TestSerializerProvider provider3 = new TestSerializerProvider(); try (TestObject o = new TestObject()) { o.put("items", new StringJsonSchema(new StringSchema())); } catch (JsonMappingException e) { e.printStackTrace(); } assertEquals(o.get("items"), new StringJsonSchema(new StringSchema())); }
@Test public void testGetSchema() throws JsonMappingException { JsonNode schema = _mapper.getSchema(null, Object.class); assertEquals("array", schema.get("items").asText()); }
@Test public void shouldGetSchema() throws JsonMappingException { JsonNode schemaNode = mapper.getSchema(null, JsonNode.class); JsonNode expectedNode = mapper.readTree("{\"no-value\":null}"); assertThat(schemaNode).isEqualTo(expectedNode); }
@Test public void shouldCreateSchemaFromObjectNode() throws JsonMappingException { JsonNode objectNode = mapper.readTree("{\"foo\":{\"bar\":\"baz\"}}"); JsonNode schema = objectNode.getSchema(null, JsonNode.class); assertThat(schema).isNotNull(); assertThat(schema.toString()).isEqualTo("{\"foo\":{\"bar\":\"baz\"}}"); }
@Test public void getSchema_type_is_any() throws JsonMappingException { JsonNode schemaNode = mock(JsonNode.class); when(schemaNode.textValue()).thenReturn("no-value"); when(schemaNode.schemaType()).thenReturn("any"); JsonSerializableSchema schemaInfo = mock(JsonSerializableSchema.class); when(schemaInfo.schemaObjectPropertiesDefinition()).thenReturn(schemaNode); when(schemaInfo.schemaObjectPropertiesDefinition()).thenReturn(schemaNode); JsonNode result = mock(JsonNode.class); when(result.toString()).thenReturn("objectNode"); when(result.toString()).thenReturn("no-value"); JsonNode schema = mock(JsonSerializableSchema.class); when(result.toString()).thenReturn("objectProperties"); when(result.toString()).thenReturn("no-value"); JsonNode result2 = mock(JsonNode.class); when(result2.toString()).thenReturn("objectProperties"); when(result2.toString()).thenReturn("objectProperties"); when(result2.toString()).thenReturn("no-value"); JsonNode schema2 = mock(JsonNode.class); when(result2.toString()).thenReturn("objectProperties"); when(result2.toString()).thenReturn("objectProperties"); when(result2.toString()).thenReturn("no-value");
@Test public void shouldGetSchema_withObjectPropertiesDefinition() throws JsonMappingException { JsonNode schema = schema(NO_VALUE, "objectProperties", "itemDefinition"); JsonNode objectNode = schema.getSchema(null, JsonNode.class); assertThat(objectNode).isNotNull(); assertThat(objectNode.get("objectProperties").asText()).isEqualTo("itemDefinition"); }
@Test public void shouldGetItemDefinition() throws Exception { String itemDefinition = null; JsonSerializableSchema schemaInfo = new JsonSerializableSchema(); JsonNode objectNode = mock(JsonObjectNode.class); when(schemaInfo.schemaType()).thenReturn("any"); when(schemaInfo.schemaObjectPropertiesDefinition()).thenReturn(objectNode); when(schemaInfo.schemaObjectPropertiesDefinition()).thenReturn(null); JsonNode schema = mock(JsonNode.class); when(schema.toString()).thenReturn("{\"itemDefinition\":\"}"); JsonNode item = null; when(schema.toString()).thenReturn("{\"itemDefinition\":\"}"); JsonNode schemaItemDefinition = mock(JsonNode.class); when(schema.toString()).thenReturn("{\"itemDefinition\":\"}"); JsonNode itemDefinitionItem = mock(JsonNode.class); when(item.toString()).thenReturn("{\"itemDefinition\":\"}"); JsonNode itemDefinitionItem = mock(JsonNode.class); when(itemDefinitionItem.toString()).thenReturn("{\"itemDefinition\":\"}"); JsonNode itemDefinition = mock(JsonNode.class); when(itemDefinitionItem.toString()).thenReturn("{\"itemDefinition\":\"}"); JsonNode itemDefinitionItem = mock(JsonNode.class); when(itemDefinitionItem.toString()).thenReturn("{\"
@Test public void shouldGetSchema() throws Exception { JsonNode schema = mapper.getSchema(null, String.class); JsonNode expected = mapper.readTree("{\"noValue\":null}"); assertThat(schema).isEqualTo(expected); }
@Test public void shouldGetSchemaFromRawClass() throws Exception { String expected = "{\"schemaType\":\"any\", \"objectPropertiesDefinition\":{\"itemDefinition\":null}}"; JsonNode schema = mapper.getSchema(null, String.class); assertThat(schema).isNotNull(); assertThat(schema.toString()).isEqualTo(expected); }
@Test public void shouldGetSchemaFromRawClass() throws Exception { JsonNode schema = mapper.getSchema(null, RawClass.class); assertNotNull(schema); }
@Test public void should_return_object_type_from_schema_info() throws JsonMappingException { JsonNode schemaNode = mapper.getSchema(null, JsonNode.class); assertThat(schemaNode).isNotNull(); assertThat(schemaNode.get("type").asText()).isEqualTo("any"); }
@Test public void shouldGetSchema_withObjectPropertiesDefinition() throws Exception { JsonNode schema = mapper.getSchema(null, ObjectProperties.class); JsonNode expected = mapper.readTree("{\"objectPropertiesDefinition\":{\"foo\":true}}"); assertThat(schema).isEqualTo(expected); }
@Test public void getSchema_itemDefinition_shouldReturnObjectProperties() throws Exception { JsonNode schemaNode = mapper.readTree("{\"no-value\":null,\"item-definition\":\"value\"}"); JsonNode objectNode = schemaNode.get("item-definition"); assertThat(objectNode).isNotNull(); assertThat(objectNode.isTextNode()).isTrue(); assertThat(objectNode.isIntNode()).isTrue(); assertThat(objectNode.isStringNode()).isTrue(); }
@Test public void shouldGetSchema() throws JsonMappingException { JsonNode schema = mapper.getSchema(null, JsonNode.class); assertThat(schema).isNotNull(); assertThat(schema.toString()).isEqualTo("{\"type\":\"any\",\"objectProperties\":{\"prop\":\"value\"}}"); }
@Test public void testShortNode() { new AssertThrows(IllegalArgumentException.class, () -> new ShortNode((short) 42)); }
@Test public void testValueOfShort() { Assert.assertEquals(new ShortNode((short) 1), ShortNode.valueOf((short) 1)); Assert.assertEquals(new ShortNode((short) 2), ShortNode.valueOf((short) 2)); }
@Test public void testAsToken() { String token = new TokenBuilder().numberType().numberValue(); token = token.asToken(); Assert.assertEquals(JsonToken.VALUE_NUMBER_INT, token); }
@Test public void testNumberType() { Assert.assertEquals(JsonParser.NumberType.INT, numberType()); }
@Test public void testCanConvertToInt() { Assert.assertTrue(new TestShortNode(0).canConvertToInt()); Assert.assertTrue(new TestShortNode(1).canConvertToInt()); Assert.assertTrue(new TestShortNode(2).canConvertToInt()); Assert.assertTrue(new TestShortNode(3).canConvertToInt()); Assert.assertTrue(new TestShortNode(4).canConvertToInt()); Assert.assertTrue(new TestShortNode(5).canConvertToInt()); Assert.assertTrue(new TestShortNode(6).canConvertToInt()); Assert.assertTrue(new TestShortNode(7).canConvertToInt()); Assert.assertTrue(new TestShortNode(8).canConvertToInt()); Assert.assertTrue(new TestShortNode(9).canConvertToInt()); Assert.assertTrue(new TestShortNode(104).canConvertToInt()); Assert.assertTrue(new TestShortNode(11).canConvertToInt()); Assert.assertTrue(new TestShortNode(124).canConvertToInt()); Assert.assertTrue(new TestShortNode(13).canConvertToInt()); Assert.assertTrue(new TestShortNode(14).canConvertToInt()); Assert.assertTrue(new TestShortNode(262144).canConvertToInt());
@Test public void testCanConvertToLong() { Assert.assertTrue(new TestShortNode(0).canConvertToLong()); Assert.assertTrue(new TestShortNode(1).canConvertToLong()); Assert.assertTrue(new TestShortNode(2).canConvertToLong()); Assert.assertTrue(new TestShortNode(3).canConvertToLong()); }
@Test public void testIntValue() { Assert.assertEquals(1, _node.intValue()); }
@Test public void testIntValue() { Assert.assertEquals(7, new ShortNode(Short.MIN_VALUE).intValue()); Assert.assertEquals(0, new ShortNode(-1).intValue()); Assert.assertEquals(0, new ShortNode(Short.MAX_VALUE).intValue()); Assert.assertEquals(0, new ShortNode(-1).intValue()); Assert.assertEquals(0, new ShortNode(Short.MIN_VALUE + 1).intValue()); Assert.assertEquals(1, new ShortNode(-1).intValue()); Assert.assertEquals(1, new ShortNode(Short.MAX_VALUE).intValue()); Assert.assertEquals(1, new ShortNode(Short.MIN_VALUE).intValue()); }
@Test public void testLongValue() { Assert.assertEquals(42l, new LongNode(42).longValue()); }
@Test public void testLongValue() { Assert.assertEquals(42l, new LongNode(42).longValue()); }
@Test public void testDoubleValue() { Assert.assertEquals(1.2, _value.doubleValue(), 0); }
@Test public void testDoubleValue() { Assert.assertEquals(1.2, numbers[0].doubleValue(), 0); Assert.assertEquals(1.2, numbers[1].doubleValue(), 0); Assert.assertEquals(1.2, numbers[2].doubleValue(), 0); }
@Test public void testDecimalValue() { BigDecimal bd = new BigDecimal("1.2345"); BigDecimal bd2 = new BigDecimal("1.2345"); BigDecimal bd3 = new BigDecimal("1.2345"); BigDecimal bd4 = new BigDecimal("1.2345"); BigDecimal bd5 = new BigDecimal("1.2345"); Assert.assertEquals(bd, bd5); Assert.assertEquals(bd.decimalValue(), bd2.decimalValue()); Assert.assertEquals(bd.decimalValue(), bd3.decimalValue()); Assert.assertEquals(bd.decimalValue(), bd4.decimalValue()); Assert.assertEquals(bd.decimalValue(), bd5.decimalValue()); }
@Test public void testDecimalValue() { BigDecimal[] numbers = new BigDecimal[] { BigDecimal.ONE, BigDecimal.TEN, BigDecimal.ONE, BigDecimal.TEN, BigDecimal.ONE, BigDecimal.TEN, BigDecimal.ONE, BigDecimal.TEN, BigDecimal.ONE, BigDecimal.TEN, BigDecimal.ONE, BigDecimal.TEN, BigDecimal.ZERO, BigDecimal.ZERO, BigDecimal.ZERO, BigDecimal.ZERO, BigDecimal.ZERO, BigDecimal.ZERO, BigDecimal.ZERO, BigDecimal.ZERO, BigDecimal.ZERO, BigDecimal.ZERO, BigDecimal.ZERO, BigDecimal.ZERO, BigDecimal.ZERO, BigDecimal.ZERO, BigDecimal.ZERO, BigDecimal.ZERO, BigDecimal.ZERO, BigDecimal.ZERO, BigDecimal.ZERO, BigDecimal.ZERO, BigDecimal.ZERO, BigDecimal.ZERO, BigDecimal.ZERO, BigDecimal.ZERO, BigDecimal.ZERO, BigDecimal.ZERO, BigDecimal.ZERO, BigDecimal.ZERO, BigDecimal.ZERO, BigDecimal.ZERO, BigDecimal.ZERO, BigDecimal.ZERO, BigDecimal.ZERO, BigDecimal.ZERO, BigDecimal.ZERO, BigDecimal.ZERO, BigDecimal.ZERO, BigDecimal.ZERO, BigDecimal.ZERO, BigDecimal.ZERO, BigDecimal.ZERO, BigDecimal.ZERO, BigDecimal.ZERO, BigDecimal.ZERO, BigDecimal.ZERO, BigDecimal.ZERO, BigDecimal.ZERO, BigDecimal.
@Test public void testBigIntegerValue() { BigInteger BigInteger BigInteger BigInteger = new BigInteger("123456"); BigInteger BigInteger actual = new BigInteger("123456"); Assert.assertEquals(expected, actual); }
@Test public void testBigIntegerValue() { BigInteger[] numbers = new BigInteger[] { BigInteger.valueOf(BigInteger.MIN_VALUE), BigInteger.valueOf(BigInteger.MAX_VALUE), BigInteger.valueOf(BigInteger.MIN_VALUE), BigInteger.valueOf(BigInteger.MAX_VALUE), BigInteger.valueOf(BigInteger.MIN_VALUE), BigInteger.valueOf(BigInteger.MAX_VALUE), BigInteger.valueOf(BigInteger.MIN_VALUE), BigInteger.valueOf(BigInteger.MAX_VALUE), BigInteger.valueOf(BigInteger.MAX_VALUE), BigInteger.valueOf(BigInteger.MAX_VALUE), BigInteger.valueOf(BigInteger.MAX_VALUE), BigInteger.valueOf(BigInteger.MAX_VALUE), BigInteger.valueOf(BigInteger.MAX_VALUE), BigInteger.valueOf(BigInteger.MAX_VALUE), BigInteger.valueOf(BigInteger.MAX_VALUE) }; for (int i = 0; i < numbers.length; i++) { Assert.assertEquals(numbers[i], numbers[i].bigIntegerValue()); } }
@Test public void testAsText() { String s = "0"; Assert.assertEquals(NumberOutput.valueOf(s).asText(), "0"); }
@Test public void testAsText() { Assert.assertEquals("1", new ShortNode(1).asText()); Assert.assertEquals("1", new ShortNode(2).asText()); Assert.assertEquals("2", new ShortNode(3).asText()); }
@Test public void testEquals() throws IOException { new EqualsTester().addEqualityGroup(ShortNode.valueOf((short) 42), ShortNode.valueOf((short) 42)).addEqualityGroup(ShortNode.valueOf((short) 99)).testEquals(); }
@Test public void testEquals() throws IOExEx { String s = "{\"value\":1,\"text\":\"value\"}"; JsonParser.Token token = jg.newToken(); token.next(); token.next(); JsonNode newNode = ShortNode.valueOf((short)1).asToken(); token.next(); token.next(); token.next(); token.next(); token.next(); token.next(); newNode.value = (short)2; [LINE] newNode = ShortNode.valueOf((short)1).asToken(); token.next(); token.next(); token.next(); token.next(); token.next(); token.next(); token.next(); token.next(); token.next(); token.next(); token.next(); token.next(); }
@Test public void testEqualsNull() { Assert.assertFalse(new Object()); }
@Test public void testEquals() { new EqualsTester().addEqualityGroup(new Object()).addEqualityGroup(new ShortNode(Short.MIN_VALUE)).addEqualityGroup(new ShortNode((short) 100)).testEquals(); }
@Test public void testEquals() throws IOException { Assert.assertFalse(numberType().equals(new LongNode(Long.MAX_VALUE))); Assert.assertFalse(numberType().equals(new LongNode(Short.MAX_VALUE))); Assert.assertFalse(numberType().equals(new LongNode(Short.MIN_VALUE))); Assert.assertFalse(numberType().equals(new LongNode(Short.MIN_VALUE + 1))); Assert.assertFalse(numberType().equals(new LongNode(Short.MAX_VALUE))); }
@Test public void testHashCode() { Assert.assertEquals(new LongNode(1).hashCode(), new LongNode(1).hashCode()); }
@Test public void testHashCode() { Assert.assertEquals(new Integer(2), new Integer(2).hashCode()); }
@Test public void testIteratorSerializer() throws Exception { TypeSerializer vts = new DefaultTypeSerializer(BasicType.INSTANCE); BeanProperty property = new BeanProperty(); IteratorSerializer src = new IteratorSerializer(new ArrayList<>(), property, vts, null); IteratorSerializer serializer = new IteratorSerializer(src, property, vts, null); assertEquals( "[]", serializer.serialize(new ArrayList<>(), property, vts)); }
@Test public void testIteratorSerializer() throws Exception { BeanProperty property = new BeanProperty(); IteratorSerializer serializer = new IteratorSerializer(null, property, vts, null); assertEquals("[LINE] IteratorSerializer(null, property, vts, null) {", "}", serializer.toString()); }
@Test public void should_serialize_iterator_withResolved() throws Exception { BeanProperty property = new BeanProperty(); IteratorSerializer src = new IteratorSerializer(JavaType.OBJECT, false, new TypeSerializerImpl(Object.class), new DefaultBeanProperty(property)); IteratorSerializer src2 = new IteratorSerializer(JavaType.OBJECT, false, new TypeSerializerImpl(Object.class), new DefaultBeanProperty(property)); src.withResolved(property, new TypeSerializerImpl(Object.class), new DefaultBeanProperty(property)); StringWriter sw = new StringWriter(); JsonGenerator jgen = new JsonGenerator(sw); src.writeTo(sw); IteratorSerializer actual = src2.withResolved(property, new TypeSerializerImpl(Object.class), new DefaultBeanProperty(property)); StringWriter sw2 = new StringWriter(); actual.serializeContents(sw2.toReader(sw2.toReader(sw2.toWriter(sw2.toReader(sw2.toReader(sw2.toReader(sw2.toReader(sw2.toReader(sw2.toReader(sw2.toReader(sw2.toReader(sw2.toReader(sw2.toReader(sw2.toReader(sw2.toReader(sw2.toReader(sw2.
@Test public void testIteratorSerializer() throws Exception { BeanProperty property = new BeanProperty(); IteratorSerializer itr = new IteratorSerializer(JavaType.INTEGER, false, new TypeSerializerImpl(String.class), new TypeSerializerImpl(String.class)); itr.withResolved(property, new TypeSerializerImpl(String.class), new TypeSerializerImpl(String.class)); itr.serializeContents(new ArrayList<>(), jgen, new DefaultSerializerProvider()); assertEquals("IteratorSerializer [LINE] IteratorSerializer [INSTANCE] IteratorSerializer [INSTANCE] IteratorSerializer [INSTANCE] [INSTANCE] [INSTANCE] (new TypeSerializerImpl(String.class), new TypeSerializerImpl(String.class))", itr.toString()); }
@Test public void typedValueSerializer() throws Exception { TypeKey ts = new TypeKey(JavaType.getAnonymousType()); JsonSerializer<Object> serializer = _map.typedValueSerializer(JavaType.getAnonymousType()); serializer.serialize(ts); assertEquals(ts, _map.typedValueSerializer(JavaType.getAnonymousType())); }
@Test public void testTypedValueSerializer() { JsonSerializerMap map = new JsonSerializerMap(); map.put(TypeKey.of("int"), new JsonSerializer<Integer>() { @Override public void write(Object obj) { obj.toString(); } }); JsonSerializer<Object> serializer = map.readValueSerializer(String.class); assertEquals("{\"int\":1,\"int\":2}", serializer.write(new Object())); map.put(TypeKey.of("int"), new JsonSerializer<Integer>() { @Override public void write(Object obj) { obj.toString(); } }); }
@Test public void testBeanSerializerFactory() throws Exception { BeanDescription beanDesc = new BeanDescription(); beanDesc.setBeanProperty("name", "Bar"); beanDesc.setBeanProperty("age", 42); beanDesc.setBeanProperty("name2", "Baz"); beanDesc.setBeanProperty("age2", 10); serializer = new BeanSerializerFactory(null).withConfig(new JsonSerializerFactoryConfig(false)); JsonSerializer<?> serializerObj = serializer.serialize(null, JavaType.OBJECT); Assert.assertEquals("Bar", serializerObj.getJsonValue("name")); Assert.assertEquals(42, serializerObj.getJsonValue("age2")); Assert.assertEquals(Integer.valueOf(42) + 42 + 42 + 42 + 42 + 42 + 42 + 42 + 42 + 42 + 42 + 42 + 42 + 42 + 42 + 42 + 42 + 42 + 42 + 42 + 42 + 42 + 42 + 42 + 42 + 42 + 42 + 42 + 42 + 42 + 42 + 42 + 42 + 42 + 42 + 42 + 42 + 42 + 42 + 42 + 42 + 42 + 42 + 42 + 42 + 42 + 42 + 42 + 42 + 42 + 42 + 42 + 42 + 42 + 42 +
@Test public void testBeanSerializerFactoryConfig() throws Exception { TypeSerializer<?> beanDesc = new TypeSerializer<?>(JavaTypes.beanType()); BeanSerializerFactoryConfig f = new BeanSerializerFactoryConfig(); f.setBeanDescription(beanDesc); JsonSerializer<Object> serializer = f.createSerializer(null, JavaTypes.beanType()); assertEquals(beanDesc, serializer.serialize(null)); }
@Test public void testWithConfig() throws Exception { JsonSerializer<?> serializer = _serializer.withConfig(_config); assertTrue(serializer instanceof BeanSerializerFactory); }
@Test public void testWithConfig() { TestSerializerProvider prov = new TestSerializerProvider(); TestSerializerProvider prov2 = new TestSerializerProvider(); TestSerializerProvider prov3 = new TestSerializerProvider(); TestSerializerFactory factory = new TestSerializerFactory(prov, prov2, JavaType.OBJECT); JsonSerializer<?> serializer = factory.withConfig(new TestSerializerFactoryConfig()); JsonDeserializer<?> inner = factory.getDeserializer(JavaType.OBJECT); JsonDeserializer<?> expected = inner; assertEquals(expected, serializer.readValue(inner)); assertEquals(expected, inner.readValue(new TypeReference<List<String>>() {})); }
@Test public void testWithConfig() { JsonSerializer<?> serializer = _serializer.withConfig(_config).withAdditionalSerializers(); assertEquals(JsonSerializer.class, serializer.getClass()); }
@Test public void testCustomSerializerFactory() throws Exception { JsonSerializer<?> serializer = _serializer.withConfig(new BeanSerializerFactoryConfig(false, false)); assertTrue(serializer instanceof BeanSerializerFactory); }
@Test public void testDelegateType() throws Exception { JavaType delegateType = conv.getOutputType(new TypeFactory<JavaType>() { }); JsonSerializer<Object> serializer = typeFactory.createSerializer(prov, delegateType); JsonMappingException exception = assertThrows(JsonMappingException.class, () -> serializer.serialize(null)); assertEquals(exception.getMessage(), "Cannot convert com.alibaba.csp.core.service.JavaType to.lang.Object"); }
@Test public void testJsonSerializer() throws Exception { JsonSerializer<Object> serializer = (JsonSerializer<Object>) factory.createSerializer(provider, JavaType.getAnonymousClass()); JsonSerializer<Object> deser = serializer.deserialize(new StringReader(json)); Assert.assertTrue(deser.isArray()); Assert.assertTrue(deser.isObject()); Assert.assertTrue(deser.isObject()); Assert.assertTrue(deser.isObject()); Assert.assertTrue(deser.isObject()); Assert.assertTrue(deser.isObject()); Assert.assertTrue(deser.isObject()); Assert.assertTrue(deser.isObject()); Assert.assertTrue(deser.isObject()); Assert.assertTrue(deser.isObject()); Assert.assertTrue(deser.isObject()); Assert.assertTrue(deser.isObject()); Assert.assertTrue(deser.isObject()); Assert.assertTrue(deser.isObject()); Assert.assertTrue(deser.isObject()); Assert.assertTrue(deser.isObject()); Assert.assertTrue(deser.isObject()); Assert.assertTrue(deser.isObject()); Assert.assert
@Test public void testCreateSerializer() throws Exception { BeanDescription beanDesc = new BeanDescription(); beanDesc.setBeanClass(MyBean.class); beanDesc.setBeanInterface(MyInterface.class); beanDesc.setBeanInterface(MyInterface.class); JsonSerializer<?> ser = _factory.createSerializer2(prov, JavaType.OBJECT, beanDesc, false); Assert.assertEquals(MyBean.class, ser.getBeanClass()); }
@Test public void testCreateContainerSerializer() throws Exception { TypeRegistry.registerType(JavaType.CONTAINER, container); BeanDescription beanDesc = new BeanDescription(); beanDesc.setContainerClass(true); JsonSerializer<?> ser = mod.modifySerializer(null, beanDesc, false); Assert.assertEquals(Container.class, ser.getClass()); }
@Test public void findPropertyTypeSerializer() throws Exception { ClassWithProperty<Foo> foo = new ClassWithProperty<Foo>(); foo.setBar(new Bar()); FooBar fooBar = new FooBar(); fooBar.setBar(new Bar()); Collection<NamedType> subtypes = config.getSubtypeResolver().collectAndResolveSubtypes( new TypeResolver<NamedType>() { @Override public TypeSerializer buildTypeSerializer( SerializationConfig config, AnnotatedMember accessor) throws JsonMappingException { TypeSerializer a = config.getAnnotation(Bar.class); TypeSerializer b = a.findPropertyTypeSerializer(fooBar, config, accessor); return a; } }); assertEquals(bar.getBar().getBar(), fooBar); }
@Test public void testFindPropertyTypeSerializer() throws Exception { SerializationConfig config = new SerializationConfig(); config.setUseObjectFieldOrder(true); config.setUseObjectFieldFieldFieldOrder(false); TypeSerializer serializer = factory.findPropertyTypeSerializer(JavaType.get(String.class), config, AnnotatedMember.of("foo")); assertNotNull(serializer); }
@Test public void testConstructBeanSerializer() throws Exception { BeanDescription beanDesc = new BeanDescription(TestBean.class, "testBean", new Type[] {String.class, String.class, Integer.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String
@Test public void testConstructBeanSerializerModifier() throws Exception { BeanDescription beanDesc = new BeanDescription(); beanDesc.setBeanClass(Object.class); beanDesc.setBeanProperty("one"); beanDesc.setBeanProperty("two"); beanDesc.setBeanProperty("three"); BeanSerializerModifier modifier = mock(BeanSerializerModifier.class); when(modifier.changeProperties(eq( SerializationConfig.class), eq(beanDesc), anyList())).thenReturn(new ArrayList<BeanPropertyWriter>()); when(modifier.applyModifiers(eq(beanDesc), anyList())).thenReturn(new ArrayList<BeanPropertyWriter>()); BeanPropertyWriter writer = mock(BeanPropertyWriter.class); when(writer.getBeanProperty()).thenReturn("one"); when(writer.getBeanPropertyWriter()).thenReturn("two"); when(writer.getBeanPropertyWriter()).thenReturn("three"); BeanPropertyWriter writer2 = mock(BeanPropertyWriter.class); when(writer2.getBeanProperty()).thenReturn("four"); when(writer2.getBeanPropertyWriter()).thenReturn("five"); when(writer2.applyModifiers(eq(beanDesc), anyList())).thenReturn(writer2); TestFactory factory = new TestFactory(); TestBeanSerializerModifier modifier
@Test public void testConstructBeanSerializer() throws Exception { BeanDescription beanDesc = new BeanDescription(TestBean.class, "testBean", new Type[] {String.class, String.class, Integer.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String
@Test public void testCustomModifier() throws Exception { BeanDescription beanDesc = new BeanDescription(); beanDesc.setBeanClass(MyBean.class); beanDesc.setBeanProperty("one"); beanDesc.setBeanProperty("two"); beanDesc.setBeanProperty("three"); BeanSerializerModifier modifier = mock(BeanSerializerModifier.class); when(modifier.changeProperties(eq( SerializationConfig.class), eq(beanDesc), anyList())).thenReturn(new ArrayList<BeanPropertyWriter>()); when(modifier.changeProperties(eq( SerializationConfig.class), eq(beanDesc), anyList())).thenReturn(new ArrayList<BeanPropertyWriter>()); BeanPropertyWriter writer = mock(BeanPropertyWriter.class); when(writer.getBeanProperty()).thenReturn("one"); when(writer.getBeanPropertyWriter()).thenReturn("two"); when(writer.getBeanPropertyWriter()).thenReturn("three"); BeanPropertyWriter writer2 = mock(BeanPropertyWriter.class); when(writer2.getBeanProperty()).thenReturn("four"); when(writer2.getBeanPropertyWriter()).thenReturn("five"); BeanPropertyWriter writer3 = mock(BeanPropertyWriter.class); when(writer3.getBeanProperty()).thenReturn("six"); when
@Test public void testConstructBeanSerializer() throws Exception { BeanDescription beanDesc = new BeanDescription(TestBean.class, "testBean", new Type[] {String.class, String.class, Integer.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String
@Test public void testConstructBeanSerializerModifier() throws Exception { BeanDeserializer<?> factory = new BeanDeserializerProvider(new StringDeserializer(), new StringDeserializer()); BeanDescription beanDesc = new BeanDescription(Foo.class, "bar", new StringDeserializer()); BeanSerializerModifier modifier = factory.createModifier(Foo.class, Foo.class); Modifier modifier2 = factory.createModifier(Bar.class, Bar.class); Modifier modifier3 = factory.createModifier(Foo.class, Foo.class); Modifier modifier4 = factory.createModifier(Bar.class, Foo.class); Modifier modifier5 = factory.createModifier(Bar.class, Bar.class); Modifier modifier6 = factory.createModifier(Foo.class, Foo.class); Modifier modifier7 = factory.createModifier(Bar.class, Bar.class); Modifier modifier8 = factory.createModifier(Bar.class, Bar.class); Modifier modifier9 = factory.createModifier(Bar.class, Bar.class); Modifier modifier10 = factory.createModifier(Bar.class, Bar.class); BeanSerializerModifier modifier11 = factory.createModifier(Bar.class, Bar.class); BeanSerializerModifier modifier12 = factory.createModifier(Bar.class
@Test public void constructObjectIdHandler_implType() throws JsonMappingException { beanDesc.setObjectIdInfo(new ObjectIdInfo()); beanDesc.setBeanClass(MyBean.class); beanDesc.setBeanName("MyBean"); beanDesc.setBeanName("MyBean"); beanDesc.setIdInfo(new ObjectIdInfo()); BeanPropertyWriter pr = mock(BeanPropertyWriter.class); when(pr.getBeanName()).thenReturn("MyBean"); when(pr.getPropertyName()).thenReturn("MyBean"); when(pr.size()).thenReturn(1); when(beanDesc.getBeanClass()).thenReturn(MyBean.class); when(beanDesc.getObjectIdInfo()).thenReturn(null); exception.expect(IllegalArgumentException.class); exception.expectMessage("Invalid Object Id definition for class MyBean: can not find property with name 'MyBean'"); constructObjectIdHandler(null, beanDesc, null); }
@Test public void constructObjectIdHandler_property_not_found() throws JsonMappingException { beanDesc.setObjectIdInfo(null); beanDesc.setBeanClass(MyBean.class); beanDesc.setBeanName("test"); beanDesc.setClassName("test"); beanDesc.setPropertyName("id"); beanDesc.setPropertyType(String.class); beanDesc.setPropertyName("id"); beanDesc.setPropertyType(String.class); beanDesc.setPropertyType(String.class); beanDesc.setPropertyName("id_prop"); beanDesc.setPropertyType(String.class); beanDesc.setPropertyInfo(new ObjectIdInfo()); try {.io.File file = new.io.File(file); ObjectIdWriter idHandler = constructObjectIdHandler(null, beanDesc, null); Assert.fail("Expected IllegalArgumentException"); } catch (IllegalArgumentException e) { Assert.assertTrue(e.getMessage().contains("can not find property with name")); } }
@Test public void constructObjectIdHandler_propertyName() throws JsonMappingException { BeanDescription beanDesc = new BeanDescription(); beanDesc.setObjectIdInfo(new ObjectIdInfo()); beanDesc.setBeanClass(TestBean.class); beanDesc.setBeanName("test"); BeanPropertyWriter writer = null; try { ObjectIdGenerator gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo); ObjectIdWriter result = gen.writeObjectIdHandler(prov, beanDesc, props); assertNotNull(result); } catch (Exception e) { fail("should not throw an exception"); } }
@Test public void constructObjectIdHandler() throws JsonMappingException { BeanPropertyWriter writer = mock(BeanPropertyWriter.class); when(writer.getBeanClass()).thenReturn(TestBean.class); when(writer.getPropertyName()).thenReturn("id"); BeanDescription beanDesc = mock(BeanDescription.class); when(beanDesc.getObjectIdInfo()).thenReturn(new ObjectIdInfo()); when(beanDesc.getBeanClass()).thenReturn(TestBean.class); when(beanDesc.getBeanName()).thenReturn("id"); ObjectIdWriter result = objectIdWriter.constructObjectIdHandler(null, "id", null, null); assertNotNull(result); assertEquals("id", result.getObjectIdInfo().getPropertyName()); }
@Test public void testRemoveIgnorableTypes() { MockSerializationConfig config = new MockSerializationConfig(); BeanDescription beanDesc = new BeanDescription(); BeanPropertyDefinition pd = new AnnotatedMember(Foo.class, "bar", new Class<?>[]{String.class}, new Object[]{new Integer(10)} ); config.addAnnotationIntrospector(pd); config.removeIgnorableTypes(config, beanDesc, Arrays.asList(pd)); }
@Test public void testObjectIdGeneratorInstance_null() throws JsonMappingException { ObjectIdInfo info = new ObjectIdInfo(); info.setGeneratorType(null); ObjectIdGenerator<?> gen = objectIdGeneratorInstance(info, null); Assert.assertNull(gen); }
@Test public void objectIdGeneratorInstance() throws JsonMappingException { @SuppressWarnings("unused") Class<?> implClass = TestObjectIdGenerator.class; @SuppressWarnings("unused") ObjectIdInfo objectIdInfo = new ObjectIdInfo(null, null, null, null, null, null); @SuppressWarnings("unused") Class<?> factoryClass = TestObjectIdGenerator.class; @SuppressWarnings("unused") ObjectIdGenerator<?> gen = (ObjectIdGenerator<?>) ClassUtil.createInstance(factoryClass, true); @SuppressWarnings("unused") Class<TestInterface> interfaceClass = TestInterface.class; @SuppressWarnings("unused") TestInterface interfaceInterface = new TestInterface(); @SuppressWarnings("unused") ObjectIdGenerator<?> genInterface = (ObjectIdGenerator<?>) ClassUtil.createInstance(interfaceClass, true); try { new Line(gen).objectIdGeneratorInstance(null, objectIdInfo); fail("Should have thrown an exception"); } catch (JsonMappingException e) { } }
@Test public void objectIdGeneratorInstance() throws JsonMappingException { MapperConfig<?> config = createConfig(); HandlerInstantiator handlerInstantiator = createHandlerInstantiator(config); ObjectIdInfo objectIdInfo = new ObjectIdInfo(HandlerInstantiator.class, "test", "test", "test"); MapperConfig<?> mapperConfig = createMapperConfig(); mapperConfig.setHandlerInstantiator(handlerInstantiator); mapperConfig.setCanOverrideAccessModifiers(true); ObjectIdGenerator<?> result = objectIdGeneratorInstance(mapperConfig, objectIdInfo); assertNotNull(result); assertTrue(result instanceof TestObjectIdGenerator); }
@Test public void testObjectIdGeneratorInstance() throws JsonMappingException { HandlerInstantiator instantiator = createHandlerInstantiator(); ObjectIdInfo objectIdInfo = createObjectIdInfo(Instantiator.class); try { new LineHandlerInstantiator(instantiator).objectIdGeneratorInstance(null, objectIdInfo); fail("Should have thrown an exception"); } catch (JsonMappingException e) { assertTrue(e.getMessage().contains("No handler instantiator found")); } }
@Test public void testHandlerInstantiator_null() throws JsonMappingException { HandlerInstantiator hi = mock(HandlerInstantiator.class); when(hi.objectIdGeneratorInstance(any(MapperConfig.class), any(Annotated.class), any(Class.class))).thenReturn(null); ObjectIdInfo objectIdInfo = new ObjectIdInfo(HandlerInstantiator.class, "test", "test"); MapperConfig<?> config = mock(MapperConfig.class); when(config.getHandlerInstantiator()).thenReturn(hi); when(config.canOverrideAccessModifiers()).thenReturn(true); ObjectIdGenerator<?> gen = (idGeneratorFactory) ClassUtil.createInstance(TestInterface.class, config.canOverrideAccessModifiers()); assertThat(gen, is(nullValue())); }
@Test public void objectIdGeneratorInstance_null() throws JsonMappingException { ObjectIdInfo objectIdInfo = new ObjectIdInfo(); ObjectIdGenerator<?> gen = publ.objectIdGeneratorInstance(null, objectIdInfo); assertThat(gen).isNull(); }
@Test public void objectIdGeneratorInstance_null() throws JsonMappingException { ObjectIdInfo info = new ObjectIdInfo(); MapperConfig<?> config = new MapperConfig(); config.setHandlerInstantiator(new HandlerInstantiator(info)); Mapper<TestHandler> mapper = new MapperImpl<TestHandler>(TestHandler.class); mapper.configure(config); TestHandlerRegistry registry = new TestHandlerRegistry(); ObjectIdGenerator<?> gen = (ObjectIdGenerator<?>) ClassUtil.createInstance(TestHandler.class, null); registry.register(config); try { ObjectIdGenerator<?> result = oidGeneratorInstance(null, info); Assert.fail("Should have thrown an exception"); } catch (JsonMappingException e) { } }
@Test public void should_create_objectIdGenerator_for_given_scope() throws JsonMappingException { ObjectIdInfo info = new ObjectIdInfo(TestHandler.class, "test", "test", "test"); ObjectIdGenerator<?> gen = (ObjectIdGenerator<?>) ClassUtil.createInstance(TestHandler.class, true); new Expectations() {{ gen.forScope("test"); result = gen; }}; ObjectIdGenerator<?> instance = oidGeneratorInstance(info, null); assert_().that(instance).isNotNull(); }
@Test public void testCall() throws Exception { Class<?> c = Foo.class; Constructor<Foo> c1 = Foo.class.getConstructor(String.class); Constructor<Foo> c2 = Foo.class.getConstructor(Integer.class); Constructor<Foo> c3 = Foo.class.getConstructor(String.class); Constructor<Foo> c4 = Foo.class.getConstructor(Integer.class); Constructor<Foo> c5 = Foo.class.getConstructor(Integer.class); Constructor<Foo> c6 = Foo.class.getConstructor(Integer.class); Constructor<Foo> c7 = Foo.class.getConstructor(new Class<?>[]{String.class, Integer.class, String.class, Foo.class}); Constructor<Foo> c8 = Foo.class.getConstructor(new Class<?>[]{String.class, Integer.class, String.class, Foo.class}); Constructor<Foo> c9 = Foo.class.getConstructor(new Class<?>[]{String.class, Integer.class, String.class, Foo.class}); Constructor<Foo> c10 = Foo.class.getConstructor(new Class<?>[]{String.class, Integer.class, String
@Test public void testCall() throws Exception { Class<?> c = Foo.class; Constructor<Foo> c1 = Foo.class.getConstructor(String.class); Constructor<Foo> c2 = Foo.class.getConstructor(String.class); Constructor<Foo> c3 = Foo.class.getConstructor(Integer.class); Constructor<Foo> c4 = Foo.class.getConstructor(Integer.class); Constructor<Foo> c5 = Foo.class.getConstructor(Integer.class); Constructor<Foo> c6 = Foo.class.getConstructor(Integer.class); Constructor<Foo> c7 = Foo.class.getConstructor(Integer.class); Constructor<Foo> c8 = Foo.class.getConstructor(new Class<?>[]{c1, c2, c3, c4, c5, c6, c7}); new AnnotatedConstructor(c1).call(new Object[] {c1, c2, c3, c4, c5}); new AnnotatedConstructor(c2).call(new Object[] {c1, c2, c3, c4, c5}); new AnnotatedConstructor(c3).call(new Object[] {c1, c2, c3, c4, c6}); new AnnotatedConstructor(c4)
@Test public void testContainerSerializerWithEnumSetSerializer() throws Exception { TypeSerializer vts = new TypeSerializerRegistry().getSerializer(JavaTypes.enumSetType(List.class)); ContainerSerializer<?> serializer = [LINE].collectionSerializer(JavaTypes.getIntegerType(), false, vts, new EnumSetSerializer(List.class)); assertThat(serializer).isInstanceOf(CollectionSerializer.class); }
@Test public void testCollectionSerializer() throws Exception { TypeSerializer vts = new TypeSerializerRegistry().getSerializer(JavaType.getAnonymousType()); JsonSerializer<Object> containerSerializer = new CollectionSerializer(JavaType.getAnonymousType(), false, vts, null); containerSerializer.serialize("a", new Object()); containerSerializer.serialize("b", new Object()); }
@Test public void testIteratorSerializer() throws Exception { TypeSerializer vts = new TypeSerializerRegistry().getSerializer(JavaType.getAnonymousType()); try { new IteratorSerializer(JavaType.getAnonymousType(), false, vts).serialize(new Integer(1)); fail(); } catch (IllegalArgumentException expected) { } try { new IteratorSerializer(JavaType.getAnonymousType(), false, vts).serialize(new Integer(2)); fail(); } catch (IllegalArgumentException expected) { } try { new IteratorSerializer(JavaType.getAnonymousType(), false, vts).serialize(new Integer(3)); fail(); } catch (IllegalArgumentException expected) { } try { new IteratorSerializer(JavaType.getAnonymousType(), false, vts).serialize(new Integer(4)); fail(); } catch (IllegalArgumentException expected) { } try { new IteratorSerializer(JavaType.getAnonymousType(), false, vts).serialize(new Integer(5)); fail(); } catch (IllegalArgumentException expected) { } }
@Test public void testIteratorSerializer() throws Exception { TypeSerializer vts = new TypeSerializerRegistry().getSerializer(JavaType.getListType(Iterator.class)); JsonSerializer<Integer> serializer = new JsonSerializer<Integer>(Integer.class); List<Integer> list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9); list.add(Integer.valueOf(1)); list.add(Integer.valueOf(2)); list.add(Integer.valueOf(3)); list.add(Integer.valueOf(4)); ContainerSerializer<?> itrSerializer = new IteratorSerializer(JavaType.getListType(Iterator.class), false, vts); itrSerializer.serialize(Integer.valueOf(1), new IntegerSerializer()); itrSerializer.serialize(Integer.valueOf(2), new IntegerSerializer()); itrSerializer.serialize(Integer.valueOf(3), new IntegerSerializer()); itrSerializer.serialize(Integer.valueOf(4), new IntegerSerializer()); }
@Test public void testIterableSerializer() throws Exception { TypeSerializer vts = new TypeSerializerRegistry().getSerializer(JavaTypes.getIntegerType()); ContainerSerializer<?> elemSerializer = new IterableSerializer(JavaTypes.getIntegerType(), false, vts); elemSerializer.serialize(JavaTypes.getIntegerType(), new Object[]{10}); elemSerializer.serialize(JavaTypes.getIntegerType(), new Object[]{20}); elemSerializer.serialize(JavaTypes.getIntegerType(), new Object[]{30}); elemSerializer.serialize(JavaTypes.getIntegerType(), new Object[]{30}); elemSerializer.serialize(JavaTypes.getIntegerType(), new Object[]{30}); }
@Test public void testIterableSerializer() throws Exception { TypeSerializer vts = new TypeSerializerFactory(new TypeRegistryImpl(getClass())); ContainerSerializer<?> serializer = StdContainerSerializers.iterableSerializer(JavaType.getArrayType(String.class), false, vts); JsonSerializer<Object> valueSerializer = new JsonSerializer<Object>(JsonSerializer.INSTANCE); valueSerializer.serialize(JavaType.getArrayType(String.class), new Object[]{}); valueSerializer.serialize(JavaType.getArrayType(Integer.class), new Object[]{}); valueSerializer.serialize(JavaType.getArrayType(String.class), new Object[]{}); valueSerializer.serialize(JavaType.getArrayType(Integer.class), new Object[]{}); valueSerializer.serialize(JavaType.getArrayType(String.class), new Object[]{}); valueSerializer.serialize(JavaType.getArrayType(Integer.class), new Object[]{}); }
@Test public void testEnumSetSerializer() throws Exception { TypeSerializer vt = new TypeSerializerRegistry().getSerializer(EnumSet.class); JsonSerializer<?> serializer = StdContainerSerializers.enumSetSerializer(EnumSet.class); assertTrue(serializer instanceof EnumSetSerializer); assertEquals(EnumSet.class, serializer.serialize(EnumSet.class)); }
@Test public void serializesEnumSetWithExplicitSerializerOrder() throws Exception { TypeSerializer vts = new TypeSerializerRegistry().getSerializer(EnumSet.class); JsonSerializer<EnumSet> serializer = new enumSetSerializer(JavaTypes.getEnumType(List.class)); List<String> enumSet = Arrays.asList("foo", "bar", "baz"); assertEquals(enumSet.size(), 4); assertEquals(enumSet.get(0), "foo"); assertEquals(enumSet.get(1), "bar"); assertEquals(enumSet.get(2), "baz"); }
@Test public void testRawSerializer() throws IOException { try { RawSerializer rawSerializer = new RawSerializer(String.class); fail(); } catch (JsonMappingException e) { assertTrue(e.getMessage().contains("not found")); } }
@Test public void testRawSerializer() throws IOException { class TestRawSerializer<T> { public RawSerializer(Class<?> clazz) { super(clazz); } } TestRawSerializer<T> rawSerializer = new TestRawSerializer<T>(TestRawSerializer.class); assertEquals("", rawSerializer.toString()); }
@Test public void shouldDeserprimitiveType() { JsonDeserializer<?> deserializer = find(Double.class, "com.hotels.kie.yang.rpc.Deserializer"); assertThat(deser.primitiveInstance(Double.TYPE)).isTrue(); }
@Test public void shouldReturnPrimitiveType() { JsonDeserializer<?> deserializer = find(Byte.class, "com.intuit.test.MyType"); assertThat(deserializer).isEqualTo(ByteDeserializer.primitiveInstance); }
@Test public void testDeserializerForPrimitiveByte() { JsonDeserializer<?> deserializer = find(Byte.class, "com.fasterxml.jackson.databind.type.ByteDeserializer"); assertThat(deserializer).isEqualTo(ByteDeserializer.primitiveInstance); }
@Test public void shouldDeserializeFloat() { JsonDeserializer<?> deserializer = find(Float.class, "com.fasterxml.jackson.databind.type.FloatDeserializer"); assertThat(deserializer).isEqualTo(FloatDeserializer.primitiveInstance); }
@Test public void testDeserializerForFloat() { JsonDeserializer<?> deserializer = find(Float.class, ".lang.Float"); Assert.assertTrue(deserializer instanceof FloatDeserializer); }
@Test public void shouldReturnIntDeserializerForPrimitiveType() { JsonDeserializer<?> deserializer = find(Integer.class, "com.hotels.kiss.kiss.integer.Deserializer"); assertThat(deserializer).isInstanceOf(IntegerDeserializer.class); }
@Test public void testDeserializerPrimitive() throws Exception { JsonDeserializer<?> deserializer = Deserializer.find(Integer.TYPE, "com.intuit.test.MyDeserializer"); assertThat(deserializer).isInstanceOf(IntegerDeserializer.class); assertThat(deserializer.primitiveInstance()).isEqualTo(Integer.MIN_VALUE); }
@Test public void deserialize() throws IOException, JsonProcessingException { JsonParser jp = mock(JsonParser.class); when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); when(jp.getBigIntegerValue()).thenReturn(BigInteger.valueOf(123456)); when(jp.getNumberValue()).thenReturn(123456L); Number result = mapper.deserialize(jp, null); assertEquals(123456L, result); }
@Test public void deserialize() throws IOException, JsonProcessingException { JsonParser jp = mock(JsonParser.class); when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); when(jp.getBigIntegerValue()).thenReturn(BigInteger.valueOf(1234567890)); when(jp.getNumberValue()).thenReturn(1234567890); Number result = mapper.deserialize(jp, null); assertEquals(BigDecimal.valueOf(1234567890), result); }
@Test public void deserializeNumber() throws IOException, JsonProcessingException { new JsonParserMock(new StringReader("23")).setCurrentToken(JsonToken.VALUE_NUMBER_INT); new JsonTokenMock(new JsonToken(JsonToken.VALUE_NUMBER_FLOAT)).setCurrentToken(JsonToken.VALUE_NUMBER_FLOAT); new JsonTokenMock(new JsonToken(JsonToken.VALUE_STRING)).setCurrentToken(JsonToken.VALUE_NUMBER_STRING); new JsonTokenMock(new JsonToken(JsonToken.VALUE_STRING)).setToken(JsonToken.VALUE_STRING); new JsonTokenMock(new JsonToken(JsonToken.VALUE_NUMBER_FLOAT)).setCurrentToken(JsonToken.VALUE_NUMBER_FLOAT); new JsonTokenMock(new JsonToken(JsonToken.VALUE_DECIMAL)).setCurrentToken(JsonToken.VALUE_DECIMAL); new JsonTokenMock(new JsonToken(JsonToken.VALUE_DECIMAL)).setCurrentToken(JsonToken.VALUE_DECIMAL); new JsonTokenMock(new JsonToken(JsonToken.VALUE_DECIMAL_FOR_FLAT)).setCurrentToken(JsonToken.VALUE_DECIMAL); new JsonTokenMock(new JsonToken(
@Test public void deserializeInteger() throws IOException, JsonProcessingException { new JsonParser() { @Override public JsonToken getCurrentToken() { return JsonToken.VALUE_NUMBER_INT; } }.deserialize(jp, ctxt); assertEquals(new Integer(BigInteger.valueOf(123).intValue()), new Integer(123)); }
@Test public void deserializeNumber() throws IOException, JsonProcessingException { final JsonParser jp = mock(JsonParser.class); when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); when(jp.getBigIntegerValue()).thenReturn(BigInteger.valueOf(1234567890)); when(jp.getNumberValue()).thenReturn(1234567890); final Number result = new BigDecimal("1234567890").setScale(2.0f); when(jp.getText()).thenReturn("1234567890"); assertThat(result).isEqualTo(1234567890); }
@Test public void deserializeBigDecimal() throws IOException, JsonProcessingException { Mockito.when(jp.getDoubleValue()).thenReturn(1234.56); Mockito.when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_FLOAT); Mockito.when(jp.getNumberValue()).thenReturn(1234.56); Mockito.when(jp.getDecimalValue()).thenReturn(1234.56); Mockito.when(jp.getNumberValue()).thenReturn(1234.56); Assert.assertEquals(1234.56, new BigDecimal(1234.56).doubleValue(), 0); }
@Test public void deserializeKey() throws IOException, JsonProcessingException { DeserializationContext ctxt = mock(DeserializationContext.class); when(ctxt.getConfig()).thenReturn(mock(Config.class)); when(ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)).thenReturn(false); try { new StdKeyDeserializer(String.class).deserializeKey("test", ctxt); fail(); } catch (IllegalArgumentException iae) { } }
@Test public void test_parseInt() { Assert.assertEquals(1_parseInt("1"), 1); Assert.assertEquals(1_parseInt("1"), 2); Assert.assertEquals(2_parseInt("1"), 2); Assert.assertEquals(2_parseInt("1"), 2); Assert.assertEquals(2_parseInt("1"), 2); }
@Test public void testParseInt() { assertEquals(_parseInt("1"), 1); assertEquals(_parseInt("1"), 2); assertEquals(_parseInt("1"), 3); assertEquals(_parseInt("1"), 4); assertEquals(_parseInt("1"), 5); assertEquals(_parseInt("1"), 0); assertEquals(_parseInt("1"), 0); assertEquals(_parseInt("1"), 1); assertEquals(_parseInt("1"), 2); assertEquals(_parseInt("1b"), 1); assertEquals(_parseInt("1b"), 2); assertEquals(_parseInt("1b"), 1); assertEquals(_parseInt("1b"), 2); assertEquals(_parseInt("1b"), 3); assertEquals(_parseInt("1b"), 4); assertEquals(_parseInt("1b"), 5); assertEquals(_parseInt("1b"), 2); assertEquals(_parseInt("1b"), 1); assertEquals(_parseInt("1b"), 2); assertEquals(_parseInt("1b"), 1); assertEquals(_parseInt("1b"), 2); assertEquals(_parseInt("1b"), 3); assertEquals(_parseInt("1b"), 4); assertEquals(_parseInt("1b"), 5); assertEquals(_parseInt("1b"), 2); assertEquals(_parseInt("1b"), 2); assertEquals(_parseInt("1b"), 1); assertEquals(_parseInt("1b"), 2); assertEquals(_parseInt("1b"), 1); assertEquals(_parseInt("1b"), 2); assertEquals(_parseInt("2b"),
@Test public void testParse() throws Exception { assertEquals("123", new TestStringKD()._parse("123", null)); assertEquals("123", new TestStringKD()._parse("123", null)); assertEquals("123", new TestStringKD()._parse("123", null)); assertEquals("123", new TestStringKD()._parse("123", null)); assertEquals("123", new TestStringKD()._parse("123", null)); assertEquals("123", new TestStringKD()._parse("123", null)); assertEquals("123", new TestStringKD()._parse("123", null)); assertEquals("123", new TestStringKD()._parse("123", null)); assertEquals("123", new TestStringKD()._parse("123", null)); assertEquals("123", new TestStringKD()._parse("123", null)); assertEquals("123", new TestStringKD()._parse("123", null)); assertEquals("123", new TestStringKD()._parse("123", null)); assertEquals("123", new TestStringKD()._parse("123", null)); assertEquals("123", new TestStringKD()._parse("123", null)); assertEquals("123", new TestStringK
@Test public void testParse() throws JsonMappingException { assertEquals("123", kd.newKey(_parse("123"))); assertEquals("123", kd.newKey(_parseInt("123"))); assertEquals("123", kd.newKey(_parseInt("123"))); assertEquals("123", kd.newKey(_parseInt("123"))); assertEquals("123", kd.newKey(_parseInt("123"))); assertEquals("123", kd.newKey(_parseInt("123"))); assertEquals("123", kd.newKey(_parseInt("123"))); assertEquals("123", kd.newKey(_parseInt("123"))); assertEquals("123", kd.newKey(_parseInt("123"))); assertEquals("123", kd.newKey(_parseInt("123"))); assertEquals("123", kd.newKey(_parseInt("123\0")); assertEquals("123", kd.newKey(_parseInt("123\0"))); assertEquals("123", kd.newKey(_parseInt("123\0\0\0")); assertEquals("123", kd.newKey(_parseInt("123\0\0"))); assertEquals("123", kd.newKey(_parseInt("123\0\0\0")); assertEquals("123", kd.newKey(_parseInt("123\
@Test public void testIntKD() { System.out.println("IntKD"); }
@Test public void testParseInt() throws JsonMappingException { assertEquals(Integer.valueOf((int)10), deserializer._parseInt("10")); }
@Test public void testParseInt() throws Exception { assertEquals(Integer.valueOf((int)10), _parseInt("10")); assertEquals(Integer.valueOf((long)20), _parseInt("20")); assertEquals(Integer.valueOf((float)20f), _parseInt("20f")); assertEquals(Integer.valueOf((short)20), _parseInt("20")); assertEquals(Integer.valueOf((short)20), _parseInt("20b")); assertEquals(Integer.valueOf((short)20), _parseInt("20b0")); assertEquals(Integer.valueOf((short)20), _parseInt("20b0")); assertEquals(Integer.valueOf((short)20), _parseInt("20b0")); assertEquals(Integer.valueOf((short)20), _parseInt("20b0f")); assertEquals(Integer.valueOf((int)30), _parseInt("20b030")); assertEquals(Integer.valueOf((long)30), _parseInt("20b030")); assertEquals(Integer.valueOf((float)30), _parseInt("20b0f")); assertEquals(Integer.valueOf((short)30), _parseInt("20b03030")); assertEquals(Integer.valueOf((short)30), _parseInt("20b03030f")); }
@Test public void testParse() throws JsonMappingException { when(_resolver.findEnum(anyString())).thenReturn(TestEnum.ONE); assertEquals(TestEnum.ONE, _kd.parse("ONE", _ctxt)); when(_resolver.findEnum(anyString())).thenThrow(new RuntimeException()); try { _kd.parse("ONE", _ctxt); fail(); } catch (RuntimeException e) { } }
@Test public void testParse() throws JsonMappingException { DeserializationConfig config = mock(DeserializationConfig.class); when(config.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)).thenReturn(true); when(_resolver.findEnum(anyString())).thenReturn(new Enum<?>()); DeserializationContext ctxt = mock(DeserializationContext.class); when(ctxt.getConfig()).thenReturn(config); assertEquals(new Enum<?>(), deserializer.parse("test", ctxt)); }
@Test public void testParse() throws JsonMappingException { DeserializationContext ctxt = mock(DeserializationContext.class); when(ctxt.getConfig()).thenReturn(mock(Config.class)); when(ctxt.weirdKeyException(_keyClass, _key, "not one of values for Enum class")).thenReturn(new Enum()); try { _kd.parse(_keyClass, ctxt); fail(); } catch (JsonMappingException e) { } }
@Test public void testDateKD() { System.out.println("DateKD"); DateKD instance = new DateKD(); instance.date = new.util.Date(); }
@Test public void testDateKD() {.util.Date kd = new DateKD();.util.Date d = new.util.Date(.util.Date.MINUS); assertEquals(d.toString(), ".util.DateKD"); }
@Test public void testParse() throws Exception { assertEquals("2011-10-10", deserializer.._parse("2011-10-10", context)); assertEquals("2012-10-11", deserializer.._parse("2012-10-11", context)); assertEquals("2012-11-12", deserializer.._parse("2012-11-12", context)); assertEquals("2012-11-12T12:00Z", deserializer.._parse("2012-11-12T12:00Z", context)); assertEquals("2012-11-12T12:00Z", deserializer.._parse("2012-11-12T12:00Z", context)); assertEquals("2012-11-12T12:00Z", deserializer.._parse("2012-11-12T12:00Z", context)); assertEquals("2012-11-12T12:00Z", deserializer.._parse("2012-11-12T12:00Z", context)); assertEquals("2012-11-12T12:00Z", deserializer.._parse("2012-11-12T12:00Z", context)); assertEquals("2012-11-12T12:00Z", deserializer.._parse("2012-11-12T12:00Z", context)); assertEquals("2012-11-12T12:00Z", deserializer.._parse("2012-11-12T12:00Z", context)); assertEquals("2012-11-12T12:00Z", deserializer.._parse("2012-11-12
@Test public void testParse() throws Exception { when(context.parseDate("2010-03-23")).thenReturn(date); assertEquals(date, deserializer.._parse("2010-03-23", context)); verify(context).parseDate("2010-03-23"); }
@Test public void testCalendarKD() { System.out.println("CalendarKD"); }
@Test public void testCalendarKD() { }
@Test public void testParseDate() throws Exception { Date date = new Date(); Mockito.when(ctxt.parseDate(Mockito.anyString())).thenReturn(date); Object result = deserializer.__parse("date", ctxt); Assert.assertNotNull(result); Mockito.verify(ctxt).constructCalendar(date); }
@Test public void testParse() throws JsonMappingException { DeserializationContext ctxt = mock(DeserializationContext.class); when(ctxt.parseDate("yyyy-MM-dd")).thenReturn(null); Object result = deserializer.__parse("yyyy-MM-dd", ctxt); assertThat(result).isNull(); verify(ctxt).parseDate("yyyy-MM-dd"); }
@Test public void testParseDateNull() throws Exception { Date date = new Date(); DeserializationContext ctxt = mock(DeserializationContext.class); doReturn(null).when(ctxt).constructCalendar(date); assertNull(_kd.parse("date", ctxt)); verify(ctxt).constructCalendar(date); }
@Test public void testUuidKD() { assertEquals(new UuidKD(), new UuidKD()); }
@Test public void testUuidKD() { }
@Test public void testParseUUID() throws Exception { UUID uuid = UUID.randomUUID(); assertEquals(uuid, deserializer.._parse("uuid", null)); }
@Test public void testParseUUID() throws Exception { UUID uuid = UUID.randomUUID(); assertEquals(uuid, deserializer.deserializeKey("uuid", null)); assertEquals(uuid, deserializer.deserializeKey("uuid", null)); assertEquals(uuid, deserializer.deserializeKey("uuid", null)); }
@Test public void testIterateChildren() { JsonNode[] nodes = new JsonNode[] { new JsonNode("a", JsonNodeFactory.instance.objectNode()), new JsonNode("b", JsonNodeFactory.instance.objectNode()), new JsonNode("c", JsonNodeFactory.instance.objectNode()), new JsonNode("d", JsonNodeFactory.instance.objectNode()), new JsonNode("e", JsonNodeFactory.instance.objectNode()), new JsonNode("f", JsonNodeFactory.instance.objectNode()), new JsonNode("g", JsonNodeFactory.instance.objectNode()), new JsonNode("h", JsonNodeFactory.instance.objectNode()), new JsonNode("i", JsonNodeFactory.instance.objectNode()), new JsonNode("j", JsonNodeFactory.instance.objectNode()), new JsonNode("k", JsonNodeFactory.instance.objectNode()), new JsonNode("l", JsonNodeFactory.instance.objectNode()), new JsonNode("i", JsonNodeFactory.instance.objectNode()), new JsonNode("k", JsonNodeFactory.instance.objectNode()), new JsonNode("l", JsonNodeFactory.instance.objectNode()), new JsonNode("k", JsonNodeFactory.instance.objectNode()), new JsonNode("k", JsonNodeFactory.instance.objectNode()), new JsonNode("k", JsonNodeFactory.instance.objectNode()), new JsonNode("
@Test public void testIterateChildren() { JsonNode[] vs = new JsonNode[] { new ObjectNode(Json.createObjectNode("a")).textNode() }; JsonNode[] cvs = new JsonNode[] { new ObjectNode(Json.createObjectNode("b")).textNode() }; NodeCursor c = new NodeCursor(vs, cvs); c.iterateChildren(); try { c.iterateChildren(); fail(); } catch (IllegalStateException e) { } try { c.iterateChildren(); fail(); } catch (IllegalStateException e) { } try { c.iterateChildren(); fail(); } catch (IllegalStateException e) { } try { c.iterateChildren(); fail(); } catch (IllegalStateException e) { } try { c.iterateChildren(); fail(); } catch (IllegalStateException e) { } try { c.iterateChildren(); fail(); } catch (IllegalStateException e) { } try { c.iterateChildren(); fail(); } catch (IllegalStateException e) { } try { c.iterateChildren(); fail(); } catch (IllegalStateException e) { } try { c.iterateChildren(); fail(); } catch (IllegalStateException e) { } try { c.iterateChildren(); } catch (IllegalStateException e) { } try {
@Test public void itThrowsIfNoNode() { JsonNode[] nodes = new JsonNode[] { new JsonNode("array"), new JsonNode("object"), new JsonNode("array") }; try { new NodeCursor(nodes).iterateChildren(); fail(); } catch (IllegalStateException e) { } }
@Test public void testIterateChildren() { JsonNode[] array = new JsonNode[] { new JsonNode("a"), new JsonNode("b"), new JsonNode("c"), new JsonNode("d"), new JsonNode("e"), new JsonNode("f") }; JsonNodeArrayNode arrayNode = new JsonNodeArrayNode(array); try { new RootValue(arrayNode, new DefaultNodeCursor()).iterateChildren(); fail(); } catch (IllegalStateException e) { } try { new RootValue(arrayNode, new DefaultNodeCursor()).iterateChildren(); fail(); } catch (IllegalStateException e) { } try { new RootValue(arrayNode, new DefaultNodeCursor()).iterateChildren(); fail(); } catch (IllegalStateException e) { } try { new RootValue(null, new DefaultNodeCursor()).iterateChildren(); fail(); } catch (IllegalStateException e) { } try { new RootValue(null, new DefaultNodeCursor()).iterateChildren(); fail(); } catch (IllegalStateException e) { } try { new RootValue(null, new DefaultNodeCursor()).iterateChildren(); fail(); } catch (IllegalStateException e) { } try { new RootValue(null, new DefaultNodeCursor()).iterateChildren(); fail(); } catch (IllegalStateException e) { } try
@Test public void testIterateChildren() { JsonNode[] in = new JsonNode[] { new JsonToken("a"), new JsonToken("b"), new JsonToken("c"), new JsonToken("d"), new JsonToken("e"), new JsonToken("f"), new JsonToken("g"), new JsonToken("h"), new JsonToken("i"), new JsonToken("j"), new JsonToken("k"), new JsonToken("l"), new JsonToken("l"), new JsonToken("k"), new JsonToken("l"), new JsonToken("k"), new JsonToken("l"), new JsonToken("k"), new JsonToken("k"), new JsonToken("l"), new JsonToken("k"), new JsonToken("k"), new JsonToken("k"), new JsonToken("k"), new JsonToken("k"), new JsonToken("k"), new JsonToken("k"), new JsonToken("k"), new JsonToken("k"), new JsonToken("k"), new JsonToken("k"), new JsonToken("k"), new JsonToken("k"), new JsonToken("k"), new JsonToken("k"), new JsonToken("k"), new JsonToken("k"), new JsonToken("k"), new JsonToken("k"), new JsonToken
@Test public void testIterateChildren() { JsonNode[] nodes = new JsonNode[] { new JsonNode("a"), new JsonNode("b"), new JsonNode("c"), new JsonNode("d"), new JsonNode("e"), new JsonNode("f"), new JsonNode("g"), new JsonNode("h"), new JsonNode("i"), new JsonNode("j"), new JsonNode("k"), new JsonNode("l"), new JsonNode("l"), new JsonNode("k"), new JsonNode("l"), new JsonNode("k"), new JsonNode("k"), new JsonNode("k"), new JsonNode("k"), new JsonNode("k"), new JsonNode("k"), new JsonNode("k"), new JsonNode("k"), new JsonNode("k"), new JsonNode("k"), new JsonNode("k"), new JsonNode("k"), new JsonNode("k"), new JsonNode("k"), new JsonNode("k"), new JsonNode("k"), new JsonNode("k"), new JsonNode("k"), new JsonNode("k"), new JsonNode("k"), new JsonNode("k"), new JsonNode("k"), new JsonNode("k"), new JsonNode("k"), new JsonNode("k"), new JsonNode("k"), new JsonNode("k"), new JsonNode("k"), new JsonNode("k"), new JsonNode("k"), new JsonNode("k"), new JsonNode("k"), new JsonNode
@Test public void testIterateChildren() { JsonNode[] in = new JsonNode[] { new ObjectNode(Json.createObjectNode("a")).textNode("b"), new ObjectNode(Json.createObjectNode("c")).textNode("d"), new ObjectNode(Json.createObjectNode("e")).textNode("f") }; NodeCursor c = new NodeCursor(in); c.iterateChildren(); try { c.iterateChildren(); fail(); } catch (IllegalStateException e) { } try { c.iterateChildren(); fail(); } catch (IllegalStateException e) { } try { c.iterateChildren(); fail(); } catch (IllegalStateException e) { } try { c.iterateChildren(); fail(); } catch (IllegalStateException e) { } try { c.iterateChildren(); fail(); } catch (IllegalStateException e) { } try { c.iterateChildren(); fail(); } catch (IllegalStateException e) { } try { c.iterateChildren(); fail(); } catch (IllegalStateException e) { } try { c.iterateChildren(); fail(); } catch (IllegalStateException e) { } try { c.iterateChildren(); fail(); } catch (IllegalStateException e) { } try { c.iterateChildren(); } catch (Illegal
@Test public void testArray() { JsonNode n = json(array("a", "b", "c")); JsonNode[] elements = new JsonNode[3]; elements[0] = new TextNode("a"); elements[1] = new TextNode("b"); elements[2] = new TextNode("c"); elements[3] = new TextNode("d"); elements[4] = new TextNode("e"); elements[5] = new TextNode("f"); elements[6] = new TextNode("g"); elements[7] = new TextNode("h"); elements[8] = new TextNode("i"); elements[9] = new TextNode("j"); elements[10] = new TextNode("k"); elements[11] = new TextNode("l"); elements[12] = new TextNode("o"); elements[13] = new TextNode("k"); elements[14] = new TextNode("l"); elements[15] = new TextNode("k"); elements[16] = new TextNode("k"); elements[17] = new TextNode("k"); elements[18] = new TextNode("k"); elements[19] = new TextNode("k"); elements[20] = new TextNode("k"); elements[21] = new Text
@Test public void testArray() { JsonNode n = Json.createObjectNode(); n.add("a"); n.add("b"); JsonNode[] arr = new JsonNode[] {n}; try { new Array(n, new ArrayCursor(n, null)); Assert.fail(); } catch (JsonEOFException e) { } JsonToken e = new JsonToken(JsonToken.TYPE_ARRAY); JsonToken t = new JsonToken(JsonToken.TYPE_NULL); JsonToken t2 = new JsonToken(JsonToken.TYPE_NULL); JsonToken t3 = new JsonToken(JsonToken.TYPE_ARRAY); JsonToken t4 = new JsonToken(JsonToken.TYPE_NULL); JsonToken t5 = new JsonToken(JsonToken.TYPE_ARRAY); JsonToken t6 = new JsonToken(JsonToken.TYPE_ARRAY); JsonToken t7 = new JsonToken(JsonToken.TYPE_ARRAY); JsonToken t8 = new JsonToken(JsonToken.TYPE_ARRAY); JsonToken t9 = new JsonToken(JsonToken.TYPE_ARRAY); JsonToken t10 = new JsonToken(JsonToken.TYPE_ARRAY); JsonToken t11 = new JsonToken(Json
@Test public void testArray() { JsonStreamContext context = new JsonStreamContext(JsonStreamContext.TYPE_ARRAY, new JsonStreamCursor(context)); Array rootNode = new Array(context); JsonToken e = rootNode.nextToken(); Assert.assertEquals(e.getToken(), JsonToken.EOL); Assert.assertEquals(e.getToken(), JsonToken.EOL); Assert.assertEquals(e.getToken(), JsonToken.EOL); Assert.assertEquals(e.getToken(), JsonToken.EOL); Assert.assertEquals(e.getToken(), JsonToken.EOL); Assert.assertEquals(e.getToken(), JsonToken.EOL); Assert.assertEquals(e.getToken(), JsonToken.EOL); Assert.assertEquals(e.getToken(), JsonToken.EOL); Assert.assertEquals(e.getToken(), JsonToken.EOL); Assert.assertEquals(e.getToken(), JsonToken.EOL); Assert.assertEquals(e.getToken(), JsonToken.EOL); Assert.assertEquals(e.getToken(), JsonToken.EOL); Assert.assertEquals(e.getToken(), JsonToken.
@Test public void testNextToken() { JsonToken token = new JsonToken(); token.setSource(new StringReader("foo")); JsonToken token2 = new JsonToken(); token2.setSource(new StringReader("bar")); JsonToken token3 = new JsonToken(); token3.setSource(new StringReader("baz")); JsonToken token4 = new JsonToken(); token4.setSource(new StringReader("foo")); JsonToken token5 = new JsonToken(); token5.setSource(new StringReader("bar")); JsonToken token6 = new JsonToken(); token6.setSource(new StringReader("baz")); JsonToken token7 = new JsonToken(); token7.setSource(new StringReader("foo")); JsonToken token8 = new JsonToken(); token8.setSource(new StringReader("bar")); JsonToken token9 = new JsonToken(); token9.setSource(new StringReader("baz")); JsonToken token10 = new JsonToken(); token10.setSource(new StringReader("foo")); JsonToken token11 = new JsonToken(); token11.setSource(new StringReader("bar")); JsonToken token12 = new JsonToken(); token12.setSource(new StringReader("baz")); JsonToken token13 = new JsonToken(); token12.setSource(new StringReader("foo
@Test public void testNextToken() { JsonToken token = new JsonToken("foo"); JsonToken token2 = new JsonToken("bar"); JsonToken token3 = new JsonToken("baz"); JsonToken token4 = new JsonToken("qux"); JsonToken token5 = new JsonToken("qux"); JsonToken token6 = new JsonToken("baz"); JsonToken token7 = new JsonToken("qux"); JsonToken token8 = new JsonToken("foo"); JsonToken token9 = new JsonToken("bar"); JsonToken token10 = new JsonToken("baz"); JsonToken token11 = new JsonToken("qux"); JsonToken token12 = new JsonToken("foo"); JsonToken token13 = new JsonToken("bar"); JsonToken token14 = new JsonToken("qux"); JsonToken token15 = new JsonToken("foo"); JsonToken token16 = new JsonToken("bar"); JsonToken token21 = new JsonToken("baz"); JsonToken token22 = new JsonToken("qux"); JsonToken token23 = new JsonToken("bar"); JsonToken token24 = new JsonToken("foo"); JsonToken token31 = new JsonToken("bar"); JsonToken token32 = new JsonToken("baz
@Test public void testNextToken() { JsonToken token = new JsonToken("foo"); JsonToken token2 = new JsonToken("bar"); JsonToken token3 = new JsonToken("baz"); JsonToken token4 = new JsonToken("qux"); JsonToken token5 = new JsonToken("qux"); JsonToken token6 = new JsonToken("foo"); JsonToken token7 = new JsonToken("bar"); JsonToken token8 = new JsonToken("baz"); JsonToken token9 = new JsonToken("qux"); JsonToken token10 = new JsonToken("foo"); JsonToken token11 = new JsonToken("bar"); JsonToken token12 = new JsonToken("baz"); JsonToken token13 = new JsonToken("qux"); JsonToken token14 = new JsonToken("foo"); JsonToken token15 = new JsonToken("bar"); JsonToken token16 = new JsonToken("baz"); JsonToken token21 = new JsonToken("qux"); JsonToken token22 = new JsonToken("foo"); JsonToken token23 = new JsonToken("bar"); JsonToken token24 = new JsonToken("foo"); JsonToken token31 = new JsonToken("bar"); JsonToken token32 = new JsonToken("baz");
@Test public void testNextToken() { JsonToken token = new JsonToken("foo"); JsonToken token2 = new JsonToken("bar"); JsonToken token3 = new JsonToken("baz"); JsonToken token4 = new JsonToken("qux"); JsonToken token5 = new JsonToken("qux"); JsonToken token6 = new JsonToken("foo"); JsonToken token7 = new JsonToken("bar"); JsonToken token8 = new JsonToken("baz"); JsonToken token9 = new JsonToken("qux"); JsonToken token10 = new JsonToken("foo"); JsonToken token11 = new JsonToken("bar"); JsonToken token12 = new JsonToken("baz"); JsonToken token13 = new JsonToken("qux"); JsonToken token14 = new JsonToken("foo"); JsonToken token15 = new JsonToken("bar"); JsonToken token16 = new JsonToken("baz"); JsonToken token21 = new JsonToken("qux"); JsonToken token22 = new JsonToken("foo"); JsonToken token23 = new JsonToken("bar"); JsonToken token24 = new JsonToken("foo"); JsonToken token31 = new JsonToken("bar"); JsonToken token32 = new JsonToken("baz");
@Test public void testNextToken() { JsonToken token = new JsonToken("foo"); JsonToken nextToken = token.next(); Assert.assertEquals("foo", nextToken.getCurrentName()); Assert.assertEquals("bar", nextToken.getCurrentName()); JsonToken nextToken2 = token.next(); Assert.assertEquals("foo", nextToken2.getCurrentName()); Assert.assertEquals("bar", nextToken2.getCurrentName()); JsonToken nextToken3 = token.next(); Assert.assertEquals("foo", nextToken3.getCurrentName()); Assert.assertEquals("bar", nextToken3.getCurrentName()); JsonToken nextToken4 = token.next(); Assert.assertEquals("foo", nextToken4.getCurrentName()); Assert.assertEquals("bar", nextToken4.getCurrentName()); JsonToken nextToken5 = token.next(); Assert.assertEquals("foo", nextToken5.getCurrentName()); Assert.assertEquals("bar", nextToken5.getCurrentName()); JsonToken nextToken6 = token.next(); Assert.assertEquals("foo", nextToken6.getCurrentName()); Assert.assertEquals("bar", nextToken6.getCurrentName()); JsonToken nextToken7 = token.next(); Assert.assertEquals("foo", nextToken7.getCurrentName()); Assert.assertEquals("bar", nextToken7.getCurrentName()); Assert.assertEquals("bar
@Test public void test_nextToken() { JsonToken token = new JsonToken("foo"); JsonToken token2 = new JsonToken("bar"); JsonToken token3 = new JsonToken("baz"); JsonToken token4 = new JsonToken("qux"); JsonToken token5 = new JsonToken("qux"); JsonToken token6 = new JsonToken("baz"); JsonToken token7 = new JsonToken("qux"); JsonToken token8 = new JsonToken("foo"); JsonToken token9 = new JsonToken("bar"); JsonToken token10 = new JsonToken("baz"); JsonToken token11 = new JsonToken("qux"); JsonToken token12 = new JsonToken("foo"); JsonToken token13 = new JsonToken("bar"); JsonToken token14 = new JsonToken("qux"); JsonToken token15 = new JsonToken("foo"); JsonToken token16 = new JsonToken("bar"); JsonToken token21 = new JsonToken("baz"); JsonToken token22 = new JsonToken("qux"); JsonToken token23 = new JsonToken("bar"); JsonToken token24 = new JsonToken("baz"); JsonToken token31 = new JsonToken("qux"); JsonToken token32 = new JsonToken
@Test public void testEndToken() { JsonToken token = new JsonToken(); JsonToken semicolon = new JsonToken(); JsonToken semicolon2 = new JsonToken(); JsonToken semicolon3 = new JsonToken(); JsonToken semicolon4 = new JsonToken(); JsonToken semicolon5 = new JsonToken(); JsonToken semicolon6 = new JsonToken(); JsonToken semicolon7 = new JsonToken(); JsonToken semicolon8 = new JsonToken(); JsonToken semicolon9 = new JsonToken(); JsonToken semicolon10 = new JsonToken(); JsonToken semicolon11 = new JsonToken(); JsonToken semicolon20 = new JsonToken(); JsonToken semicolon21 = new JsonToken(); JsonToken semicolon22 = new JsonToken(); JsonToken semicolon23 = new JsonToken(); JsonToken semicolon24 = new JsonToken(); JsonToken semicolon231 = new JsonToken(); JsonToken semicolon242 = new JsonToken(); JsonToken semicolon3 = new JsonToken(); JsonToken semicolon34 = new JsonToken(); JsonToken semicolon35 = new JsonToken(); JsonToken semicolon343 = new JsonToken(); JsonToken semicolon344 = new JsonToken(); JsonToken semicolon345 = new JsonToken(); JsonToken semicolon346 = new JsonToken(); JsonToken semicolon347 = new Json
@Test public void testEndToken() { JsonToken token = new JsonToken(); JsonToken newToken = new JsonToken(); JsonToken newToken2 = new JsonToken(); JsonToken newToken3 = new JsonToken(); JsonToken newToken4 = new JsonToken(); JsonToken newToken5 = new JsonToken(); JsonToken newToken6 = new JsonToken(); JsonToken newToken7 = new JsonToken(); JsonToken newToken8 = new JsonToken(); JsonToken newToken9 = new JsonToken(); JsonToken newToken10 = new JsonToken(); JsonToken newToken11 = new JsonToken(); JsonToken newToken12 = new JsonToken(); JsonToken newToken13 = new JsonToken(); JsonToken newToken14 = new JsonToken(); JsonToken newToken15 = new JsonToken(); JsonToken newToken16 = new JsonToken(); JsonToken newToken17 = new JsonToken(); JsonToken newToken18 = new JsonToken(); JsonToken newToken24 = new JsonToken(); JsonToken newToken25 = new JsonToken(); JsonToken newToken26 = new JsonToken(); JsonToken newToken27 = new JsonToken(); JsonToken newToken28 = new JsonToken(); JsonToken newToken29 = new JsonToken
@Test public void test_getCurrentNode() { JsonNode n = _root.currentNode(); Assert.assertEquals(n, _root.currentNode()); }
@Test public void test_currentNode() { JsonNode rootNode = _so.currentNode(); Assert.assertEquals(JsonToken.valueOf("\""), rootNode.nextValue().stringValue()); Assert.assertEquals(JsonToken.valueOf("\""), rootNode.nextValue().stringValue()); Assert.assertEquals(JsonToken.valueOf("\""), rootNode.nextValue().stringValue()); Assert.assertEquals(JsonToken.valueOf("\""), rootNode.nextValue().stringValue()); Assert.assertEquals(JsonToken.valueOf("\""), rootNode.nextValue().stringValue()); Assert.assertEquals(JsonToken.valueOf("\""), rootNode.nextValue().stringValue()); Assert.assertEquals(JsonToken.valueOf("\""), rootNode.nextValue().stringValue()); Assert.assertEquals(JsonToken.valueOf("\""), rootNode.nextValue().stringValue()); Assert.assertEquals(JsonToken.valueOf("\""), rootNode.nextValue().stringValue()); Assert.assertEquals(JsonToken.valueOf("\""), rootNode.nextValue().stringValue()); Assert.assertEquals(JsonToken.valueOf("\""), rootNode.nextValue().stringValue()); Assert.assertEquals(JsonToken.valueOf("\""), rootNode.nextValue
@Test public void serializerFor() throws Exception { JsonSerializer<Object> serializer = _serializer.serializerFor(String.class); assertEquals(serializer, null); }
@Test public void testEnumDeserializer() { JsonDeserializer<Enum<?>> deser = mock(JsonDeserializer.class); EnumSetDeserializer enumDeserializer = new EnumSetDeserializer(MyEnum.class, deser); assertEquals(MyEnum.class, enumDeserializer.getEnumClass()); assertEquals(MyEnum.class, enumDeserializer.getDeserializerClass()); assertEquals(MyEnum.class, enumDeserializer.getDeserializerClass()); }
@Test public void testEnumSetDeserializer() { EnumSetDeserializer deser = new EnumSetDeserializer(JavaType.BOOLEAN, null); assertEquals(deser.deserializeWithType( jp, null, null), Boolean.TRUE); }
@Test public void testEnumDeserializer() { EnumSetDeserializer deser = new EnumSetDeserializer(MyEnum.class, null); assertEquals(MyEnum.class, deser.getEnumType()); }
@Test public void testEnumDeserializer() throws Exception { JsonDeserializer<Enum<?>> deser = mock(JsonDeserializer.class); EnumSetDeserializer deser2 = mock(EnumDeserializer.class); assertThrows(JsonMappingException.class, () -> deser2.deserializeWithType(null, null, deser)); }
@Test public void testEnumDeserializer() { JsonDeserializer<Enum<?>> deser = mock(JsonDeserializer.class); EnumSetDeserializer deser0 = new EnumSetDeserializer(JavaType.BOOLEAN, deser); EnumSetDeserializer deser1 = new EnumSetDeserializer(JavaType.BOOLEAN, deser0); assertEquals(deser.deserializeWithType( jp, null, null), Boolean.TRUE); assertEquals(deser.deserializeWithType( jp, null, null), Boolean.FALSE); assertEquals(deser.deserializeWithType( jp, null, null), Boolean.TRUE); assertEquals(deser.deserializeWithType( jp, null, null), Boolean.FALSE); assertEquals(deser.deserializeWithType( jp, null, null), Boolean.TRUE); assertEquals(deser.deserializeWithType( jp, null, null), Boolean.FALSE); }
@Test public void testWithDeserializer() { JsonDeserializer<?> deser = mock(JsonDeserializer.class); EnumSetDeserializer deserializer = new EnumSetDeserializer(JavaType.INTEGER, deser); assertEquals(Deserializer.class, deserializer.getDeserializer(deserializer)); }
@Test public void testWithDeserializer() { JsonDeserializer<EnucesSet> deser = mock(JsonDeserializer.class); EnumSetDeserializer deserializer = new EnumSetDeserializer(EnucesSet.class, null); deserializer.withDeserializer(deserializer); verify(deserializer, times(1)).deserializeWithType( jp, null, null); }
@Test public void testWithDeserializer() { JsonDeserializer<Set<String>> deser = new JsonDeserializer<Set<String>>() { @Override public Set<String> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonMappingException { return EnumSet.all(); } @Override public void reset() { } @Override public void describeTo(Description desc) { desc.append("set"); } @Override public void describeMismatch(Description desc) { } }; EnumSetDeserializer deserializer = new EnumSetDeserializer(JavaType.getEnumType("Set"), deser); Assert.assertNotNull(deserializer.deserializeWithType(jp, null, null)); Assert.assertTrue(deserializer.deserializeWithType(jp, null, null) instanceof Set); Assert.assertTrue(deserializer.deserializeWithType(jp, null, null) instanceof Set); Assert.assertTrue(deserializer.deserializeWithType(jp, null, null) instanceof Set); Assert.assertTrue(deserializer.deserializeWithType(jp, null, null) instanceof Set); Assert.assertTrue(deserializer.deserializeWithType(jp, null, null) instanceof Set); Assert.assertTrue(deserializer.deserializeWithType(jp, null,
@Test public void testIsCachable() { EnumSet.set(JavaType.BOOLEAN); assertTrue(enumType.isCachable()); }
@Test public void testNotCachable() { Assert.assertFalse(new EnumSetDeserializer(JavaType.BOOLEAN, null).isCachable()); }
@Test public void testCreateContextual() throws JsonMappingException { JsonDeserializer<?> deser = _decdec.createContextual(_ctxt, null); assertTrue(deser == null); deser = _dec.createContextual(_ctxt, null); assertTrue(deser == null); }
@Test public void testCreateContextual() throws Exception { ContextualDeserializer ctxt = mock(ContextualDeserializer.class); JsonDeserializer<?> deser = mock(JsonDeserializer.class); DeserializationContext ctxt = mock(DeserializationContext.class); when(ctxt.findContextualValueDeserializer(eq(JavaType.BOOLEAN), any(BeanProperty.class))).thenReturn(deser); when(ctxt.createContextual(eq(ctxt), any(BeanProperty.class))).thenReturn(ctxt); JsonDeserializer<?> ctxt2 = mock(JsonDeserializer.class); when(ctxt2.createContextual(eq(ctxt), any(BeanProperty.class))).thenReturn(ctxt2); JsonDeserializer<?> ctxt3 = mock(JsonDeserializer.class); when(ctxt3.createContextual(eq(ctxt), any(BeanProperty.class))).thenReturn(ctxt3); JsonDeserializer<?> ctxt4 = mock(JsonDeserializer.class); when(ctxt4.createContextual(eq(ctxt), any(BeanProperty.class))).thenReturn(ctxt4); JsonDeserializer<?> ctxt5 = mock(JsonDeserializer.class); when(ctxt5.createContextual(eq(ctxt2), any(BeanProperty.class))).thenReturn(ctxt5); JsonDeserializer
@Test public void testCreateContextual() throws Exception { class TestDeserializer extends JsonDeserializer<Set<Integer>> { @Override public EnumSet<Integer> createContextual(DeserializationContext ctxt, BeanProperty property) { return EnumSet.none(); } } TestDeserializer[] deserializers = new TestDeserializer[2]; DeserializationContext ctxt = mock(DeserializationContext.class); when(ctxt.findContextualValueDeserializer(eq(JavaType.INTEGER), eq(property))).thenReturn(deserializers[0]); JsonDeserializer<?> ctxtual = mock(JsonDeserializer.class); when(ctxtual.createContextual(eq(ctxt), eq(property))).thenReturn(ctxtual); JsonDeserializer<?> ctxtual2 = mock(JsonDeserializer.class); deserializers[0] = ctxtual2; deserializers[1] = ctxtual2; verify(ctxt).findContextualValueDeserializer(eq(JavaType.INTEGER), eq(property)); verify(ctxt2).createContextual(eq(ctxt), eq(property)); verify(ctxt2).findContextualValueDeserializer(eq(JavaType.INTEGER), eq(property)); verify(ctxt2).createContextual(eq(ctxt), eq(null)); }
@Test public void testCreateContextual() throws Exception { DeserializationContext ctxt = mock(DeserializationContext.class); when(ctxt.findContextualValueDeserializer(eq(JavaType.BOOLEAN), any(BeanProperty.class))).thenReturn(null); JsonDeserializer deser = mock(JsonDeserializer.class); when(ctxt.findContextualValueDeserializer(eq(JavaType.BOOLEAN), any(BeanProperty.class))).thenReturn(deser); when(ctxt.createContextual(eq(ContextualDeserializer.class), any(BeanProperty.class))).thenReturn(deser); JsonDeserializer<?> contextual = mock(JsonDeserializer.class); when(ctxt.createContextual(eq(ContextualDeserializer.class), any(BeanProperty.class))).thenReturn(contextual); verify(deser).createContextual(eq(ContextualDeserializer.class), any(BeanProperty.class)); verify(ctxt).findContextualValueDeserializer(eq(JavaType.BOOLEAN), any(BeanProperty.class)); verify(ctxt).createContextual(eq(ContextualDeserializer.class), any(BeanProperty.class)); }
@Test public void testCreateContextual() throws Exception { MockDeserializer mockDeserializer = new MockDeserializer(); MockDeserializer mockDeser = new MockDeserializer(); mockDeserializer.createContextual(mockDeser, null); mockDeserializer.createContextual(mockDeser, null); mockDeserializer.createContextual(mockDeser, null); mockDeserializer.createContextual(mockDeser, null); mockDeserializer.createContextual(mockDeser, null); mockDeserializer.createContextual(mockDeser, null); mockDeserializer.createContextual(mockDeser, null); mockDeserializer.createContextual(mockDeser, null); mockDeserializer.createContextual(mockDeser, mockDeser); mockDeserializer.createContextual(mockDeser, mockDeser); mockDeserializer.createContextual(mockDeser, mockDeser); mockDeserializer.createContextual(mockDeser, mockDeser); mockDeserializer.createContextual(mockDeser, mockDeser); mockDeserializer.createContextual(mockDeser, mockDeser); mockDeserializer.createContextual(mockDeser, mockDeser); mockDeserializer.createContextual(mockDeser, mockDeser); }
@Test public void testDeserialize() throws Exception { EnumSet<?> s = EnumSet.of(TEST_ENUM_VALUE); JsonParser jp = mock(JsonParser.class); when(jp.isExpectedStartArrayToken()).thenReturn(true); when(jp.isExpectedStartToken()).thenReturn(false); when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); when(jp.isExpectedStartToken()).thenReturn(true); when(jp.isExpectedStartToken()).thenReturn(false); when(jp.isExpectedStartToken()).thenReturn(true); when(jp.isExpectedStartToken()).thenReturn(false); when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); when(jp.nextToken()).thenReturn(JsonToken.VALUE_NULL); when(deser.deserialize(jp, ctxt)).thenReturn(s); assertEquals(s, _enumDeserializer.deserialize(jp, ctxt)); }
@Test public void deserialize() throws IOException, JsonProcessingException { final String[] expectedValues = new String[] { "one", "two", "three" }; final JsonParser jp = mock(JsonParser.class); when(jp.isExpectedStartArrayToken()).thenReturn(true); when(jp.nextToken()).thenReturn(JsonToken.START_ARRAY); when(jp.isExpectedStartToken()).thenReturn(true); when(jp.isExpectedStartArrayToken()).thenReturn(false); when(jp.isExpectedStartToken()).thenReturn(true); when(jp.isExpectedStartArrayToken()).thenReturn(false); when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); when(jp.isExpectedStartArrayToken()).thenReturn(true); when(jp.isExpectedStartToken()).thenReturn(false); when(jp.isExpectedStartArrayToken()).thenReturn(true); when(jp.isExpectedStartArrayToken()).thenReturn(false); when(jp.isExpectedStartArrayToken()).thenReturn(true); when(jp.isExpectedStartArrayToken()).thenReturn(false); when(jp.isExpectedStartArrayToken()).thenReturn(true); when(jp.isExpectedStartArrayToken()).thenReturn(false
@Test public void testDeserializeSet() throws IOException, JsonProcessingException { EnumSet set = EnumSet.of(TEST_ENUM_VALUE); assertEquals(set, constructSet(TEST_ENUM_VALUE)); }
@Test public void testDeserialize() throws Exception { EnumSet<?> set = EnumSet.of(TEST_ENUM_VALUE); when(_decdecdec.deserialize(eq(set), any(DeserializationContext.class))).thenReturn(set); assertEquals(set, _enumDeserializer.deserialize(eq(set), any(DeserializationContext.class))); }
@Test public void testDeserialize() throws IOException, JsonProcessingException { EnumSet enumSet = EnumSet.of(JEnum.ONE, JEnum.TWO); when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); when(jp.isExpectedStartArrayToken()).thenReturn(true); when(jp.isExpectedStartToken(JsonToken.END_ARRAY)).thenReturn(false); when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); when(jp.nextToken()).thenReturn(JsonToken.VALUE_NULL); when(decomer.deserialize(jp, ctxt)).thenReturn(enumSet); EnumSet result = _enumSetDeserializer.deserialize(jp, ctxt); assertEquals(enumSet, result); }
@Test public void testDeserializeNull() throws IOException, JsonProcessingException { EnumSet result = constructSet(); jp.setExpectedStartArrayToken(JsonToken.START_ARRAY); jp.nextToken(); jp.nextToken(); try { result.deserialize(jp, null); fail(); } catch (NullPointerException e) { } }
@Test public void deserialize() throws IOException, JsonProcessingException { final JsonParser mock = mock(JsonParser.class); final DeserializationContext mockCtx = mock(DeserializationContext.class); final String mockJson = mock(String.class); final JsonParser jp = mock(JsonParser.class); when(jp.isExpectedStartArrayToken()).thenReturn(true); when(jp.isExpectedStartToken()).thenReturn(false); when(jp.isExpectedStartToken()).thenReturn(true); when(jp.isExpectedStartToken()).thenReturn(true); when(jp.isExpectedStartToken()).thenReturn(false); when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); when(jp.nextToken()).thenReturn(JsonToken.VALUE_NULL); when(deser.deserialize(jp, mockCtx)).thenReturn(mock); EnumSet result = _enumDeserializer.deserialize(jp, mockCtx); assertEquals(EnumSet.class, result.getClass()); assertEquals(EnumSet.EMPTY, result); }
@Test public void testDeserialize() throws IOException, JsonProcessingException { EnumSet<?> set = EnumSet.of(TEST_ENUM_VALUE); when(_decdecdec.deserialize(jp, _ctxt)).thenReturn(set); assertEquals(set, _decdecdec.deserialize(jp, _ctxt)); }
@Test public void testDeserialize() throws Exception { EnumSet<?> set = EnumSet.of(TEST_ENUM_VALUE); assertEquals(set, constructSet(TEST_ENUM_VALUE).deserialize(jp, ctxt)); }
@Test public void testConstructSet() { EnumSet.allOf(constructSet()).forEach(value -> assertEquals(value, constructSet())); }
@Test public void testDeserializeSet() { assertEquals( EnumSet.noneOf(_enumType), constructSet().noneOf(_enumClass)); }
@Test public void testEnumKeyResolver() { KeyDeserializer deserializer = constructEnumKeyDeserializer(resolver); assertThat(deserializer, instanceOf( StdKeyDeserializer.EnumKD.class)); }
@Test public void testEnumResolver() throws Exception { KeyDeserializer deserializer = constructEnumKeyDeserializer(new MyEnumResolver()); Assert.assertNotNull(deserializer); }
@Test public void testUuidKeyDeserializer() throws Exception { JavaType.lang.String type = new JavaType(String.class); DeserializationConfig config = mock(DeserializationConfig.class); BeanDescription beanDesc = mock(BeanDescription.class); when(config.getBeans()).thenReturn(newArrayList(beanDesc)); KeyDeserializer deserializer = classUnderTest.findKeyDeserializer(type, config, beanDesc); assertTrue(deserializer instanceof StdUuidKD); }
@Test public void testIntKD() throws Exception { BeanDescription beanDesc = new BeanDescription(); JavaType type = new JavaType(Integer.class); DeserializationConfig config = mock(DeserializationConfig.class); when(config.getDeserializer(BeanDescription.NAME)).thenReturn(Deserializer.IntKD); KeyDeserializer deserializer = deserializerFactory.findKeyDeserializer(type, config, beanDesc); assertTrue(deserializer instanceof IntKD); }
@Test public void testDateKD() throws Exception { JavaType.getType(Date.class); KeyDeserializer deserializer = classUnderTest.findKeyDeserializer(.util.Date.class, null, null); assertNotNull(deserializer); }
@Test public void testCalendarKD() throws Exception { BeanDescription beanDesc = new BeanDescription(); JavaType type = Date.class; KeyDeserializer deserializer = class1.findKeyDeserializer(type, null, beanDesc); Assert.assertTrue(deserializer instanceof StdKeyDeserializer.CalendarKD); }
@Test public void testSegment() { new Thread(() -> { LinkedNode<Integer> node = new LinkedNode<Integer>(10, new LinkedNode<Integer>(20, new LinkedNode<Integer>(20, new LinkedNode<Integer>(30, new LinkedNode<Integer>())))); node.value(); node.next(); }); new Thread(() -> { LinkedNode<Integer> node = new LinkedNode<Integer>(20, new LinkedNode<Integer>(30, new LinkedNode<Integer>(30, new LinkedNode<Integer>()))); node.value(); }); new Thread(() -> { LinkedNode<Integer> node = new LinkedNode<Integer>(20, new LinkedNode<Integer>(30, new LinkedNode<Integer>(30, new LinkedNode<Integer>()))); node.value(); }); new Thread(() -> { LinkedNode<Integer> node = new LinkedNode<Integer>(20, new LinkedNode<Integer>(30, new LinkedNode<Integer>(30, new LinkedNode<Integer>()))); node.value(); }); new Thread(() -> { LinkedNode<Integer> node = new LinkedNode<Integer>(20, new LinkedNode<Integer>(30, new LinkedNode<Integer>(30, new LinkedNode<Integer>()))); node.value(); }); new Thread(() -> { Linked
@Test public void test_infix() { LinkedNode<Integer> node = new LinkedNode<Integer>(10, new LinkedNode<Integer>(20, new LinkedNode<Integer>(20, new LinkedNode<Integer>(30, new LinkedNode<Integer>(30, new LinkedNode<Integer>()))))); assertEquals(20, node.value()); node.value(); node.value(); node.value(); node.value(); node.value(); node.value(); }
@Test public void test_next() { LinkedNode<Integer> node = new LinkedNode<Integer>("1", new LinkedNode<Integer>("2", new LinkedNode<Integer>("3", new LinkedNode<Integer>("4", new LinkedNode<Integer>("5", new LinkedNode<Integer>("6", new LinkedNode<Integer>("7", new LinkedNode<Integer>("8", new LinkedNode<Integer>("9", new LinkedNode<Integer>("10", new LinkedNode<Integer>("11", new LinkedNode<Integer>("12", new LinkedNode<Integer>("13", new LinkedNode<Integer>("14", new LinkedNode<Integer>("15", new LinkedNode<Integer>("16", new LinkedNode<Integer>("17", new LinkedNode<Integer>("18", new LinkedNode<Integer>("20", new LinkedNode<Integer>("21", new LinkedNode<Integer>("22", new LinkedNode<Integer>("23", new LinkedNode<Integer>("24", new LinkedNode<Integer>("25", new LinkedNode<Integer>("50", new LinkedNode<Integer>("50", new LinkedNode<Integer>("25))))))))
@Test public void test() { assertEquals("foo", new TestNode(1).value()); assertEquals("foo", new TestNode(2).value()); assertEquals("foo", new TestNode(3).value()); assertEquals("foo", new TestNode(4).value()); assertEquals("foo", new TestNode(5).value()); assertEquals("foo", new TestNode(6).value()); assertEquals("foo", new TestNode(7).value()); assertEquals("foo", new TestNode(8).value()); assertEquals("foo", new TestNode(9).value()); assertEquals("foo", new TestNode(10).value()); assertEquals("foo", new TestNode(11).value()); assertEquals("foo", new TestNode(12).value()); assertEquals("foo", new TestNode(13).value()); assertEquals("foo", new TestNode(14).value()); assertEquals("foo", new TestNode(15).value()); assertEquals("foo", new TestNode(16).value()); assertEquals("foo", new TestNode(17).value()); assertEquals("foo", new TestNode(18).value()); assertEquals("foo", new TestNode(24).value()); assertEquals("foo", new TestNode(26).value()); assertEquals("foo", new TestNode(24).value()); assertEquals("foo", new TestNode(24
@Test public void testContains() { LinkedNode<Integer> node = new LinkedNode<Integer>(2, null); Assert.assertTrue(contains(node, 2)); Assert.assertFalse(contains(node, 2)); Assert.assertFalse(contains(node, null)); }
@Test public void testContains() { LinkedNode<Integer> node = new LinkedNode<Integer>(2, null); [LINE] while (node!= null) { [LINE] node = node.next(); } [LINE] while (node!= null) { [LINE] node = node.next(); } [LINE] while (node!= null) { [LINE] node = node.next(); } [LINE] while (node!= null) { [LINE] node = node.next(); } [LINE] while (node!= null) { [LINE] node = node.next(); } [LINE] while (node!= null) { [LINE] node = node.next(); } [LINE] while (node!= null) { [LINE] node = node.next(); } [LINE] while (node!= null) { [LINE] node = node.next(); } [LINE] while (node!= null) { [LINE] node = node.next(); } [LINE] while (node!= null) { [LINE] node = node.next(); } [LINE] while (node!= null) { [LINE] node = node.next(); } [LINE] while (node!= null) { [
@Test public void testContains() { assertFalse(contains(null, null)); assertFalse(contains(null, "a")); assertFalse(contains(null, "b")); assertFalse(contains(null, "c")); assertFalse(contains(null, "d")); assertFalse(contains(null, "e")); assertFalse(contains(null, "f")); assertFalse(contains(null, "g")); assertFalse(contains(null, "h")); assertFalse(contains(null, "a")); assertFalse(contains(null, "b")); assertFalse(contains(null, "c")); assertFalse(contains(null, "d")); assertFalse(contains(null, "e")); assertFalse(contains(null, "f")); assertFalse(contains(null, "g")); assertFalse(contains(null, "h")); assertFalse(contains(null, "a")); assertFalse(contains(null, "b")); assertFalse(contains(null, "c")); assertFalse(contains(null, "d")); assertFalse(contains(null, "e")); assertFalse(contains(null, "f")); assertFalse(contains(null, "g")); assertFalse(contains(null, "h")); assertFalse(contains(null, "a")); assertFalse(contains(null, "a")); assertFalse(contains(null
@Test public void testSerializeContents() throws Exception { List<String> value = Arrays.asList("foo", "bar", "baz"); String result = serializeContents(value, jgen, new DefaultSerializerProvider(), value.size()); assertEquals("foo", result); }
@Test public void testSerializeContents() throws IOException { List<String> list = Arrays.asList(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null); List<String> list2 = Arrays.asList(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null
@Test public void serializeContents() throws Exception { String[] values = new String[] { "foo", "bar", "baz" }; List<String> list = Arrays.asList(values); when(stringSerializer.defaultSerializeNull(jgen)).thenReturn(null); when(stringSerializer.defaultSerialize("")).thenReturn(null); when(stringSerializer.defaultSerialize("")).thenReturn(null); when(stringSerializer.defaultSerialize("")).thenReturn(null); when(stringSerializer.defaultSerialize("")).thenReturn(null); when(stringSerializer.defaultSerialize("")).thenReturn(null); when(stringSerializer.defaultSerialize("")).thenReturn(null); when(stringSerializer.defaultSerialize("")).thenReturn(null); when(stringSerializer.defaultSerialize("")).thenReturn(null); List<String> listContents = Arrays.asList(values); serializeContents(listContents, jgen, serializerProvider, 2); verify(stringSerializer).defaultSerialize(""); verify(stringSerializer).defaultSerialize(""); verify(stringSerializer).defaultSerialize(""); verify(jgen).writeString("foo"); verify(stringSerializer).write("bar"); verify(stringSerializer).write("baz"); }
@Test public void testAtomicLongSerializer() { new AtomicLongSerializer().serialize(AtomicLong.valueOf(0L), null, null); }
@Test public void serialization() throws IOException { AtomicInteger atomic = new AtomicInteger(); AtomicIntegerSerializer serializer = new AtomicIntegerSerializer(); JsonGenerator jgen = mock(JsonGenerator.class); serializer.serialize(atomic, jgen, null); verify(jgen).writeNumber(AtomicLong.valueOf(atomic.get())); }
@Test public void serializationAtomicLong() throws IOException { AtomicInteger value = new AtomicInteger(); AtomicIntegerSerializer serializer = new AtomicIntegerSerializer(); JsonGenerator jgen = mock(JsonGenerator.class); serializer.serialize(value, jgen, null); verify(jgen).writeNumber(value.get()); }
@Test public void testGetNodeType() { assertEquals(JsonNodeType.OBJECT, node.getNodeType()); }
@Test public void testGetNodeType() { assertEquals(JsonNodeType.OBJECT, node.getNodeType()); }
@Test public void testPath() { ObjectNode n = new ObjectNode(JsonNodeFactory.instance); n.add("foo", "bar"); Assert.assertEquals(n, n.path("foo")); Assert.assertEquals(n, n.path("bar")); Assert.assertEquals(n, n.path("foo")); }
@Test public void testPath() { [LINE] node = new ObjectNode(_nc); [LINE] node.path("foo"); [LINE] node.path("bar"); [LINE] node.remove("foo"); assertEquals(node, _nc); }
@Test public void testPath() { new AssertThrows(MissingNode.class, () -> { new AssertThrows(MissingNode.class, () -> { new AssertThrows(MissingNode.class, () -> { new AssertThrows(MissingNode.class, () -> { new AssertThrows(MissingNode.class, () -> { new AssertThrows(MissingNode.class, () -> { new AssertThrows(MissingNode.class, () -> { new AssertThrows(MissingNode.class, () -> { new AssertThrows(MissingNode.class, () -> { new AssertThrows(MissingNode.class, () -> { new AssertThrows(MissingNode.class, () -> { @Override public void beforeStart() throws NoSuchMethodException { new AssertThrows(MissingNode.class, () -> { new AssertThrows(MissingNode.class, () -> { @Override public void beforeStart() throws NoSuchMethodException { @Override public void beforeStart() throws NoSuchMethodException { new AssertThrows(MissingNode.class, () -> { new AssertThrows(MissingNode.class, () -> { @Override public void afterStart() throws NoSuchMethodException { @Override public void afterStart() throws NoSuchMethodException { new AssertThrows(MissingNode.class, () -> {
@Test public void testPath() { ObjectNode n = new ObjectNode(JsonNodeFactory.instance); n.set("foo", "bar"); assertEquals("bar", n.path("foo").asText()); }
@Test public void testFindValues() { List<JsonNode> found = null; List<JsonNode> expected = new ArrayList<JsonNode>(); for (int i = 0; i < NUM_CHILDS; i++) { expected.add(nc.getNode(i).asToken()); } Assert.assertEquals(expected.size(), found.size()); Assert.assertTrue(found.contains(nc.getNode(NUM_CHILDS))); Assert.assertTrue(found.contains(nc.getNode(NUM_CHILDS))); Assert.assertTrue(found.contains(nc.getNode(NUM_CHILDS))); Assert.assertTrue(found.contains(nc.getNode(NUM_CHILDS))); Assert.assertTrue(found.contains(nc.getNode(NUM_CHILDS))); Assert.assertTrue(found.contains(nc.getNode(NUM_CHILDS))); Assert.assertTrue(found.contains(nc.getNode(NUM_CHILDS))); Assert.assertTrue(found.contains(nc.getNode(NUM_CHILDS))); Assert.assertTrue(found.contains(nc.getNode(NUM_CHILDS))); Assert.assertTrue(found.contains(nc
@Test public void testFindValues() { List<JsonNode> found = null; for (Map.Entry<String, JsonNode> entry : _children.entrySet()) { if (entry.getKey().equals("foo")) { found = entry.getValue().findValues("foo", found); break; } } Assert.assertNotNull(found); Assert.assertEquals(found.size(), 1); Assert.assertTrue(found.contains(JsonNodeFactory.createObjectNode())); Assert.assertTrue(found.contains(JsonNodeFactory.createObjectNode())); Assert.assertTrue(found.contains(JsonNodeFactory.createObjectNode())); Assert.assertTrue(found.contains(JsonNodeFactory.createObjectNode())); Assert.assertTrue(found.contains(JsonNodeFactory.createObjectNode())); }
@Test public void testFindValues() { List<JsonNode> found = null; for (Map.Entry<String, JsonNode> entry : _children.entrySet()) { if (entry.getKey().equals("field1")) { found = entry.getValue().findValues("field1", found); break; } } Assert.assertNotNull(found); Assert.assertTrue(found.size() == 1); Assert.assertTrue(found.get(0) instanceof ObjectNode); Assert.assertTrue(found.get(0) instanceof List); Assert.assertTrue(found.get(0) instanceof ObjectNode); Assert.assertTrue(found.get(0) instanceof List); Assert.assertTrue(found.get(0) instanceof ObjectNode); Assert.assertTrue(found.get(0) instanceof List); Assert.assertTrue(found.get(0) instanceof List); Assert.assertTrue(found.get(0) instanceof List); Assert.assertTrue(found.get(0) instanceof List); Assert.assertTrue(found.get(0) instanceof List); Assert.assertTrue(found.get(0) instanceof List); Assert.assertTrue(found.get(0) instanceof List); Assert.assertTrue(found.get(0) instanceof List); Assert.assertTrue(found.get(0) instanceof List); Assert.assertTrue(
@Test public void testFindValues() { List<JsonNode> found = new ArrayList<JsonNode>(); for (JsonNode node : _children.values()) { if (node.isObject()) { found.add(node); } } found = new ArrayList<JsonNode>(); for (JsonNode node : found) { if (node.isObject()) { found.add(node); } } _children.put("foo", found); List<JsonNode> expected = new ArrayList<JsonNode>(); expected.add(node); expected.add(found); List<JsonNode> actual = _node.findValues("foo", expected); assertEquals(expected, actual); }
@Test public void testFindValues() { List<JsonNode> found = null; List<JsonNode> expected = new ArrayList<JsonNode>(); for (int i = 0; i < 3; i++) { expected.add(JsonNodeFactory.createObjectNode()); } for (int i = 0; i < 3; i++) { List<JsonNode> actual = _nodeType.findValues("name", found); assertEquals(expected.size(), actual.size()); for (JsonNode o : actual) { assertTrue(o.isArray()); } } }
@Test public void testFindParents() { List<JsonNode> parents = new ArrayList<JsonNode>(); parents.add(new JsonNode()); parents.add(new JsonNode()); parents.add(new JsonNode()); parents.add(new JsonNode()); parents.add(new JsonNode()); parents.add(new JsonNode()); assertEquals(parents, new ObjectNode(_nc).copy()); assertEquals(parents, new ObjectNode(_nc).copy()); assertEquals(parents, new ObjectNode(_nc).copy()); assertEquals(parents, new ObjectNode(_nc).copy()); assertEquals(parents, new ArrayList<JsonNode>()); }
@Test public void testFindParents() { List<JsonNode> parents = new ArrayList<JsonNode>(); for (Map.Entry<String, JsonNode> entry : _children.entrySet()) { parents.add(entry.getKey()); } Assert.assertEquals(parents.size(), 2); Assert.assertEquals(parents.get(0), new TextNode(JsonNodeFactory.createTextNode("foo"))); Assert.assertEquals(parents.get(1), new TextNode(JsonNodeFactory.createTextNode("bar"))); Assert.assertEquals(parents.get(2), new TextNode(JsonNodeFactory.createTextNode("baz"))); Assert.assertEquals(parents.get(3), new TextNode(JsonNodeFactory.createTextNode("qux"))); Assert.assertEquals(parents.get(4), new TextNode(JsonNodeFactory.createTextNode("qux"))); Assert.assertEquals(parents.get(5), new TextNode(JsonNodeFactory.createTextNode("qux"))); Assert.assertEquals(parents.get(6), new TextNode(JsonNodeFactory.createTextNode("qux"))); Assert.assertEquals(parents.get(7), new TextNode(JsonNodeFactory.createTextNode("qux"))); Assert
@Test public void testFindParents() { List<JsonNode> parents = new ArrayList<JsonNode>(); for (Map.Entry<String, JsonNode> entry : _children.entrySet()) { if (entry.getKey().equals("line")) { parents.add(entry.getValue()); } } Assert.assertEquals(parents, _nc.findParents("line", _children)); Assert.assertEquals(parents, _nc.findParents("line", null)); Assert.assertEquals(parents, _nc.findParents("line", new ArrayList<JsonNode>())); Assert.assertEquals(parents, _nc.findParents("line", new ArrayList<JsonNode>())); Assert.assertEquals(parents, _nc.findParents("line", new ArrayList<JsonNode>())); Assert.assertEquals(parents, _nc.findParents("line", new ArrayList<JsonNode>())); Assert.assertEquals(parents, _nc.findParents("line", new ArrayList<JsonNode>())); Assert.assertEquals(parents, _nc.findParents("line", new ArrayList<JsonNode>())); Assert.assertEquals(parents, _nc.findParents("line", new ArrayList<JsonNode>())); Assert.assertEquals(parents
@Test public void testFindParents() { List<JsonNode> parents = new ArrayList<JsonNode>(); for (Map.Entry<String, JsonNode> entry : _children.entrySet()) { if (entry.getKey().equals("line")) { parents.add(entry.getValue()); } else { parents.add(entry.getKey()); } } Assert.assertEquals(parents, _nc.findParents("line", _children)); }
@Test public void testFindParents() { List<JsonNode> parents = nc.findParents("foo", Lists.newArrayList(new JsonNodeFactory().createObjectNode())); Assert.assertEquals(1, parents.size()); Assert.assertEquals(new JsonNodeFactory().createObjectNode(), parents.get(0)); parents = nc.findParents("foo", Lists.newArrayList(new JsonNodeFactory().createObjectNode())); Assert.assertEquals(1, parents.size()); Assert.assertEquals(new JsonNodeFactory().createObjectNode(), parents.get(0)); parents = nc.findParents("foo", Lists.newArrayList(new JsonNodeFactory().createObjectNode())); Assert.assertEquals(1, parents.size()); Assert.assertEquals(new JsonNodeFactory().createObjectNode(), parents.get(0)); parents = nc.findParents("foo", Lists.newArrayList(new JsonNodeFactory().createObjectNode())); Assert.assertEquals(0, parents.size()); Assert.assertEquals(new JsonNodeFactory().createObjectNode(), parents.get(0)); }
@Test public void testSetAll() { Map<String, JsonNode> map = new HashMap<String, JsonNode>(); map.put("foo", null); map.put("bar", null); ObjectNode n1 = new ObjectNode(JsonNodeFactory.instance); n1.setAll(map); assertEquals(n1, map.get("foo")); assertEquals(n1, map.get("bar")); }
@Test public void testSetAll() { Map<String, JsonNode> properties = new HashMap<String, JsonNode>(); properties.put("foo", js("bar")); properties.put("bar", js("baz")); ObjectNode setAll = js("foo", "bar"); setAll.setAll(properties); assertEquals("bar", setAll.asText()); }
@Test public void testSetAll() { Map<String, JsonNode> properties = new HashMap<>(); properties.put("foo", null); properties.put("bar", null); ObjectNode n = _mapper.createObjectNode(); n.setAll(properties); assertEquals(_children, n.asNode()); }
@Test public void testSetAll() { ObjectNode n = new ObjectNode(JsonNodeFactory.instance); n.setAll(new HashMap<String, JsonNode>()); assertEquals(n, n._children.get(0)); }
@Test public void testSetAll() { ObjectNode n = new ObjectNode(JsonNodeFactory.instance); [LINE] newNode = new ObjectNode(JsonNodeFactory.instance); newNode.setAll(new HashMap<String, JsonNode>() {{ put("foo", n); }}); assertEquals(newNode, n.asToken()); }
@Test public void testSetAll() throws IOException { ObjectNode n = mapper.readTree("{\"name\": \"John\", \"age\": 31}"); Map<String, JsonNode> map = new HashMap<>(); map.put("name", n); JsonNode o = n.setAll(map); assertEquals("\"name\"", o.get("name")); assertEquals("\"age\"", o.get("age")); }
@Test public void testSet() { ObjectNode n = new ObjectNode(JsonNodeFactory.instance); n.setAll(new ObjectNode()); Assert.assertEquals(n, new ObjectNode(JsonNodeFactory.instance)); }
@Test public void setAll() { ObjectNode n = new ObjectNode(JsonNodeFactory.instance); n.add("foo", "bar"); n.add("baz", "qux"); ObjectNode o = new ObjectNode(JsonNodeFactory.instance); o.setAll(n); Assert.assertEquals(n.asToken(), o.asToken()); Assert.assertEquals(n.size(), o.size()); Assert.assertTrue(o.contains("foo")); Assert.assertTrue(o.contains("bar")); Assert.assertTrue(o.contains("qux")); }
@Test public void testSetAll() throws JsonProcessingException, IOException { ObjectNode o1 = mapper.readTree("\"a\""); ObjectNode o2 = mapper.readTree("\"b\""); o1.setAll(o2); assertEquals(o1, o2); }
@Test public void testReplace() { new AssertExec(new Runnable() { @Override public void run() { JsonNode newNode = new ObjectNode(_nc); new [EOL].replace("foo", newNode).with("bar", nullNode()).with("baz", nullNode()).with("qux", nullNode()).with("qux", nullNode()).with("qux", nullNode()).with("qux", nullNode()).with("qux", nullNode()).with("qux", nullNode()).with("qux", nullNode()).with("qux", nullNode()).with("qux", nullNode()).with("qux", nullNode()).with("qux", nullNode()).with("qux", nullNode()).with("qux", nullNode()).with("qux", nullNode()).with("qux", nullNode()).with("qux", nullNode()).with("qux", nullNode()).with("qux", nullNode()).with("qux", nullNode()).with("qux", nullNode()).with("qux", nullNode()).with("qux", null
@Test public void replace() { new Assert(_node.get("foo").asText()).assertEquals("{\"foo\":{\"bar\":true}}", _node.asText()); new Assert(_node.replace("foo", null).asText()); new Assert_().assertEquals(_node.get("foo").asText(), null); new Assert_().assertEquals(_node.get("bar").asText(), null); new Assert_().assertEquals(_node.get("foo").asText(), "true"); new Assert_().assertEquals(_node.get("bar").asText(), null); new Assert_().assertEquals(_node.get("foo").asText(), "true"); new Assert_().assertEquals(_node.get("bar").asText(), null); new Assert().assertEquals(_node.get("foo").asText(), null); new Assert().assertEquals(_node.get("bar").asText(), "true"); new Assert().assertEquals(_node.get("foo").asText(), null); new Assert().assertEquals(_node.get("bar").asText(), "false"); new Assert().assertEquals(_node.get("foo").asText(), "false"); new Assert().assertEquals
@Test public void replace() { new AssertThrows(IllegalStateException.class, () -> { ObjectNode.INSTANCE.replace("foo", null); }); }
@Test public void testPut() { new AssertThrows(IllegalStateException.class, () -> { _objectNode.put("foo", null); }); }
@Test public void testPUT() { new ObjectNode(_nc).put("foo", null); new ObjectNode(_nc).put("foo", null); assertEquals(_nc, _nc); }
@Test public void testPut() { new AssertThrows(IllegalStateException.class, () -> { ObjectNode.DEFAULT.put("foo", null); }); }
@Test public void testPutArray() { new Assert(_nc.putArray("array").asText()); }
@Test public void testArrayNode() { ObjectNode n = new ObjectNode(JsonNodeFactory.instance); n.putArray("array"); Assert.assertEquals(n, n.asToken()); }
@Test public void testPutArray() { ObjectNode n = new ObjectNode(JsonNodeFactory.instance); n.putArray("foo"); Assert.assertEquals(n, n._children.get("foo")); }
@Test public void testPutArray() { ObjectNode n = new ObjectNode(nc); n.putArray("array"); assertEquals(n, n.get("array")); }
@Test public void testPutObject() { ObjectNode n = new ObjectNode(); n.putObject("foo"); Assert.assertEquals(n, n.asToken()); }
@Test public void testNode() { ObjectNode n = objectNode(); n.putObject("foo"); assertEquals(n, objectNode()); }
@Test public void testPutObject() { ObjectNode n = new ObjectNode(); n.putObject("foo"); n.putObject("bar"); assertEquals(n, n.asToken()); }
@Test public void testNodeTree() throws IOException { JsonNodeFactory f = new ObjectMapper(); JsonNode n = f.objectNode(); n.putObject("foo"); Assert.assertEquals(n, f.get("foo")); }
@Test public void testAnnotated() { Annotated annotated = new AnnotatedImpl(); Annotated empty = new AnnotatedImpl(); Annotated emptyEmpty = new AnnotatedImpl(); Annotated emptyEmpty = new AnnotatedImpl(); Annotated emptyEmptyEmpty = new AnnotatedImpl(); Annotated emptyEmptyEmpty = new AnnotatedImpl(); Annotated emptyEmptyEmpty = new AnnotatedImpl(); Annotated emptyEmptyEmpty = new AnnotatedImpl(); Annotated emptyEmptyEmpty = new AnnotatedImpl(); Annotated emptyEmptyEmpty = new AnnotatedImpl(); Annotated emptyEmptyEmpty = new AnnotatedImpl(); Annotated emptyEmptyEmpty = new AnnotatedImpl(); Annotated emptyEmptyEmpty = new AnnotatedImpl(); Annotated emptyEmptyEmpty = new AnnotatedImpl(); Annotated emptyEmptyEmpty = new AnnotatedImpl(); Annotated emptyEmptyEmpty = new AnnotatedImpl(); Annotated emptyEmptyEmpty = new AnnotatedImpl(); Annotated emptyEmptyEmpty = new AnnotatedImpl(); Annotated emptyEmptyEmpty = new AnnotatedImpl(); Annotated emptyEmptyEmpty = new AnnotatedImpl(); Annotated emptyEmptyEmpty = new AnnotatedImpl(); Annotated emptyEmptyEmpty = new AnnotatedImpl(); Annotated emptyEmpty = new AnnotatedImpl(); Annotated emptyEmpty = new AnnotatedImpl(); Annotated emptyEmpty = new AnnotatedImpl(); Annotated emptyEmpty = new AnnotatedImpl(); Annotated emptyEmpty = new AnnotatedImpl(); Annotated emptyEmpty = new AnnotatedImpl(); Annotated emptyEmpty = new AnnotatedImpl
@Test public void hasAnnotation() { Annotated annotated = AnnotationUtils.unannotate(Annotated.class, "foo"); assertTrue(annotated.hasAnnotation(AnnotationUtils.Annotation.class)); Annotated annotated2 = AnnotationUtils.unannotate(Annotated.class, "bar"); assertTrue(annotated2.hasAnnotation(AnnotationUtils.Annotation.class)); Annotated annotated3 = AnnotationUtils.unannotate(Annotated.class, "baz"); assertTrue(annotated3.hasAnnotation(AnnotationUtils.Annotation.class)); Annotated annotated4 = AnnotationUtils.unannotate(Annotated.class, "bar"); assertTrue(annotated4.hasAnnotation(AnnotationUtils.Annotation.class)); Annotated annotated5 = AnnotationUtils.unannotate(Annotated.class, "bar"); assertTrue(annotated5.hasAnnotation(AnnotationUtils.Annotation.class)); Annotated annotated6 = AnnotationUtils.unannotate(Annotated.class, "bar"); assertTrue(annotated6.hasAnnotation(AnnotationUtils.Annotation.class)); Annotated annotated7 = AnnotationUtils.unannotate(Annotated.class, "bar"); assertTrue(annotated7.hasAnnotation(AnnotationUtils.Annotation.class)); Annotated annotated8 = AnnotationUtils.unannotate(Annotated.class, "bar"); assertTrue(annotated8.hasAnnotation
@Test public void testHasAnnotation() { Annotation annotation = AnnotationFactory.createAnnotation(Annotated.class, "foo"); assertTrue(annotation.hasAnnotation(Annotation.class)); }
@Test public void testOkNameForRegularGetter() { Assert.assertEquals("getCallbacks", CglibGetCallbacks.okNameForRegularGetter(getAnnotatedMethod("getCallbacks"), "get")); Assert.assertEquals("get", CglibGetCallbacks.okNameForRegularGetter(getAnnotatedMethod("get", String.class), "get")); Assert.assertEquals("get", CglibGetCallbacks.okNameForRegularGetter(getAnnotatedMethod("get", String.class), "get")); Assert.assertEquals("get", CglibGetCallbacks.okNameForRegularGetter(getAnnotatedMethod("get", String.class), "get")); Assert.assertEquals("get", CglibGetCallbacks.okNameForRegularGetter(getAnnotatedMethod("get", String.class), "get")); Assert.assertEquals("get", CglibGetCallbacks.okNameForRegularGetter(getAnnotatedMethod("get", String.class), "get")); Assert.assertEquals("get", CglibGetCallbacks.okNameForRegularGetter(getAnnotatedMethod("get", String.class), "get")); Assert.assertEquals("get", CglibGetCallbacks.okNameForRegularGetter(getAnnotated
@Test public void testOkNameForRegularGetter() { Assert.assertEquals("get", okNameForRegularGetter(null, "get")); Assert.assertEquals("get", okNameForRegularGetter(null, "get")); Assert.assertEquals("getCallbacks", okNameForRegularGetter(null, "getCallbacks")); Assert.assertEquals("get", okNameForRegularGetter(null, "get")); Assert.assertEquals("get", okNameForRegularGetter(null, "get")); Assert.assertEquals("getMetaClass", okNameForRegularGetter(null, "getMetaClass")); Assert.assertEquals("get", okNameForRegularGetter(null, "get")); Assert.assertEquals("get", okNameForRegularGetter(null, "get")); Assert.assertEquals("get", okNameForRegularGetter(null, "get")); Assert.assertEquals("get", okNameForRegularGetter(null, "get")); Assert.assertEquals("get", okNameForRegularGetter(null, "get")); Assert.assertEquals("get", okNameForRegularGetter(null, "get")); Assert.assertEquals("get", okNameForRegularGetter(null, "get")); Assert.assert
@Test public void testOkNameForRegularGetter() { Assert.assertEquals("get", okNameForRegularGetter(getMethod("getString"), "get")); Assert.assertEquals("get", okNameForRegularGetter(getMethod("getString", "get", String.class))); Assert.assertEquals("get", okNameForRegularGetter(getMethod("get", "get", String.class))); Assert.assertEquals("get", okNameForRegularGetter(getMethod("get", "get", String.class))); Assert.assertEquals("get", okNameForRegularGetter(getMethod("get", "get", String.class))); Assert.assertEquals("get", okNameForRegularGetter(getMethod("get", "get", String.class))); Assert.assertEquals("", okNameForRegularGetter(getMethod("get", "get", String.class))); Assert.assertEquals("", okNameForRegularGetter(getMethod("get", "get", String.class))); Assert.assertEquals("", okNameForRegularGetter(getMethod("get", "get", String.class)); Assert.assertEquals("", okNameForIsGetter(getMethod("get", "get", String.class
@Test public void testOkNameForRegularGetter() { Assert.assertEquals("get", okNameForRegularGetter(null, "get")); Assert.assertEquals("get", okNameForRegularGetter(null, "get")); Assert.assertEquals("getCallbacks", okNameForRegularGetter(null, "getCallbacks")); Assert.assertEquals("get", okNameForRegularGetter(null, "get")); Assert.assertEquals("get", okNameForRegularGetter(null, "get")); Assert.assertEquals("getMetaClass", okNameForRegularGetter(null, "getMetaClass")); Assert.assertEquals("get", okNameForRegularGetter(null, "get")); Assert.assertEquals("get", okNameForRegularGetter(null, "get")); Assert.assertEquals("get", okNameForRegularGetter(null, "get")); Assert.assertEquals("get", okNameForRegularGetter(null, "get")); Assert.assertEquals("get", okNameForRegularGetter(null, "get")); Assert.assertEquals("get", okNameForRegularGetter(null, "get")); Assert.assertEquals("get", okNameForRegularGetter(null, "get")); Assert.assert
@Test public void testCglibGetCallbacks() { assertTrue(isCglibGetCallbacks(cglibGetMethods)); assertTrue(isCglibGetCallbacks(cglibGetMethodsWithPrefix)); assertTrue(isCglibGetCallbacks(cglibGetMethodsWithPrefix)); assertTrue(isCglibGetCallbacks(cglibGetMethodsWithPrefix)); assertTrue(isCglibGetCallbacks(cglibGetMethodsWithPrefix)); assertTrue(isCglibGetCallbacks(cglibGetMethodsWithPrefix)); assertTrue(isCglibGetCallbacks(cglibGetMethodsWithPrefix)); assertTrue(isCglibGetCallbacks(cglibGetMethodsWithPrefix)); assertTrue(isCglibGetCallbacks(cglibGetMethodsWithPrefix)); assertTrue(isCglibGetCallbacks(cglibGetMethodsWithPrefix)); assertTrue(isCglibGetCallbacks(cglibGetMethodsWithPrefix)); assertTrue(isCglibGetCallbacks(cglibGetMethodsWithPrefix)); assertTrue(isCglibGetCallbacks(cglibGetMethodsWithPrefix)); assertTrue(isCglibGetCallbacks(cglibGetMethodsWithPrefix)); assertTrue(isCglibGetCallbacks(cglibGetMethodsWithPrefix)); assertTrue(isCg
@Test public void test_isCglibGetCallbacks() { AnnoMapCallback callback = mock(AnnoMapCallback.class); when(callback.isArray()).thenReturn(true); when(callback.getCallbackType()).thenReturn(String.class); assertTrue(callback.isCglibGetCallbacks(callback)); }
@Test public void isCglibGetCallbacks() { AnnotatedMethod am = ReflectionUtil.findMethod(cglibGetCallbacksClass, "getArray", String.class); assertTrue(am.isArray()); }
@Test public void isCglibGetCallbacks() { assertTrue(isCglibGetCallbacks(unmanagedMethod)); assertTrue(isCglibGetCallbacks(unmanagedMethodWithAnnotation)); assertTrue(isCglibGetCallbacks(unmanagedMethodWithAnnotationWithPackage)); assertTrue(isCglibGetCallbacks(unmanagedMethodWithAnnotationWithPackage)); assertTrue(isCglibGetCallbacks(unmanagedMethodWithAnnotationWithPackage)); assertTrue(isCglibGetCallbacks(unmanagedMethodWithAnnotationWithPackage)); assertTrue(isCglibGetCallbacks(unmanagedMethodWithAnnotationWithPackage)); assertTrue(isCglibGetCallbacks(unmanagedMethodWithAnnotationWithPackage)); assertTrue(isCglibGetCallbacks(unmanagedMethodWithAnnotationWithPackage)); assertTrue(isCglibGetCallbacks(unmanagedMethodWithAnnotationWithPackage)); assertTrue(isCglibGetCallbacks(unmanagedMethodWithAnnotationWithPackage)); assertTrue(isCglibGetCallbacks(unmanagedMethodWithAnnotationWithPackage)); assertTrue(isCglibGetCallbacks(unmanagedMethodWithAnnotationWithPackage)); assertTrue(isCglibGetCallbacks(unmanagedMethodWithAnnotationWithPackage)); assertTrue(isCglibGetCallbacks(unmanaged
@Test public void test_isCglibGetCallbacks() { Class<?> rt = AnnotatedTestClass.class; Class<?> compType = rt.getComponentType(); Package pkg = compType.getPackage(); [LINE] public Package getName() { return pkg; } [LINE] public void testGetCallback(String name) { Assert.assertTrue(name, isCglibGetCallbacks(new AnnotatedMethod(pkg, name))); } [LINE] public void testGetCallback(String name, Class<?> rt, boolean[] callback) { Assert.assertTrue(name, isCglibGetCallbacks(new AnnotatedMethod(pkg, name))); }
@Test public void test_isCglibGetCallbacks() { Class<?> rt = Foo.class; Package pkg = rt.getPackage(); Class<?> compType = rt.getComponentType(); Field m = pkg.getDeclaredField("cglibGetCallbacks"); m.setAccessible(true); assertTrue(isCglibGetCallbacks(m)); pkg = rt.getPackage(); pkg.set(pname); m = pkg.getDeclaredField("cglibGetCallbacks"); m.setAccessible(true); assertTrue(isCglibGetCallbacks(m)); pkg = rt.getPackage(); pkg.set(pname); m = pkg.getDeclaredField("cglibGetCallbacks"); m.setAccessible(true); assertTrue(isCglibGetCallbacks(m)); pkg = rt.getPackage(); pkg.set(pname); m = pkg.getDeclaredField("cglibGetCallbacks"); m.setAccessible(true); assertTrue(isCglibGetCallbacks(m)); pkg = rt.getPackage(); pkg.set(pname); m = pkg.getDeclaredField("cglibGetCallbacks"); m.setAccessible(true); assertTrue(isCglibGetCallbacks(m)); }
@Test public void testCGlibGetCallbacks() { Mockito.when(mockA.getName()).thenReturn("net.sf.cglib"); Mockito.when(mockA.getRawType()).thenReturn(null); Assert.assertFalse(Annotator.isCglibGetCallbacks(mockA, "net.sf.cglib")); Mockito.when(mockA.getRawType().isArray()).thenReturn(true); Assert.assertTrue(Annotator.isCglibGetCallbacks(mockA, "net.sf.cglib")); Mockito.when(mockA.getRawType().isObject()).thenReturn(true); Assert.assertTrue(Annotator.isCglibGetCallbacks(mockA, "net.sf.cglib")); Mockito.when(mockA.getRawType().isObject()).thenReturn(true); Assert.assertTrue(Annotator.isCglibGetCallbacks(mockA, "net.sf.cglib")); Mockito.when(mockA.getRawType().isArray()).thenReturn(false); Assert.assertFalse(Annotator.isCglibGetCallbacks(mockA, "net.sf.cglib")); Mockito.when(mockA.getRaw
@Test public void testCglibGetCallback() { String name = "cglibGetCallback"; Class<?> rt = Mockito.mock(Class.class); Mockito.when(rt.isArray()).thenReturn(true); Mockito.when(rt.getComponentType()).thenReturn(this.getClass()); Mockito.when(pkg.getName()).thenReturn(name); Mockito.when(pkg.getName()).thenReturn(name); Assert.assertTrue(isCglibGetCallbacks(null)); Assert.assertFalse(isCglibGetCallbacks(this.getClass())); Mockito.when(pkg.getName()).thenReturn(name); Assert.assertFalse(isCglibGetCallbacks(this.getClass())); Mockito.when(name.startsWith("net.sf.cglib")).thenReturn(true); Assert.assertTrue(isCglibGetCallbacks(this.getClass())); Mockito.when(name.startsWith("org.hibernate.repackage.cglib")).thenReturn(false); Assert.assertFalse(isCglibGetCallbacks(this.getClass())); Mockito.when(name.startsWith("net.sf.cglib")).thenReturn(false); Assert.assertFalse(isCglibGetCallbacks(this.getClass()));
@Test public void testCGlibGetCallbacks() throws NoSuchMethodException { Class<?> rt = Foo.class; Method m = rt.getMethod("get", Object.class); assertTrue(isCglibGetCallbacks(m)); rt = Foo.class; m = rt.getMethod("isArray", Object[].class); assertTrue(isCglibGetCallbacks(m)); rt = Foo.class; m = rt.getMethod("isArray", Object[].class); assertTrue(isCglibGetCallbacks(m)); rt = Foo.class; m = rt.getMethod("isArray", Object[].class); assertTrue(isCglibGetCallbacks(m)); }
@Test public void isGroovyMetaClassGetter() { assertTrue(isGroovyMetaClassGetter(getMethod("getString", String.class))); assertTrue(isGroovyMetaClassGetter(getMethod("isInteger", int.class))); assertTrue(isGroovyMetaClassGetter(getMethod("isArray", int.class))); assertTrue(isGroovyMetaClassGetter(getMethod("isStringArray", int.class))); assertTrue(isGroovyMetaClassGetter(getMethod("isStringArray", int.class))); assertTrue(isGroovyMetaClassGetter(getMethod("isStringArray", int.class))); assertTrue(isGroovyMetaClassGetter(getMethod("isStringArray", int.class))); assertTrue(isGroovyMetaClassGetter(getMethod("isStringArray", int.class))); assertTrue(isGroovyMetaClassGetter(getMethod("isStringArray", int.class))); assertTrue(isGroovyMetaClassGetter(getMethod("isStringArray", int.class))); assertTrue(isGroovyMetaClassGetter(getMethod("isStringArray", int.class))); assertTrue(isGroovyMetaClassGetter(getMethod("isStringArray", int.class))); assertTrue(isGroovyMetaClassGetter(getMethod("isStringArray", int.class)));
@Test public void testGroovyMetaClassGetter() { assertTrue(isGroovyMetaClassGetter(getMethod("getString", String.class))); assertTrue(isGroovyMetaClassGetter(getMethod("isArray", String.class))); assertTrue(isGroovyMetaClassGetter(getMethod("isString", String.class))); assertTrue(isGroovyMetaClassGetter(getMethod("isArray", String.class))); assertTrue(isGroovyMetaClassGetter(getMethod("isString", String.class))); assertTrue(isGroovyMetaClassGetter(getMethod("isString", String.class))); assertTrue(isGroovyMetaClassGetter(getMethod("isString", String.class))); assertTrue(isGroovyMetaClassGetter(getMethod("isString", String.class))); assertTrue(isGroovyMetaClassGetter(getMethod("isString", String.class))); assertTrue(isGroovyMetaClassGetter(getMethod("isString", String.class))); assertTrue(isGroovyMetaClassGetter(getMethod("isString", String.class))); assertTrue(isGroovyMetaClassGetter(getMethod("isString", String.class))); assertTrue(isGroovyMetaClassGetter(getMethod("isString", String.class))); assertTrue(isGroovyMetaClassGetter(getMethod
@Test public void testGroovyMetaClassGetter() { assertGroovyGetter(Arrays.class, "get", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int
@Test public void testIsGroovyMetaClassGetter() { class G { public boolean getA() { return true; } public boolean getA2() { return false; } public boolean getA3() { return false; } }
@Test public void testGroovyMetaClassGetter() { Package pkg = Thread.currentThread().getContextClassLoader().getPackage(); Class<?> clazz = Thread.currentThread().getContextClassLoader().loadClass( "org.apache.geode.runner.TestThread"); assertTrue(clazz.getName().startsWith("groovy.lang.Thread")); assertTrue(clazz.getName().startsWith("groovy.lang.ClassLoader")); assertFalse(clazz.getName().startsWith("groovy.lang.Thread")); }
@Test public void testGroovyMetaClassGetter() { assertTrue(isGroovyMetaClassGetter(getMethod("getString", String.class))); assertTrue(isGroovyMetaClassGetter(getMethod("isStringArray", String.class))); assertTrue(isGroovyMetaClassGetter(getMethod("isArray", String.class))); assertTrue(isGroovyMetaClassGetter(getMethod("isArray", String.class))); assertTrue(isGroovyMetaClassGetter(getMethod("isArray", String.class))); assertTrue(isGroovyMetaClassGetter(getMethod("isArray", String.class))); assertTrue(isGroovyMetaClassGetter(getMethod("isArray", String.class))); assertTrue(isGroovyMetaClassGetter(getMethod("isArray", String.class))); assertTrue(isGroovyMetaClassGetter(getMethod("isArray", String.class))); assertTrue(isGroovyMetaClassGetter(getMethod("isArray", String.class))); assertTrue(isGroovyMetaClassGetter(getMethod("isArray", String.class))); assertTrue(isGroovyMetaClassGetter(getMethod("isArray", String.class))); assertTrue(isGroovyMetaClassGetter(getMethod("isArray", String.class))); assertTrue(isGroovyMetaClassGetter(get
@Test public void testManglePropertyName() { Assert.assertNull(LINE + "hello.Bar.baz", Line.manglePropertyName("hello.Bar.baz")); Assert.assertNull(LINE + "hello.Bar.baz", Line.manglePropertyName("hello.Bar.baz")); Assert.assertNull(LINE + "hello.Bar.baz", Line.manglePropertyName("hello.Bar.baz")); Assert.assertNull(LINE + "hello.Bar.baz", Line.manglePropertyName("hello.Bar.baz")); Assert.assertNull(LINE + "hello.Bar.baz", Line.manglePropertyName("hello.Bar.baz")); }
@Test public void testIntNode() { IntNode[] nodes = new IntNode[] { new IntNode(10), new IntNode(10), new IntNode(10), new IntNode(10), new IntNode(10), new IntNode(10), new IntNode(10), new IntNode(10), new IntNode(10), new IntNode(10), new IntNode(10), new IntNode(10), new IntNode(10), new IntNode(10), new IntNode(10), new IntNode(10), new IntNode(10), new IntNode(10), new IntNode(10), new IntNode(10), new IntNode(10), new IntNode(10), new IntNode(10), new IntNode(10), new IntNode(10), new IntNode(10), new IntNode(10), new IntNode(10), new IntNode(10), new IntNode(10), new IntNode(10), new IntNode(10), new IntNode(10), new IntNode(10), new IntNode(10), new IntNode(10), new IntNode(10), new IntNode(10), new IntNode(10), new IntNode(10), new IntNode(10), new IntNode(10), new IntNode(10), new IntNode(10), new IntNode(10), new IntNode(10), new IntNode(10), new
@Test public void testValueOf() { IntNode i = new IntNode(1); Assert.assertEquals(new IntNode(1), i); i = new IntNode(2); Assert.assertEquals(new IntNode(2), i); i = new IntNode(3); Assert.assertEquals(new IntNode(4), i); i = new IntNode(5); Assert.assertEquals(new IntNode(6), i); i = new IntNode(7); Assert.assertEquals(new IntNode(7), i); i = new IntNode(8); Assert.assertEquals(new IntNode(8), i); i = new IntNode(9); Assert.assertEquals(new IntNode(9), i); i = new IntNode(10); Assert.assertEquals(new IntNode(10), i); i = new IntNode(11); Assert.assertEquals(new IntNode(11), i); i = new IntNode(13); Assert.assertEquals(new IntNode(13), i); i = new IntNode(14); Assert.assertEquals(new IntNode(14), i); i = new IntNode(21); Assert.assertEquals(new IntNode(21), i); i = new IntNode(22); Assert.assertEquals(new
@Test public void testBigInteger() { BigInteger bigInteger = BigInteger.valueOf(BigInteger.valueOf(BigInteger.valueOf(Long.MAX_VALUE).pow(1))); BigInteger bigInteger2 = BigInteger.valueOf(BigInteger.valueOf(Long.MIN_VALUE).pow(1))); BigInteger bigInteger3 = BigInteger.valueOf(BigInteger.valueOf(Long.MIN_VALUE).pow(1)); BigInteger bigDecimal = BigInteger.valueOf(BigInteger.valueOf(Long.MAX_VALUE).pow(1)); BigInteger bigDecimal2 = BigInteger.valueOf(BigInteger.valueOf(Long.MIN_VALUE).pow(1)); BigInteger bigDecimal3 = BigInteger.valueOf(BigInteger.valueOf(Long.MAX_VALUE).pow(1)); assertEquals(bigInteger, bigDecimal.asBigInteger()); assertEquals(bigInteger2, bigDecimal2.asBigInteger()); assertEquals(bigDecimal3, bigDecimal3.asBigInteger()); }
@Test public void testIsIntegralNumber() { Assert.assertTrue(new IntNode(1).isIntegralNumber()); Assert.assertTrue(new IntNode(2).isIntegralNumber()); Assert.assertTrue(new IntNode(-2).isIntegralNumber()); }
@Test public void testIsIntegralNumber() { Assert.assertTrue(new IntNode(1).isIntegralNumber()); }
@Test public void testIntValue() { IntNode[] actual = IntNode.values(); Assert.assertEquals(actual.length, 2); Assert.assertEquals(actual[0], 1); Assert.assertEquals(actual[1], 2); Assert.assertEquals(actual[2], 3); }
@Test public void test_intValue() { IntNode[] actual = IntNode.valueOf(10).intValue(); Assert.assertEquals(10, actual[0]); Assert.assertEquals(10, actual[1]); Assert.assertEquals(10, actual[2]); }
@Test public void testUnwrappedPropertyHandler() throws IOException { UnwrappedPropertyHandler unwrappedPropertyHandler = new UnwrappedPropertyHandler(); unwrappedPropertyHandler.addProperty(new SimpleSettableBeanProperty("name", "value")); assertEquals("value", unwrappedPropertyHandler.getProperty("name").getValue()); }
@Test public void testAddProperty() { class Test { public Test() { } } TestBean bean = new TestBean(); bean.addProperty(new SettableBeanProperty("name", "value")); bean.addProperty(new SettableBeanProperty("age", 5)); bean.addProperty(new SettableBeanProperty("name", "other")); bean.addProperty(new SettableBeanProperty("age", 7)); bean.addProperty(new SettableBeanProperty("name", "value")); bean.addProperty(new SettableBeanProperty("age", 8)); }
@Test public void testProperty() throws IOException { TestBean bean = new TestBean(); bean.addProperty(new SettableBeanProperty("name", "value")); bean.addProperty(new SettableBeanProperty("age", 5)); bean.addProperty(new SettableBeanProperty("name2", "value2")); bean.addProperty(new SettableBeanProperty("age", 7)); bean.addProperty(new SettableBeanProperty("name3", "value3")); bean.addProperty(new SettableBeanProperty("name4", "value4")); bean.addProperty(new SettableBeanProperty("name5", "value5")); bean.addProperty(new SettableBeanProperty("name6", "value6")); bean.addProperty(new SettableBeanProperty("name7", "value7")); bean.addProperty(new SettableBeanProperty("name8", "value8")); bean.addProperty(new SettableBeanProperty("name9", "value9")); bean.addProperty(new SettableBeanProperty("name10", "value10")); bean.addProperty(new SettableBeanProperty("name11", "value11")); bean.addProperty(new SettableBeanProperty("name12", "value
@Test public void testProcessUnwrapped() throws IOException, JsonProcessingException { MockTokenBuffer bean = new MockTokenBuffer(); bean.setBean(new MockBean()); bean.processUnwrapped(null, null, bean, null); bean.setBean(new MockBean()); bean.setBean(new MockBean()); bean.setBean(new MockBean()); bean.setBean(new MockBean()); bean.setBean(new MockBean()); bean.setBean(new MockBean()); bean.setBean(new MockBean()); bean.setBean(new MockBean()); bean.setBean(new MockBean()); bean.setBean(new MockBean()); bean.setBean(new MockBean()); bean.setBean(new MockBean()); bean.setBean(new MockBean()); bean.setBean(new MockBean()); bean.setBean(new MockBean()); bean.setBean(new MockBean()); bean.setBean(new MockBean()); bean.setBean(new MockBean()); bean.setBean(new MockBean()); bean.setBean(new MockBean()); bean.setBean(new MockBean()); bean.setBean(new MockBean()); bean.setBean(new MockBean
@Test public void testProcessUnwrapped() throws IOException, JsonProcessingException { MockTokenBuffer mock = new MockTokenBuffer(); MockBean bean = new MockBean(); bean.setBeanProperty("a"); bean.setBeanProperty("b"); bean.setBeanProperty("c"); bean.setBeanProperty("d"); bean.setBeanProperty("e"); bean.setBeanProperty("f"); bean.setBeanProperty("g"); bean.setBeanProperty("h"); bean.setBeanProperty("i"); bean.setBeanProperty("j"); bean.setBeanProperty("k"); bean.setBeanProperty("l"); bean.setBeanProperty("l"); bean.setBeanProperty("l2"); bean.setBeanProperty("k"); bean.setBeanProperty("l2"); bean.setBeanProperty("k"); bean.setBeanProperty("l3"); bean.setBeanProperty("e"); bean.setBeanProperty("f"); bean.setBeanProperty("g"); bean.setBeanProperty("h"); bean.setBeanProperty("i"); bean.setBeanProperty("j"); bean.setBeanProperty("k"); bean.setBeanProperty("l3"); bean.setBeanProperty("k"); bean.set
@Test public void testProcessUnwrapped() throws IOException, JsonProcessingException { class TestBean implements Bean { private String s; public String s() { return s; } } TestBean bean = new TestBean(); bean.setS("s"); bean.setS("s"); bean.setS("s"); bean.setS("s"); bean.setS("s"); bean.setS("s"); bean.setS("s"); bean.setS("s"); bean.setS("s"); bean.setS("s"); bean.setS("s"); bean.setS("s"); bean.setS("s"); bean.setS("s"); bean.setS("s"); bean.setS("s"); bean.setS("s"); bean.setS("s"); bean.setS("s"); bean.setS("s"); bean.setS("s"); bean.setS("s"); bean.setS("s"); bean.setS("s"); bean.setS("s"); bean.setS("s"); bean.setS("s"); bean.setS("s"); bean.setS("s"); bean.setS("s"); bean
@Test public void processUnwrapped() throws IOException, JsonProcessingException { MockTokenBuffer mockTokenBuffer = new MockTokenBuffer(); new UnwrappedPropertyHandler().processUnwrapped(null, null, null, mockTokenBuffer); assertEquals("bean", bean); mockTokenBuffer.reset(); new UnwrappedPropertyHandler().processUnwrapped(null, null, null, mockTokenBuffer); assertEquals("bean", bean); mockTokenBuffer.reset(); new UnwrappedPropertyHandler().processUnwrapped(null, null, null, mockTokenBuffer); assertEquals("bean", bean); mockTokenBuffer.reset(); new UnwrappedPropertyHandler().processUnwrapped(null, null, null, mockTokenBuffer); assertEquals("bean", bean); mockTokenBuffer.reset(); new UnwrappedPropertyHandler().processUnwrapped(null, null, null, mockTokenBuffer); assertEquals("bean", bean); mockTokenBuffer.reset(); new UnwrappedPropertyHandler().processUnwrapped(null, null, null, mockTokenBuffer); assertEquals("bean", bean); mockTokenBuffer.reset(); new UnwrappedPropertyHandler().processUnwrapped(null, null, null, mockTokenBuffer); assertEquals("bean", bean); mockTokenBuffer.reset(); new UnwrappedProperty
@Test public void testProcessUnwrapped() throws IOException, JsonProcessingException { MockTokenBuffer mock = new MockTokenBuffer(); new MockTokenBuffer(mock).nextToken(); new MockTokenBuffer(mock).nextToken(); new MockTokenBuffer(mock).nextToken(); new MockTokenBuffer(mock).nextToken(); new MockTokenBuffer(mock).nextToken(); new MockTokenBuffer(mock).nextToken(); new MockTokenBuffer(mock).nextToken(); new MockTokenBuffer(mock).nextToken(); new MockTokenBuffer(mock).nextToken(); new MockTokenBuffer(mock).nextToken(); new MockTokenBuffer(mock).nextToken(); new MockTokenBuffer(mock).nextToken(); new MockTokenBuffer(mock).nextToken(); new MockTokenBuffer(mock).nextToken(); new MockTokenBuffer(mock).nextToken(); new MockTokenBuffer(mock).nextToken(); new MockTokenBuffer(mock).nextToken(); new MockTokenBuffer(mock).nextToken(); new MockTokenBuffer(mock).nextToken(); new MockTokenBuffer(mock).nextToken(); new MockTokenBuffer(mock).nextToken(); new MockTokenBuffer(mock).nextToken(); new MockTokenBuffer(mock).nextToken
@Test public void should_deserializeAndSet_property() throws Exception { MockTokenBuffer bean = new MockTokenBuffer(); new MockTokenBuffer(bean, "foo").processUnwrapped(null, null, bean, bean); assertEquals("foo", bean.getFoo()); assertEquals("bar", bean.getBar()); }
@Test public void testProcessUnwrapped() throws IOException, JsonProcessingException { MockTokenBuffer mock = new MockTokenBuffer(); MockDeserializationContext mockCtx = new MockDeserializationContext(); Object bean = new Object(); bean.processUnwrapped(mock, mockCtx, bean, mockBuf); assertEquals(bean, mockCtx.getBean()); }
@Test public void testSimpleDeserializers() throws Exception { List<Deserializer<?>> deserializers = new ArrayList<Deserializer<?>>() {{ add(new SimpleDeserializerializers().forClass(MyBean.class)); add(new SimpleDeserializers().forClass(MyBean2.class)); }}; for (Deserializer<?>> deserializer : deserializers) { assertEquals(MyBean2.class, deserializer.deserialize(deserializer.getInput())); } }
@Test public void testAddDeserializer() { JsonDeserializer<String> de = new SimpleDeserializers().findArrayDeserializer(String.class, null, null, null); de.addDeserializer(String.class, de); de.addDeserializer(String.class, de); try { de.findBeanDeserializer(String.class, null, null); fail(); } catch (JsonMappingException e) { } }
@Test public void testDeserializer() throws Exception { class Test { public void test() { } } MockDeserializer deser = new MockDeserializer(); MockDeserializer.reset(); MockDeserializer.addDeserializer(Test.class, deser); MockDeserializer.addDeserializer(Test.class, deser); MockDeserializer.addDeserializer(Test.class, deser); Assert.assertEquals(Deserializer.class, deser.getDeserializer()); Assert.assertEquals(Deserializer.class, deser.getDeserializer()); Assert.assertEquals(Deserializer.class, deser.getDeserializer()); }
@Test public void testAddDeserializer() { new Expectations() { { new SimpleDeserializers(); { new ClassKey(String.class); { new ClassKey(Integer.class); { new ClassKey(Integer.class); { new ClassKey(String.class); { new ClassKey(Integer.class); { new ClassKey(Integer.class); { new ClassKey(Integer.class); { new ClassKey(Integer.class); { new ClassKey(Integer.class); { new ClassKey(Integer.class); { new ClassKey(Integer.class); { { new ClassKey(Integer.class); { { new ClassKey(Integer.class); { { new ClassKey(Integer.class); { { { new ClassKey(Integer.class); { { { new ClassKey(Integer.class); { { { { new ClassKey(Integer.class); { { { { { { { { { { { { { { { { { { { { { { { { { { { { { { { { { { { { { { { { { { { { { { { { { { { { { { { { { { { { { { { { { { { { { { { { { { { { { { { { { { { { { { { { { { { { { { {
@Test public void testAddDeserializer() { MockDeserializer deserializer = new MockDeserializer(); deserializer.addDeserializer(MyBean.class, new MyBeanDeserializer()); MockDeserializer deserializer2 = new MockDeserializer(); deserializer2.addDeserializer(MyBean.class, new MyBeanDeserializer()); Assert.assertEquals(Deserializer.class, deserializer2.getDeserializer()); Assert.assertEquals(Deserializer.class, deserializer2.getDeserializer()); }
@Test public void testAddDeserializer() throws Exception { SimpleDeserializers deser = new SimpleDeserializers(); deser.addDeserializer(MyBean.class, new MyDeserializer()); DeserializationConfig config = new DeserializationConfig(); config.setSerializeNulls(true); beanDesc.setSerializeArray(Arrays.asList(MyBean.class.getName())); MockDeserializer deserializer = new MockDeserializer(); deser.addDeserializer(MyBean.class, deserializer); MockDeserializer deserializer2 = new MockDeserializer(); deser2.addDeserializer(MyBean.class, deserializer2); MockDeserializer deserializer3 = new MockDeserializer(); deser3.addDeserializer(MyBean.class, deserializer3); DeserializationConfig config2 = new DeserializationConfig(); config2.setSerializeNulls(true); beanDesc2.setSerializeArray(Arrays.asList(MyBean.class.getName())); MockDeserializer deserializer4 = new MockDeserializer(); deser4.addDeserializer(MyBean.class, deserializer4); Assert.assertEquals(deser.getDeserializeArray(MyBean.class), deserializer2); Assert.assertEquals(deser2.getDeserializeArray(MyBean.class), deserializer3); Assert.assertEquals(deser3.getDeserializeArray(MyBean.class), deserializer
@Test public void testFindArrayDeserializer() throws JsonMappingException { MockDeserializer mockDeserializer = new MockDeserializer(); MockDeserializer mockDeserializer2 = new MockDeserializer(); MockDeserializer mockDeserializer3 = new MockDeserializer(); MockDeserializer mockDeserializer4 = new MockDeserializer(); MockDeserializer mockDeserializer5 = new MockDeserializer(); MockDeserializer mockDeserializer6 = new MockDeserializer(); mockDeserializer7.setReturn(true); mockDeserializer8.setReturn(false); mockDeserializer1.setReturn(true); mockDeserializer2.setReturn(false); mockDeserializer3.setReturn(true); mockDeserializer4.setReturn(false); mockDeserializer5.setReturn(true); mockDeserializer6.setReturn(false); mockDeserializer7.setReturn(false); mockDeserializer7.setReturn(true); mockDeserializer2.setReturn(false); mockDeserializer2.setReturn(true); mockDeserializer2.setReturn(true); mockDeserializer2.setReturn(mockDeserializer3); mockDeserializer3.setReturn(false); mockDeserializer4.setReturn(true); mockDeserializer5.setReturn(false); JsonDeserializer<?> deserializer = deserializer.findArrayDeserializer(new ArrayType(int[].class), null, null, mockDeserializer, mockDeserializer4, mockDeserializer6, mockDeserializer1); Assert.assertNull(deserializer); Assert.assert
@Test public void testFindArrayDeserializer() throws JsonMappingException { BeanDescription beanDesc = new BeanDescription(); beanDesc.setClassMappings(null); JsonDeserializer<?> deserializer = _deserializers.findArrayDeserializer(ArrayType.class, null, beanDesc, null, null); Assert.assertNotNull(deserializer); Assert.assertEquals(Deserializer.class, deserializer.getClass()); }
@Test public void testFindBeanDeserializer() throws JsonMappingException { BeanDescription beanDesc = new BeanDescription("testBean"); JsonDeserializer<?> deserializer = _deserializers.findBeanDeserializer(JavaType.getArrayType(String.class), null, beanDesc); Assert.assertNotNull(deserializer); Assert.assertEquals(Deserializer.class, deserializer.getClass()); }
@Test public void testFindBeanDeserializer() throws JsonMappingException { BeanDescription beanDesc = new BeanDescription("testBean"); beanDesc.setClassMappings(null); JsonDeserializer<?> deserializer = _deserializers.findBeanDeserializer(MyBean.class, null, beanDesc); Assert.assertNotNull(deserializer); Assert.assertEquals(MyBean.class, deserializer.getClass()); }
@Test public void testFindEnumDeserializer() throws JsonMappingException { MockDeserializer mockDeserializer = new MockDeserializer(); MockDeserializer mockDeserializer2 = new MockDeserializer(); MockDeserializer mockDeserializer3 = new MockDeserializer(); MockDeserializer mockDeserializer4 = new MockDeserializer(); MockDeserializer mockDeserializer5 = new MockDeserializer(); MockDeserializer mockDeserializer6 = new MockDeserializer(); MockDeserializer mockDeserializer7 = new MockDeserializer(); MockDeserializer mockDeserializer8 = new MockDeserializer(); MockDeserializer mockDeserializer9 = new MockDeserializer(); MockDeserializer mockDeserializer10 = new MockDeserializer(); MockDeserializer mockDeserializer11 = new MockDeserializer(); MockDeserializer mockDeserializer12 = new MockDeserializer(); MockDeserializer mockDeserializer13 = new MockDeserializer(); MockDeserializer mockDeserializer14 = new MockDeserializer(); MockDeserializer mockDeserializer15 = new MockDeserializer(); mockDeserializer1.setReturn(mockDeserializer); mockDeserializer2.setReturn(mockDeserializer); mockDeserializer3.setReturn(mockDeserializer); mockDeserializer4.setReturn(mockDeserializer5); mockDeserializer5.setReturn(mockDeserializer6); mockDeserializer7.setReturn(mockDeserializer7); mockDeserializer8.setReturn(mockDeserializer8); mockDeserializer1.setReturn(mockDeserializer9); mockDeserializer2.setReturn(mockDeserializer10); mockDeserializer1.setReturn(
@Test public void testFindEnumDeserializer() throws JsonMappingException { BeanDescription beanDesc = new BeanDescription(); beanDesc.setClassMappings(null); JsonDeserializer<?> deserializer = _deserializers.findEnumDeserializer(MyEnum.class, null, beanDesc); Assert.assertNotNull(deserializer); Assert.assertEquals(MyEnum.class, deserializer.getClass()); }
@Test public void testReplaceParameterAnnotations() { AnnotationMap annotations = AnnotationMap.createAnnotationMap(String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class); AnnotatedWithParams annotatedWithParams = new AnnotatedWithParams(annotations, new AnnotationMap[]{ annotations }); AnnotatedParameter out = annotatedWithParams.replaceParameterAnnotations(0, annotations); AnnotatedParameter p = out.getParameter(42); assertEquals(p.getLabel(), "foo"); assertEquals(p.getAnnotations().get(0), annotations); }
@Test public void replaceParameterAnnotations() { AnnotationMap annMap = AnnotationMap.createAnnotationMap(String.class, "foo"); AnnotatedParameter a = annotatedWithParams(anAnnotationMap).replaceParameterAnnotations(0, annMap); AnnotationMap b = annotatedWithParams(anAnnotationMap).replaceParameterAnnotations(1, annMap); assertEquals(a, b); }
@Test public void testReplaceParameterAnnotations() { AnnotationMap annotations = AnnotationMap.createAnnotationMap(String.class, String.class, String.class, String.class, String.class, String.class, String.class); AnnotatedWithParams annotatedWithParams = new AnnotatedWithParams(annotations, new AnnotationMap[]{AnnotationMap.createAnnotationMap(String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, String
@Test public void testIgnoredPropertyNames() { Set<String> ignoredNames = new HashSet<>(); ignoredNames.add("foo"); ignoredNames.add("bar"); assertEquals(ignoredNames, classDef.getIgnoredPropertyNames()); }
@Test public void testInjectables() { AnnotatedClass ac = AnnotatedClass.forClass(Foo.class); AnnotatedMember foo = ac.findInjectables().get("foo"); AnnotatedMember bar = ac.findInjectables().get("bar"); AnnotatedMember baz = ac.findInjectables().get("baz"); AnnotatedMember dz = ac.findInjectables().get("dz"); AnnotatedMember ez = ac.findInjectables().get("ez"); AnnotatedMember fz = ac.findInjectables().get("fz"); AnnotatedMember gz = ac.findInjectables().get("gz"); AnnotatedMember dz = ac.findInjectables().get("gz"); AnnotatedMember ez = ac.findInjectables().get("ez"); AnnotatedMember fz = ac.findInjectables().get("fz"); AnnotatedMember gz = ac.findInjectables().get("gz"); AnnotatedMember ez = ac.findInjectables().get("ez"); AnnotatedMember fz = ac.findInjectables().get("fz"); AnnotatedMember gz = ac.findInjectables().get("gz"); AnnotatedMember ez = ac.findInjectables().get("e
@Test public void testInjectables() { AnnotatedClass class1 = new AnnotatedClass(typeBindings); AnnotatedClass class2 = new AnnotatedClass(typeBindings); AnnotatedClass class3 = new AnnotatedClass(typeBindings); AnnotatedClass class4 = new AnnotatedClass(typeBindings); AnnotatedClass class5 = new AnnotatedClass(typeBindings); AnnotatedClass class6 = new AnnotatedClass(typeBindings); AnnotatedClass class7 = new AnnotatedClass(typeBindings); AnnotatedClass class8 = new AnnotatedClass(typeBindings); AnnotatedClass class9 = new AnnotatedClass(typeBindings); AnnotatedClass class10 = new AnnotatedClass(typeBindings); AnnotatedClass class11 = new AnnotatedClass(typeBindings); AnnotatedClass class12 = new AnnotatedClass(typeBindings); AnnotatedClass class13 = new AnnotatedClass(typeBindings); AnnotatedClass class14 = new AnnotatedClass(typeBindings); AnnotatedClass class21 = new AnnotatedClass(typeBindings); AnnotatedClass class22 = new AnnotatedClass(typeBindings); AnnotatedClass class23 = new AnnotatedClass(typeBindings); AnnotatedClass class24 = new AnnotatedClass(typeBindings); AnnotatedClass class21a = new AnnotatedClass(typeBindings); AnnotatedClass class22b = new AnnotatedClass(typeBindings); AnnotatedClass class23
@Test public void testFindBackReferenceProperties() { AnnotatedMember nonBackReference = new AnnotatedMember(BASED_NAME, null, null, null); AnnotatedMember nonBackReference2 = new AnnotatedMember(BASED_NAME, null, null, null); AnnotatedMember nonBackReference3 = new AnnotatedMember(BASED_NAME, null, null, null); AnnotatedMember nonBackReference4 = new AnnotatedMember(BASED_NAME, null, null, null); AnnotatedMember nonBackReference5 = new AnnotatedMember(BASED_NAME, null, null, null); AnnotatedMember nonBackReference6 = new AnnotatedMember(BASED_NAME, null, null, null); AnnotatedMember nonBackReference7 = new AnnotatedMember(BASED_NAME, null, null, null); AnnotatedMember nonBackReference8 = new AnnotatedMember(BASED_NAME, null, null, null); Map<String, AnnotatedMember> properties = new HashMap<String, AnnotatedMember>(); properties.put(nonBackReference.getName(), nonBackReference); properties.put(nonBackReference2.getName(), nonBackReference2); properties.put(nonBackReference3.getName(), nonBackReference3); Map<String, AnnotatedMember> backReferences = new
@Test public void findBackReferenceProperties_MultipleBackReferences() { String name = "foo"; AnnotatedMember am = mock(AnnotatedMember.class); AnnotationIntrospector.ReferenceProperty ref = mock(AnnotationIntrospector.ReferenceProperty.class); when(ref.getName()).thenReturn(name); when(ref.isBackReference()).thenReturn(true); when(ref.getMutator()).thenReturn(am); when(am.getName()).thenReturn(name); when(am.isBackReference()).thenReturn(true); when(ref.isBackReference()).thenReturn(false); when(ref.getName()).thenReturn(name); when(annotationIntrospector.findReferenceType(am)).thenReturn(null); Map<String, AnnotatedMember> result = null; result = _cut.findBackReferenceProperties(); assertNotNull(result); assertEquals(2, result.size()); AnnotatedMember am2 = result.get(name); AnnotatedMember am3 = result.get(name); assertSame(am2, am3); assertSame(am3, result.get(name)); assertSame(am3, result.get(name)); }
@Test public void findBackReferenceProperties() { class MyBean { public void foo() { } } MyBean bean = new MyBean(); bean.foo(); bean.foo(); bean.foo(); bean.foo(); Map<String, AnnotatedMember> map = new HashMap<String, AnnotatedMember>(); map.put("foo", mock(AnnotatedMember.class)); map.put("bar", mock(AnnotatedMember.class)); assertEquals(map, classUnderTest.findBackReferenceProperties()); }
@Test public void findBackReferenceProperties() { AnnotatedMember am = property.getMutator(); AnnotatedMember backReference = property.getBackReference(); assertEquals(property.getMember(), backReference); }
@Test public void findBackReferenceProperties() { class Test { public void test() { } } TestAnnotationIntrospector annotationIntrospector = new TestAnnotationIntrospector(); AnnotationIntrospector.ReferenceProperty refProperty = new AnnotationIntrospector.ReferenceProperty(AnnotationIntrospector.class, "ref", true); AnnotationIntrospector.ReferenceMethod backReferenceMethod = new AnnotationIntrospector.ReferenceMethod(refProperty, null); AnnotationIntrospector.ReferenceMethod backReferenceMethod = new AnnotationIntrospector.ReferenceMethod(backReferenceMethod, null); AnnotationIntrospector.ReferenceMethod backReferenceMethod2 = new AnnotationIntrospector.ReferenceMethod(backReferenceMethod, null); AnnotationIntrospector.ReferenceMethod backReferenceMethod3 = new AnnotationIntrospector.ReferenceMethod(backReferenceMethod, null); AnnotationIntrospector.ReferenceMethod backReferenceMethod4 = new AnnotationIntrospector.ReferenceMethod(backReferenceMethod, null); AnnotationIntrospector.ReferenceMethod backReferenceMethod5 = new AnnotationIntrospector.ReferenceMethod(backReferenceMethod, null); AnnotationIntrospector.ReferenceMethod backReferenceMethod6 = new AnnotationIntrospector.ReferenceMethod(backReferenceMethod, null); AnnotationIntrospector.ReferenceMethod backReferenceMethod7 = new AnnotationIntrospector.ReferenceMethod(backReference
@Test public void findBackReferenceProperties() { AnnotationIntrospector.ReferenceProperty property = mock(AnnotationIntrospector.ReferenceProperty.class); when(property.isBackReference()).thenReturn(true); AnnotationIntrospector.ReferenceProperty refProperty = mock(AnnotationIntrospector.ReferenceProperty.class); when(refProperty.getMutator()).thenReturn(property); when(property.getRefName()).thenReturn("foo"); AnnotationIntrospector.ReferenceProperty ref = mock(AnnotationIntrospector.ReferenceProperty.class); when(ref.isBackReference()).thenReturn(true); when(ref.getRefName()).thenReturn("bar"); AnnotationIntrospector.ReferenceProperty property2 = mock(AnnotationIntrospector.ReferenceProperty.class); when(property2.isBackReference()).thenReturn(true); when(property2.getRefName()).thenReturn("bar2"); AnnotationIntrospector.ReferenceProperty ref2 = mock(AnnotationIntrospector.ReferenceProperty.class); when(ref2.getMutator()).thenReturn(property2); AnnotationIntrospector.ReferenceProperty property3 = mock(AnnotationIntrospector.ReferenceProperty.class); when(property3.isBackReference()).thenReturn(true); when(property3.getRefName()).thenReturn("bar3"); AnnotationIntrospector.Reference
@Test public void findBackReferencePropertiesMultipleBackReferences() { class MyBackReference { public void foo() { } } MyBackReferenceBean bean = new MyBackReferenceBean(); bean.foo(); Map<String, AnnotatedMember> props = bean.findBackReferenceProperties(); assertEquals(1, props.size()); AnnotatedMember fooA = props.get("foo"); assertEquals("foo", fooA.getName()); AnnotatedMember fooB = props.get("foo"); assertEquals("bar", fooB.getName()); AnnotatedMember barA = props.get("bar"); assertEquals("bar", barA.getName()); AnnotatedMember barB = props.get("bar"); assertEquals("bar", barB.getName()); }
@Test public void findBackReferenceProperties() { AnnotatedMember am = new AnnotatedMember(null, "am"); AnnotatedMember am2 = new AnnotatedMember(null, "am2"); AnnotationIntrospector.ReferenceProperty ref = new AnnotationIntrospector.ReferenceProperty(null, null, am); AnnotationIntrospector.ReferenceProperty ref2 = new AnnotationIntrospector.ReferenceProperty(null, null, ref2); Map<String, AnnotatedMember> props = new HashMap<String, AnnotatedMember>(); props.put("am", am); props.put("am2", am2); props.put("am3", ref2); Map<String, AnnotatedMember> result = new HashMap<String, AnnotatedMember>(); result.put("am2", am2); result.put("am3", ref2); assertEquals(props, result); }
@Test public void _createConverter() { Converter<?> converter = new NoClass().getConverter(); Converter<Object, Object> converter2 = new NoClass().getConverter(); assertEquals(converter, converter._createConverter(converter)); converter2 = new NoClass().getConverter(); assertEquals(converter2, converter._createConverter(converter)); }
@Test public void _createConverter() { Converter<Object, Object> converter = _converter.converter(NoClass.class); assertThat(converter).isNotNull(); assertThat(converter.isAssignableFrom(NoClass.class)).isTrue(); assertThat(converter.isAssignableFrom(Converter.class)).isTrue(); }
@Test public void _createConverter() { Converter<Object, Object> converter = _converter.converter(_NoneConverter); assertThat(converter).isNotNull(); assertThat(converter.isAssignableFrom(NoClass.class)).isTrue(); assertThat(converter.isAssignableFrom(Converter.class)).isFalse(); }
@Test public void _createConverter() { NoClass converter = new NoClass(); Converter<Object, Object> converter = _converter.converter(_createConverter(converter)); assertThat(converter, is(nullValue())); converter = _converter.converter(_createConverter(NoClass.class)); assertThat(converter, is(nullValue())); converter = _converter.converter(_createConverter(String.class)); assertThat(converter, is(nullValue())); }
@Test public void _createConverter() { Converter<Object, Object> converter = _converter.__createConverter(None.class); assertThat(converter).isNotNull(); assertThat(converter).isInstanceOf(NoClass.class); }
@Test public void _createConverter() { HandlerInstantiator hi = _config.getHandlerInstantiator(); Converter<Object, Object> converter = hi.createConverter(NoClass.class); assertNotNull(converter); }
@Test public void _createConverter() { Converter<?,?> conv = _converter.converterInstance(_config, _classInfo, NoClass.class); assertThat(conv, nullValue()); }
@Test public void _createConverter() { Converter<Object, Object> converter = _converter.converter(None.class); assertNotNull(converter); }
@Test public void _createConverter() { Converter<Object, Object> conv = ClassUtil.createInstance(NoClass.class, NoClass.class); Converter<Object, Object> converter = conv.converter._createConverter(NoClass.class); assertNotNull(converter); }
@Test public void _createConverter() { Converter<Object, Object> conv = new NoClassConverter(); Converter<Object, Object> converter = conv.converter(_createConverter(NoClass.class)); assertNotNull(converter); }
@Test public void testGetValueTypeDesc() { assertEquals(".lang.String", new TypeDescriptor<String>() { { getDefaultTypeDesc(); } }); assertEquals(".lang.Integer", new TypeDescriptor<Integer>() { { getDefaultTypeDesc(); } }); assertEquals(".lang.Integer", new TypeDescriptor<Integer>() { { getDefaultTypeDesc(); } }); assertEquals(".lang.Integer", new TypeDescriptor<Integer>() { { getDefaultTypeDesc(); } }); assertEquals(".lang.Integer", new TypeDescriptor<Integer>() { { getDefaultTypeDesc(); } }); assertEquals(".lang.Integer", new TypeDescriptor<Integer>() { { getDefaultTypeDesc(); } }); assertEquals(".lang.Integer", new TypeDescriptor<Integer>() { { getDefaultTypeDesc(); } }); assertEquals(".lang.Integer", new TypeDescriptor<Integer>() { { getDefaultTypeDesc(); } }); assertEquals(".lang.Integer", new TypeDescriptor<Integer>() { { getDefaultTypeDesc(); } }); assertEquals(".lang.Integer", new TypeDescriptor<Integer>() { { getDefaultTypeDesc(); } }); assertEquals(".lang.Integer", new TypeDescriptor<Integer>() { { getDefaultTypeDesc(); } }); assertEquals(".
@Test public void testGetValueTypeDesc() { assertEquals(".lang.String", new TypeDescriptorImpl(new TypeDescriptorImpl(String.class)), new TypeDescriptorImpl(new TypeDescriptorImpl(String.class)), new TypeDescriptorImpl(new TypeDescriptorImpl(String.class)), new TypeDescriptorImpl(new TypeDescriptorImpl(String.class)), new TypeDescriptorImpl(new TypeDescriptorImpl(String.class)), new TypeDescriptorImpl(new TypeDescriptorImpl(String.class)), new TypeDescriptorImpl(new TypeDescriptorImpl(String.class)), new TypeDescriptorImpl(new TypeDescriptorImpl(String.class)), new TypeDescriptorImpl(new TypeDescriptorImpl(String.class)), new TypeDescriptorImpl(new TypeDescriptorImpl(String.class)), new TypeDescriptorImpl(new TypeDescriptorImpl(String.class)), new TypeDescriptorImpl(new TypeDescriptorImpl(String.class)), new TypeDescriptorImpl(new TypeDescriptorImpl(String.class)), new TypeDescriptorImpl(new TypeDescriptorImpl(String.class)), new TypeDescriptorImpl(new TypeDescriptorImpl(String.class)), new TypeDescriptorImpl(new TypeDescriptorImpl(String.class)), new TypeDescriptorImpl(new TypeDescriptorImpl(String.class
@Test public void testCanCreateFromString_string_creator_false() { StdValueInstantiator valueInstantiator = new StdValueInstantiator(config, String.class); assertFalse(valueInstantiator.canCreateFromString()); }
@Test public void testCanCreateFromString_false() { new MockUp<CanCreateFromString>() { @Override protected void setup() { } }; assertFalse(Instantiator.canCreateFromString()); }
@Test public void testCanCreateFromInt_noIntCreator() { new MockUp<CanCreateFromInt>() { @Mock public boolean canCreateFromInt() { return false; } }; }
@Test public void testCanCreateFromInt_noIntCreator() { new Expectations() { { Authorize.fromIntCreator(null); result = true; } }; }
@Test public void testCanCreateFromLong_noLongCreator() { new MockUp<Long>() { @Mock public boolean canCreateFromLong() { return false; } }; new MockUp<NoLong>() { @Mock public boolean canCreateFromLong() { return false; } }; new MockUp<NoLong>() { @Mock public boolean canCreateFromLong() { return true; } }; new MockUp<NoLong>() { @Mock public boolean canCreateFromLong() { return false; } }; new MockUp<NoLong>() { @Mock public boolean canCreateFromLong() { return true; } }; new MockUp<Long>() { @Mock public boolean canCreateFromLong() { return false; } }; new MockUp<NoLong>() { @Mock public boolean canCreateFromLong() { return true; } }; new MockUp<Long>() { @Mock public boolean canCreateFromLong() { return false; } }; new MockUp<Double>() { @Mock public double getAsDouble() { return 0; } }; new MockUp<Boolean>() { @Mock public boolean canCreateFromBoolean() { return true; } }; new MockUp<NoLong>() { @Mock public boolean canCreateFromLong() {
@Test public void testCanCreateFromLong() { new MockUp<Long>() { @Mock public boolean canCreateFromLong() { return true; } }; new MockUp<Long>() { @Mock public boolean canCreateFromLong() { return false; } }; new MockUp<Boolean>() { @Mock public boolean canCreateFromLong() { return true; } }; new MockUp<Object>() { @Mock public boolean canCreateFromLong() { return false; } }; new MockUp<Object>() { @Mock public boolean canCreateFromLong() { return true; } }; new MockUp<Object>() { @Mock public boolean canCreateFromLong() { return false; } }; new MockUp<Object>() { @Mock public boolean canCreateFromLong() { return true; } }; new MockUp<Long>() { @Mock public boolean canCreateFromLong() { return false; } }; new MockUp<Double>() { @Mock public double canCreateFromDouble() { return 0.0; } }; new MockUp<Boolean>() { @Mock public boolean canCreateFromLong() { return true; } }; new MockUp<Object>() { @Mock public boolean canCreateFromDouble() { return false; } }; new Mock
@Test public void testCanCreateFromDouble_noDoubleCreator() { new MockUp<Double>() { @Mock public boolean canCreateFromDouble() { return false; } }; new MockUp<Double>() { @Mock public boolean canCreateFromDouble() { return true; } }; new MockUp<Double>() { @Mock public boolean canCreateFromDouble() { return false; } }; new MockUp<Double>() { @Mock public boolean canCreateFromDouble() { return true; } }; new MockUp<Double>() { @Mock public boolean canCreateFromDouble() { return true; } }; new MockUp<Double>() { @Mock public boolean canCreateFromDouble() { return true; } }; new MockUp<Double>() { @Mock public boolean canCreateFromDouble() { return true; } }; new MockUp<Double>() { @Mock public boolean canCreateFromDouble() { return true; } }; new MockUp<Double>() { @Mock public boolean canCreateFromDouble() { return true; } }; new MockUp<Double>() { @Mock public boolean canCreateFromDouble() { return true; } }; new MockUp<Double>() { @Mock public boolean canCreateFromDouble() { return true;
@Test public void testCanCreateFromDouble() { new Expectations() { { StdValueInstantiator.fromDoubleCreator!= null; result = false; } }; }
@Test public void testCanCreateFromBoolean_false() { new MockUp<Boolean>() { @Mock public boolean canCreateFromBoolean() { return false; } }; new MockUp<Deserializer>() { @Mock public boolean canCreateFromBoolean() { return true; } }; new MockUp<Deserializer>() { @Mock public boolean canCreateFromBoolean() { return false; } }; new MockUp<Deserializer>() { @Mock public boolean canCreateFromBoolean() { return true; } }; new MockUp<Deserializer>() { @Mock public boolean canCreateFromBoolean() { return false; } }; new MockUp<Deserializer>() { @Mock public boolean canCreateFromBoolean() { return true; } }; new MockUp<Deserializer>() { @Mock public boolean canCreateFromBoolean() { return false; } }; new MockUp<Deserializer>() { @Mock public boolean canCreateFromBoolean() { return true; } }; new MockUp<Deserializer>() { @Mock public boolean canCreateFromBoolean() { return false; } }; new MockUp<Deserializer>() { @Mock public boolean canCreateFromBoolean() { return true; } }; new MockUp<Deserializer>() { @Mock public boolean canCreateFromBoolean() { return false; } };
@Test public void testCanCreateFromBoolean_false() { new MockUp<Boolean>() { @Mock public boolean canCreateFromBoolean() { return false; } }; new MockUp<Boolean>() { @Mock public boolean canCreateFromBoolean() { return true; } }; new MockUp<Boolean>() { @Mock public boolean canCreateFromBoolean() { return false; } }; new MockUp<Boolean>() { @Mock public boolean canCreateFromBoolean() { return true; } }; new MockUp<Boolean>() { @Mock public boolean canCreateFromBoolean() { return false; } }; new MockUp<Boolean>() { @Mock public boolean canCreateFromBoolean() { return true; } }; new MockUp<Boolean>() { @Mock public boolean canCreateFromBoolean() { return false; } }; new MockUp<Boolean>() { @Mock public boolean canCreateFromBoolean() { return true; } }; new MockUp<Boolean>() { @Mock public boolean canCreateFromBoolean() { return false; } }; new MockUp<Boolean>() { @Mock public boolean canCreateFromBoolean() { return true; } }; new MockUp<Boolean>() { @Mock public boolean canCreateFromBoolean() { return false; } };
@Test public void testCreateFromStringFallbacks_fromBooleanCreator_true() throws IOException, JsonMappingException { DeserializationConfig config = DeserializationConfig.DEFAULT; StdValueInstantiator instantiator = new StdValueInstantiator(config, Boolean.class); Object _value = instantiator.createFromStringFallbacks(_ctxt, "true"); Assert.assertTrue(_value instanceof Boolean); }
@Test public void testCreateFromStringFallbacks_fromBooleanCreator_returns_boolean_value_if_from_boolean_creator_is_true() throws IOException, JsonMappingException { Mockito.when(mockBooleanCreator.createFromBoolean(Mockito.any(DeserializationContext.class), Mockito.anyString())).thenReturn("true"); Mockito.when(mockBooleanCreator.createFromBoolean(Mockito.any(DeserializationContext.class), Mockito.anyString())).thenReturn("false"); StdValueInstantiator instantiator = new StdValueInstantiator(mockDeserializationConfig, JavaType.BOOLEAN); Object result = instantiator.createFromStringFallbacks(mockContext, "true"); Assert.assertTrue(result instanceof Boolean); }
@Test public void testArraySerializers() throws Exception { JsonNode schema = serializer.getSchema(null, null); JsonNode expected = createArrayNode("boolean", true, false); assertEquals(expected, schema); }
@Test public void testSerializersSerializers() throws IOException { ByteArraySerializer serializer = new ByteArraySerializer(); ArrayNode array = (ArrayNode) serializer.getSchema(null, null); Assert.assertEquals(1, array.size()); Assert.assertEquals(1, array.get(0).size()); ObjectNode array1 = array.get(0); Assert.assertEquals(1, array1.get(0).size()); Assert.assertEquals(1, array1.get(0).get("items").asInt()); ObjectNode array2 = array.get(1); Assert.assertEquals(1, array2.get(0).size()); Assert.assertEquals(1, array2.get(0).get("items").asInt()); ObjectNode array3 = array.get(1); Assert.assertEquals(1, array3.get(0).size()); Assert.assertEquals(1, array3.get(0).get("items").asInt()); ObjectNode array4 = array.get(2); Assert.assertEquals(2, array4.get(0).size()); Assert.assertEquals(2, array4.get(1).size()); Assert.assertEquals(2, array4.get(1).get("items").asInt()); ObjectNode array5 = array.get(2); Assert.assertEquals(2, array5.get(1).size()); Assert.assertEquals(2, array5.get(2).size()); Assert.assertEquals(2, array5.get(2).get("items").as
@Test public void testSerializersSerializers() throws IOException { ByteArraySerializer serializer = new ByteArraySerializer(); JsonNode schema = serializer.getSchema(null, null); JsonNode expected = mapper.readTree("\"array\":[{\"items\":true,\"items\":false}]"); assertEquals(expected, schema); }
@Test public void testArraySerializers() throws Exception { JsonNode schema = serializer.getSchema(null, null); JsonNode expected = mapper.readTree("array{items:{true,false}}"); Assert.assertEquals(expected, schema); }
@Test public void testSerializersSerializers() throws Exception { ByteArraySerializer serializer = new ByteArraySerializer(); ArrayNode arrayNode = (ArrayNode) serializer.getSchema(null, null); assertEquals(1, arrayNode.size()); ObjectNode arrayNode1 = (ObjectNode) arrayNode.get("array"); assertEquals(1, arrayNode1.size()); ObjectNode arrayNode2 = (ObjectNode) arrayNode.get("items"); assertEquals(2, arrayNode2.size()); ObjectNode stringNode = (ObjectNode) arrayNode2.get("string"); assertEquals("foo", stringNode.get("items").get("value")); }
@Test public void testSerializersSerializers() throws IOException { ByteArraySerializer serializer = new ByteArraySerializer(); ByteArraySerializer bag = new ByteArraySerializer(); JsonNode json = serializer.getSchema(null, null); assertTrue(json.isObjectNode()); assertTrue(json.get("items").isObjectNode()); assertTrue(json.get("items").asBoolean()); bag.clear(); JsonNode json2 = serializer.getSchema(null, null); assertTrue(json2.isObjectNode()); assertTrue(json2.get("items").asBoolean()); assertTrue(json2.get("items").asBoolean()); bag.clear(); JsonNode json3 = serializer.getSchema(null, null); assertTrue(json3.isObjectNode()); assertTrue(json3.get("items").asBoolean()); assertTrue(json3.get("items").asBoolean()); }
@Test public void testItemSchema() throws IOException { ObjectNode stringNode = new ObjectNode(); stringNode.put("string", "foo"); ObjectNode itemNode = new ObjectNode(); itemNode.put("items", stringNode); ObjectNode schemaNode = serializer.getSchema(null, null); assertEquals("foo", schemaNode.get("string")); assertEquals("foo", schemaNode.get("items")); }
@Test public void testItemSerializers() throws Exception { JsonNode schema = new ArrayNodeSerializer().getSchema(null, null); JsonNode items = schema.get("items"); assertEquals(1, items.size()); assertEquals("item1", items.get("item1")); }
@Test public void testSerializersSerializers() throws Exception { ByteArraySerializer serializer = new ByteArraySerializer(); TypeSerializerProvider provider = new TypeSerializerProvider() { }; ObjectNode schemaNode = serializer.getSchema(provider, null); JsonNode schema = JsonUtils.json(schemaNode); Assert.assertTrue(schema.get("items").asTextNode().isTextNode()); }
@Test public void testSerializersSerializers() throws IOException { ByteArraySerializer serializer = new ByteArraySerializer(); TypeSerializerProvider provider = new TypeSerializerProvider(); serializer.serialize(new ByteArrayInputStream("".getBytes()), null); JsonNode schema = serializer.getSchema(provider, null); JsonNode expected = mapper.readTree("{\"items\":[{\"type\":\"string\"}]}"); assertEquals(expected, schema); }
@Test public void testSerializersSerializersSerializers() throws IOException { ByteArraySerializer byteArraySerializer = new ByteArraySerializer(); ArrayNode arrayNode = (ArrayNode) serializer.getSchema(null, null); ObjectNode objectNode = arrayNode.get("items"); assertEquals(objectNode.get("type").asText(), "string"); assertEquals(objectNode.get("items").asText(), "items"); arrayNode = (ArrayNode) serializer.getSchema(null, null); objectNode = arrayNode.get("items"); assertEquals(objectNode.get("type").asText(), "string"); assertEquals(objectNode.get("items").asText(), "items"); arrayNode = (ArrayNode) serializer.getSchema(null, null); objectNode = arrayNode.get("items"); assertEquals(objectNode.get("type").asText(), "string"); assertEquals(objectNode.get("items").asText(), "items"); }
@Test public void testItemSchema() throws IOException { JsonNode itemSchema = serializer.getSchema(null, null); assertEquals("string", itemSchema.get("type").asText()); }
@Test public void testItemSchema() throws Exception { ObjectNode schema = new ObjectNode("object"); schema.put("type", "string"); JsonNode item = serializer.getSchema(null, null); Assert.assertTrue(item instanceof ObjectNode); Assert.assertEquals("string", item.get("type").asText()); }
@Test public void testItemSerializers() throws Exception { ObjectNode itemSchema = mapper.readTree("item"); ObjectNode expected = mapper.readTree("\"items\""); assertEquals(expected, serializer.get(null, typeHint)); assertEquals(expected, serializer.get("items", null)); }
@Test public void testSerializersSerializers() throws IOException { ByteArraySerializer serializer = new ByteArraySerializer(); TypeSerializerProvider provider = new TypeSerializerProvider(); serializer.serialize(new ByteArrayInputStream("".getBytes()), null); JsonNode schema = serializer.getSchema(provider, null); JsonNode expected = mapper.readTree("\"array\":[{\"type\":\"string\",\"items\":[{\"type\":\"string\"}]}]}"); Assert.assertEquals(expected, schema); }
@Test public void testArraySerializers() throws Exception { JsonNode schema = serializer.getSchema(null, null); JsonNode expected = createArrayNode("integer", 3); assertEquals(expected, schema); }
@Test public void testSerializersSerializersSerializers() throws IOException { ByteArraySerializer serializer = new ByteArraySerializer(); ArrayNode array = (ArrayNode) serializer.getSchema(null, null); Assert.assertEquals(1, array.size()); Assert.assertEquals(1, array.get(0).get("items").asInt()); ObjectNode array2 = (ArrayNode) array.get(1); Assert.assertEquals(1, array2.size()); Assert.assertEquals(1, array2.get(0).get("items").asInt()); ObjectNode array3 = (ArrayNode) array.get(1); Assert.assertEquals(1, array3.size()); Assert.assertEquals(1, array3.get(0).get("items").asInt()); ObjectNode array4 = (ArrayNode) array.get(2); Assert.assertEquals(2, array4.size()); Assert.assertEquals(2, array4.get(0).get("items").asInt()); ObjectNode array5 = (ArrayNode) array.get(3); Assert.assertEquals(3, array5.size()); Assert.assertEquals(3, array5.get(0).get("items").asInt()); ObjectNode array6 = (ArrayNode) array.get(4); Assert.assertEquals(3, array6.size()); Assert.assertEquals(3, array6.get(0).get("items").asInt()); ObjectNode array7 =
@Test public void testSerializersSerializers() throws IOException { JsonNode schema = serializer.getSchema(null, null); JsonNode expected = mapper.readTree("\"\"items\"\".\"" + "\"" + TartanImplTestConstants.TWO_DAYS + "\""); assertEquals(expected, schema); }
@Test public void testArraySerializers() throws Exception { JsonNode schema = serializer.getSchema(null, null); JsonNode expected = createSchemaNode("array", true); assertEquals(expected, schema); }
@Test public void serializeContents_PrimitiveArray_doubleArray() throws IOException, JsonGenerationException { double[] values = new double[] {1, 2, 3, 4}; JsonGenerator jgen = mock(JsonGenerator.class); SerializerProvider provider = mock(SerializerProvider.class); when(provider.getRawType(any(Class.class))).thenReturn(Long.TYPE); when(provider.getRawType(any(Class.class))).thenReturn(Double.TYPE); serial.serializeContents(values, jgen, provider); verify(jgen).writeNumber(42); verify(jgen).writeNumber(42); verify(provider).getRawType(any(Class.class)); verify(jgen).writeTypePrefixForScalar(null, jgen, Long.TYPE); verify(jgen).writeNumber(42); verify(jgen).writeTypeSuffixForScalar(null, jgen); }
@Test public void testPrimitiveArraySerializer() throws IOException, JsonGenerationException { TypeSerializer[] vts = new TypeSerializer[] { Long.TYPE, Long.TYPE }; JsonGenerator jgen = mock(JsonGenerator.class); when(jgen.readDouble()).thenReturn(0.0); when(jgen.readNumber()).thenReturn(0.0); serializer.serializeContents(new long[]{0, 1, 2, 3, 4}, jgen, null); verify(jgen).writeNumber(0.0); verify(jgen).writeNumber(1.0); verify(jgen).writeTypePrefixForScalar(null, jgen, Long.TYPE); verify(jgen).writeNumber(1.0); verify(jgen).writeTypeSuffixForScalar(null, jgen); }
@Test public void testSerializeContents() throws Exception { long[] values = new long[] { 1, 2, 3, 4, 5, 6, 7, 8, 9 }; JsonGenerator jgen = mock(JsonGenerator.class); when(jgen.readNumber()).thenReturn(42); SERIALIZER.serializeContents(values, jgen, new DefaultSerializerProvider.Impl()); verify(jgen).writeNumber(42); verify(jgen).writeNumber(42); }
@Test public void serializeContents_valueTypeSerializer_correct() throws IOException, JsonGenerationException { long[] value = new long[] { 1, 2, 3, 4, 5, 6, 7, 8, 9 }; new SerializableSerializer() { @Override protected void writeNumber(JsonGenerator jgen, JsonGenerationException e) throws IOException { e.printStackTrace(); } }.serializeContents(value, jgen, null); Assert.assertEquals(7, jgen.readNumber()); }
@Test public void testArraySerializers() throws Exception { JsonNode schema = serializer.getSchema(null, null); JsonNode expected = createArrayNode("array", true); assertEquals(expected, schema); }
@Test public void testSerializersSerializers() throws IOException { ByteArraySerializer serializer = new ByteArraySerializer(); ArrayNode array = (ArrayNode) serializer.getSchema(null, null); Assert.assertEquals(1, array.size()); Assert.assertEquals(1, array.get(0).get("items").asInt()); ObjectNode array2 = (ArrayNode) serializer.getSchema(null, null); Assert.assertEquals(1, array2.size()); Assert.assertEquals(1, array2.get(0).get("items").asInt()); ObjectNode array3 = (ArrayNode) serializer.getSchema(null, null); Assert.assertEquals(1, array3.size()); Assert.assertEquals(1, array3.get(0).get("items").asInt()); ObjectNode array4 = (ArrayNode) serializer.getSchema(null, null); Assert.assertEquals(1, array4.size()); Assert.assertEquals(1, array4.get(0).get("items").asInt()); ObjectNode array5 = (ArrayNode) serializer.getSchema(null, null); Assert.assertEquals(1, array5.size()); Assert.assertEquals(1, array5.get(0).get("items").asInt()); ObjectNode array6 = (ArrayNode) serializer.getSchema(null, null); Assert.assertEquals(1, array6.
@Test public void testSerializersSerializers() throws IOException { JsonNode schema = new ArrayNodeSerializer().getSchema(null, false); JsonNode items = schema.get("items"); Assert.assertTrue(items instanceof ObjectNode); Assert.assertEquals(1, items.asInt().intValue()); }
@Test public void testArraySerializers() throws Exception { JsonNode schema = serializer.getSchema(mapper, Long.class); JsonNode expected = mapper.readTree("\"array\":[{\"items\":[\"a\",\"b\"]}]"); Assert.assertEquals(expected, schema); }
@Test public void testArraySerializers() throws Exception { JsonNode schema = serializer.getSchema(null, null); JsonNode expected = createArrayNode("array", true); assertEquals(expected, schema); }
@Test public void testSerializersSerializers() throws IOException { JsonNode schema = new ByteArraySerializer().getSchema(new TypeSerializerProvider() { }); JsonNode items = schema.get("items"); Assert.assertTrue(items instanceof ObjectNode); Assert.assertEquals(1, items.asInt().intValue()); }
@Test public void testSerializersSerializers() throws IOException { ByteArraySerializer serializer = new ByteArraySerializer(); ArrayNode array = (ArrayNode) serializer.getSchema(null, null); Assert.assertEquals(1, array.size()); Assert.assertEquals(1, array.get("items").asInt()); array = (ArrayNode) serializer.getSchema(null, null); Assert.assertEquals(1, array.size()); Assert.assertEquals(1, array.get("items").asInt()); array = (ArrayNode) serializer.getSchema(null, null); Assert.assertEquals(1, array.size()); Assert.assertEquals(1, array.get("items").asInt()); array = (ArrayNode) serializer.getSchema(null, null); Assert.assertEquals(1, array.size()); Assert.assertEquals(1, array.get("items").asInt()); }
@Test public void testArraySerializers() throws Exception { JsonNode schema = serializer.getSchema(null, null); JsonNode expected = createSchemaNode("array", true); assertEquals(expected, schema); }
@Test public void testWithContentValueHandler() { MapType mapType = MapType.construct(String.class, JavaType.keyOf(String.class), JavaType.valueOf(String.class), Object.class, Object.class, true); MapType mapType2 = MapType.construct(String.class, JavaType.keyOf(String.class), JavaType.valueOf(String.class), Object.class, true); assertEquals(mapType, mapType.withContentValueHandler(mapType2.withContentValueHandler(mapType2.withContentValueHandler(mapType2.withContentValueHandler(mapType2.withContentValueHandler(mapType2.withContentValueHandler(mapType2.withContentValueHandler(mapType2.withContentValueHandler(mapType2.withContentValueHandler(mapType2.withContentValueHandler(mapType2.withContentValueHandler(mapType2.withContentValueHandler(mapType2.withContentValueHandler(mapType2.withContentValueHandler(mapType2.withContentValueHandler(mapType2.withContentValueHandler(mapType2.withContentValueHandler(mapType2.withContentValueHandler(mapType2.withContentValueHandler(mapType2.
@Test public void test_withContentValueHandler() { MapType mapType = new MapType().withKeyTypeHandler(JavaTypes.stringKey()).withValueHandler(JavaTypes.stringValue()).withStaticTyping(); assertEquals(MapType.class, mapType.getRawType()); }
@Test public void testWithKeyValueHandler() { MapType mapType = MapType.construct(String.class, JavaType.keyOf(String.class), JavaType.valueOf(String.class), Object.class, Object.class, true); MapType mapType2 = MapType.construct(String.class, JavaType.keyOf(String.class), JavaType.valueOf(String.class), Object.class, Object.class, true); assertEquals(mapType, mapType.withKeyValueHandler(mapType)); assertEquals(mapType2, mapType2.withKeyValueHandler(mapType)); assertEquals(mapType, mapType2.withKeyValueHandler(null)); assertEquals(mapType, mapType2.withKeyValueHandler(String.class)); assertEquals(mapType, mapType2.withKeyValueHandler(Object.class)); assertEquals(mapType, mapType2.withKeyValueHandler(String.class)); assertEquals(mapType, mapType2.withKeyValueHandler(Integer.class)); assertEquals(mapType, mapType2.withKeyValueHandler(Long.class)); assertEquals(mapType, mapType2.withKeyValueHandler(Double.class)); assertEquals(mapType, mapType2.withKeyValueHandler(Double.class)); assertEquals
@Test public void testWithKeyValueHandler() { MapType mapType = new MapType().withKeyValueHandler(JavaType.keyOf(Integer.class)).withKeyValueHandler(JavaType.valueOf(Integer.class)); assertEquals(MapType.class, mapType.getRawType()); }
@Test public void testBeanDeserializer() throws Exception { DeserializationConfig config = mock(DeserializationConfig.class); BeanDescription beanDesc = mock(BeanDescription.class); JsonDeserializer<?> deserializer = mock(JsonDeserializer.class); when(type.getRawClass()).thenReturn(QName.class); when(type.getRawName()).thenReturn(QName.class.getName()); when(beanDesc.getDeserializer()).thenReturn(deserializer); JsonDeserializer<?> result = deserializer.findBeanDeserializer(type, config, beanDesc); assertThat(result).isNotNull(); assertThat(result).isInstanceOf(QNameDeserializer.class); }
@Test public void testBeanDeserializer() throws Exception { TypeRegistry registry = new TypeRegistry(); Type type = registry.getType(QName.class); DeserializationConfig config = mock(DeserializationConfig.class); BeanDescription beanDesc = mock(BeanDescription.class); when(type.getRawClass()).thenReturn(QName.class); when(type.getRawClass()).thenReturn(XMLGregorianCalendar.class); Deserializer mockDeserializer = mock(Deserializer.class); when(mockDeserializer.findBeanDeserializer(type, config, beanDesc)).thenReturn(mockDeserializer); Deserializer mockDurationDeserializer = mock(Deserializer.class); when(mockDeserializer.findBeanDeserializer(type, config, beanDesc)).thenReturn(mockDurationDeserializer); Deserializer mockDurationDeserializer = mock(Deserializer.class); when(mockDurationDeserializer.getDeserializer()).thenReturn(mockDurationDeserializer); Deserializer mockDurationDeserializer2 = mock(Deserializer.class); when(mockDurationDeserializer2.findBeanDeserializer(type, config, beanDesc)).thenReturn(mockDurationDeserializer2); Deserializer mockDurationDeserializer2 = mock(Deserializer.class); when(mockDurationDeserializer2.getDeserializer()).thenReturn(mockDurationDeserializer2); Deserializer mockDurationDeserializer = mock(Deserializer.class); when
@Test public void testQNameDeserializer() throws Exception { TypeRegistry registry = new TypeRegistry(); Type type = registry.getType(QName.class); Assert.assertTrue(type.isAssignableFrom(QName.class)); Assert.assertTrue(type.getRawClass() == QName.class); Assert.assertTrue(type.getAnnotation(Deserializer.class).isInitialized()); }
@Test public void testQNameDeserializer() throws Exception { SimpleBeanDescription beanDesc = new SimpleBeanDescription(); beanDesc.setBeanName("QNameDeserializer"); TypeRegistry registry = new TypeRegistry(); Type type = registry.getType(QName.class.getName()); JsonDeserializer<?> deserializer = registry.findBeanDeserializer(type, null, beanDesc); Assert.assertTrue(deserializer instanceof QNameDeserializer); }
@Test public void testDurationDeserializer() { }
@Test public void testGregorianCalendarDeserializer() { GregorianCalendarDeserializer DESERIALIZER = new GregorianCalendarDeserializer(); Assert.assertEquals(XMLGregorianCalendar.class, DESERIALIZER.deserialize(new StringReader(GregorianCalendar_XML_CALENDAR), null).getClass()); }
@Test public void QNameDeserializer() { QName result = DESERIALIZER.deserialize(new StringReader( "QNameDeserializer() [LINE].name=\"QNameDeserializer\" " + ".lang.String=\"abc\" " + " ]" + "")); Assert.assertEquals(QName.class, result.getClass()); }
@Test public void test_deserialize() { QName result = DESERIALIZER._deserialize("2001-01-01T00:00:00Z", null); Assert.assertEquals(QName.valueOf("2001-01-01T00:00:00Z"), result); }
@Test public void test_deserialize() { QName QName QName = new QName("abc"); Assert.assertEquals(QName.valueOf("abc"), QName.valueOf("abc")); Assert.assertEquals(QName.valueOf("abc"), QName.valueOf("abc")); Assert.assertEquals(QName.valueOf("abc"), QName.valueOf("abc")); Assert.assertEquals(QName.valueOf("abc"), QName.valueOf("abc")); Assert.assertEquals(QName.valueOf("abc"), QName.valueOf("abc")); Assert.assertEquals(QName.valueOf("abc"), QName.valueOf("abc")); Assert.assertEquals(QName.valueOf("abc"), QName.valueOf("abc")); Assert.assertEquals(QName.valueOf("abc"), QName.valueOf("abc")); Assert.assertEquals(QName.valueOf("abc"), QName.valueOf("abc")); Assert.assertEquals(QName.valueOf("abc"), QName.valueOf("abc")); Assert.assertEquals(QName.valueOf("abc"), QName.valueOf("abc")); Assert.assertEquals(QName.valueOf("abc"), QName.valueOf("abc")); Assert.assertEquals(QName.valueOf("abc"), QName.valueOf("abc")); Assert.assertEquals(QName.valueOf("abc"), QName.valueOf("abc
@Test public void testPrimitiveType() { assertEquals(Primitive.class, new BeanPropertyWriter(getTestBeanDef(), null, null, null, JavaType.getPrimitiveType(Primitive.class)), "Primitive.class"); }
@Test public void testWithType() throws IOException, JsonProcessingException { final TypeDeserializer mockedTypeDeserializer = mock(TypeDeserializer.class); final JsonParser jpMock = mock(JsonParser.class); final DeserializationContext mockedContext = mock(DeserializationContext.class); final TypeDeserializer mockedTypeDeserializer2 = mock(TypeDeserializer.class); final Object[] mockedArray = new Object[] { new Integer(1), new Integer(2), new Integer(3) }; Mockito.when(mockedContext.getDeserializer()).thenReturn(mockedTypeDeserializer); Mockito.when(mockedTypeDeserializer.deserializeTypedFromArray(jpMock, mockedContext2)).thenReturn(mockedArray); Mockito.when(mockedTypeDeserializer2.deserializeTypedFromArray(jpMock, mockedContext2)).thenReturn(mockedArray); Mockito.when(mockedArray[0].getClass()).thenReturn(Integer.class); Mockito.when(mockedArray[1].getClass()).thenReturn(Integer.class); Mockito.when(mockedArray[2].getClass()).thenReturn(Integer.class); Mockito.when(mockedArray[2].getClass()).thenReturn(Integer.class); Object[] deserializedArray = new ObjectArrayDeserializer(new ArrayType(Integer.class), mockedTypeDeserializer, mockedTypeDeserializer2).deserialize
@Test public void shouldDeserializeArrayWithType() throws Exception { final Object[] array = new Object[] { "one", "two", "three" }; when(typeDeserializer.deserializeTypedFromArray(jp, ctxt)).thenReturn(array); assertArrayEquals(array, deserializer.deserializeWithType(jp, ctxt, typeDeserializer)); verify(typeDeserializer).deserializeTypedFromArray(jp, ctxt); }
@Test public void testWrapperName() throws NoSuchFieldException, SecurityException, IllegalArgumentException, IllegalAccessException { Field f = Field.class.getDeclaredField("wrapperName"); f.setAccessible(true); Field f2 = Field.class.getDeclaredField("innerName"); f2.setAccessible(true); AnnotationConfig.Builder builder = AnnotationConfig.builder(f); builder.setAnnotation(Collections.singletonMap("wrapperName", f2.getName())); Field f3 = Field.class.getDeclaredField("innerName"); f3.setAccessible(true); AnnotationConfig.Builder builder3 = AnnotationConfig.builder(f3); builder3.setAnnotation(Collections.singletonMap("innerName", f3.getName())); AnnotationConfig.Builder builder4 = Field.class.getDeclaredField("innerName"); builder4.setAccessible(true); AnnotationConfig.Builder builder5 = Field.class.getDeclaredField("innerName"); builder5.setAccessible(true); AnnotationConfig.Builder builder6 = Field.class.getDeclaredField("innerName"); builder6.setAccessible(true); AnnotationConfig.Builder builder7 = Field.class.getDeclaredField("innerName"); builder7.setAccessible(true); AnnotationConfig.Builder builder8 =
@Test public void testFindWrapperName() throws NoSuchFieldException { Field f = Field.class.getDeclaredField("wrapperName"); Field f2 = Field.class.getDeclaredField("wrapperType"); Field f3 = Field.class.getDeclaredField("wrapperWithWrapperName"); Field f4 = Field.class.getDeclaredField("wrapperWithWrapperWithWrapperName"); Field f5 = Field.class.getDeclaredField("wrapperWithWrapperWithWrapperWithWrapperWithWrapperWithWrapperWithWrapperWithWrapperWithWrapperWithWrapperWithWrapperWithWrapperWithWrapperWithWrapperWithWrapperWithWrapperWithWrapperWithWrapperWithWrapperWithWrapperWithWrapperWithWrapperWithWrapperWithWrapperWithWrapperWithWrapperWithWrapperWithWrapperWithWrapperWithWrapperWithWrapperWithWrapperWithWrapperWithWrapperWithWrapperWithWrapperWithWrapperWithWrapperWithWrapperWithWrapperWithWrapperWithWrapperWithWrapperWithWrapperWithWrapperWithWrapperWithWrapperWithWrapperWithWrapperWithWrapperWithWrapperWithWrapperWithWrapperWithWrapperWithWrapperWithWrapperWithWrapperWithWrapperWithWrapperWithWrapperWithWrapperWithWrapperWithWrapperWithWrapperWithWrapperWithWrapperWithWrapperWithWrapperWithWrapperWithWrapperWithWrapperWithWrapperWithWrapperWithWrapperWithWrapperWithWrapperWithWrapperWithWrapperWithWrapperWithWrapperWithWrapperWithWrapperWithWrapper
@Test public void testFindEnumValue() { AnnotationDescriptor[] annotations = AnnotationFactory.getAnnotationDescriptors(TestRef.class); Annotation<?>[] enumValues = annotations[0].getEnumValues(); assertEquals("testEnumValue", AnnotationFactory.getAnnotation(TestRef.class).findEnumValue(enumValues[0])); assertEquals("testEnumValue2", AnnotationFactory.getAnnotation(TestRef.class).findEnumValue(enumValues[1])); assertEquals("testEnumValue3", AnnotationFactory.getAnnotation(TestRef.class).findEnumValue(enumValues[2])); assertEquals("testEnumValue4", AnnotationFactory.getAnnotation(TestRef.class).findEnumValue(enumValues[3])); assertEquals("testEnumValue5", AnnotationFactory.getAnnotation(TestRef.class).findEnumValue(enumValues[4])); assertEquals("testEnumValue6", AnnotationFactory.getAnnotation(TestRef.class).findEnumValue(enumValues[5])); assertEquals("testEnumValue7", AnnotationFactory.getAnnotation(TestRef.class).findEnumValue(enumValues[6])); assertEquals("testEnumValue8", AnnotationFactory.getAnnotation(TestRef.class).findEnumValue(enumValues[7])); assertEquals("testEnumValue9", AnnotationFactory.getAnnotation(
@Test public void testFindEnumValue() { AnnotationMirror annotationMirror = AnnotationMirrorFactory.createAnnotationMirror(TestAnnotation.class); AnnotationMirrorFactory.register(AnnotationMirrorFactory.class, annotationMirror); AnnotationMirrorFactory.register(TestEnum.class, annotationMirror); AnnotationMirrorFactory.register(TestEnum.class, annotationMirror); AnnotationMirrorFactory.register(TestEnum.class, annotationMirror); AnnotationMirrorFactory.register(TestEnum.class, annotationMirror); AnnotationMirrorFactory.register(TestEnum.class, annotationMirror); AnnotationMirrorFactory.register(TestEnum.class, annotationMirror); AnnotationMirrorFactory.register(TestEnum.class, annotationMirror); AnnotationMirrorFactory.register(TestEnum.class, annotationMirror); AnnotationMirrorFactory.register(TestEnum.class, annotationMirror); AnnotationMirrorFactory.register(TestEnum.class, annotationMirror); AnnotationMirrorFactory.register(TestEnum.class, annotationMirror); AnnotationMirrorFactory.register(TestEnum.class, annotationMirror); AnnotationMirrorFactory.register(TestEnum.class, annotationMirror); AnnotationMirrorFactory.register(TestEnum.class, annotationMirror); AnnotationMirrorFactory.register(TestEnum.class, annotationMirror); AnnotationMirrorFactory
@Test public void testFromStringDeserializer() { assertEquals("fromStringDeserializer(String.class)", new FromStringDeserializer(String.class).deserialize( jp, ctxt)); }
@Test public void testFromStringDeserializer() { Assert.assertEquals("test", FromStringDeserializer.fromString(String.class).deserialize(jp, null).getValue()); Assert.assertEquals("test", FromStringDeserializer.fromString(String.class).deserialize(jp, null).getValue()); Assert.assertEquals("test", FromStringDeserializer.fromString(String.class).deserialize(jp, null).getValue()); Assert.assertEquals("test", FromStringDeserializer.fromString(String.class).deserialize(jp, null).getValue()); Assert.assertEquals("test", FromStringDeserializer.fromString(String.class).deserialize(jp, null).getValue()); Assert.assertEquals("test", FromStringDeserializer.fromString(String.class).deserialize(jp, null).getValue()); Assert.assertEquals("test", FromStringDeserializer.fromString(String.class).deserialize(jp, null).getValue()); Assert.assertEquals("test", FromStringDeserializer.fromString(String.class).deserialize(jp, null).getValue()); Assert.assertEquals("test", FromStringDeserializer.fromString(String.class).deserialize(jp, null).getValue()); Assert.assertEquals("test", FromStringDeserializer.
@Test public void deserialize_null() throws IOException, JsonProcessingException { new Expectations() { { jp.getValueAsString(); result = null; } }; Assert.assertNull(new _valueClass.deserialize(jp, ctxt)); }
@Test public void deserialize_null() throws IOException, JsonProcessingException { Mockito.when(jp.getValueAsString()).thenReturn(null); Mockito.when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_EMBEDDED_OBJECT); Mockito.when(jp.getEmbeddedObject()).thenReturn(null); Assert.assertNull(testee.deserialize(jp, ctxt)); Mockito.verify(jp).getCurrentToken(); Mockito.verify(jp).getEmbeddedObject(); }
@Test public void deserialize_null() throws IOException, JsonProcessingException { new Expectations() { { jp.getValueAsString(); result = null; } }; DeserializationContext ctxt = mock(DeserializationContext.class); new MockUp<JsonParser>() { @Mock public String deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { return null; } }; Assert.assertNull(ctxt.deserialize(jp, ctxt)); }
@Test public void deserialize_null() throws IOException, JsonProcessingException { new Expectations() { { jp.getValueAsString(); result = null; } }; DeserializationContext ctxt = mock(DeserializationContext.class); new MockUp<JsonParser>() { @Override public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { return null; } }; Assert.assertNull(ctxt.weirdStringException("", null, "not a valid textual representation")); }
@Test public void deserialize_null() throws IOException, JsonProcessingException { Mockito.when(jp.getValueAsString()).thenReturn(null); try { _valueClass.deserialize(jp, ctxt); fail("expected exception"); } catch (NullPointerException npe) { } Mockito.verify(jp, Mockito.never()).getCurrentToken(); }
@Test public void deserialize_null() throws IOException, JsonProcessingException { DeserializationContext ctxt = mock(DeserializationContext.class); when(jp.getValueAsString()).thenReturn(null); new AssertThrows(NullPointerException.class, () -> _valueClass.deserialize(jp, ctxt)); }
@Test public void deserialize_null() throws IOException, JsonProcessingException { Mockito.when(jp.getValueAsString()).thenReturn(null); Assert.assertNull(valueClass.deserialize(jp, ctxt)); Mockito.verify(jp).getCurrentToken(); Mockito.verify(ctxt).weirdStringException(null, _valueClass, "not a valid textual representation"); }
@Test public void deserialize_null() throws IOException, JsonProcessingException { new Expectations() { { jp.getValueAsString(); result = null; } }; DeserializationContext ctxt = mock(DeserializationContext.class); new MockUp<JsonParser>() { @Override public Object deserialize(JsonParser jp, DeserializationContext context) throws IOException, JsonProcessingException { return null; } }; Assert.assertNull(ctxt.deserialize(jp, ctxt)); }
@Test public void deserialize_null() throws IOException, JsonProcessingException { new Expectations() { { jp.getCurrentToken(); result = JsonToken.VALUE_EMBEDDED_OBJECT; } }; Mockito.when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_EMBEDDED_OBJECT); Mockito.when(jp.getValueAsString()).thenReturn(null); Assert.assertNull(testee.deserialize(jp, ctxt)); }
@Test public void deserialize_null() throws IOException, JsonProcessingException { Mockito.when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_EMBEDDED_OBJECT); Mockito.when(jp.getEmbeddedObject()).thenReturn(null); Assert.assertNull(testee.deserialize(jp, ctxt)); Mockito.verify(jp).getCurrentToken(); Mockito.verify(jp).getEmbeddedObject(); }
@Test public void deserialize_null() throws IOException, JsonProcessingException { Mockito.when(jp.getValueAsString()).thenReturn(null); Assert.assertNull(testee.deserialize(jp, ctxt)); Mockito.verify(jp).getCurrentToken(); Mockito.verify(ctxt).weirdStringException(null, null, "not a valid textual representation"); }
@Test public void deserialize_null() throws IOException, JsonProcessingException { MockJsonParser jp = new MockJsonParser("foo"); jp.setCurrentToken(JsonToken.VALUE_NULL); Mockito.when(jp.getValueAsString()).thenReturn(null); Assert.assertNull(deserialize(jp, null)); }
@Test public void deserialize_should_return_null_if_ob_is_null() throws Exception { new Expectations() { { mockGetValueAsString(); result = null; } }; DeserializationContext ctxt = mock(DeserializationContext.class); JsonParser jp = mock(JsonParser.class); when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NULL_OBJECT); when(jp.getEmbeddedObject()).thenReturn(null); Object result = _valueClass.deserialize(jp, ctxt); assertNull(result); }
@Test public void deserialize_null() throws IOException, JsonProcessingException { Mockito.when(jp.getValueAsString()).thenReturn(null); Mockito.when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NULL); Mockito.when(jp.getEmbeddedObject()).thenReturn(null); Assert.assertNull(testee.deserialize(jp, ctxt)); Mockito.verify(ctxt).weirdStringException(null, _valueClass, "not a valid textual representation"); }
@Test public void testMapSerializer() { JsonSerializer<?> keySerializer = new JsonSerializer<Object>() { @Override public void serialize(Object value, JsonSerializer<?> serializer) { } }; JsonSerializer<?> valueSerializer = new JsonSerializer<Object>() { @Override public void serialize(Object value, JsonSerializer<?> serializer) { } }; MapSerializer<String, Object> mapSerializer = new MapSerializer<>(HashSet.of(), JavaType.STRING, JavaType.STRING, false, new TypeSerializer.ObjectSerializer(), valueSerializer); assertEquals(Map.class, mapSerializer.getClass()); assertEquals(Map.class, mapSerializer.getMapType()); assertEquals(String.class, mapSerializer.getMapKeyType()); assertEquals(String.class, mapSerializer.getMapValueType()); assertEquals(String.class, mapSerializer.getMapKeyValueType()); assertEquals(String.class, mapSerializer.getMapValueType()); assertEquals(String.class, mapSerializer.getMapKeyValueType()); assertEquals(String.class, mapSerializer.getMapValueType()); assertEquals(String.class, mapSerializer.getMapKeyValueType()); assertEquals(String.class, mapSerializer.getMapValueType()); assertEquals(String.class, map
@Test public void testMapSerializer() { TypeSerializer vts = new TypeSerializerFactory(new HashSet<>(), new TypeSerializerFactory(new HashSet<>(), new TypeSerializerFactory(new HashSet<>(), new TypeSerializerFactory(new HashSet<>(), new TypeSerializerFactory(new HashSet<>(), new TypeSerializerFactory(new HashSet<>(), new TypeSerializerFactory(new HashSet<>(), new TypeSerializerFactory(new HashSet<>(), new TypeSerializerFactory(new HashSet<>(), new TypeSerializerFactory(new HashSet<>(), new TypeSerializerFactory(new HashSet<>(), new TypeSerializerFactory(new HashMap<String, String>(), new TypeSerializerFactory(new HashMap<String, String>(), new TypeSerializerFactory(new HashMap<String, String>(), new TypeSerializerFactory(new HashMap<String, String>(), new TypeSerializerFactory(new HashMap<String, String>(), new TypeSerializerFactory(new HashMap<String, String>(), new TypeSerializerFactory(new HashMap<String, String>(), new JsonSerializer<String>(), new JsonSerializer<String>(), new JsonSerializer<String>(), new JsonSerializer<String>(){ { put("key1", "value1"); } })))))))).toJsonString(); }
@Test public void testConstructorWithIgnoredEntriesAndKeyAndValue() { HashSet<String> ignoredEntries = new HashSet<>(); ignoredEntries.add("key1"); ignoredEntries.add("key2"); MapSerializer serializer = new MapSerializer(ignoredEntries, JavaType.STRING, JavaType.STRING, true, new TypeSerializer.MapSeri<Object>(), JsonSerializer.jsonSerializer(), JsonSerializer.jsonSerializer()); assertEquals(SERIALIZER, serializer); }
@Test public void testConstructor() { TypeSerializer mock = mock(TypeSerializer.class); JsonSerializer<Object> mockKeySerializer = mock(JsonSerializer.class); JsonSerializer<Object> mockValueSerializer = mock(JsonSerializer.class); MapSerializer<Object, Object> mapSerializer = new MapSerializer<Object, Object>(HashSet.newHashSet(), JavaType.STRING, JavaType.STRING, true, mock, mock, mockKeySerializer, mockValueSerializer); assertEquals(mock, mapSerializer); }
@Test public void testConstructor_MapSerializer() { TypeSerializer vts = new TypeSerializer<Map<String, Object>>() { @Override public Map<String, Object> deserialize(JsonReader reader) throws IOException { return new MapSerializer<>(reader.readMap("\"key1\",\"value1\",\"key2\",\"value2\"), JavaTypes.STRING, true, vts, JsonSerializer.jsonSerializer(), JsonSerializer.jsonSerializer()); } }; MapSerializer mapSerializer = new MapSerializer(HashSet.of(), JavaTypes.STRING, JavaTypes.STRING, true, vts, JsonSerializer.jsonSerializer(), JsonSerializer.jsonSerializer()); assertEquals(mapSerializer, mapSerializer); }
@Test public void testConstructorWithJsonSerializer() { TypeSerializer mockVts = mock(TypeSerializer.class); JsonSerializer mockKeySerializer = mock(JsonSerializer.class); JsonSerializer mockValueSerializer = mock(JsonSerializer.class); TypeSerializer mockValueSerializer = mock(TypeSerializer.class); JsonSerializer mockDynamicValueSerializers = mock(JsonSerializer.class); JsonSerializer mockObjectSerializer = mock(JsonSerializer.class); JsonSerializer mockObjectSerializer = mock(JsonSerializer.class); JsonSerializer mockObjectSerializer = mock(JsonSerializer.class); MapSerializerTester.addIgnoredEntries(new HashSet<String>(), JavaType.STRING, JavaType.STRING, true, mockVts, mockKeySerializer, mockValueSerializer); MapSerializerTester.addIgnoredEntries(new HashSet<String>(), JavaType.STRING, JavaType.STRING, true, mockVts, mockObjectSerializer, mockObjectSerializer); MapSerializerTester.addIgnoredEntries(new HashSet<String>(), JavaType.STRING, JavaType.STRING, true, mockVts, mockObjectSerializer, mockObjectSerializer); MapSerializerTester.addKeyIgnoredEntries(new HashSet<String>(), JavaType.STRING, JavaType.STRING,
@Test public void testConstructor_MapSerializer() { TypeSerializer vts = new TypeSerializerImpl(); MapSerializer mapSerializer = new MapSerializer(HashSet.newHashSet(), JavaType.OBJECT, JavaType.STRING, true, vts, (JsonSerializer<?>) null, (JsonSerializer<?>) null); assertEquals(Map.class, mapSerializer.getClass()); assertEquals(JavaType.OBJECT, mapSerializer.getKeyType()); assertEquals(JavaType.STRING, mapSerializer.getValueType()); assertEquals(VSTUB_SERIALIZER, vts.getSerializer(String.class)); assertEquals(VSTUB_SERIALIZER, vts.getSerializer(String.class)); }
@Test public void testConstructorWithJsonSerializer() { JsonSerializer<?> keySerializer = new JsonSerializer<Object>() { @Override public void serialize(Object value, JsonSerializer<Object> serializer) { } }; JsonSerializer<?> valueSerializer = new JsonSerializer<Object>() { @Override public void serialize(Object value, JsonSerializer<Object> serializer) { } }; TypeSerializer vts = new TypeSerializerImpl(); MapSerializer mapSerializer = new MapSerializer(HashSet.of(), JavaType.INTEGER, JavaType.INTEGER, false, vts, keySerializer, valueSerializer); assertEquals(mapSerializer, mapSerializer); }
@Test public void testValueSerializer() { JsonSerializer<?> valueSerializer = new JsonSerializer<Object>() { @Override public void serialize(Object value, JsonSerializer<?> parent) { } }; JsonSerializer<?> valueSerializer2 = new JsonSerializer<Object>() { @Override public void serialize(Object value, JsonSerializer<?> parent) { } }; JsonSerializer<?> valueSerializer3 = new JsonSerializer<Object>() { @Override public void serialize(Object value, JsonSerializer<?> parent) { } }; JsonSerializer<?> valueSerializer4 = new JsonSerializer<Object>() { @Override public void serialize(Object value, JsonSerializer<?> parent) { } }; JsonSerializer<?> valueSerializer5 = new JsonSerializer<Object>() { @Override public void serialize(Object value, JsonSerializer<?> parent) { } }; JsonSerializer<?> valueSerializer6 = new JsonSerializer<Object>() { @Override public void serialize(Object value, JsonSerializer<?> parent) { } }; JsonSerializer<?> valueSerializer7 = new JsonSerializer<Object>() { @Override public void serialize(Object value, JsonSerializer<?> parent) { } }; JsonSerializer<?> valueSerializer8 = new JsonSerializer<Object>() { @Override public void serialize(Object value, JsonSerializer<?> parent) { }
@Test public void testConstructorWithDynamicValueSerializers() { TypeSerializer vts = new JsonSerializer<Object>() { @Override public JsonSerializer<Object> createInstance(HashSet<String> ignoredEntries, JavaType keyType, JavaType valueType, boolean valueTypeIsStatic, JsonSerializer<?> keySerializer, JsonSerializer<?> valueSerializer) { return new JsonSerializer<Object>() { @Override public JsonSerializer<Object> createInstance(HashSet<String> ignoredEntries, JavaType keyType, JavaType valueType, boolean valueTypeIsStatic, TypeSerializer vts, JsonSerializer<?> keySerializer, JsonSerializer<?> valueSerializer) { return new JsonSerializer<Object>() { @Override public JsonSerializer<Object> createInstance(HashSet<String> ignoredEntries, JavaType keyType, JavaType valueType, boolean valueTypeIsStatic, TypeSerializer vts, JsonSerializer<?> valueSerializer) { return new JsonSerializer<Object>() { @Override public JsonSerializer<Object> createInstance(HashSet<String> ignoredEntries, JavaType keyType, JavaType valueType, boolean valueTypeIsStatic, TypeSerializer vts, JsonSerializer<?> valueSerializer) { return new JsonSerializer<Object>() { @Override public JsonSerializer<Object> createInstance(HashSet<String> ignoredEntries, JavaType keyType, JavaType valueType
@Test public void testConstructorWithNullKeySerializer() { JsonSerializer<?> keySerializer = new JsonSerializer<?>(); JsonSerializer<?> valueSerializer = new JsonSerializer<?>(); MapSerializer<String, String> mapSerializer = new MapSerializer<>(HashSet.newSet("foo"), JavaType.STRING, JavaType.STRING, false, new TypeSerializer.ObjectSerializer(), keySerializer, valueSerializer); assertEquals(null, mapSerializer.getIgnoredEntries()); assertEquals(null, mapSerializer.getKeyType()); assertEquals(JavaType.STRING, mapSerializer.getValueType()); assertEquals(null, mapSerializer.getDynamicValueSerializers()); }
@Test public void construct_ignoreList_mapType_value_is_final() throws Exception { String ignoredList = "key1", "key2"; String[] ignoredEntries = new String[]{"key1", "key2"}; MapSerializer expected = new MapSerializer(ignoredEntries, null, null, null, null, null); JsonSerializer<Object> valueSerializer = new JsonSerializer(ignoredEntries, null, null, null, null); assertEquals(expected, valueSerializer.serialize(new HashMap<>())); }
@Test public void mapSerializer_ignoredList() { HashSet<String> ignoredEntries = new HashSet<>(); ignoredEntries.add("entry1"); ignoredEntries.add("entry2"); MapSerializer mapSerializer = new MapSerializer(ignoredEntries, null, null, null, null, null); assertThat(mapSerializer.toSet(ignoredEntries)).containsExactly("entry1", "entry2"); }
@Test public void construct_mapType_keyType_staticValueType() { JsonSerializer<?> keySerializer = mock(JsonSerializer.class); JsonSerializer<?> valueSerializer = mock(JsonSerializer.class); TypeSerializer mockStaticValueType = mock(TypeSerializer.class); MapSerializer expectedResult = new MapSerializer(new HashSet<String>(), null, null, null, keySerializer, valueSerializer); assertEquals(expectedResult, construct(new String[]{"key", "value"}, null, null, null, keySerializer, valueSerializer)); }
@Test public void construct_mapTypeIsNull() { String[] ignoredList = new String[] {}; JavaType mapType = null; TypeSerializer vts = mock(TypeSerializer.class); JsonSerializer<Object> keySerializer = mock(JsonSerializer.class); JsonSerializer<Object> valueSerializer = mock(JsonSerializer.class); MapSerializer expectedResult = new MapSerializer(ignoredList, mapType, false, vts, keySerializer, valueSerializer); expectedResult.add(null); expectedResult.add(null); expectedResult.add(null); expectedResult.add(null); expectedResult.add(null); expectedResult.add(null); expectedResult.add(null); expectedResult.add(null); expectedResult.add(null); expectedResult.add(null); expectedResult.add(null); expectedResult.add(null); expectedResult.add(null); expectedResult.add(null); expectedResult.add(null); expectedResult.add(null); expectedResult.add(null); expectedResult.add(null); expectedResult.add(null); expectedResult.add(null); expectedResult.add(null); MapSerializer actual = new MapSerializer(ignoredList, mapType, false, vts, keySerializer, valueSerializer); assertEquals(expectedResult, actual); }
@Test public void construct_mapTypeKeyContentType_ignoredList() throws Exception { JsMap map = new JsMap(); map.addKey("key"); map.addKey("key2"); map.addKey("key3"); map.addKey("key4"); map.addKey("key5"); map.addKey("key6"); map.addKey("key7"); map.addKey("key8"); map.addKey("key9"); map.addKey("key10"); map.addKey("key11"); map.addKey("key12"); map.addKey("key13"); map.addKey("key14"); map.addKey("key15"); map.addKey("key16"); map.addKey("key17"); map.addKey("key18"); map.addKey("key21"); map.addKey("key22"); map.addKey("key23"); map.addKey("key24"); map.addKey("key31"); map.addKey("key32"); map.addKey("key33"); map.setValue("value"); MapSerializer expected = new MapSerializer(new HashSet<String>(), JavaType.STRING, JavaType.STRING, true,
@Test public void mapWithStaticKeyContentType_shouldNotBeNull() { TypeSerializer mockedSerializer = mock(TypeSerializer.class); JsonSerializer<Object> mockedKeySerializer = mock(JsonSerializer.class); JsonSerializer<Object> mockedValueSerializer = mock(JsonSerializer.class); when(mockedKeySerializer.serialize(null)).thenReturn("null"); when(mockedValueSerializer.serialize(null)).thenReturn("null"); MapSerializer expected = new MapSerializer(new HashSet<String>(), null, null, null, mockedKeySerializer, mockedValueSerializer); assertThat(expected).isEqualTo(expected); }
@Test public void construct_staticKeyAndStaticValue() { JsonSerializer<Object> keySerializer = mock(JsonSerializer.class); JsonSerializer<Object> valueSerializer = mock(JsonSerializer.class); TypeSerializer mockStaticValueType = mock(TypeSerializer.class); new MapSerializer(new HashSet<String>(), null, false, mockStaticValueType, mockStaticValueType, keySerializer, valueSerializer).construct(new String[]{"key1", "key2"}, null, false, mockStaticValueType, mockStaticValueType, mockKeySerializer, valueSerializer); }
@Test public void testConstructMapWithStaticKeyAndStaticValue() throws Exception { String[] ignoredList = new String[] { "key1", "key2" }; JavaType keyType = new JavaType(String.class); JavaType valueType = new JavaType(String.class); TypeSerializer vts = mock(TypeSerializer.class); JsonSerializer<Object> keySerializer = mock(JsonSerializer.class); JsonSerializer<Object> valueSerializer = mock(JsonSerializer.class); JsonSerializer<Object> valueSerializer = mock(JsonSerializer.class); JsonSerializer.construct(ignoredList, keyType, valueType, staticValueType, vts, keySerializer, valueSerializer); verify(keySerializer).serialize(any(JavaType.class), any(String.class)); verify(valueSerializer).serialize(any(JavaType.class), any(String.class)); }
@Test public void construct_mapTypeContentType_ignoredList() throws Exception { HashSet<String> ignoredEntries = new HashSet<>(); ignoredEntries.add("key1"); ignoredEntries.add("key2"); JavaType mapType = new JavaType(String.class); TypeSerializer vts = mock(TypeSerializer.class); JsonSerializer<Object> keySerializer = mock(JsonSerializer.class); JsonSerializer<Object> valueSerializer = mock(JsonSerializer.class); MapSerializer expected = new MapSerializer(ignoredEntries, mapType, mapType, false, vts, keySerializer, valueSerializer); assertEquals(expected, construct(ignoredEntries, mapType, mapType, false, vts, keySerializer, valueSerializer)); }
@Test public void testSetToHashSet() { HashSet<String> ignored = new HashSet<String>(); ignored.add("foo"); ignored.add("bar"); HashSet<String> actual = toSet(new String[] { "foo", "bar" }); assertEquals(ignored, actual); ignored.add("foo"); ignored.add("bar"); actual = toSet(new String[] { "foo", "bar" }); assertEquals(ignored, actual); ignored.add("foo"); actual = toSet(new String[] { "foo", "bar" }); assertEquals(ignored, actual); ignored.add("foo"); actual = toSet(new String[] { "foo", "bar" }); assertEquals(ignored, actual); ignored.add("foo"); actual = toSet(new String[] { "foo", "bar" }); assertEquals(ignored, actual); ignored.add("foo"); actual = toSet(new String[] { "foo", "bar" }); assertEquals(null, actual); ignored.add("foo"); actual = toSet(new String[] { "foo", "bar" }); assertEquals(null, actual); ignored.add("foo"); actual = toSet(new String[] { "foo", "bar" }); assertEquals(null, actual); }
@Test public void testBlankIgnoredEntries() { HashSet<String> ignored = new HashSet<String>(); ignored.add("a"); ignored.add("b"); ignored.add("c"); HashSet<String> ignored2 = new HashSet<String>(); ignored2.add("a"); ignored2.add("b"); ignored2.add("c"); assertEquals(ignored, toSet(ignored2)); }
@Test public void testSetToHashSet() { HashSet<String> ignored = new HashSet<String>(); ignored.add("foo"); ignored.add("bar"); HashSet<String> result = toSet(ignored); assertEquals(1, result.size()); assertEquals("foo", result.iterator().next()); }
@Test public void testSerializeMapWithDynamicValueSerializers() throws IOException, JsonGenerationException { Map<String, Object> value = new LinkedHashMap<>(); value.put("key1", "value1"); value.put("key2", "value2"); value.put("key3", "value3"); JsonGenerator jgen = mock(JsonGenerator.class); new JsonSerializer<Object>().serializeTypedFields(value, jgen, new DefaultSerializerProvider()); verify(jgen).writeString("value1"); verify(jgen).writeString("value2"); verify(jgen).writeString("value3"); }
@Test public void testDynamicValueSerializers() throws IOException, JsonGenerationException { Map<String, Object> value = new LinkedHashMap<>(); value.put("key", "value"); value.put("key2", "value2"); JsonGenerator jgen = mock(JsonGenerator.class); SerializerProvider provider = mock(SerializerProvider.class); when(provider.findNullKeySerializer(any(), any())).thenReturn(null); new JsonSerializer<Object>().serializeFields(value, jgen, provider); verify(provider).findNullKeySerializer(any(), any()); }
@Test public void testJsonGenerationException() throws IOException, JsonGenerationException { Map<String, Object> map = new HashMap<>(); map.put("key", "value"); new JsonSerializer<Object>().serializeTypedFields(map, _jgen, new DefaultSerializerProvider()); }
@Test public void testSerializeTypedFields() throws IOException, JsonGenerationException { Map<String, String> map = new HashMap<>(); map.put("key", "value"); JsonSerializer<Object> serializer = mock(JsonSerializer.class); when(serializer.serialize(null, null, null)).thenReturn("value"); JsonSerializerProvider provider = mock(JsonSerializerProvider.class); when(provider.findNullKeySerializer(String.class, "key")).thenReturn(null); JsonSerializer<Object> valueSerializer = mock(JsonSerializer.class); when(valueSerializer.serialize(null, null, null)).thenReturn("value"); JsonSerializer<Object> valueSerializer2 = mock(JsonSerializer.class); when(valueSerializer2.serialize(null, null, null)).thenReturn("value2"); JsonSerializer<Object> valueSerializer3 = mock(JsonSerializer.class); when(valueSerializer3.serialize(null, null, null)).thenReturn("value3"); JsonSerializer<Object> valueSerializer4 = mock(JsonSerializer.class); when(valueSerializer4.serialize(null, null, null)).thenReturn("value4"); JsonSerializer<Object> valueSerializer5 = mock(JsonSerializer.class); when(valueSerializer5.serialize(
@Test public void testSerializeTypedFields() throws IOException, JsonGenerationException { Map<String, Object> value = new HashMap<>(); value.put("key", "value"); value.put("key2", "value2"); JsonSerializer<Object> prevValueSerializer = null; JsonGenerator jgen = mock(JsonGenerator.class); when(jgen.nextObject()).thenReturn(prevValueSerializer); JsonSerializer<Object> valueSerializer = mock(JsonSerializer.class); when(prevValueSerializer.serialize(null, jgen, provider)).thenReturn(value); JsonSerializer<Object> valueSerializer2 = mock(JsonSerializer.class); when(prevValueSerializer.serialize(null, jgen, provider)).thenReturn(valueSerializer2); JsonSerializer<Object> prevValueSerializer2 = null; JsonSerializer<Object> valueSerializer3 = mock(JsonSerializer.class); when(prevValueSerializer.serialize(null, jgen, provider)).thenReturn(valueSerializer3); JsonSerializer<Object> valueSerializer4 = mock(JsonSerializer.class); when(prevValueSerializer.deserialize(null, jgen, provider)).thenReturn(valueSerializer4); JsonSerializer<Object> valueSerializer5 = mock(JsonSerializer.class); when(
@Test public void testSerializeTypedFields_mapWithNonMap() throws IOException, JsonGenerationException { Map<String, Object> map = new HashMap<>(); map.put("key", "value"); map.put("key2", null); map.put("key3", "value3"); JsonGenerator jgen = mock(JsonGenerator.class); new JsonSerializer<Object>().serializeTypedFields(map, jgen, new DefaultSerializerProvider()); verify(jgen).writeString("{\"key2\":null}"); }
@Test public void testIgnored() throws IOException, JsonGenerationException { Map<String, Object> value = new HashMap<>(); value.put("key1", "value1"); value.put("key2", "value2"); value.put("key3", "value3"); JsonGenerator jgen = mock(JsonGenerator.class); new JsonSerializer<Object>().serialize(value, jgen, new DefaultSerializerProvider()); verify(jgen).writeString("{\"key1\":\"value1\"}"); verify(jgen).writeString("{\"key2\":\"value2\"}"); }
@Test public void testSerializeTypedFields() throws IOException, JsonGenerationException { final JsonGenerator jgen = mock(JsonGenerator.class); final SerializerProvider provider = mock(SerializerProvider.class); when(provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES)).thenReturn(true); final Map<String, Object> map = new HashMap<>(); map.put("key", "value"); map.put("null", null); JsonSerializer<Object> serializer = mock(JsonSerializer.class); when(provider.findNullKeySerializer(String.class, "key")).thenReturn(serializer); when(provider.findNullValueSerializer(String.class, "value")).thenReturn(serializer); JsonSerializationUtils.serializeTypedFields(map, jgen, provider); verify(provider).isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES); }
@Test public void testSerializeTypedFields() throws IOException, JsonGenerationException { Map<String, String> value = new HashMap<>(); value.put("key1", "value1"); value.put("key2", "value2"); value.put("key3", "value3"); value.put("key4", "value4"); JsonGenerator jsonGenerator = mock(JsonGenerator.class); new JsonSerializer<Object>().serialize(value, jsonGenerator, new DefaultSerializerProvider()); verify(jsonGenerator).writeString(eq("{\"key1\":\"value1\"}")); verify(jsonGenerator).writeString(eq("{\"key2\":\"value2\"}")); verify(jsonGenerator).writeString(eq("{\"key3\":\"value3\"}")); }
@Test public void testJsonGenerationException() throws IOException { Map<String, Object> value = new LinkedHashMap<>(); value.put("key", "value"); value.put("key2", "value2"); JsonGenerator jgen = mock(JsonGenerator.class); new JsonSerializer<Object>().serializeTypedFields(value, jgen, new DefaultSerializerProvider()); verify(jgen).writeString(eq("value")); }
@Test public void testTypedKey() throws IOException { Map<String, Object> map = new LinkedHashMap<>(); map.put("key", "value"); map.put("key2", null); map.put("key3", "value3"); new JsonSerializer<Object>().serializeTypedFields(map, _jgen, _provider); assertEquals("{\"key\":\"value\",\"key2\":null}", jgen.toString()); }
@Test public void testTypedFieldsWithIgnoredValues() throws IOException { Map<String, Object> testMap = new HashMap<>(); testMap.put("foo", "bar"); _mapper.writeValueAsString(testMap); _writer.flush(); JsonGenerationException e = assertThrows(JsonGenerationException.class, () -> _writer.next()); assertEquals("Unexpected exception message.", e.getMessage()); }
@Test public void testJsonGenerationException() throws IOException { Map<String, Object> value = new HashMap<>(); value.put("key", "value"); value.put("key2", null); value.put("key3", "value3"); JsonGenerator jgen = mock(JsonGenerator.class); new JsonSerializer<Object>().serialize(value, jgen, new DefaultSerializerProvider()); assertThrows(JsonGenerationException.class, () -> _testStream.writeTo(jgen).toString()); }
@Test public void testIgnoreNullMapValues() throws IOException, JsonGenerationException { final Map<String, Object> value = new HashMap<String, Object>(); value.put("key", null); value.put("key2", "value2"); JsonGenerator jgen = mock(JsonGenerator.class); final SerializerProvider provider = mock(SerializerProvider.class); when(provider.findNullKeySerializer(String.class, "key")).thenReturn(null); when(provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES)).thenReturn(true); when(provider.isEnabled(SerializationFeature.READ_ENUMS)).thenReturn(false); final JsonSerializer<Object> serializer = mock(JsonSerializer.class); when(provider.findNullKeySerializer(String.class, "key")).thenReturn(serializer); when(provider.findNullKeySerializer(Object.class, "key2")).thenReturn(null); when(provider.findNullKeySerializer(Object.class, "key3")).thenReturn(serializer); final StringWriter writer = new StringWriter(); Json.serializeTypedFields(value, jgen, provider); JsonTestUtils.writeString(writer, "key\nvalue\nvalue\n"); writer.flush();
@Test public void testKeySerializer() throws Exception { Map<String, String> value = new HashMap<>(); value.put("key1", "value1"); value.put("key2", "value2"); JsonGenerator jsonGenerator = mock(JsonGenerator.class); new JsonSerializer<Object>().serialize(value, jsonGenerator, new DefaultSerializerProvider()); verify(jsonGenerator).writeString("value1"); verify(jsonGenerator).writeString("value2"); }
@Test public void testTypedFieldsWithNonMap() throws IOException { Map<String, Object> value = new HashMap<>(); value.put("key", "value"); value.put("key2", "value2"); JsonGenerator jgen = mock(JsonGenerator.class); new JsonSerializer<Object>().serializeTypedFields(value, jgen, new DefaultSerializerProvider()); verify(jgen).writeString("{\"key2\":\"value2\"}"); }
@Test public void testTypedFieldWithMap() throws IOException { Map<String, Object> value = new HashMap<>(); value.put("key", "value"); value.put("key2", "value2"); JsonGenerator jgen = mock(JsonGenerator.class); new JsonSerializer<Object>().serializeTypedFields(value, jgen, new DefaultSerializerProvider()); verify(jgen).writeString("{\"key2\":\"value2\"}"); }
@Test public void testTypedFields() throws IOException { JsonSerializer<Object> serializer = new JsonSerializer<Object>() { @Override public void serialize(JsonGenerator jgen, SerializerProvider provider) throws IOException { } }; JsonSerializer<Object> value = new JsonSerializer<Object>() { @Override public void serialize(JsonGenerator jgen, SerializerProvider provider) throws IOException { } }; JsonSerializer<Object> prevValueSerializer = null; JsonSerializer<Object> value2 = new JsonSerializer<Object>() { @Override public void serialize(JsonGenerator jgen, SerializerProvider provider) throws IOException { } }; JsonSerializer<Object> value3 = new JsonSerializer<Object>() { @Override public void serialize(JsonGenerator jgen, SerializerProvider provider) throws IOException { } }; JsonSerializer<Object> prevValueSerializer = null; JsonSerializer<Object> value4 = new JsonSerializer<Object>() { @Override public void serialize(JsonGenerator jgen, SerializerProvider provider) throws IOException { } }; JsonSerializer<Object> value5 = new JsonSerializer<Object>() { @Override public void serialize(JsonGenerator jgen, SerializerProvider provider) throws IOException { } }; JsonSerializer<Object> value6 = new JsonSerializer<Object>()
@Test public void testValueClass() throws IOException { new Expectations() {{ {{ ((Class<? extends Number>) Integer.class).getField("integer"); result = 1; }}; }}; JsonGenerator jgen = mock(JsonGenerator.class); final SerializerProvider provider = mock(SerializerProvider.class); new JsonSerializer<Object>((Class<?>) Integer.class).serialize(null, jgen, provider); }
@Test public void testSerializeTypedFields() throws IOException, JsonGenerationException { Map<String, String> value = new HashMap<>(); value.put("key1", "value1"); value.put("key2", "value2"); value.put("key3", "value3"); JsonGenerator jgen = mock(JsonGenerator.class); when(cc.findValueSerializer(eq("key1"), eq("key2"))).thenReturn(new JsonSerializer<Object>() { @Override public voidserialize(JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { } }); JsonSerializer<Object> prevValueSerializer = null; JsonSerializer<Object> currValueSerializer = provider.findValueSerializer(cc, "key1"); assertEquals(currValueSerializer, prevValueSerializer); }
@Test public void testSerializeTypedFields() throws IOException { JsonSerializer<Object> prevValueSerializer = mock(JsonSerializer.class); JsonSerializer<Object> value = mock(JsonSerializer.class); when(prevValueSerializer.serialize(null, jgen, provider)).thenReturn(value); JsonSerializer<Object> value2 = mock(JsonSerializer.class); when(value2.serialize(null, jgen, provider)).thenReturn(value2); JsonSerializer<Object> prevValueClass = null; JsonSerializer<Object> value2Class = null; JsonSerializer<Object> value3 = mock(JsonSerializer.class); when(value2.serialize(null, jgen, provider)).thenReturn(value3); JsonSerializer<Object> value4 = mock(JsonSerializer.class); when(value3.serialize(null, jgen, provider)).thenReturn(value4); JsonSerializer<Object> value5 = mock(JsonSerializer.class); when(value5.serialize(null, jgen, provider)).thenReturn(value5); JsonSerializer<Object> value6 = mock(JsonSerializer.class); when(value6.serialize(null, jgen, provider)).thenReturn(value6); JsonSerializer<Object> value7 = mock
@Test public void testSerializeTypedFields() throws IOException { Map<String, String> value = new HashMap<>(); value.put("key", "value"); value.put("key2", "value2"); JsonGenerator jgen = mock(JsonGenerator.class); JsonSerializerProvider provider = mock(JsonSerializerProvider.class); when(provider.findNullKeySerializer(String.class, "key")).thenReturn(provider); when(provider.findNullKeySerializer(String.class, "key")).thenReturn(provider); JsonSerializer<String> prevValueClass = null; JsonSerializer<String> valueSerializer = mock(JsonSerializer.class); when(valueSerializer.serialize(null, jgen, provider)).thenReturn(valueSerializer); new JsonSerializer<String>() { @Override public void serialize(JsonGenerator jgen, SerializerProvider provider) throws IOException { } }.serializeTypedFields(value, jgen, provider); verify(provider).findNullKeySerializer(String.class, "key"); verify(provider).findNullKeySerializer(String.class, "key2"); verify(provider).findNullValueSerializer(String.class, "key2"); verify(jgen).writeString("value"); }
@Test public void testSerializeTypedFields() throws IOException, JsonGenerationException { final Map<String, String> map = new LinkedHashMap<>(); map.put("key", "value"); map.put("null", null); map.put("null", "null"); map.put("null", "null"); map.put("null", "null"); map.put("null", "null"); map.put("null", "null"); map.put("null", null); map.put("null", "null"); map.put("null", "null"); map.put("null", null); map.put("null", "null"); map.put("null", "null"); StringWriter writer = new StringWriter(); new JsonSerializer<Map<String, String>>().serializeTypedFields(map, writer, new DefaultSerializerProvider()); JsonGenerationException e = assertThrows(JsonGenerationException.class, () -> writer.toString()); assertEquals("null", e.getMessage()); }
@Test public void testSerializeWithType() throws Exception { Map<String, String> value = new HashMap<>(); value.put("key", "value"); value.put("key2", "value2"); JsonGenerator jsonGenerator = mock(JsonGenerator.class); new JsonSerializer<Object>().serializeWithType(value, jsonGenerator, mock(JsonTypeSerializerProvider.class)); verify(jsonGenerator).writeString(eq("value"), eq("value2")); }
@Test public void testGetSchema() throws Exception { JsonNode schema = mapper.getSchema(mapper, JsonNodeFactory.instance); JsonNode expected = mapper.readTree("{\"object\":[{\"field\":\"value\"}]}"); assertEquals(expected, schema); }
@Test public void testJsonSchema() throws IOException { JsonNode schema = mapper.readTree("{\"key\": \"value\"}"); JsonNode expected = mapper.readTree("{\"key\": \"value\"}"); assertEquals(expected, schema); }
@Test public void testJsonSchema() throws Exception { JsonNode schema = mapper.getSchema(mapper, JsonNode.class); JsonNode expected = mapper.readTree("{\"object\":[{\"name\":\"test\"}]}"); assertEquals(expected, schema); }
@Test public void testWithResolved() { JsonDeserializer<Object> src = mock(JsonDeserializer.class); JsonDeserializer<Object> valueType = mock(JsonDeserializer.class); HashSet<String> ignorable = new HashSet<>(); MapDeserializer deserializer = new MapDeserializer(JavaType.OBJECT, new ValueInstantiator(new Instant(0), null), keyDeser, valueType, ignorable).withResolved(src, mock(KeyDeserializer.class), mock(TypeDeserializer.class), mock(JsonDeserializer.class)); assertEquals(src, deserializer.withResolved(null, mock(KeyDeserializer.class), mock(TypeDeserializer.class), mock(StringDeserializer.class))); assertEquals(src, deserializer.withResolved(null, mock(KeyDeserializer.class), mock(TypeDeserializer.class), mock(StringDeserializer.class), mock(StringDeserializer.class))); assertEquals(src, deserializer.withResolved(null, mock(KeyDeserializer.class), mock(TypeDeserializer.class), mock(StringDeserializer.class), mock(StringDeserializer.class), mock(StringDeserializer.class))); assertEquals(src, deserializer.withResolved(null, mock(KeyDeserializer.class), mock(TypeDeserializer.class), mock(StringDeserializer.class), mock
@Test public void testResolve() throws JsonMappingException { Config config = Config.createConfig(); Instantiator valueInstantiator = new MockInstantiator(config); new Expectations() {{ valueInstantiator.getFromObjectArguments(any(Config.class)); result = null; }}; { MockInstantiator.canCreateUsingDelegate(); result = false; } { MockInstantiator.canCreateFromObjectWith(); result = true; } }
@Test public void testResolve() throws JsonMappingException { Instantiator valueInstantiator = new MockInstantiator(); MockConfig config = new MockConfig(); MockInstantiator.configure(config, valueInstantiator); MockInstantiator.configure(config, valueInstantiator); MockInstantiator.configure(config, new MockInstantiator.Config()); MockInstantiator.configure(config, new MockInstantiator.Config()); MockInstantiator.configure(config, new MockInstantiator.Config()); MockInstantiator.configure(config, new MockInstantiator.Config()); MockInstantiator.configure(config, new MockInstantiator.Config()); MockInstantiator.configure(config, new MockInstantiator.Config()); MockInstantiator.configure(config, new MockInstantiator.Config()); MockInstantiator.configure(config, new MockInstantiator.Config()); MockInstantiator.configure(config, new MockInstantiator.Config()); MockInstantiator.configure(config, new MockInstantiator.Config()); MockInstantiator.configure(config, new MockInstantiator.Config()); MockInstantiator.configure(config, new MockInstantiator.Config()); MockInstantiator.configure(config, new MockInstantiator.Config()); MockInstantiator.configure
@Test public void createContextual() throws JsonMappingException { MockDeserializer mock = new MockDeserializer(); MockBeanProperty property = new MockBeanProperty(); JsonDeserializer<?> ctxt = new MockDeserializer(); ctxt.addBeanProperty(property); ctxt.addBeanProperty(property); JsonDeserializer<?> contextual = mock.createContextual(ctxt, property); contextual.assertValid(); }
@Test public void createContextual() throws JsonMappingException { BeanProperty property = new BeanProperty("key", "string"); JsonDeserializer<?> vd = mock(JsonDeserializer.class); when(vtd.forProperty(property)).thenReturn(vd); when(vd.createContextual(ctxt, property)).thenReturn(null); JsonDeserializer<?> contextual = vtd.forProperty(property); verify(vtd).forProperty(property); assertThat(contextual).isNotNull(); }
@Test public void deserializeWithDelegate() throws IOException, JsonProcessingException { Mockito.when(mockedValueInstantiator.createUsingDelegate(Mockito.eq(ctxt), Mockito.eq(mockedDelegateDeserializer))).thenReturn(mockedMap); Mockito.when(mockedMap.get("key")).thenReturn("value"); Mockito.when(mockedDelegateDeserializer.deserialize(jp, ctxt)).thenReturn(mockedMap); Mockito.when(mockedMap.get("key")).thenReturn("value"); Mockito.when(mockedMap.get("key")).thenReturn("value"); Mockito.when(mockedMap.get("key")).thenReturn("value"); Mockito.when(mockedMap.get("key")).thenReturn("value"); Mockito.when(mockedMap.get("key")).thenReturn("value"); Mockito.when(mockedMap.get("key")).thenReturn("value"); Mockito.when(mockedMap.get("key")).thenReturn("value"); Mockito.when(mockedMap.get("key")).thenReturn("value"); Mockito.when(mockedMap.get("key")).thenReturn("value"); Mockito.when(mockedMap.get("key")).thenReturn("value"); Mockito.when(mock
@Test public void deserialize_StringKey() throws Exception { Map<Object, Object> result = new HashMap<Object, Object>(); jp.setCurrentToken(JsonToken.START_OBJECT); jp.nextToken(); try { mapDeserializer.deserialize(jp, ctxt, result); fail("Expected exception not thrown"); } catch (JsonProcessingException e) { assertEquals(e.getMessage(), "Unable to read key"); } }
@Test public void testDeserializationWithStringKey() throws Exception { Map<Object, Object> result = new HashMap<Object, Object>(); jp.setCurrentToken(JsonToken.START_OBJECT); jp.setToken(JsonToken.FIELD_NAME, "stringKey"); Map<Object, Object> srcMap = new HashMap<Object, Object>(); srcMap.put("stringKey", "value"); srcMap.put("stringKey2", "value2"); Map<Object, Object> actual = mapDeserializer.deserialize(jp, ctxt, result); assertEquals(result, actual); }
@Test public void testDeserializationWithStringKey() throws IOException, JsonProcessingException { final String value = "value"; final Map<Object, Object> result = new HashMap<Object, Object>(); Mockito.when(mockedKeyDeser.deserialize(jp, ctxt, result)).thenReturn(value); Mockito.when(mockedValueDeser.deserialize(jp, ctxt, result)).thenReturn(value); Assert.assertEquals(result, deserializer.deserialize(jp, ctxt, result)); Mockito.verify(mockedKeyDeser).deserialize(jp, ctxt, result); Mockito.verify(mockedValueDeser).deserialize(jp, ctxt, result); }
@Test public void testKeyDeserialization() throws Exception { final String key = "key"; final String value = "value"; final JsonParser jp = mock(JsonParser.class); when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); when(jp.getFieldName()).thenReturn(key); when(jp.getToken(JsonToken.FIELD_NAME)).thenReturn(JsonToken.FIELD_VALUE); final DeserializationContext ctxt = mock(DeserializationContext.class); when(ctxt.mappingException(eq(Map.class))).thenReturn(new IOException()); final Map<Object, Object> result = new HashMap<Object, Object>(); when(jp.readValue(eq(key))).thenReturn(value); when(jp.getToken(JsonToken.START_OBJECT)).thenReturn(JsonToken.START_OBJECT); when(jp.getToken(JsonToken.FIELD_NAME)).thenReturn(JsonToken.FIELD_VALUE); when(jp.getToken(JsonToken.START_ARRAY)).thenReturn(new JsonArray(new String[] { key + "value" })); try (Map<Object, Object> map = mapDeserializer.deserialize(jp, ctxt, result)) { assertEquals(result,
@Test public void readValueWithStandardKey() throws Exception { Map<Object, Object> result = new HashMap<>(); MockDeserializer<Map<Object, Object>> deserializer = new MockDeserializer<>(); MockParser jp = new MockParser(); jp.setToken(JsonToken.START_OBJECT, JsonToken.FIELD_NAME); jp.setToken(JsonToken.START_STRING, "key"); deserializer.deserialize(jp, ctxt, result); assertEquals(result, map); }
@Test public void testDeserializationOfMapWithStringKey() throws Exception { Map<Object, Object> result = new HashMap<Object, Object>(); jp.setCurrentToken(JsonToken.START_OBJECT); jp.setToken(JsonToken.FIELD_NAME, "key"); Map<Object, Object> actual = mapDeserializer.deserialize(jp, ctxt, result); assertEquals(result, expected); }
@Test public void test_readAndBind() throws Exception { MockDeserializer<Object> deserializer = new MockDeserializer<>(); MockJsonParser jp = new MockJsonParser(); jp.setCurrentToken(JsonToken.START_OBJECT); jp.nextToken(); mapper.readValue(mapper.writeValueAsString(new Object()), null); mapper.readValue(mapper.writeValueAsString(new Object()), null); assertNull(jp.getCurrentToken()); mapper.readValue(mapper.writeValueAsString(new Object()), null); assertNull(jp.getCurrentToken()); mapper.readValue(mapper.writeValueAsString(new Object()), null); assertNull(jp.getCurrentToken()); mapper.readValue(mapper.writeValueAsString(new Object()), null); assertNull(jp.getCurrentToken()); mapper.readValue(mapper.writeValueAsString(new Object()), null); assertNull(jp.getCurrentToken()); mapper.readValue(mapper.writeValueAsString(new Object()), null); assertNull(jp.getCurrentToken()); mapper.readValue(mapper.writeValueAsString(new Object()), null); assertNull(jp.getCurrentToken()); mapper.readValue(mapper.writeValueAsString(new Object()), null); assertNull(jp.getCurrentToken()); mapper.read
@Test public void deserializeWithType() throws Exception { final TypeDeserializer<Object> typeDeser = mock(TypeDeserializer.class); final JsonParser jp = mock(JsonParser.class); when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.nextToken()).thenReturn(JsonToken.VALUE_NULL); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.nextToken()).thenReturn(JsonToken.VALUE_PROPERTY); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.nextToken()).thenReturn(JsonToken.VALUE_PROPERTY); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.nextToken()).thenReturn(JsonToken.VALUE_PROPERTY); when(jp.nextToken()).thenReturn(JsonToken.VALUE_PROPERTY); when(typeDeser.deserializeWithType(jp, null, typeDeser)).thenReturn(new Object()); _readAndBindStringMap(_mapper, _context, null); verify(
@Test public void _deserializeUsingCreator() throws IOException, JsonProcessingException { final PropertyBasedCreator creator = mock(PropertyBasedCreator.class); final PropertyValueBuffer buffer = mock(PropertyValueBuffer.class); when(creator.startBuilding(jp, null, null)).thenReturn(buffer); when(buffer.nextToken()).thenReturn(JsonToken.START_OBJECT); when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(
@Test public void _deserializeUsingCreator() throws IOException, JsonProcessingException { [LINE] final PropertyBasedCreator creator = new PropertyBasedCreator(); Mockito.when(creator.startBuilding(Mockito.any(JsonParser.class), Mockito.any(DeserializationContext.class), Mockito.any(PropertyValueBuffer.class))).thenReturn(mock(PropertyValueBuffer.class)); Mockito.when(mock(JsonToken.FIELD_NAME)).thenReturn(JsonToken.FIELD_NAME); Mockito.when(mock(JsonToken.FIELD_VALUE_NAME)).thenReturn(JsonToken.FIELD_VALUE_NAME); Mockito.when(mock(JsonToken.FIELD_TYPE_NAME)).thenReturn(JsonToken.FIELD_TYPE_NAME); Mockito.when(mock(JsonToken.FIELD_VALUE_NAME)).thenReturn(JsonToken.FIELD_VALUE_NAME); Mockito.when(mock(JsonToken.FIELD_TYPE_NAME)).thenReturn(JsonToken.FIELD_TYPE_NAME); Mockito.when(mock(JsonToken.FIELD_VALUE_NAME)).thenReturn(JsonToken.FIELD_VALUE_NAME); Mockito.when(mock(JsonToken.FIELD_VALUE_NAME)).thenReturn(JsonToken.FIELD_VALUE
@Test public void _deserializeUsingCreator() throws IOException, JsonProcessingException { PropertyBasedCreator creator = mock(PropertyBasedCreator.class); when(creator.startBuilding(jp, ctxt, null)).thenReturn(buffer); when(buffer.nextToken()).thenReturn(JsonToken.START_OBJECT); when(creator.startBuilding(jp, ctxt, null)).thenReturn(buffer); Map<Object, Object> actual = creator.__deserializeUsingCreator(jp, ctxt); assertEquals(buffer, actual); }
@Test public void _deserializeUsingCreator() throws IOException, JsonProcessingException { final String value = "value"; final JsonParser jp = mock(JsonParser.class); when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.nextToken()).thenReturn(JsonToken.FIELD_VALUE); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.nextToken()).thenReturn(JsonToken.FIELD_VALUE_NAME); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME_AND_VALUE); Map<Object, Object> map = _propertyBasedCreator.deserializeUsingCreator(jp, null); assertEquals(map.size(), 2); assertEquals(map.get("value"), value); assertEquals(map.get("value2"), value2); }
@Test public void _deserializeUsingCreator() throws IOException, JsonProcessingException { final String value = "value"; final String fieldName = "fieldName"; final String propertyValue = "anotherValue"; final PropertyBasedCreator creator = mock(PropertyBasedCreator.class); when(creator.startBuilding(jp, ctxt, null)).thenReturn(buffer); when(buffer.nextToken()).thenReturn(JsonToken.START_OBJECT); when(jp.getCurrentToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.nextToken()).thenReturn(JsonToken.FIELD_VALUE); when(buffer.nextToken()).thenReturn(JsonToken.FIELD_VALUE); when(creator.startBuilding(jp, ctxt, null)).thenReturn(buffer); when(buffer.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(propertyBasedCreator.endBuilding(jp, ctxt, null)).thenReturn(buffer); final Map<Object, Object> map = _propertyBasedCreator.__deserializeUsingCreator(jp, null); assertEquals(map.size(), 2); assertEquals(map.get(fieldName), value); assertEquals(map.get(fieldName), propertyValue); }
@Test public void _deserializeUsingCreator() throws IOException, JsonProcessingException { final String propertyValue = "foo"; final String propertyValue2 = "bar"; final String propertyValue3 = "baz"; final String propertyValue4 = "qux"; final String propertyValue5 = "qux2"; final PropertyBasedCreator creator = mock(PropertyBasedCreator.class); when(creator.startBuilding(jp, ctxt, null)).thenReturn(buffer); when(buffer.nextToken()).thenReturn(JsonToken.START_OBJECT); when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); when(jp.nextToken()).thenReturn(JsonToken.START_STRING); when(jp.nextToken()).thenReturn(JsonToken.START_STRING); when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); when(jp.nextToken()).thenReturn(JsonToken.START_STRING); when(jp.nextToken()).thenReturn(JsonToken.START_STRING); when(jp.nextToken()).thenReturn(JsonToken.START_STRING); when(jp.nextToken()).thenReturn(JsonToken.START_STRING); when(jp.nextToken()).thenReturn(JsonToken.START_STRING); when(jp.nextToken
@Test public void _deserializeUsingCreator() throws IOException, JsonProcessingException { final String value = "value"; final JsonDeserializer<Object> valueDes = mock(JsonDeserializer.class); final DeserializationContext ctxt = mock(DeserializationContext.class); when(ctxt.getDeserializer()).thenReturn(valueDes); when(valueDes.deserialize(null, ctxt)).thenReturn(value); final Map<Object, Object> map = _valueDeserializer.deserializeUsingCreator(jp, ctxt); assertEquals(map.get(value), value); }
@Test public void _deserializeUsingCreator() throws IOException, JsonProcessingException { final String propertyValue = "foo"; final PropertyBasedCreator creator = mock(PropertyBasedCreator.class); when(creator.startBuilding(jp, null, null)).thenReturn(buffer); when(buffer.nextToken()).thenReturn(JsonToken.START_OBJECT); when(jp.getCurrentToken()).thenReturn(JsonToken.FIELD_NAME); when(buffer.nextToken()).thenReturn(JsonToken.FIELD_VALUE); when(creator.startBuilding(jp, null, null)).thenReturn(buffer); when(buffer.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.nextToken()).thenReturn(JsonToken.FIELD_VALUE); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.nextToken()).thenReturn
@Test public void _deserializeUsingCreator() throws IOException, JsonProcessingException { final String value = "value"; final PropertyValueBuffer buffer = PropertyValueBuffer.createPropertyValueBuffer(value); Mockito.when(_propertyBasedCreator.startBuilding(Mockito.eq(jp), Mockito.eq(null), Mockito.eq(null))).thenReturn(buffer); Mockito.when(_propertyBasedCreator.endBuilding(Mockito.eq(jp), Mockito.eq(null))).thenReturn(buffer); Mockito.when(_propertyBasedCreator.endBuilding(Mockito.eq(jp), Mockito.eq(null))).thenReturn(buffer); Mockito.when(_propertyBasedCreator.endBuilding(Mockito.eq(jp), Mockito.eq(null))).thenReturn(null); final Map<Object, Object> map = _converter.__deserializeUsingCreator(jp, _ctxt); Mockito.verify(_propertyBasedCreator).startBuilding(Mockito.eq(jp), Mockito.eq(null), Mockito.eq(null)); Mockito.verify(_propertyBasedCreator).endBuilding(Mockito.eq(jp), Mockito.eq(null)); Mockito.verify(_propertyBasedCreator).endBuilding(Mockito.eq(jp
@Test public void _deserializeUsingCreator() throws IOException, JsonProcessingException { final String propertyValue = "foo"; final PropertyValueBuffer buffer = new PropertyValueBuffer(); buffer.addToken(JsonToken.FIELD_NAME, JsonToken.START_OBJECT); buffer.addToken(JsonToken.FIELD_NAME, JsonToken.FIELD_VALUE); Mockito.when(_propertyBasedCreator.startBuilding(jp, _ctxt, null)).thenReturn(buffer); Mockito.when(_propertyBasedCreator.endBuilding(jp, _ctxt, null)).thenReturn(buffer); Mockito.when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); Mockito.when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); Mockito.when(_propertyBasedCreator.endBuilding(jp, _ctxt, null)).thenReturn(buffer); Map<Object, Object> map = _propertyBasedClassUnderTest.__deserializeUsingCreator(jp, _ctxt); Mockito.verify(_propertyBasedCreator).startBuilding(jp, _ctxt, null); Mockito.verify(_propertyBasedCreator).endBuilding(jp, _ctxt, null); Mockito.verify(jp).nextToken(); Mockito.verify(jp).skipChildren(); Mockito.verify
@Test public void _deserializeUsingCreator() throws IOException, JsonProcessingException { final PropertyBasedCreator creator = mock(PropertyBasedCreator.class); final PropertyValueBuffer buffer = mock(PropertyValueBuffer.class); when(creator.startBuilding(jp, null, null)).thenReturn(buffer); when(buffer.nextToken()).thenReturn(JsonToken.START_OBJECT); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.nextToken()).thenReturn(JsonToken.FIELD_VALUE); when(buffer.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(buffer.nextToken()).thenReturn(JsonToken.FIELD_VALUE); when(buffer.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(buffer.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(
@Test public void _deserializeUsingCreator() throws IOException, JsonProcessingException { final PropertyBasedCreator creator = mock(PropertyBasedCreator.class); Mockito.when(creator.startBuilding(Mockito.any(JsonParser.class), Mockito.any(DeserializationContext.class), Mockito.any(NullWritable.class))).thenReturn(new PropertyValueBuffer()); Mockito.when(creator.startBuilding(Mockito.any(JsonParser.class), Mockito.any(DeserializationContext.class), Mockito.any(NullWritable.class))).thenReturn(new PropertyValueBuffer()); Mockito.when(propertyBasedCreator.startBuilding(Mockito.any(JsonParser.class), Mockito.any(DeserializationContext.class), Mockito.any(NullWritable.class))).thenReturn(new PropertyValueBuffer()); Mockito.when(propertyBasedCreator.endBuilding(Mockito.any(JsonParser.class), Mockito.any(DeserializationContext.class), Mockito.any(NullWritable.class))).thenReturn(new PropertyValueBuffer()); Mockito.when(propertyBasedCreator.end(Mockito.any(JsonParser.class), Mockito.any(DeserializationContext.class), Mockito.any(NullWritable.
@Test public void _deserializeUsingCreator() throws IOException, JsonProcessingException { [LINE] creator = new SettableBeanProperty("name"); creator.setProperty("name", "value"); creator.setProperty("name2", "value2"); creator.setProperty("name3", "value3"); Map<Object, Object> map = _propertyBasedCreator.deserializeUsingCreator(getJsonParser("\"name\"=\"value\""), null); assertEquals("value", map.get("name")); assertEquals("value2", map.get("name2")); assertEquals("value3", map.get("name3")); }
@Test public void _deserializeUsingCreator() throws IOException, JsonProcessingException { String propertyValue = "{\"property\":\"propertyValue\"}"; MockPropertyValueBuffer buffer = new MockPropertyValueBuffer(); buffer.addToken(JsonToken.FIELD_NAME, JsonToken.START_OBJECT); buffer.addToken(JsonToken.FIELD_NAME, JsonToken.START_STRING); buffer.addToken(JsonToken.FIELD_NAME, JsonToken.START_OBJECT); buffer.addToken(JsonToken.FIELD_NAME, JsonToken.START_STRING); buffer.addToken(JsonToken.FIELD_NAME, JsonToken.START_STRING); Mockito.when(_propertyBasedCreator.startBuilding(Mockito.eq(jp), Mockito.eq(ctxt), Mockito.any(PropertyValueBuffer.class))).thenReturn(buffer); Mockito.when(_propertyBasedCreator.endBuilding(Mockito.eq(jp), Mockito.eq(ctxt), Mockito.any(PropertyValueBuffer.class))).thenReturn(null); Map<Object, Object> map = _converter.__deserializeUsingCreator(jp, ctxt); Assert.assertEquals(propertyValue, map); Mockito.verify(_propertyBasedCreator, Mockito.times(1)
@Test public void _deserializeUsingCreator() throws IOException, JsonProcessingException { final PropertyBasedCreator creator = mock(PropertyBasedCreator.class); final DeserializationContext ctxt = mock(DeserializationContext.class); when(creator.deserialize(jp, ctxt)).thenReturn(new HashMap<>()); when(ctxt.getDeserializer()).thenReturn(mock(Deserializer.class)); when(propertyBasedCreator.startBuilding(jp, ctxt, null)).thenReturn(buffer); when(buffer.nextToken()).thenReturn(JsonToken.START_OBJECT); when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); when(jp.nextToken()).thenReturn(JsonToken.START_ARRAY); when(buffer.nextToken()).thenReturn(JsonToken.START_STRING); when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); when(jp.nextToken()).thenReturn(JsonToken.START_STRING); when(jp.nextToken()).thenReturn(JsonToken.START_ARRAY); when(propertyBasedCreator.deserialize(jp, ctxt)).thenReturn(new HashMap<>()); Map<Object, Object> actualMap = propertyBased.deserializeUsingCreator(jp, ctxt); assertEquals(actualMap, new HashMap<>()); }
@Test public void _deserializeUsingCreator() throws IOException, JsonProcessingException { PropertyValueBuffer buffer = propertyValueBuffer(new String[] {"foo", "bar", "baz", "foo", "bar", "baz"}); mockPropertyBasedCreator(buffer, "foo", "bar", "baz"); mockPropertyBasedCreator(buffer, "foo", "bar", "baz"); mockPropertyBasedCreator(buffer, "foo", "bar", "baz"); Map<Object, Object> map = _cut.__deserializeUsingCreator(jp, _ctxt); assertEquals("bar", map.get("foo")); assertEquals("baz", map.get("bar")); mockPropertyBasedCreator(buffer, "foo", "bar", "baz"); }
@Test public void _deserializeUsingCreator() throws IOException, JsonProcessingException { final String propertyValue = "foo"; final JsonParser jp = mock(JsonParser.class); when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME + propertyValue.length()); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME + propertyValue.length()); final Map<Object, Object> map = _propertyBasedCreator.__deserializeUsingCreator(jp, null); assertEquals(propertyValue, map); }
@Test public void _deserializeUsingCreator() throws IOException, JsonProcessingException { final String value = "value"; final PropertyBasedCreator creator = mock(PropertyBasedCreator.class); final PropertyValueBuffer buffer = mock(PropertyValueBuffer.class); when(creator.startBuilding(jp, ctxt, null)).thenReturn(buffer); when(buffer.nextToken()).thenReturn(JsonToken.START_OBJECT); when(jp.getCurrentToken()).thenReturn(JsonToken.FIELD_NAME); when(buffer.nextToken()).thenReturn(JsonToken.FIELD_VALUE); when(buffer.nextToken()).thenReturn(JsonToken.FIELD_VALUE); when(buffer.nextToken()).thenReturn(JsonToken.FIELD_TYPE); when(buffer.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(buffer.nextToken()).thenReturn(JsonToken.FIELD_VALUE); when(buffer.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(propertyBasedCreator.startBuilding(jp, ctxt, null)).thenReturn(buffer); when(propertyBasedCreator.endBuilding(jp, ctxt, null)).thenReturn(buffer); Map<Object, Object> map = _mapUnderTest.__deserializeUsingCreator(jp, ctxt);
@Test public void _deserializeUsingCreator() throws IOException, JsonProcessingException { final String propertyValue = "{\"property\":\"propertyValue\"}"; final PropertyBasedCreator creator = mock(PropertyBasedCreator.class); when(creator.startBuilding(jp, ctxt, null)).thenReturn(buffer); when(buffer.nextToken()).thenReturn(JsonToken.START_OBJECT); when(jp.getCurrentToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.nextToken()).thenReturn(JsonToken.FIELD_VALUE); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(propertyBasedCreator.startBuilding(jp, ctxt, null)).thenReturn(buffer); when(propertyBasedCreator.endBuilding(jp, ctxt, null)).thenReturn(buffer); Map<Object, Object> map = _converter.__deserializeUsingCreator(jp, null); assertEquals(map, map); }
@Test public void _deserializeUsingCreator() throws IOException, JsonProcessingException { PropertyValueBuffer buffer = PropertyValueBuffer.createPropertyBuffer("foo"); buffer.writeObject("bar"); buffer.writeObject("baz"); Map<Object, Object> result = _propertyBasedCreator.build(_mapper.toJson(buffer), _ctxt, null); assertEquals("bar", result.get("bar")); assertEquals("baz", result.get("baz")); }
@Test public void _deserializeUsingCreator() throws IOException, JsonProcessingException { final String propertyValue = "{\"property\":\"value\"}"; final Map<Object, Object> map = _propertyBasedCreator.deserializeUsingCreator(jp, _ctxt, null); assertEquals("value", map.get("property")); }
@Test public void _deserializeUsingCreator() throws IOException, JsonProcessingException { final String propertyValue = "{\"property\":\"value\"}"; final JsonParser jp = mock(JsonParser.class); when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); when(jp.nextToken()).
@Test public void _deserializeUsingCreator() throws IOException, JsonProcessingException { final String value = "value"; final JsonParser jp = mock(JsonParser.class); when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME + 1); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME + 2); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME + 3); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME + 4); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME + 5); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME + 6); when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT + 9); when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT + 10); when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT
@Test public void _deserializeUsingCreator() throws IOException, JsonProcessingException { final String fieldName = "fieldName"; final JsonParser jp = mock(JsonParser.class); when(jp.getCurrentName()).thenReturn(fieldName); when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.nextToken()).thenReturn(JsonToken.FIELD_VALUE); when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); final Map<Object, Object> map = _propertyBasedCreator.__deserializeUsingCreator(jp, null); assertEquals(map.get(fieldName), "fieldName"); }
@Test public void testKeyDeserializer() throws IOException, JsonProcessingException { final String key = "key"; final String fieldName = "fieldName"; final Map<Object, Object> map = new HashMap<>(); map.put(key, "value"); map.put(key, "value"); final DeserializationContext ctxt = mock(DeserializationContext.class); when(ctxt.getDeserializer(fieldName)).thenReturn(new StringDeserializer()); when(ctxt.getDeserializer(fieldName)).thenReturn(new StringDeserializer()); when(keyDeserializer.deserializeKey(fieldName, ctxt)).thenReturn(map); final Map<Object, Object> actual = _underTest.deserializeUsingCreator(jp, ctxt); assertEquals(map, actual); }
@Test public void _deserializeUsingCreator() throws IOException, JsonProcessingException { final String value = "value"; final JsonParser jp = mock(JsonParser.class); when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME + 1); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME + 2); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME + 3); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME + 4); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME + 5); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME + 6); when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT + 7); when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT + 9); when(jp.nextToken()).thenReturn(JsonToken.START_
@Test public void _deserializeUsingCreator() throws IOException, JsonProcessingException { final String value = "value"; final PropertyBasedCreator creator = mock(PropertyBasedCreator.class); when(creator.startBuilding(jp, ctxt, null)).thenReturn(buffer); when(buffer.nextToken()).thenReturn(JsonToken.START_OBJECT); when(jp.getCurrentToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.nextToken()).thenReturn(JsonToken.FIELD_VALUE); when(buffer.nextToken()).thenReturn(JsonToken.FIELD_VALUE); Map<Object, Object> actualMap = new SettabMap(_propertyBasedCreator).__deserializeUsingCreator(jp, ctxt); assertEquals(actualMap, map); }
@Test public void _deserializeUsingCreator() throws IOException, JsonProcessingException { final String propertyValue = "foo"; final PropertyBasedCreator creator = mock(PropertyBasedCreator.class); when(creator.startBuilding(jp, null, null)).thenReturn(buffer); when(buffer.nextToken()).thenReturn(JsonToken.START_OBJECT); when(jp.getCurrentToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.nextToken()).thenReturn(JsonToken.FIELD_VALUE); when(propertyBasedCreator.startBuilding(jp, null, null)).thenReturn(buffer); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.getCurrentToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.nextToken()).thenReturn(JsonToken.FIELD_VALUE); when(propertyBasedCreator.endBuilding(jp, null, null)).thenReturn(buffer); final Map<Object, Object> map = _propertyBasedCreator.__deserializeUsingCreator(jp, null); assertEquals(propertyValue, map); }
@Test public void _deserializeUsingCreator() throws IOException, JsonProcessingException { final String value = "value"; final DeserializationContext ctxt = mock(DeserializationContext.class); when(ctxt.getDeserializer()).thenReturn(mock(JsonDeserializer.class)); when(mock(JsonDeserializer.class).deserialize(jp, ctxt)).thenReturn(value); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.nextToken()).
@Test public void bufferMapProperty() throws IOException, JsonProcessingException { PropertyValueBuffer buffer = propertyValueBuffer(new String[] { "foo", "bar" }); jp.nextToken(); buffer.bufferMapProperty(key, value); Mockito.verify(propertyBasedCreator).startBuilding(jp, ctxt, null); Mockito.verify(propertyBasedCreator).endBuilding(jp, ctxt, null); }
@Test public void unwrappingDeserializer() throws Exception { JsonDeserializer<Object> de = new JsonDeserializer<Object>() { @Override public Object deserialize(JsonParser jp, DeserializationContext ctxt, Object intoValue) throws IOException, JsonProcessingException { return de.deserializeWithType(jp, ctxt, null); } }; de.unwrappingDeserializer(NameTransformer.INSTANCE); assertEquals(null, de.getDelegatee()); de.getDelegatee(); }
@Test public void unwrappingDeserializer() throws IOException, JsonProcessingException { JsonDeserializer<String> mock = mock(JsonDeserializer.class); when(mock.unwrappingDeserializer(NameTransformer.class)).thenReturn(mock); JsonDeserializer<String> mock2 = mock(JsonDeserializer.class); when(mock2.unwrappingDeserializer(NameTransformer.class)).thenReturn(mock2); assertEquals(mock, mock.unwrappingDeserializer(NameTransformer.class)); }
@Test public void testFormat() { assertEquals("2008-02-23T00:00:00Z",format(date(2018, 2, 23, 59, 999), TimeZone.getTimeZone("GMT"))); assertEquals("2008-02-23T00:00:00Z",format(date(2018, 2, 23, 59, 999), TimeZone.getTimeZone("GMT"))); assertEquals("2008-02-23T00:00:00Z",format(date(2018, 2, 23, 59, 999), TimeZone.getTimeZone("GMT"))); assertEquals("2008-02-23T00:00:00Z",format(date(2018, 2, 23, 59, 999), TimeZone.getTimeZone("GMT"))); assertEquals("2008-02-23T00:00:00Z",format(date(2018, 2, 23, 59, 999), TimeZone.getTimeZone("GMT"))); assertEquals("2008-02-23T00:00:00Z",format(date(2018, 2, 23, 59, 999), TimeZone.getTimeZone("GMT"))); assertEquals("2008-02-23T00:00:00Z",format(date(2018, 2, 23, 59, 999), TimeZone.getTimeZone("GMT"))); assertEquals("2008-02-23T00:00:00Z",format(date(2018, 2, 23, 59, 999), TimeZone.getTimeZone("GMT"))); assertEquals("2008-02-23T00:00:00Z",format(date(2018, 2, 23, 59, 999), TimeZone.
@Test public void testFormat() { String date = "2015-03-03T12:15:00.001Z"; String result = [LINE].format(date, true); assertEquals("2015-03-03T12:15:00.001Z", result); date = "2015-03-03T12:15:00Z"; result = [LINE].format(date, true); assertEquals("2015-03-03T12:15:00Z", result); date = "2015-03-03T12:15:00Z"; result = [LINE].format(date, true); assertEquals("2015-03-03T12:15:00Z", result); date = "2015-03-03T12:15:00Z"; result = [LINE].format(date, true); assertEquals("2015-03-03T12:15:00Z", result); date = "2015-03-03T12:15:00Z"; result = [LINE].format(date, true); assertEquals("2015-03-03T12:15:00Z", result); date = "2015-03-03T12:15:00Z"; result = [LINE].format(date, true); assertEquals("2015-03-03T12:15:00Z", result); date = "2015-03-03T12:15:00Z"; result = [LINE].format(date, true); assertEquals("
@Test public void testFormat() { String formatted = format(date, false, tz); assertEquals("yyyy-MM-dd", formatted); }
@Test public void testPadMillis() { assertEquals("yyyy-MM-ddThh:mm:sss", format(date, false, tz)); assertEquals("yyyy-MM-ddThh:mm:sss", format(date, true, tz)); assertEquals("yyyy-MM-ddThh:mm:sss", format(date, true, tz)); assertEquals("yyyy-MM-ddThh:mm:sss", format(date, true, tz)); assertEquals("yyyy-MM-ddThh:mm:sss", format(date, true, tz)); assertEquals("yyyy-MM-ddThh:mm:sss", format(date, true, tz)); assertEquals("yyyy-MM-ddThh:mm:sss", format(date, true, tz)); assertEquals("yyyy-MM-ddThh:mm:sss", format(date, true, tz)); assertEquals("yyyy-MM-ddThh:mm:sss", format(date, true, tz)); assertEquals("yyyy-MM-ddThh:mm:sss", format(date, true, tz)); assertEquals("yyyy-MM-ddThh:mm:sss", format
@Test public void testHours() { assertEquals(0, format(date(2016, 1, 1, 1), HOUR)); assertEquals(0, format(date(2016, 1, 2, 2), HOUR)); assertEquals(0, format(date(2016, 1, 3, 3), HOUR)); assertEquals(0, format(date(2016, 1, 4, 3), HOUR)); assertEquals(0, format(date(2016, 1, 5, 3), HOUR)); assertEquals(0, format(date(2016, 1, 6, 7), HOUR)); assertEquals(0, format(date(2016, 1, 7, 3), HOUR)); assertEquals(0, format(date(2016, 1, 8, 0), HOUR)); assertEquals(0, format(date(2016, 1, 9, 0), HOUR)); assertEquals(0, format(date(2016, 1, 10, 0), HOUR)); assertEquals(0, format(date(2016, 1, 12, 0), HOUR)); assertEquals(0, format(date(2016, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 1, 12, 1, 1, 12, 1, 1, 12, 1, 1, 1, 12, 1, 1, 1, 12, 1, 1, 1, 12, 1, 1, 1, 12, 1, 1, 1, 1, 12, 1, 1, 1, 1, 12, 1, 1, 1, 1, 12, 1, 1, 1, 1, 12, 1, 1, 1, 1, 12, 1, 1, 1, 1, 12, 1, 1, 1, 1, 12, 1, 1, 1, 1, 12, 1, 1, 1, 12, 1, 1, 1, 12, 1, 1, 1, 12, 1, 1, 1, 12, 1, 1, 1, 12,
@Test public void testMinute() { String minutes = format(date, true, tz); assertEquals("yyyy-MM-ddThh:mm:ss", minutes); }
@Test public void test_format_offset() { String formatted = new StringBuilder(new String[] { "-yyyy-MM-ddThh:mm:ss", "-yyyy-MM-ddThh:mm:ss", "-yyyy-MM-ddThh:mm:ss", "-yyyy-MM-ddThh:mm:ss", "-yyyy-MM-ddThh:mm:ss", "-yyyy-MM-ddThh:mm:ss", "-yyyy-MM-ddThh:mm:ss", "-yyyy-MM-ddThh:mm:ss", "-yyyy-MM-ddThh:mm:ss", "-yyyy-MM-ddThh:mm:ss", "-yyyy-MM-ddThh:mm:ss", "-yyyy-MM-ddThh:mm:ss", "-yyyy-MM-ddThh:mm:ss", "-yyyy-MM-ddThh:mm:ss", "-yyyy-MM-ddThh:mm:ss", "-yyyy-MM-ddThh:mm:ss", "-yyyy-MM-ddThh:mm:ss", "-yyyy-MM-ddThh:mm:ss",
@Test public void testPadInt() { assertEquals("yyyy-MM-ddThh:mm:ss", format(date(2014, Calendar.YEAR, 1, 1), 0, 0)); assertEquals("yyyy-MM-ddThh:mm:ss", format(date(2014, Calendar.MONTH, 1, 1), 0, 0)); assertEquals("yyyy-MM-ddThh:mm:ss", format(date(2014, Calendar.DAY_OF_MONTH, 1, 1), 0, 0)); assertEquals("yyyy-MM-ddThh:mm:ss", format(date(2014, Calendar.HOUR_OF_DAY, 1, 1), 0, 0)); assertEquals("yyyy-MM-ddThh:mm:ss", format(date(2014, Calendar.MINUTE, 1, 1), 0, 0)); assertEquals("yyyy-MM-ddThh:mm:ss", format(date(2014, Calendar.HOUR_OF_DAY, 1, 1), 0, 0)); assertEquals("yyyy-MM-ddThh:mm:ss", format(date(2014, Calendar.MINUTE, 1, 1), 0, 0)); assertEquals("yyyy-MM-ddThh:mm:ss", format(date(2014, Calendar.HOUR_OF_DAY, 1, 1), 0, 0)); assertEquals("yyyy-
@Test public void testFormat() { String formatted = format(date, false, tz); assertEquals("yyyy-MM-dd'T'HH:mm:ss", formatted); }
@Test public void testPadInt() { String[] minutes = new String[] { "yyyy-MM-dd", "yyyy-MM-dd-HH", "mm", "mm", "mm", "mm", "mm", "mm", "mm", "mm", "mm", "mm", "mm", "mm", "mm", "mm", "mm", "mm", "mm", "mm", "mm", "mm", "mm", "mm", "mm", "mm", "mm", "mm", "mm", "mm", "mm", "mm", "mm", "mm", "mm", "mm", "mm", "mm", "mm", "mm", "mm", "mm", "mm", "mm", "mm", "mm", "mm", "mm", "mm", "mm", "mm", "mm", "mm", "mm", "mm", "mm", "mm", "mm", "mm", "mm", "mm", "mm", "mm", "mm", "mm", "mm", "mm", "mm", "mm", "mm", "mm", "mm", "mm", "mm", "mm", "mm",
@Test public void testTokenBufferDeserializer() throws Exception { JsonDeserializer<?> deserializer = DeserializerFactory.find(TokenBuffer.class); assertThat(deserializer).isNotNull(); assertThat(deserializer instanceof TokenBufferDeserializer); }
@Test public void testJavaTypeDeserializer() { }
@Test public void testDeserializeEmptyString() throws IOException, JsonProcessingException { JsonParser jp = mock(JsonParser.class); when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); when(jp.getText()).thenReturn(""); JavaType expectedType = mock(JavaType.class); when(jp.getEmbeddedObject()).thenReturn(expectedType); JavaType actualType = deserializer.deserialize(jp, ctxt); assertEquals(expectedType, actualType); }
@Test public void testDeserialization() throws Exception { JsonParser jp = mock(JsonParser.class); JsonToken nullValue = mock(JsonToken.class); JsonToken nullValue2 = mock(JsonToken.class); when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); when(jp.getText()).thenReturn("value"); when(jp.getToken()).thenReturn(JsonToken.VALUE_EMBEDDED_OBJECT); when(jp.getEmbeddedObject()).thenReturn(null); JavaType expectedType = mock(JavaType.class); when(jp.getToken()).thenReturn(JsonToken.VALUE_STRING); when(jp.getEmbeddedObject()).thenReturn(expectedType); DeserializationContext ctxt = mock(DeserializationContext.class); when(ctxt.getTypeFactory()).thenReturn(expectedType); JsonParser mock = mock(JsonParser.class); when(mock.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); when(mock.getText()).thenReturn("value"); when(mock.getCurrentToken()).thenReturn(JsonToken.VALUE_EMBEDDED_OBJECT); JsonDeserializer<JavaType> deseriali = new JsonDeserializer<JavaType>() { @Override public JavaType deserialize(JsonParser jp
@Test public void testDeserializationOfString() throws Exception { JsonParser jp = mock(JsonParser.class); JsonToken value = mock(JsonToken.class); JsonToken value2 = mock(JsonToken.class); when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); when(jp.getText()).thenReturn("value"); when(jp.getToken()).thenReturn(JsonToken.VALUE_STRING); when(jp.getEmbeddedObject()).thenReturn(JavaType.valueOf("value")); JavaType deserialized = deserializer.deserialize(jp, ctxt); assertEquals(JavaType.valueOf("value"), deserialized); }
@Test public void testDeserialize() throws Exception { String value = "string"; MockJsParser mockJp = new MockJsParser(value); when(mockJp.getText()).thenReturn(value); JavaType actual = deserializer.deserialize(mockJp, ctxt); assertEquals(actual, expectedType); }
@Test public void test_empty_string() throws IOException, JsonProcessingException { Mockito.when(jp.getText()).thenReturn(""); JavaType expectedType = new JavaType(String.class); Mockito.when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); Mockito.when(jp.getEmbeddedObject()).thenReturn(expectedType); JavaType actual = deserializer.deserialize(jp, ctxt); Assert.assertEquals(expectedType, actual); }
@Test public void shouldDeserialiseFromCanonical() throws Exception { JsonParser jp = mock(JsonParser.class); when(jp.getText()).thenReturn("\"value\""); when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); when(jp.getToken()).thenReturn(JsonToken.VALUE_EMBEDDED_OBJECT); when(ctxt.getTypeFactory()).thenReturn(new SimpleTypeFactory()); JavaType actual = deserializer.deserialize(jp, ctxt); assertThat(actual, equalTo(JavaType.valueOf("value"))); }
@Test public void setDefaultKeySerializer() { JsonSerializer<Object> ks = new JsonSerializer<Object>() { @Override public void serialize(Object value, SerializationConfig config) throws IOException { } }; _provider.setDefaultKeySerializer(ks); _provider.setNullValueSerializer(ks); _provider.setDefaultKeySerializer(null); _provider.setNullKeySerializer(ks); _provider.setNullValueSerializer(null); }
@Test public void setDefaultKeySerializer() { SerializationConfig config = new SerializationConfig(); config.setSerializationView(String.class); MockSerializerProvider provider = new MockSerializerProvider(); provider.setDefaultKeySerializer(new JsonSerializer<Object>() { @Override public void serialize(Object value, JsonWriter writer) throws IOException { writer.write("hello"); } }); MockSerializer ks = new MockSerializer(); provider.setDefaultKeySerializer(ks); SerializationConfig config2 = new SerializationConfig(); config2.setSerializationView(String.class); provider.setNullValueSerializer(ks); MockSerializerProvider provider2 = new MockSerializerProvider(); provider2.setDefaultKeySerializer(ks2); SerializationConfig config3 = new SerializationConfig(); config3.setSerializationView(String.class); provider2.setNullValueSerializer(ks3); MockSerializerProvider provider3 = new MockSerializerProvider(); provider3.setDefaultKeySerializer(ks3); SerializationConfig config = new SerializationConfig(); config.setSerializationView(String.class); provider3.setNullValueSerializer(ks3); MockSerializerProvider provider4 = new MockSerializerProvider(); provider4.setDefaultKeySerializer(ks4); SerializationConfig config4 = new SerializationConfig(); config4.setSerializationView(String.class); provider4.setNullValue
@Test public void test_setDefaultKeySerializer() { SerializationConfig config = new SerializationConfig(); MockSerializerProvider provider = new MockSerializerProvider(); MockSerializerProvider.setNullValueSerializer(null); MockSerializerProvider.setNullKeySerializer(null); SerializationProvider provider2 = new MockSerializerProvider(); MockSerializerProvider.setNullKeySerializer(null); SerializationConfig config2 = new MockSerializationConfig(); MockSerializerProvider.setNullKeySerializer(null); SerializationProvider provider3 = new MockSerializerProvider(); MockSerializerProvider.setNullKeySerializer(null); SerializationProvider.setNullValueSerializer(null); SerializationProvider.setSerializationView(MockSerializationView.class); MockSerializerProvider.setEnabled(true); MockSerializerProvider.setEnabled(false); MockSerializerProvider.setEnabled(true); MockSerializerProvider.setEnabled(true); MockSerializerProvider.setEnabled(false); MockSerializerProvider.setEnabled(true); MockSerializerProvider.setEnabled(true); MockSerializerProvider.setEnabled(true); MockSerializerProvider.setEnabled(false); MockSerializerProvider.setEnabled(true); MockSerializerProvider.setEnabled(true); MockSerializerProvider.setEnabled(true); MockSerializerProvider.setEnabled(true); Mock
@Test public void testNullValueSerializer() { JsonSerializer<Object> mock = mock(JsonSerializer.class); _nullValueSerializer.setNullValueSerializer(mock); }
@Test public void testNullValueSerializer() { classUnderTest.setNullValueSerializer(null); }
@Test public void testNullValueSerializer() { JsonSerializer<Object> mock = mock(JsonSerializer.class); _provider.setNullValueSerializer(mock); verify(mock, atLeastOnce()).setNullValueSerializer(any(JsonSerializer.class)); }
@Test public void testGetLocale() { SerializationConfig config = new SerializationConfig(); config.setLocale(Locale.US); ClasRepositoryManager mgr = new ClasRepositoryManager(config); mgr.addRepository(new TestRepository()); Locale locale = mgr.getLocale(); Assert.assertEquals(Locale.US, locale); }
@Test public void testGetLocale() { SerializationConfig config = new SerializationConfig(); config.setLocale(Locale.US); ClasRepositoryManager mgr = new ClasRepositoryManager(config); mgr.addRepository(new TestRepository()); Locale locale = mgr.getLocale(); Assert.assertEquals(Locale.US, locale); }
@Test public void testTimeZone() { TimeZone tz = TimeZone.getTimeZone("Europe/London"); assertEquals(tz.getTimeZone(), TimeZone.getTimeZone("Europe/London")); }
@Test public void testGetTimeZone() { TimeZone tz = TimeZone.getTimeZone("GMT"); assertEquals(tz, _config.getTimeZone()); }
@Test public void testFindTypedValueSerializerCache() throws JsonMappingException { TestConfig config = new TestConfig(); TestSerializerCache cache = new TestSerializerCache(); config.registerSerializerProvider(new TestSerializerProvider(), cache); TestSerializerFactory factory = new TestSerializerFactory(); TestSerializer testSerializer = new TestSerializer(factory, config); JsonSerializer<Object> ser = _provider.findTypedValueSerializer(TestValueType.class, true, cache); Assert.assertTrue(ser instanceof TestSerializerCache); Assert.assertTrue(cache.isTypedSerializer(TestValueType.class)); Assert.assertTrue(ser.isCache()); }
@Test public void testSerializeNull() throws IOException, JsonProcessingException { ByteArrayOutputStream baos = new ByteArrayOutputStream(); JsonGenerator jgen = new JsonFactory().createGenerator(baos); serializerProvider.defaultSerializeNull(jgen); jgen.flush(); String s = baos.toString(); Assert.assertTrue(s.contains("null")); }
@Test public void testSerializeNullNull() throws IOException { final JsonSerializer<Object> ks = jgen.createSerializer(NullValue.class); ks.serialize(null, jgen, this); jgen.flush(); final ByteArrayOutputStream baos = new ByteArrayOutputStream(); ks.getDefaultNullValueSerializer().serialize(null, jgen, this); Assert.assertEquals(baos.toString(), "null"); }
@Test public void testReportIncompatibleRootType() throws Exception { JavaType rootType = ClassUtil.wrapperType(String.class); try { _provider.reportIncompatibleRootType("foo", rootType); fail("Should not be able to serialize an Integer"); } catch (JsonMappingException e) { } try { _provider.reportIncompatibleRootType("foo", rootType); fail("Should not be able to serialize an Integer"); } catch (JsonMappingException e) { } }
@Test public void testReportIncompatibleRootType() throws Exception { JavaType rootType = ClassUtil.wrapperType(String.class); try { _provider.reportIncompatibleRootType("hello", rootType); fail("Should not be able to serialize an Object"); } catch (JsonMappingException e) { } }
@Test public void testReportIncompatibleRootType() throws Exception { Class<?> wrapperType = ClassUtil.wrapperType(String.class); _reportIncompatibleRootType(wrapperType, JavaType.STRING); _reportIncompatibleRootType(wrapperType, JavaType.STRING); _reportIncompatibleRootType(wrapperType, JavaType.STRING); _reportIncompatibleRootType(wrapperType, JavaType.STRING); _reportIncompatibleRootType(wrapperType, JavaType.STRING); _reportIncompatibleRootType(wrapperType, JavaType.STRING); _reportIncompatibleRootType(wrapperType, JavaType.STRING); _reportIncompatibleRootType(wrapperType, JavaType.STRING); _reportIncompatibleRootType(wrapperType, JavaType.STRING); _reportIncompatibleRootType(wrapperType, JavaType.STRING); _reportIncompatibleRootType(wrapperType, JavaType.STRING); _reportIncompatibleRootType(wrapperType, JavaType.STRING); _reportIncompatibleRootType(wrapperType, JavaType.STRING); _reportIncompatibleRootType(wrapperType, JavaType.STRING); _reportIncompatibleRootType(wrapperType, JavaType.STRING); _reportIncompatibleRootType(wrapperType, JavaType.STRING); _reportIncompatible
@Test public void testReportIncompatibleRootType() throws Exception { JavaType rootType = ClassUtil.wrapperType(String.class); _reportIncompatibleRootType(new String("hello"), rootType); _reportIncompatibleRootType(new Integer("hello"), rootType); _reportIncompatibleRootType(new Double("hello"), rootType); _reportIncompatibleRootType(new Double("hello"), rootType); _reportIncompatibleRootType(new Double("hello"), rootType); _reportIncompatibleRootType(new Double("hello"), rootType); _reportIncompatibleRootType(new Double("hello"), rootType); _reportIncompatibleRootType(new Double("hello"), rootType); _reportIncompatibleRootType(new Double("hello"), rootType); _reportIncompatibleRootType(new Double("hello"), rootType); _reportIncompatibleRootType(new Double("hello"), rootType); _reportIncompatibleRootType(new Double("hello"), rootType); _reportIncompatibleRootType(new Double("hello"), rootType); _reportIncompatibleRootType(new Double("hello"), rootType); _reportIncompatibleRootType(new Double("hello"), rootType); _reportIncompatibleRootType(new Double("hello"), rootType); _reportIncompatible
@Test public void testReportIncompatibleRootType() throws IOException, JsonMappingException { class MyEnum { private final String s = "abc"; @Override public String toString() { return s; } } MyEnum myEnum = new MyEnum(); myEnum._reportIncompatibleRootType(myEnum, JavaTypes.getEnumType(MyEnum.class)); }
@Test public void testReportIncompatibleRootType() throws Exception { try { new MockUp<JavaType>() { @Mock public Class<? extends JavaType> get() { return null; } }; fail("should have thrown"); } catch (JsonMappingException e) { } try { new MockUp<JavaType>() { @Mock public Class<? extends JavaType> get() { return null; } }; fail("should have thrown"); } catch (JsonMappingException e) { } try { new MockUp<JavaType>() { @Mock public Class<? extends JavaType> get() { return null; } }; fail("should have thrown"); } catch (JsonMappingException e) { } try { new MockUp<JavaType>() { @Mock public Class<? extends JavaType> get() { return null; } }; fail("should have thrown"); } catch (JsonMappingException e) { } try { new MockUp<JavaType>() { @Mock public Class<? extends JavaType> get() { return null; } }; fail("should have thrown"); } catch (JsonMappingException e) { } }
@Test public void testCreateAndCacheUntypedSerializer() throws JsonMappingException { SerializationConfig config = new SerializationConfig(); config.setAllowJsonDeserialization(true); config.setAllowJsonDeserializationSchema(true); MockSerializerProvider mock = new MockSerializerProvider(); MockSerializerProvider provider = new MockSerializerProvider(); provider.setNullValueSerializer(mock); MockSerializerProvider cache = new MockSerializerProvider(); MockSerializerProvider cacheSpy = new MockSerializerProvider(); try { provider.createAndCacheUntypedSerializer(MyEnum.class); fail(); } catch (JsonMappingException iae) { } try { provider.createAndCacheUntypedSerializer(MyEnum.class); fail(); } catch (JsonMappingException iae) { } MockSerializerProvider cacheSpy = new MockSerializerProvider(); try { provider.createAndCacheUntypedSerializer(MyEnum.class); fail(); } catch (JsonMappingException iae) { } MockSerializerProvider cache = new MockSerializerProvider(); try { provider.createAndCacheUntypedSerializer(MyEnum.class); fail(); } catch (JsonMappingException iae) { } try { provider.createAndCacheUntypedSerializer(MyEnum.class); fail(); } catch (
