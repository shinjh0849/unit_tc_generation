public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser("[ 1, true ]"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals("[", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testAsInt() throws Exception { [EOL]     final String input = "[ 1, -3, 4.98, true, false, null, \"-17\", \"foo\" ]"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testAsInt() throws Exception { [EOL]     final String input = "[ 1, -3, 4.98, true, false, null, \"-17\", \"foo\" ]"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE
public void testAsInt() throws Exception { [EOL]     final String input = "[ 1, -3, 4.98, true, false, null, \"-17\", \"foo\" ]"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testInvalidIntAccess() throws Exception { [EOL]     JsonParser jp = createParserUsingReader("[ \"abc\" ]"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getIntValue(); [EOL]         fail("Expected error trying to call getIntValue on non-numeric value"); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, "can not use numeric value accessors"); [EOL]     } [EOL]     jp.close(); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testAsInt() throws Exception { [EOL]     final String input = "[ 1, -3, 4.98, true, false, null, \"-17\", \"foo\" ]"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testAsInt() throws Exception { [EOL]     final String input = "[ 1, -3, 4.98, true, false, null, \"-17\", \"foo\" ]"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE
public void testAsInt() throws Exception { [EOL]     final String input = "[ 1, -3, 4.98, true, false, null, \"-17\", \"foo\" ]"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE
public void testAsInt() throws Exception { [EOL]     final String input = "[ 1, -3, 4.98, true, false, null, \"-17\", \"foo\" ]"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testAsInt() throws Exception { [EOL]     final String input = "[ 1, -3, 4.98, true, false, null, \"-17\", \"foo\" ]"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE
public void testAsInt() throws Exception { [EOL]     final String input = "[ 1, -3, 4.98, true, false, null, \"-17\", \"foo\" ]"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE
public void testAsInt() throws Exception { [EOL]     final String input = "[ 1, -3, 4.98, true, false, null, \"-17\", \"foo\" ]"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE
public void testAsInt() throws Exception { [EOL]     final String input = "[ 1, -3, 4.98, true, false, null, \"-17\", \"foo\" ]"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE
public void testAsInt() throws Exception { [EOL]     final String input = "[ 1, -3, 4.98, true, false, null, \"-17\", \"foo\" ]"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE
public void testAsInt() throws Exception { [EOL]     final String input = "[ 1, -3, 4.98, true, false, null, \"-17\", \"foo\" ]"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE
public void testAsInt() throws Exception { [EOL]     final String input = "[ 1, -3, 4.98, true, false, null, \"-17\", \"foo\" ]"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE
public void testInvalidIntAccess() throws Exception { [EOL]     JsonParser jp = createParserUsingReader("[ \"abc\" ]"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getIntValue(); [EOL]         fail("Expected error trying to call getIntValue on non-numeric value"); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, "can not use numeric value accessors"); [EOL]     } [EOL]     jp.close(); [EOL] }
public void testInvalidIntAccess() throws Exception { [EOL]     JsonParser jp = createParserUsingReader("[ \"abc\" ]"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getIntValue(); [EOL]         fail("Expected error trying to call getIntValue on non-numeric value"); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, "can not use numeric value accessors"); [EOL]     } [EOL]     jp.close(); [EOL] }
public void testAsInt() throws Exception { [EOL]     final String input = "[ 1, -3, 4.98, true, false, null, \"-17\", \"foo\" ]"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE
public void testAsInt() throws Exception { [EOL]     final String input = "[ 1, -3, 4.98, true, false, null, \"-17\", \"foo\" ]"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE
public void testSimpleValidString() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String JSON = "\"JSON!\""; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes("UTF-8"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals("JSON", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.WEAK_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals("JSON!", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleVariant() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = "{ \"a\" : 1, \"x\" : [ ] }"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testSimple() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = "{ \"a\" : 1, \"x\" : [ ] }"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testSimple() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = "{ \"a\" : 1, \"x\" : [ ] }"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testSimple() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = "{ \"a\" : 1, \"x\" : [ ] }"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testSimpleVariant() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = "{ \"a\" : 1, \"x\" : [ ] }"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testSimpleWriteObject() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(1); [EOL]     gen.writeObject((short) -2); [EOL]     gen.writeObject((long) 3); [EOL]     gen.writeObject((byte) -4); [EOL]     gen.writeObject(0.25); [EOL]     gen.writeObject(-0.125f); [EOL]     gen.writeObject(Boolean.TRUE); [EOL]     gen.close(); [EOL]     String act = sw.toString().trim(); [EOL]     assertEquals("[1,-2,3,-4,0.25,-0.125,true]", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(BigInteger.valueOf(1234)); [EOL]     gen.writeObject(new BigDecimal(0.5)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals("[1234,0.5]", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(new AtomicBoolean(false)); [EOL]     gen.writeObject(new AtomicInteger(13)); [EOL]     gen.writeObject(new AtomicLong(-127L)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals("[false,13,-127]", act); [EOL] }
public void testSimpleWriteObject() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(1); [EOL]     gen.writeObject((short) -2); [EOL]     gen.writeObject((long) 3); [EOL]     gen.writeObject((byte) -4); [EOL]     gen.writeObject(0.25); [EOL]     gen.writeObject(-0.125f); [EOL]     gen.writeObject(Boolean.TRUE); [EOL]     gen.close(); [EOL]     String act = sw.toString().trim(); [EOL]     assertEquals("[1,-2,3,-4,0.25,-0.125,true]", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(BigInteger.valueOf(1234)); [EOL]     gen.writeObject(new BigDecimal(0.5)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals("[1234,0.5]", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(new AtomicBoolean(false)); [EOL]     gen.writeObject(new AtomicInteger(13)); [EOL]     gen.writeObject(new AtomicLong(-127L)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals("[false,13,-127]", act); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal("0.1"); [EOL]     final String TEXT = "\"some\nString!\""; [EOL]     gen.writeNullField("null"); [EOL]     gen.writeBooleanField("bt", true); [EOL]     gen.writeBooleanField("bf", false); [EOL]     gen.writeNumberField("int", -1289); [EOL]     gen.writeNumberField("dec", dec); [EOL]     gen.writeObjectFieldStart("ob"); [EOL]     gen.writeStringField("str", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart("arr"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("null", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("bt", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("bf", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("int", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal("0.1"); [EOL]     final String TEXT = "\"some\nString!\""; [EOL]     gen.writeNullField("null"); [EOL]     gen.writeBooleanField("bt", true); [EOL]     gen.writeBooleanField("bf", false); [EOL]     gen.writeNumberField("int", -1289); [EOL]     gen.writeNumberField("dec", dec); [EOL]     gen.writeObjectFieldStart("ob"); [EOL]     gen.writeStringField("str", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart("arr"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("null", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("bt", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("bf", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("int", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.
public void testNextFieldName() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     SerializedString id = new SerializedString("id"); [EOL]     ByteArrayOutputStream os = new ByteArrayOutputStream(); [EOL]     os.write('{'); [EOL]     for (int i = 0; i < 3994; i++) { [EOL]         os.write(' '); [EOL]     } [EOL]     os.write("\"id\":2".getBytes("UTF-8")); [EOL]     os.write('}'); [EOL]     JsonParser parser = f.createParser(new ByteArrayInputStream(os.toByteArray())); [EOL]     assertEquals(parser.nextToken(), JsonToken.START_OBJECT); [EOL]     assertTrue(parser.nextFieldName(id)); [EOL]     assertEquals(parser.nextToken(), JsonToken.VALUE_NUMBER_INT); [EOL]     assertEquals(parser.nextToken(), JsonToken.END_OBJECT); [EOL]     parser.close(); [EOL] }
public void testNextFieldName() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     SerializedString id = new SerializedString("id"); [EOL]     ByteArrayOutputStream os = new ByteArrayOutputStream(); [EOL]     os.write('{'); [EOL]     for (int i = 0; i < 3994; i++) { [EOL]         os.write(' '); [EOL]     } [EOL]     os.write("\"id\":2".getBytes("UTF-8")); [EOL]     os.write('}'); [EOL]     JsonParser parser = f.createParser(new ByteArrayInputStream(os.toByteArray())); [EOL]     assertEquals(parser.nextToken(), JsonToken.START_OBJECT); [EOL]     assertTrue(parser.nextFieldName(id)); [EOL]     assertEquals(parser.nextToken(), JsonToken.VALUE_NUMBER_INT); [EOL]     assertEquals(parser.nextToken(), JsonToken.END_OBJECT); [EOL]     parser.close(); [EOL] }
public void testNextFieldName() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     SerializedString id = new SerializedString("id"); [EOL]     ByteArrayOutputStream os = new ByteArrayOutputStream(); [EOL]     os.write('{'); [EOL]     for (int i = 0; i < 3994; i++) { [EOL]         os.write(' '); [EOL]     } [EOL]     os.write("\"id\":2".getBytes("UTF-8")); [EOL]     os.write('}'); [EOL]     JsonParser parser = f.createParser(new ByteArrayInputStream(os.toByteArray())); [EOL]     assertEquals(parser.nextToken(), JsonToken.START_OBJECT); [EOL]     assertTrue(parser.nextFieldName(id)); [EOL]     assertEquals(parser.nextToken(), JsonToken.VALUE_NUMBER_INT); [EOL]     assertEquals(parser.nextToken(), JsonToken.END_OBJECT); [EOL]     parser.close(); [EOL] }
public void testNextFieldName() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     SerializedString id = new SerializedString("id"); [EOL]     ByteArrayOutputStream os = new ByteArrayOutputStream(); [EOL]     os.write('{'); [EOL]     for (int i = 0; i < 3994; i++) { [EOL]         os.write(' '); [EOL]     } [EOL]     os.write("\"id\":2".getBytes("UTF-8")); [EOL]     os.write('}'); [EOL]     JsonParser parser = f.createParser(new ByteArrayInputStream(os.toByteArray())); [EOL]     assertEquals(parser.nextToken(), JsonToken.START_OBJECT); [EOL]     assertTrue(parser.nextFieldName(id)); [EOL]     assertEquals(parser.nextToken(), JsonToken.VALUE_NUMBER_INT); [EOL]     assertEquals(parser.nextToken(), JsonToken.END_OBJECT); [EOL]     parser.close(); [EOL] }
public void testNextFieldName() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     SerializedString id = new SerializedString("id"); [EOL]     ByteArrayOutputStream os = new ByteArrayOutputStream(); [EOL]     os.write('{'); [EOL]     for (int i = 0; i < 3994; i++) { [EOL]         os.write(' '); [EOL]     } [EOL]     os.write("\"id\":2".getBytes("UTF-8")); [EOL]     os.write('}'); [EOL]     JsonParser parser = f.createParser(new ByteArrayInputStream(os.toByteArray())); [EOL]     assertEquals(parser.nextToken(), JsonToken.START_OBJECT); [EOL]     assertTrue(parser.nextFieldName(id)); [EOL]     assertEquals(parser.nextToken(), JsonToken.VALUE_NUMBER_INT); [EOL]     assertEquals(parser.nextToken(), JsonToken.END_OBJECT); [EOL]     parser.close(); [EOL] }
public void testNextFieldName() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     SerializedString id = new SerializedString("id"); [EOL]     ByteArrayOutputStream os = new ByteArrayOutputStream(); [EOL]     os.write('{'); [EOL]     for (int i = 0; i < 3994; i++) { [EOL]         os.write(' '); [EOL]     } [EOL]     os.write("\"id\":2".getBytes("UTF-8")); [EOL]     os.write('}'); [EOL]     JsonParser parser = f.createParser(new ByteArrayInputStream(os.toByteArray())); [EOL]     assertEquals(parser.nextToken(), JsonToken.START_OBJECT); [EOL]     assertTrue(parser.nextFieldName(id)); [EOL]     assertEquals(parser.nextToken(), JsonToken.VALUE_NUMBER_INT); [EOL]     assertEquals(parser.nextToken(), JsonToken.END_OBJECT); [EOL]     parser.close(); [EOL] }
public void testNextFieldName() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     SerializedString id = new SerializedString("id"); [EOL]     ByteArrayOutputStream os = new ByteArrayOutputStream(); [EOL]     os.write('{'); [EOL]     for (int i = 0; i < 3994; i++) { [EOL]         os.write(' '); [EOL]     } [EOL]     os.write("\"id\":2".getBytes("UTF-8")); [EOL]     os.write('}'); [EOL]     JsonParser parser = f.createParser(new ByteArrayInputStream(os.toByteArray())); [EOL]     assertEquals(parser.nextToken(), JsonToken.START_OBJECT); [EOL]     assertTrue(parser.nextFieldName(id)); [EOL]     assertEquals(parser.nextToken(), JsonToken.VALUE_NUMBER_INT); [EOL]     assertEquals(parser.nextToken(), JsonToken.END_OBJECT); [EOL]     parser.close(); [EOL] }
public void testNextFieldName() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     SerializedString id = new SerializedString("id"); [EOL]     ByteArrayOutputStream os = new ByteArrayOutputStream(); [EOL]     os.write('{'); [EOL]     for (int i = 0; i < 3994; i++) { [EOL]         os.write(' '); [EOL]     } [EOL]     os.write("\"id\":2".getBytes("UTF-8")); [EOL]     os.write('}'); [EOL]     JsonParser parser = f.createParser(new ByteArrayInputStream(os.toByteArray())); [EOL]     assertEquals(parser.nextToken(), JsonToken.START_OBJECT); [EOL]     assertTrue(parser.nextFieldName(id)); [EOL]     assertEquals(parser.nextToken(), JsonToken.VALUE_NUMBER_INT); [EOL]     assertEquals(parser.nextToken(), JsonToken.END_OBJECT); [EOL]     parser.close(); [EOL] }
public void testNextFieldName() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     SerializedString id = new SerializedString("id"); [EOL]     ByteArrayOutputStream os = new ByteArrayOutputStream(); [EOL]     os.write('{'); [EOL]     for (int i = 0; i < 3994; i++) { [EOL]         os.write(' '); [EOL]     } [EOL]     os.write("\"id\":2".getBytes("UTF-8")); [EOL]     os.write('}'); [EOL]     JsonParser parser = f.createParser(new ByteArrayInputStream(os.toByteArray())); [EOL]     assertEquals(parser.nextToken(), JsonToken.START_OBJECT); [EOL]     assertTrue(parser.nextFieldName(id)); [EOL]     assertEquals(parser.nextToken(), JsonToken.VALUE_NUMBER_INT); [EOL]     assertEquals(parser.nextToken(), JsonToken.END_OBJECT); [EOL]     parser.close(); [EOL] }
public void testNextFieldName() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     SerializedString id = new SerializedString("id"); [EOL]     ByteArrayOutputStream os = new ByteArrayOutputStream(); [EOL]     os.write('{'); [EOL]     for (int i = 0; i < 3994; i++) { [EOL]         os.write(' '); [EOL]     } [EOL]     os.write("\"id\":2".getBytes("UTF-8")); [EOL]     os.write('}'); [EOL]     JsonParser parser = f.createParser(new ByteArrayInputStream(os.toByteArray())); [EOL]     assertEquals(parser.nextToken(), JsonToken.START_OBJECT); [EOL]     assertTrue(parser.nextFieldName(id)); [EOL]     assertEquals(parser.nextToken(), JsonToken.VALUE_NUMBER_INT); [EOL]     assertEquals(parser.nextToken(), JsonToken.END_OBJECT); [EOL]     parser.close(); [EOL] }
public void testNextFieldName() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     SerializedString id = new SerializedString("id"); [EOL]     ByteArrayOutputStream os = new ByteArrayOutputStream(); [EOL]     os.write('{'); [EOL]     for (int i = 0; i < 3994; i++) { [EOL]         os.write(' '); [EOL]     } [EOL]     os.write("\"id\":2".getBytes("UTF-8")); [EOL]     os.write('}'); [EOL]     JsonParser parser = f.createParser(new ByteArrayInputStream(os.toByteArray())); [EOL]     assertEquals(parser.nextToken(), JsonToken.START_OBJECT); [EOL]     assertTrue(parser.nextFieldName(id)); [EOL]     assertEquals(parser.nextToken(), JsonToken.VALUE_NUMBER_INT); [EOL]     assertEquals(parser.nextToken(), JsonToken.END_OBJECT); [EOL]     parser.close(); [EOL] }
public void testNextFieldName() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     SerializedString id = new SerializedString("id"); [EOL]     ByteArrayOutputStream os = new ByteArrayOutputStream(); [EOL]     os.write('{'); [EOL]     for (int i = 0; i < 3994; i++) { [EOL]         os.write(' '); [EOL]     } [EOL]     os.write("\"id\":2".getBytes("UTF-8")); [EOL]     os.write('}'); [EOL]     JsonParser parser = f.createParser(new ByteArrayInputStream(os.toByteArray())); [EOL]     assertEquals(parser.nextToken(), JsonToken.START_OBJECT); [EOL]     assertTrue(parser.nextFieldName(id)); [EOL]     assertEquals(parser.nextToken(), JsonToken.VALUE_NUMBER_INT); [EOL]     assertEquals(parser.nextToken(), JsonToken.END_OBJECT); [EOL]     parser.close(); [EOL] }
public void testNextFieldName() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     SerializedString id = new SerializedString("id"); [EOL]     ByteArrayOutputStream os = new ByteArrayOutputStream(); [EOL]     os.write('{'); [EOL]     for (int i = 0; i < 3994; i++) { [EOL]         os.write(' '); [EOL]     } [EOL]     os.write("\"id\":2".getBytes("UTF-8")); [EOL]     os.write('}'); [EOL]     JsonParser parser = f.createParser(new ByteArrayInputStream(os.toByteArray())); [EOL]     assertEquals(parser.nextToken(), JsonToken.START_OBJECT); [EOL]     assertTrue(parser.nextFieldName(id)); [EOL]     assertEquals(parser.nextToken(), JsonToken.VALUE_NUMBER_INT); [EOL]     assertEquals(parser.nextToken(), JsonToken.END_OBJECT); [EOL]     parser.close(); [EOL] }
public void testNextFieldName() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     SerializedString id = new SerializedString("id"); [EOL]     ByteArrayOutputStream os = new ByteArrayOutputStream(); [EOL]     os.write('{'); [EOL]     for (int i = 0; i < 3994; i++) { [EOL]         os.write(' '); [EOL]     } [EOL]     os.write("\"id\":2".getBytes("UTF-8")); [EOL]     os.write('}'); [EOL]     JsonParser parser = f.createParser(new ByteArrayInputStream(os.toByteArray())); [EOL]     assertEquals(parser.nextToken(), JsonToken.START_OBJECT); [EOL]     assertTrue(parser.nextFieldName(id)); [EOL]     assertEquals(parser.nextToken(), JsonToken.VALUE_NUMBER_INT); [EOL]     assertEquals(parser.nextToken(), JsonToken.END_OBJECT); [EOL]     parser.close(); [EOL] }
public void testNextFieldName() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     SerializedString id = new SerializedString("id"); [EOL]     ByteArrayOutputStream os = new ByteArrayOutputStream(); [EOL]     os.write('{'); [EOL]     for (int i = 0; i < 3994; i++) { [EOL]         os.write(' '); [EOL]     } [EOL]     os.write("\"id\":2".getBytes("UTF-8")); [EOL]     os.write('}'); [EOL]     JsonParser parser = f.createParser(new ByteArrayInputStream(os.toByteArray())); [EOL]     assertEquals(parser.nextToken(), JsonToken.START_OBJECT); [EOL]     assertTrue(parser.nextFieldName(id)); [EOL]     assertEquals(parser.nextToken(), JsonToken.VALUE_NUMBER_INT); [EOL]     assertEquals(parser.nextToken(), JsonToken.END_OBJECT); [EOL]     parser.close(); [EOL] }
public void testNextFieldName() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     SerializedString id = new SerializedString("id"); [EOL]     ByteArrayOutputStream os = new ByteArrayOutputStream(); [EOL]     os.write('{'); [EOL]     for (int i = 0; i < 3994; i++) { [EOL]         os.write(' '); [EOL]     } [EOL]     os.write("\"id\":2".getBytes("UTF-8")); [EOL]     os.write('}'); [EOL]     JsonParser parser = f.createParser(new ByteArrayInputStream(os.toByteArray())); [EOL]     assertEquals(parser.nextToken(), JsonToken.START_OBJECT); [EOL]     assertTrue(parser.nextFieldName(id)); [EOL]     assertEquals(parser.nextToken(), JsonToken.VALUE_NUMBER_INT); [EOL]     assertEquals(parser.nextToken(), JsonToken.END_OBJECT); [EOL]     parser.close(); [EOL] }
public void testNextFieldName() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     SerializedString id = new SerializedString("id"); [EOL]     ByteArrayOutputStream os = new ByteArrayOutputStream(); [EOL]     os.write('{'); [EOL]     for (int i = 0; i < 3994; i++) { [EOL]         os.write(' '); [EOL]     } [EOL]     os.write("\"id\":2".getBytes("UTF-8")); [EOL]     os.write('}'); [EOL]     JsonParser parser = f.createParser(new ByteArrayInputStream(os.toByteArray())); [EOL]     assertEquals(parser.nextToken(), JsonToken.START_OBJECT); [EOL]     assertTrue(parser.nextFieldName(id)); [EOL]     assertEquals(parser.nextToken(), JsonToken.VALUE_NUMBER_INT); [EOL]     assertEquals(parser.nextToken(), JsonToken.END_OBJECT); [EOL]     parser.close(); [EOL] }
public void testNextFieldName() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     SerializedString id = new SerializedString("id"); [EOL]     ByteArrayOutputStream os = new ByteArrayOutputStream(); [EOL]     os.write('{'); [EOL]     for (int i = 0; i < 3994; i++) { [EOL]         os.write(' '); [EOL]     } [EOL]     os.write("\"id\":2".getBytes("UTF-8")); [EOL]     os.write('}'); [EOL]     JsonParser parser = f.createParser(new ByteArrayInputStream(os.toByteArray())); [EOL]     assertEquals(parser.nextToken(), JsonToken.START_OBJECT); [EOL]     assertTrue(parser.nextFieldName(id)); [EOL]     assertEquals(parser.nextToken(), JsonToken.VALUE_NUMBER_INT); [EOL]     assertEquals(parser.nextToken(), JsonToken.END_OBJECT); [EOL]     parser.close(); [EOL] }
public void testNextFieldName() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     SerializedString id = new SerializedString("id"); [EOL]     ByteArrayOutputStream os = new ByteArrayOutputStream(); [EOL]     os.write('{'); [EOL]     for (int i = 0; i < 3994; i++) { [EOL]         os.write(' '); [EOL]     } [EOL]     os.write("\"id\":2".getBytes("UTF-8")); [EOL]     os.write('}'); [EOL]     JsonParser parser = f.createParser(new ByteArrayInputStream(os.toByteArray())); [EOL]     assertEquals(parser.nextToken(), JsonToken.START_OBJECT); [EOL]     assertTrue(parser.nextFieldName(id)); [EOL]     assertEquals(parser.nextToken(), JsonToken.VALUE_NUMBER_INT); [EOL]     assertEquals(parser.nextToken(), JsonToken.END_OBJECT); [EOL]     parser.close(); [EOL] }
public void testNextFieldName() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     SerializedString id = new SerializedString("id"); [EOL]     ByteArrayOutputStream os = new ByteArrayOutputStream(); [EOL]     os.write('{'); [EOL]     for (int i = 0; i < 3994; i++) { [EOL]         os.write(' '); [EOL]     } [EOL]     os.write("\"id\":2".getBytes("UTF-8")); [EOL]     os.write('}'); [EOL]     JsonParser parser = f.createParser(new ByteArrayInputStream(os.toByteArray())); [EOL]     assertEquals(parser.nextToken(), JsonToken.START_OBJECT); [EOL]     assertTrue(parser.nextFieldName(id)); [EOL]     assertEquals(parser.nextToken(), JsonToken.VALUE_NUMBER_INT); [EOL]     assertEquals(parser.nextToken(), JsonToken.END_OBJECT); [EOL]     parser.close(); [EOL] }
public void testNextFieldName() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     SerializedString id = new SerializedString("id"); [EOL]     ByteArrayOutputStream os = new ByteArrayOutputStream(); [EOL]     os.write('{'); [EOL]     for (int i = 0; i < 3994; i++) { [EOL]         os.write(' '); [EOL]     } [EOL]     os.write("\"id\":2".getBytes("UTF-8")); [EOL]     os.write('}'); [EOL]     JsonParser parser = f.createParser(new ByteArrayInputStream(os.toByteArray())); [EOL]     assertEquals(parser.nextToken(), JsonToken.START_OBJECT); [EOL]     assertTrue(parser.nextFieldName(id)); [EOL]     assertEquals(parser.nextToken(), JsonToken.VALUE_NUMBER_INT); [EOL]     assertEquals(parser.nextToken(), JsonToken.END_OBJECT); [EOL]     parser.close(); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser("[ 1, true ]"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals("[", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser("[ 1, true ]"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals("[", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser("[ 1, true ]"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals("[", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser("[ 1, true ]"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals("[", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser("[ 1, true ]"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals("[", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser("[ 1, true ]"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals("[", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser("[ 1, true ]"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals("[", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser("[ 1, true ]"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals("[", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser("[ 1, true ]"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals("[", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser("[ 1, true ]"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals("[", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser("[ 1, true ]"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals("[", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser("[ 1, true ]"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals("[", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser("[ 1, true ]"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals("[", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser("[ 1, true ]"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals("[", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser("[ 1, true ]"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals("[", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser("[ 1, true ]"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals("[", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser("[ 1, true ]"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals("[", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser("[ 1, true ]"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals("[", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser("[ 1, true ]"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals("[", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser("[ 1, true ]"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals("[", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser("[ 1, true ]"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals("[", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser("[ 1, true ]"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals("[", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser("[ 1, true ]"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals("[", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser("[ 1, true ]"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals("[", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser("[ 1, true ]"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals("[", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser("[ 1, true ]"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals("[", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser("[ 1, true ]"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals("[", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser("[ 1, true ]"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals("[", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser("[ 1, true ]"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals("[", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser("[ 1, true ]"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals("[", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser("[ 1, true ]"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals("[", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser("[ 1, true ]"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals("[", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser("[ 1, true ]"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals("[", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser("[ 1, true ]"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals("[", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser("[ 1, true ]"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals("[", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser("[ 1, true ]"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals("[", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser("[ 1, true ]"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals("[", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser("[ 1, true ]"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals("[", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser("[ 1, true ]"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals("[", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser("[ 1, true ]"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals("[", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser("[ 1, true ]"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals("[", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser("[ 1, true ]"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals("[", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser("[ 1, true ]"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals("[", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser("[ 1, true ]"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals("[", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser("[ 1, true ]"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals("[", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testParserDelegate() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser("[ 1, true ]"); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals("[", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertTrue(jp.isClosed()); [EOL] }
public void testLongBoundsChecks() throws Exception { [EOL]     String minLong = String.valueOf(Long.MIN_VALUE).substring(1); [EOL]     String maxLong = String.valueOf(Long.MAX_VALUE); [EOL]     final String VALUE_491 = "1323372036854775807"; [EOL]     final String OVERFLOW = "9999999999999999999"; [EOL]     assertTrue(NumberInput.inLongRange(minLong, true)); [EOL]     assertTrue(NumberInput.inLongRange(maxLong, false)); [EOL]     assertFalse(NumberInput.inLongRange(VALUE_491, true)); [EOL]     char[] cbuf = minLong.toCharArray(); [EOL]     assertTrue(NumberInput.inLongRange(cbuf, 0, cbuf.length, true)); [EOL]     assertFalse(NumberInput.inLongRange(cbuf, 0, cbuf.length, false)); [EOL]     cbuf = maxLong.toCharArray(); [EOL]     assertTrue(NumberInput.inLongRange(cbuf, 0, cbuf.length, true)); [EOL]     assertFalse(NumberInput.inLongRange(cbuf, 0, cbuf.length, false)); [EOL]     cbuf = OVERFLOW.toCharArray(); [EOL]     assertTrue(NumberInput.inLongRange(cbuf, 0, cbuf.length, true)); [EOL]     assertFalse(NumberInput.inLongRange(cbuf, 0, cbuf.length, false)); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testLongBoundsChecks() throws Exception { [EOL]     String minLong = String.valueOf(Long.MIN_VALUE).substring(1); [EOL]     String maxLong = String.valueOf(Long.MAX_VALUE); [EOL]     final String VALUE_491 = "1323372036854775807"; [EOL]     final String OVERFLOW = "9999999999999999999"; [EOL]     assertTrue(NumberInput.inLongRange(minLong, true)); [EOL]     assertTrue(NumberInput.inLongRange(maxLong, false)); [EOL]     assertFalse(NumberInput.inLongRange(VALUE_491, true)); [EOL]     char[] cbuf = minLong.toCharArray(); [EOL]     assertTrue(NumberInput.inLongRange(cbuf, 0, cbuf.length, true)); [EOL]     assertFalse(NumberInput.inLongRange(cbuf, 0, cbuf.length, false)); [EOL]     cbuf = maxLong.toCharArray(); [EOL]     assertTrue(NumberInput.inLongRange(cbuf, 0, cbuf.length, true)); [EOL]     assertFalse(NumberInput.inLongRange(cbuf, 0, cbuf.length, false)); [EOL]     cbuf = OVERFLOW.toCharArray(); [EOL]     assertTrue(NumberInput.inLongRange(cbuf, 0, cbuf.length, true)); [EOL]     assertFalse(NumberInput.inLongRange(cbuf, 0, cbuf.length, false)); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testReleaseContentChars() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser("[true]xyz"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertEquals(3, jp.releaseBuffered(new ByteArrayOutputStream())); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testReleaseContentChars() throws Exception { [EOL]     JsonParser jp = new JsonFactory().createParser("[true]xyz"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertEquals(3, jp.releaseBuffered(new ByteArrayOutputStream())); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testReleaseContentChars() throws IOException { [EOL]     JsonParser jp = new JsonFactory().createParser("[true]xyz"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertEquals(3, jp.releaseBuffered(new ByteArrayOutputStream())); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testReleaseContentChars() throws Exception { [EOL]     JsonParser jp = new JsonFactory().createParser("[true]xyz"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertEquals(3, jp.releaseBuffered(new ByteArrayOutputStream())); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testReleaseContentChars() throws Exception { [EOL]     JsonParser jp = new JsonFactory().createParser("[true]xyz"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertEquals(3, jp.releaseBuffered(new ByteArrayOutputStream())); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testReleaseContentChars() throws Exception { [EOL]     JsonParser jp = new JsonFactory().createParser("[true]xyz"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertEquals(3, jp.releaseBuffered(new ByteArrayOutputStream())); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal("0.1"); [EOL]     final String TEXT = "\"some\nString!\""; [EOL]     gen.writeNullField("null"); [EOL]     gen.writeBooleanField("bt", true); [EOL]     gen.writeBooleanField("bf", false); [EOL]     gen.writeNumberField("int", -1289); [EOL]     gen.writeNumberField("dec", dec); [EOL]     gen.writeObjectFieldStart("ob"); [EOL]     gen.writeStringField("str", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart("arr"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("null", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("bt", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("bf", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("int", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { "1234.00", "2.1101567E-16", "1.0e5", "2.5e+5", "9e4", "-12e-3", "0.25" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = "[" + STR + "]"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, "UTF-8"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { "1234.00", "2.1101567E-16", "1.0e5", "2.5e+5", "9e4", "-12e-3", "0.25" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = "[" + STR + "]"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, "UTF-8"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { "1234.00", "2.1101567E-16", "1.0e5", "2.5e+5", "9e4", "-12e-3", "0.25" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = "[" + STR + "]"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, "UTF-8"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { "1234.00", "2.1101567E-16", "1.0e5", "2.5e+5", "9e4", "-12e-3", "0.25" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = "[" + STR + "]"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, "UTF-8"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testAsInt() throws Exception { [EOL]     final String input = "[ 1, -3, 4.98, true, false, null, \"-17\", \"foo\" ]"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(9, jp.getValueAsLong(9)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertEquals(1, jp.getValueAsLong(-99)); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-3, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(4, jp.getValueAsLong()); [EOL]         assertEquals(4, jp.getValueAsLong(99)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(1, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(0, jp.getValueAsLong()); [EOL]         assertEquals(0, jp.getValueAsLong(27)); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(-17, jp.getValueAsLong()); [EOL]         assertEquals(-17, jp.getValueAsLong(3)); [EOL]         assertToken(JsonToken.VALUE
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { "1234.00", "2.1101567E-16", "1.0e5", "2.5e+5", "9e4", "-12e-3", "0.25" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = "[" + STR + "]"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, "UTF-8"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { "1234.00", "2.1101567E-16", "1.0e5", "2.5e+5", "9e4", "-12e-3", "0.25" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = "[" + STR + "]"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, "UTF-8"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { "1234.00", "2.1101567E-16", "1.0e5", "2.5e+5", "9e4", "-12e-3", "0.25" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = "[" + STR + "]"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, "UTF-8"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { "1234.00", "2.1101567E-16", "1.0e5", "2.5e+5", "9e4", "-12e-3", "0.25" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = "[" + STR + "]"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, "UTF-8"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { "1234.00", "2.1101567E-16", "1.0e5", "2.5e+5", "9e4", "-12e-3", "0.25" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = "[" + STR + "]"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, "UTF-8"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { "1234.00", "2.1101567E-16", "1.0e5", "2.5e+5", "9e4", "-12e-3", "0.25" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = "[" + STR + "]"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, "UTF-8"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { "1234.00", "2.1101567E-16", "1.0e5", "2.5e+5", "9e4", "-12e-3", "0.25" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = "[" + STR + "]"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, "UTF-8"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { "1234.00", "2.1101567E-16", "1.0e5", "2.5e+5", "9e4", "-12e-3", "0.25" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = "[" + STR + "]"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, "UTF-8"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { "1234.00", "2.1101567E-16", "1.0e5", "2.5e+5", "9e4", "-12e-3", "0.25" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = "[" + STR + "]"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, "UTF-8"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { "1234.00", "2.1101567E-16", "1.0e5", "2.5e+5", "9e4", "-12e-3", "0.25" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = "[" + STR + "]"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, "UTF-8"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { "1234.00", "2.1101567E-16", "1.0e5", "2.5e+5", "9e4", "-12e-3", "0.25" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = "[" + STR + "]"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, "UTF-8"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testTabsEnabled() throws Exception { [EOL]     _testTabsEnabled(false); [EOL]     _testTabsEnabled(true); [EOL] }
public void testTabsEnabled() throws Exception { [EOL]     _testTabsEnabled(false); [EOL]     _testTabsEnabled(true); [EOL] }
public void testTabsEnabled() throws Exception { [EOL]     _testTabsEnabled(false); [EOL]     _testTabsEnabled(true); [EOL] }
public void testTabsEnabled() throws Exception { [EOL]     _testTabsEnabled(false); [EOL]     _testTabsEnabled(true); [EOL] }
public void testTabsEnabled() throws Exception { [EOL]     _testTabsEnabled(false); [EOL]     _testTabsEnabled(true); [EOL] }
public void testTabsEnabled() throws Exception { [EOL]     _testTabsEnabled(false); [EOL]     _testTabsEnabled(true); [EOL] }
public void testTabsEnabled() throws Exception { [EOL]     _testTabsEnabled(false); [EOL]     _testTabsEnabled(true); [EOL] }
public void testTabsEnabled() throws Exception { [EOL]     _testTabsEnabled(false); [EOL]     _testTabsEnabled(true); [EOL] }
public void testTabsEnabled() throws Exception { [EOL]     _testTabsEnabled(false); [EOL]     _testTabsEnabled(true); [EOL] }
public void testTabsEnabled() throws Exception { [EOL]     _testTabsEnabled(false); [EOL]     _testTabsEnabled(true); [EOL] }
public void testTabsEnabled() throws Exception { [EOL]     _testTabsEnabled(false); [EOL]     _testTabsEnabled(true); [EOL] }
public void testTabsEnabled() throws Exception { [EOL]     _testTabsEnabled(false); [EOL]     _testTabsEnabled(true); [EOL] }
public void testTabsEnabled() throws Exception { [EOL]     _testTabsEnabled(false); [EOL]     _testTabsEnabled(true); [EOL] }
public void testTabsEnabled() throws Exception { [EOL]     _testTabsEnabled(false); [EOL]     _testTabsEnabled(true); [EOL] }
public void testTabsEnabled() throws Exception { [EOL]     _testTabsEnabled(false); [EOL]     _testTabsEnabled(true); [EOL] }
public void testAllowInfinity() throws Exception { [EOL]     _testAllowInf(false); [EOL]     _testAllowInf(true); [EOL] }
public void testAllowInfinity() throws Exception { [EOL]     _testAllowInf(false); [EOL]     _testAllowInf(true); [EOL] }
public void testCommentsWithUTF8() throws Exception { [EOL]     final String JSON = "[ 1, 3, [ true, null ], 3, { \"a\":\"b\" }, [ [ ] ], { } ]"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp = (i == 0) ? createParserUsingReader(JSON) : createParserUsingStream(JSON, "UTF-8"); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getIntValue()); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         jp.close(); [EOL]     JsonParser jp2 = createParserUsingReader(JSON); [EOL]         assertToken(JsonToken.START_ARRAY, jp2.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]         assertToken(JsonToken.END_ARRAY, jp2.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testCRLF() throws Exception { [EOL]     _testLinefeeds("\r\n", true); [EOL]     _testLinefeeds("\r\n", false); [EOL] }
public void testCRLF() throws Exception { [EOL]     _testLinefeeds("\r\n", true); [EOL]     _testLinefeeds("\r\n", false); [EOL] }
public void testCommentsWithUTF8() throws Exception { [EOL]     final String JSON = "[ 1, 3, [ true, null ], 3, { \"a\":\"b\" }, [ [ ] ], { } ]"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp = (i == 0) ? createParserUsingReader(JSON) : createParserUsingStream(JSON, "UTF-8"); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getIntValue()); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         jp.close(); [EOL]     JsonParser jp2 = createParserUsingReader(JSON); [EOL]         assertToken(JsonToken.START_ARRAY, jp2.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]         assertToken(JsonToken.END_ARRAY, jp2.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testCommentsWithUTF8() throws Exception { [EOL]     final String JSON = "[ 1, 3, [ true, null ], 3, { \"a\":\"b\" }, [ [ ] ], { } ]"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp = (i == 0) ? createParserUsingReader(JSON) : createParserUsingStream(JSON, "UTF-8"); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getIntValue()); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         jp.close(); [EOL]     JsonParser jp2 = createParserUsingReader(JSON); [EOL]         assertToken(JsonToken.START_ARRAY, jp2.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]         assertToken(JsonToken.END_ARRAY, jp2.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testCommentsWithUTF8() throws Exception { [EOL]     final String JSON = "[ 1, 3, [ true, null ], 3, { \"a\":\"b\" }, [ [ ] ], { } ]"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp = (i == 0) ? createParserUsingReader(JSON) : createParserUsingStream(JSON, "UTF-8"); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getIntValue()); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         jp.close(); [EOL]     JsonParser jp2 = createParserUsingReader(JSON); [EOL]         assertToken(JsonToken.START_ARRAY, jp2.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]         assertToken(JsonToken.END_ARRAY, jp2.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testCommentsWithUTF8() throws Exception { [EOL]     final String JSON = "[ 1, 3, [ true, null ], 3, { \"a\":\"b\" }, [ [ ] ], { } ]"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp = (i == 0) ? createParserUsingReader(JSON) : createParserUsingStream(JSON, "UTF-8"); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getIntValue()); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         jp.close(); [EOL]     JsonParser jp2 = createParserUsingReader(JSON); [EOL]         assertToken(JsonToken.START_ARRAY, jp2.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]         assertToken(JsonToken.END_ARRAY, jp2.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testCommentsWithUTF8() throws Exception { [EOL]     final String JSON = "[ 1, 3, [ true, null ], 3, { \"a\":\"b\" }, [ [ ] ], { } ]"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp = (i == 0) ? createParserUsingReader(JSON) : createParserUsingStream(JSON, "UTF-8"); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getIntValue()); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         jp.close(); [EOL]     JsonParser jp2 = createParserUsingReader(JSON); [EOL]         assertToken(JsonToken.START_ARRAY, jp2.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]         assertToken(JsonToken.END_ARRAY, jp2.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testCommentsWithUTF8() throws Exception { [EOL]     final String JSON = "[ 1, 3, [ true, null ], 3, { \"a\":\"b\" }, [ [ ] ], { } ]"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp = (i == 0) ? createParserUsingReader(JSON) : createParserUsingStream(JSON, "UTF-8"); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getIntValue()); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         jp.close(); [EOL]     JsonParser jp2 = createParserUsingReader(JSON); [EOL]         assertToken(JsonToken.START_ARRAY, jp2.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]         assertToken(JsonToken.END_ARRAY, jp2.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testCommentsWithUTF8() throws Exception { [EOL]     final String JSON = "[ 1, 3, [ true, null ], 3, { \"a\":\"b\" }, [ [ ] ], { } ]"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp = (i == 0) ? createParserUsingReader(JSON) : createParserUsingStream(JSON, "UTF-8"); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getIntValue()); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         jp.close(); [EOL]     JsonParser jp2 = createParserUsingReader(JSON); [EOL]         assertToken(JsonToken.START_ARRAY, jp2.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]         assertToken(JsonToken.END_ARRAY, jp2.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testCommentsWithUTF8() throws Exception { [EOL]     final String JSON = "[ 1, 3, [ true, null ], 3, { \"a\":\"b\" }, [ [ ] ], { } ]"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp = (i == 0) ? createParserUsingReader(JSON) : createParserUsingStream(JSON, "UTF-8"); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getIntValue()); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         jp.close(); [EOL]     JsonParser jp2 = createParserUsingReader(JSON); [EOL]         assertToken(JsonToken.START_ARRAY, jp2.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]         assertToken(JsonToken.END_ARRAY, jp2.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testCommentsWithUTF8() throws Exception { [EOL]     final String JSON = "/* \u00a9 2099 Yoyodyne Inc. */\n [ \"bar? \u00a9\" ]\n"; [EOL]     _testWithUTF8Chars(JSON, false); [EOL]     _testWithUTF8Chars(JSON, true); [EOL] }
public void testCommentsWithUTF8() throws Exception { [EOL]     final String JSON = "/* \u00a9 2099 Yoyodyne Inc. */\n [ \"bar? \u00a9\" ]\n"; [EOL]     _testWithUTF8Chars(JSON, false); [EOL]     _testWithUTF8Chars(JSON, true); [EOL] }
public void testCommentsWithUTF8() throws Exception { [EOL]     final String JSON = "/* \u00a9 2099 Yoyodyne Inc. */\n [ \"bar? \u00a9\" ]\n"; [EOL]     _testWithUTF8Chars(JSON, false); [EOL]     _testWithUTF8Chars(JSON, true); [EOL] }
public void testCommentsWithUTF8() throws Exception { [EOL]     final String JSON = "/* \u00a9 2099 Yoyodyne Inc. */\n [ \"bar? \u00a9\" ]\n"; [EOL]     _testWithUTF8Chars(JSON, false); [EOL]     _testWithUTF8Chars(JSON, true); [EOL] }
public void testCommentsWithUTF8() throws Exception { [EOL]     final String JSON = "/* \u00a9 2099 Yoyodyne Inc. */\n [ \"bar? \u00a9\" ]\n"; [EOL]     _testWithUTF8Chars(JSON, false); [EOL]     _testWithUTF8Chars(JSON, true); [EOL] }
public void testCommentsWithUTF8() throws Exception { [EOL]     final String JSON = "/* \u00a9 2099 Yoyodyne Inc. */\n [ \"bar? \u00a9\" ]\n"; [EOL]     _testWithUTF8Chars(JSON, false); [EOL]     _testWithUTF8Chars(JSON, true); [EOL] }
public void testCommentsWithUTF8() throws Exception { [EOL]     final String JSON = "/* \u00a9 2099 Yoyodyne Inc. */\n [ \"bar? \u00a9\" ]\n"; [EOL]     _testWithUTF8Chars(JSON, false); [EOL]     _testWithUTF8Chars(JSON, true); [EOL] }
public void testCommentsWithUTF8() throws Exception { [EOL]     final String JSON = "/* \u00a9 2099 Yoyodyne Inc. */\n [ \"bar? \u00a9\" ]\n"; [EOL]     _testWithUTF8Chars(JSON, false); [EOL]     _testWithUTF8Chars(JSON, true); [EOL] }
public void testCommentsWithUTF8() throws Exception { [EOL]     final String JSON = "/* \u00a9 2099 Yoyodyne Inc. */\n [ \"bar? \u00a9\" ]\n"; [EOL]     _testWithUTF8Chars(JSON, false); [EOL]     _testWithUTF8Chars(JSON, true); [EOL] }
public void testCommentsWithUTF8() throws Exception { [EOL]     final String JSON = "/* \u00a9 2099 Yoyodyne Inc. */\n [ \"bar? \u00a9\" ]\n"; [EOL]     _testWithUTF8Chars(JSON, false); [EOL]     _testWithUTF8Chars(JSON, true); [EOL] }
public void testCommentsWithUTF8() throws Exception { [EOL]     final String JSON = "/* \u00a9 2099 Yoyodyne Inc. */\n [ \"bar? \u00a9\" ]\n"; [EOL]     _testWithUTF8Chars(JSON, false); [EOL]     _testWithUTF8Chars(JSON, true); [EOL] }
public void testCommentsWithUTF8() throws Exception { [EOL]     final String JSON = "/* \u00a9 2099 Yoyodyne Inc. */\n [ \"bar? \u00a9\" ]\n"; [EOL]     _testWithUTF8Chars(JSON, false); [EOL]     _testWithUTF8Chars(JSON, true); [EOL] }
public void testCommentsWithUTF8() throws Exception { [EOL]     final String JSON = "/* \u00a9 2099 Yoyodyne Inc. */\n [ \"bar? \u00a9\" ]\n"; [EOL]     _testWithUTF8Chars(JSON, false); [EOL]     _testWithUTF8Chars(JSON, true); [EOL] }
public void testCommentsWithUTF8() throws Exception { [EOL]     final String JSON = "/* \u00a9 2099 Yoyodyne Inc. */\n [ \"bar? \u00a9\" ]\n"; [EOL]     _testWithUTF8Chars(JSON, false); [EOL]     _testWithUTF8Chars(JSON, true); [EOL] }
public void testCommentsWithUTF8() throws Exception { [EOL]     final String JSON = "/* \u00a9 2099 Yoyodyne Inc. */\n [ \"bar? \u00a9\" ]\n"; [EOL]     _testWithUTF8Chars(JSON, false); [EOL]     _testWithUTF8Chars(JSON, true); [EOL] }
public void testCommentsWithUTF8() throws Exception { [EOL]     final String JSON = "/* \u00a9 2099 Yoyodyne Inc. */\n [ \"bar? \u00a9\" ]\n"; [EOL]     _testWithUTF8Chars(JSON, false); [EOL]     _testWithUTF8Chars(JSON, true); [EOL] }
public void testCommentsWithUTF8() throws Exception { [EOL]     final String JSON = "/* \u00a9 2099 Yoyodyne Inc. */\n [ \"bar? \u00a9\" ]\n"; [EOL]     _testWithUTF8Chars(JSON, false); [EOL]     _testWithUTF8Chars(JSON, true); [EOL] }
public void testCommentsWithUTF8() throws Exception { [EOL]     final String JSON = "/* \u00a9 2099 Yoyodyne Inc. */\n [ \"bar? \u00a9\" ]\n"; [EOL]     _testWithUTF8Chars(JSON, false); [EOL]     _testWithUTF8Chars(JSON, true); [EOL] }
public void testCommentsWithUTF8() throws Exception { [EOL]     final String JSON = "/* \u00a9 2099 Yoyodyne Inc. */\n [ \"bar? \u00a9\" ]\n"; [EOL]     _testWithUTF8Chars(JSON, false); [EOL]     _testWithUTF8Chars(JSON, true); [EOL] }
public void testCommentsWithUTF8() throws Exception { [EOL]     final String JSON = "/* \u00a9 2099 Yoyodyne Inc. */\n [ \"bar? \u00a9\" ]\n"; [EOL]     _testWithUTF8Chars(JSON, false); [EOL]     _testWithUTF8Chars(JSON, true); [EOL] }
public void testCommentsWithUTF8() throws Exception { [EOL]     final String JSON = "/* \u00a9 2099 Yoyodyne Inc. */\n [ \"bar? \u00a9\" ]\n"; [EOL]     _testWithUTF8Chars(JSON, false); [EOL]     _testWithUTF8Chars(JSON, true); [EOL] }
public void testCommentsWithUTF8() throws Exception { [EOL]     final String JSON = "/* \u00a9 2099 Yoyodyne Inc. */\n [ \"bar? \u00a9\" ]\n"; [EOL]     _testWithUTF8Chars(JSON, false); [EOL]     _testWithUTF8Chars(JSON, true); [EOL] }
public void testCommentsWithUTF8() throws Exception { [EOL]     final String JSON = "/* \u00a9 2099 Yoyodyne Inc. */\n [ \"bar? \u00a9\" ]\n"; [EOL]     _testWithUTF8Chars(JSON, false); [EOL]     _testWithUTF8Chars(JSON, true); [EOL] }
public void testCommentsWithUTF8() throws Exception { [EOL]     final String JSON = "/* \u00a9 2099 Yoyodyne Inc. */\n [ \"bar? \u00a9\" ]\n"; [EOL]     _testWithUTF8Chars(JSON, false); [EOL]     _testWithUTF8Chars(JSON, true); [EOL] }
public void testCommentsWithUTF8() throws Exception { [EOL]     final String JSON = "/* \u00a9 2099 Yoyodyne Inc. */\n [ \"bar? \u00a9\" ]\n"; [EOL]     _testWithUTF8Chars(JSON, false); [EOL]     _testWithUTF8Chars(JSON, true); [EOL] }
public void testCommentsWithUTF8() throws Exception { [EOL]     final String JSON = "/* \u00a9 2099 Yoyodyne Inc. */\n [ \"bar? \u00a9\" ]\n"; [EOL]     _testWithUTF8Chars(JSON, false); [EOL]     _testWithUTF8Chars(JSON, true); [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { "1234.00", "2.1101567E-16", "1.0e5", "2.5e+5", "9e4", "-12e-3", "0.25" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = "[" + STR + "]"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, "UTF-8"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { "1234.00", "2.1101567E-16", "1.0e5", "2.5e+5", "9e4", "-12e-3", "0.25" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = "[" + STR + "]"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, "UTF-8"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { "1234.00", "2.1101567E-16", "1.0e5", "2.5e+5", "9e4", "-12e-3", "0.25" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = "[" + STR + "]"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, "UTF-8"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { "1234.00", "2.1101567E-16", "1.0e5", "2.5e+5", "9e4", "-12e-3", "0.25" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = "[" + STR + "]"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, "UTF-8"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { "1234.00", "2.1101567E-16", "1.0e5", "2.5e+5", "9e4", "-12e-3", "0.25" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = "[" + STR + "]"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, "UTF-8"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { "1234.00", "2.1101567E-16", "1.0e5", "2.5e+5", "9e4", "-12e-3", "0.25" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = "[" + STR + "]"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, "UTF-8"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { "1234.00", "2.1101567E-16", "1.0e5", "2.5e+5", "9e4", "-12e-3", "0.25" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = "[" + STR + "]"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, "UTF-8"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { "1234.00", "2.1101567E-16", "1.0e5", "2.5e+5", "9e4", "-12e-3", "0.25" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = "[" + STR + "]"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, "UTF-8"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { "1234.00", "2.1101567E-16", "1.0e5", "2.5e+5", "9e4", "-12e-3", "0.25" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = "[" + STR + "]"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, "UTF-8"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { "1234.00", "2.1101567E-16", "1.0e5", "2.5e+5", "9e4", "-12e-3", "0.25" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = "[" + STR + "]"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, "UTF-8"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { "1234.00", "2.1101567E-16", "1.0e5", "2.5e+5", "9e4", "-12e-3", "0.25" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = "[" + STR + "]"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, "UTF-8"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { "1234.00", "2.1101567E-16", "1.0e5", "2.5e+5", "9e4", "-12e-3", "0.25" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = "[" + STR + "]"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, "UTF-8"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { "1234.00", "2.1101567E-16", "1.0e5", "2.5e+5", "9e4", "-12e-3", "0.25" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = "[" + STR + "]"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, "UTF-8"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { "1234.00", "2.1101567E-16", "1.0e5", "2.5e+5", "9e4", "-12e-3", "0.25" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = "[" + STR + "]"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, "UTF-8"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { "1234.00", "2.1101567E-16", "1.0e5", "2.5e+5", "9e4", "-12e-3", "0.25" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = "[" + STR + "]"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, "UTF-8"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { "1234.00", "2.1101567E-16", "1.0e5", "2.5e+5", "9e4", "-12e-3", "0.25" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = "[" + STR + "]"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, "UTF-8"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { "1234.00", "2.1101567E-16", "1.0e5", "2.5e+5", "9e4", "-12e-3", "0.25" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = "[" + STR + "]"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, "UTF-8"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { "1234.00", "2.1101567E-16", "1.0e5", "2.5e+5", "9e4", "-12e-3", "0.25" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = "[" + STR + "]"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, "UTF-8"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { "1234.00", "2.1101567E-16", "1.0e5", "2.5e+5", "9e4", "-12e-3", "0.25" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = "[" + STR + "]"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, "UTF-8"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { "1234.00", "2.1101567E-16", "1.0e5", "2.5e+5", "9e4", "-12e-3", "0.25" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = "[" + STR + "]"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, "UTF-8"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { "1234.00", "2.1101567E-16", "1.0e5", "2.5e+5", "9e4", "-12e-3", "0.25" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = "[" + STR + "]"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, "UTF-8"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { "1234.00", "2.1101567E-16", "1.0e5", "2.5e+5", "9e4", "-12e-3", "0.25" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = "[" + STR + "]"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, "UTF-8"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { "1234.00", "2.1101567E-16", "1.0e5", "2.5e+5", "9e4", "-12e-3", "0.25" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = "[" + STR + "]"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, "UTF-8"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { "1234.00", "2.1101567E-16", "1.0e5", "2.5e+5", "9e4", "-12e-3", "0.25" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = "[" + STR + "]"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, "UTF-8"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { "1234.00", "2.1101567E-16", "1.0e5", "2.5e+5", "9e4", "-12e-3", "0.25" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = "[" + STR + "]"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, "UTF-8"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { "1234.00", "2.1101567E-16", "1.0e5", "2.5e+5", "9e4", "-12e-3", "0.25" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = "[" + STR + "]"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, "UTF-8"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { "1234.00", "2.1101567E-16", "1.0e5", "2.5e+5", "9e4", "-12e-3", "0.25" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = "[" + STR + "]"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, "UTF-8"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { "1234.00", "2.1101567E-16", "1.0e5", "2.5e+5", "9e4", "-12e-3", "0.25" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = "[" + STR + "]"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, "UTF-8"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { "1234.00", "2.1101567E-16", "1.0e5", "2.5e+5", "9e4", "-12e-3", "0.25" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = "[" + STR + "]"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, "UTF-8"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes("UTF-8"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes("UTF-8"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSurrogates() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     _testSurrogates(f, true); [EOL]     _testSurrogates(f, false); [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes("UTF-8"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes("UTF-8"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes("UTF-8"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSurrogates() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     _testSurrogates(f, true); [EOL]     _testSurrogates(f, false); [EOL] }
public void testSurrogates() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     _testSurrogates(f, true); [EOL]     _testSurrogates(f, false); [EOL] }
public void testSurrogates() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     _testSurrogates(f, true); [EOL]     _testSurrogates(f, false); [EOL] }
public void testSurrogates() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     _testSurrogates(f, true); [EOL]     _testSurrogates(f, false); [EOL] }
public void testSurrogates() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     _testSurrogates(f, true); [EOL]     _testSurrogates(f, false); [EOL] }
public void testSurrogates() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     _testSurrogates(f, true); [EOL]     _testSurrogates(f, false); [EOL] }
public void testSurrogates() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     _testSurrogates(f, true); [EOL]     _testSurrogates(f, false); [EOL] }
public void testSurrogates() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     _testSurrogates(f, true); [EOL]     _testSurrogates(f, false); [EOL] }
public void testSurrogates() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     _testSurrogates(f, true); [EOL]     _testSurrogates(f, false); [EOL] }
public void testSurrogates() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     _testSurrogates(f, true); [EOL]     _testSurrogates(f, false); [EOL] }
public void testSurrogates() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     _testSurrogates(f, true); [EOL]     _testSurrogates(f, false); [EOL] }
public void testSurrogates() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     _testSurrogates(f, true); [EOL]     _testSurrogates(f, false); [EOL] }
public void testSurrogates() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     _testSurrogates(f, true); [EOL]     _testSurrogates(f, false); [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes("UTF-8"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSurrogates() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     _testSurrogates(f, true); [EOL]     _testSurrogates(f, false); [EOL] }
public void testSurrogates() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     _testSurrogates(f, true); [EOL]     _testSurrogates(f, false); [EOL] }
public void testSurrogates() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     _testSurrogates(f, true); [EOL]     _testSurrogates(f, false); [EOL] }
public void testSurrogates() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     _testSurrogates(f, true); [EOL]     _testSurrogates(f, false); [EOL] }
public void testSurrogates() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     _testSurrogates(f, true); [EOL]     _testSurrogates(f, false); [EOL] }
public void testSurrogates() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     _testSurrogates(f, true); [EOL]     _testSurrogates(f, false); [EOL] }
public void testSurrogates() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     _testSurrogates(f, true); [EOL]     _testSurrogates(f, false); [EOL] }
public void testSurrogates() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     _testSurrogates(f, true); [EOL]     _testSurrogates(f, false); [EOL] }
public void testCRLF() throws Exception { [EOL]     _testLinefeeds("\r\n", true); [EOL]     _testLinefeeds("\r\n", false); [EOL] }
public void testCRLF() throws Exception { [EOL]     _testLinefeeds("\r\n", true); [EOL]     _testLinefeeds("\r\n", false); [EOL] }
public void testCRLF() throws Exception { [EOL]     _testLinefeeds("\r\n", true); [EOL]     _testLinefeeds("\r\n", false); [EOL] }
public void testCRLF() throws Exception { [EOL]     _testLinefeeds("\r\n", true); [EOL]     _testLinefeeds("\r\n", false); [EOL] }
public void testCRLF() throws Exception { [EOL]     _testLinefeeds("\r\n", true); [EOL]     _testLinefeeds("\r\n", false); [EOL] }
public void testSimple() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(sw); [EOL]     _writeSimple(jgen); [EOL]     jgen.close(); [EOL]     String json = sw.toString(); [EOL]     _verifySimple(jf.createParser(json)); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     _writeSimple(jgen); [EOL]     jgen.close(); [EOL]     byte[] jsonB = out.toByteArray(); [EOL]     _verifySimple(jf.createParser(jsonB)); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimple() { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(sw); [EOL]     _writeSimple(jgen); [EOL]     jgen.close(); [EOL]     String json = sw.toString(); [EOL]     _verifySimple(jf.createParser(json)); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     _writeSimple(jgen); [EOL]     jgen.close(); [EOL]     byte[] jsonB = out.toByteArray(); [EOL]     _verifySimple(jf.createParser(jsonB)); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleValidString() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String JSON = "\"JSON!\""; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes("UTF-8"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals("JSON", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.WEAK_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals("JSON!", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testAsBoolean() throws Exception { [EOL]     final String input = "[ true, false, null, 1, 0, \"true\", \"false\", \"foo\" ]"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertEquals(true, jp.getValueAsBoolean(true)); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(true, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getIntValue()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         assertEquals(false, jp.getValueAsBoolean()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken());
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = "{\"simple\":[1,true,{}]}"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = "{\"simple\":[1,true,{}]}"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = "{\"simple\":[1,true,{}]}"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = "{\"simple\":[1,true,{}]}"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = "{\"simple\":[1,true,{}]}"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = "{\"simple\":[1,true,{}]}"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testSharedSymbols() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = "{ \"a\" : 1, \"x\" : [ ] }"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimpleWriteObject() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(1); [EOL]     gen.writeObject((short) -2); [EOL]     gen.writeObject((long) 3); [EOL]     gen.writeObject((byte) -4); [EOL]     gen.writeObject(0.25); [EOL]     gen.writeObject(-0.125f); [EOL]     gen.writeObject(Boolean.TRUE); [EOL]     gen.close(); [EOL]     String act = sw.toString().trim(); [EOL]     assertEquals("[1,-2,3,-4,0.25,-0.125,true]", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(BigInteger.valueOf(1234)); [EOL]     gen.writeObject(new BigDecimal(0.5)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals("[1234,0.5]", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL] gen.writeObject(new AtomicBoolean(false)); [EOL]     gen.writeObject(new AtomicInteger(13)); [EOL]     gen.writeObject(new AtomicLong(-127L)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals("[false,13,-127]", act); [EOL] }
public void testSimpleWriteObject() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(1); [EOL]     gen.writeObject((short) -2); [EOL]     gen.writeObject((long) 3); [EOL]     gen.writeObject((byte) -4); [EOL]     gen.writeObject(0.25); [EOL]     gen.writeObject(-0.125f); [EOL]     gen.writeObject(Boolean.TRUE); [EOL]     gen.close(); [EOL]     String act = sw.toString().trim(); [EOL]     assertEquals("[1,-2,3,-4,0.25,-0.125,true]", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(BigInteger.valueOf(1234)); [EOL]     gen.writeObject(new BigDecimal(0.5)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals("[1234,0.5]", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL] gen.writeObject(new AtomicBoolean(false)); [EOL]     gen.writeObject(new AtomicInteger(13)); [EOL]     gen.writeObject(new AtomicLong(-127L)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals("[false,13,-127]", act); [EOL] }
public void testSimpleWriteObject() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(1); [EOL]     gen.writeObject((short) -2); [EOL]     gen.writeObject((long) 3); [EOL]     gen.writeObject((byte) -4); [EOL]     gen.writeObject(0.25); [EOL]     gen.writeObject(-0.125f); [EOL]     gen.writeObject(Boolean.TRUE); [EOL]     gen.close(); [EOL]     String act = sw.toString().trim(); [EOL]     assertEquals("[1,-2,3,-4,0.25,-0.125,true]", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(BigInteger.valueOf(1234)); [EOL]     gen.writeObject(new BigDecimal(0.5)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals("[1234,0.5]", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL] gen.writeObject(new AtomicBoolean(false)); [EOL]     gen.writeObject(new AtomicInteger(13)); [EOL]     gen.writeObject(new AtomicLong(-127L)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals("[false,13,-127]", act); [EOL] }
public void testSimpleWriteObject() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(1); [EOL]     gen.writeObject((short) -2); [EOL]     gen.writeObject((long) 3); [EOL]     gen.writeObject((byte) -4); [EOL]     gen.writeObject(0.25); [EOL]     gen.writeObject(-0.125f); [EOL]     gen.writeObject(Boolean.TRUE); [EOL]     gen.close(); [EOL]     String act = sw.toString().trim(); [EOL]     assertEquals("[1,-2,3,-4,0.25,-0.125,true]", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(BigInteger.valueOf(1234)); [EOL]     gen.writeObject(new BigDecimal(0.5)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals("[1234,0.5]", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(new AtomicBoolean(false)); [EOL]     gen.writeObject(new AtomicInteger(13)); [EOL]     gen.writeObject(new AtomicLong(-127L)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals("[false,13,-127]", act); [EOL] }
public void testSimpleWriteObject() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(1); [EOL]     gen.writeObject((short) -2); [EOL]     gen.writeObject((long) 3); [EOL]     gen.writeObject((byte) -4); [EOL]     gen.writeObject(0.25); [EOL]     gen.writeObject(-0.125f); [EOL]     gen.writeObject(Boolean.TRUE); [EOL]     gen.close(); [EOL]     String act = sw.toString().trim(); [EOL]     assertEquals("[1,-2,3,-4,0.25,-0.125,true]", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(BigInteger.valueOf(1234)); [EOL]     gen.writeObject(new BigDecimal(0.5)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals("[1234,0.5]", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL] gen.writeObject(new AtomicBoolean(false)); [EOL]     gen.writeObject(new AtomicInteger(13)); [EOL]     gen.writeObject(new AtomicLong(-127L)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals("[false,13,-127]", act); [EOL] }
public void testSimpleWriteObject() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(1); [EOL]     gen.writeObject((short) -2); [EOL]     gen.writeObject((long) 3); [EOL]     gen.writeObject((byte) -4); [EOL]     gen.writeObject(0.25); [EOL]     gen.writeObject(-0.125f); [EOL]     gen.writeObject(Boolean.TRUE); [EOL]     gen.close(); [EOL]     String act = sw.toString().trim(); [EOL]     assertEquals("[1,-2,3,-4,0.25,-0.125,true]", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(BigInteger.valueOf(1234)); [EOL]     gen.writeObject(new BigDecimal(0.5)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals("[1234,0.5]", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(new AtomicBoolean(false)); [EOL]     gen.writeObject(new AtomicInteger(13)); [EOL]     gen.writeObject(new AtomicLong(-127L)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals("[false,13,-127]", act); [EOL] }
public void testSimpleWriteObject() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(1); [EOL]     gen.writeObject((short) -2); [EOL]     gen.writeObject((long) 3); [EOL]     gen.writeObject((byte) -4); [EOL]     gen.writeObject(0.25); [EOL]     gen.writeObject(-0.125f); [EOL]     gen.writeObject(Boolean.TRUE); [EOL]     gen.close(); [EOL]     String act = sw.toString().trim(); [EOL]     assertEquals("[1,-2,3,-4,0.25,-0.125,true]", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL] gen.writeObject(BigInteger.valueOf(1234)); [EOL]     gen.writeObject(new BigDecimal(0.5)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals("[1234,0.5]", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL] gen.writeObject(new AtomicBoolean(false)); [EOL]     gen.writeObject(new AtomicInteger(13)); [EOL]     gen.writeObject(new AtomicLong(-127L)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals("[false,13,-127]", act); [EOL] }
public void testSimpleWriteObject() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(1); [EOL]     gen.writeObject((short) -2); [EOL]     gen.writeObject((long) 3); [EOL]     gen.writeObject((byte) -4); [EOL]     gen.writeObject(0.25); [EOL]     gen.writeObject(-0.125f); [EOL]     gen.writeObject(Boolean.TRUE); [EOL]     gen.close(); [EOL]     String act = sw.toString().trim(); [EOL]     assertEquals("[1,-2,3,-4,0.25,-0.125,true]", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL] gen.writeObject(BigInteger.valueOf(1234)); [EOL]     gen.writeObject(new BigDecimal(0.5)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals("[1234,0.5]", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL] gen.writeObject(new AtomicBoolean(false)); [EOL]     gen.writeObject(new AtomicInteger(13)); [EOL]     gen.writeObject(new AtomicLong(-127L)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals("[false,13,-127]", act); [EOL] }
public void testSimpleWriteObject() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(1); [EOL]     gen.writeObject((short) -2); [EOL]     gen.writeObject((long) 3); [EOL]     gen.writeObject((byte) -4); [EOL]     gen.writeObject(0.25); [EOL]     gen.writeObject(-0.125f); [EOL]     gen.writeObject(Boolean.TRUE); [EOL]     gen.close(); [EOL]     String act = sw.toString().trim(); [EOL]     assertEquals("[1,-2,3,-4,0.25,-0.125,true]", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL] gen.writeObject(BigInteger.valueOf(1234)); [EOL]     gen.writeObject(new BigDecimal(0.5)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals("[1234,0.5]", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL] gen.writeObject(new AtomicBoolean(false)); [EOL]     gen.writeObject(new AtomicInteger(13)); [EOL]     gen.writeObject(new AtomicLong(-127L)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals("[false,13,-127]", act); [EOL] }
public void testSimpleWriteObject() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(1); [EOL]     gen.writeObject((short) -2); [EOL]     gen.writeObject((long) 3); [EOL]     gen.writeObject((byte) -4); [EOL]     gen.writeObject(0.25); [EOL]     gen.writeObject(-0.125f); [EOL]     gen.writeObject(Boolean.TRUE); [EOL]     gen.close(); [EOL]     String act = sw.toString().trim(); [EOL]     assertEquals("[1,-2,3,-4,0.25,-0.125,true]", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL] gen.writeObject(BigInteger.valueOf(1234)); [EOL]     gen.writeObject(new BigDecimal(0.5)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals("[1234,0.5]", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL] gen.writeObject(new AtomicBoolean(false)); [EOL]     gen.writeObject(new AtomicInteger(13)); [EOL]     gen.writeObject(new AtomicLong(-127L)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals("[false,13,-127]", act); [EOL] }
public void testSimpleWriteObject() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(1); [EOL]     gen.writeObject((short) -2); [EOL]     gen.writeObject((long) 3); [EOL]     gen.writeObject((byte) -4); [EOL]     gen.writeObject(0.25); [EOL]     gen.writeObject(-0.125f); [EOL]     gen.writeObject(Boolean.TRUE); [EOL]     gen.close(); [EOL]     String act = sw.toString().trim(); [EOL]     assertEquals("[1,-2,3,-4,0.25,-0.125,true]", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL] gen.writeObject(BigInteger.valueOf(1234)); [EOL]     gen.writeObject(new BigDecimal(0.5)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals("[1234,0.5]", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL] gen.writeObject(new AtomicBoolean(false)); [EOL]     gen.writeObject(new AtomicInteger(13)); [EOL]     gen.writeObject(new AtomicLong(-127L)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals("[false,13,-127]", act); [EOL] }
public void testSimpleWriteObject() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     gen.writeObject(1); [EOL]     gen.writeObject((short) -2); [EOL]     gen.writeObject((long) 3); [EOL]     gen.writeObject((byte) -4); [EOL]     gen.writeObject(0.25); [EOL]     gen.writeObject(-0.125f); [EOL]     gen.writeObject(Boolean.TRUE); [EOL]     gen.close(); [EOL]     String act = sw.toString().trim(); [EOL]     assertEquals("[1,-2,3,-4,0.25,-0.125,true]", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL] gen.writeObject(BigInteger.valueOf(1234)); [EOL]     gen.writeObject(new BigDecimal(0.5)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals("[1234,0.5]", act); [EOL]     sw = new StringWriter(); [EOL]     gen = jf.createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL] gen.writeObject(new AtomicBoolean(false)); [EOL]     gen.writeObject(new AtomicInteger(13)); [EOL]     gen.writeObject(new AtomicLong(-127L)); [EOL]     gen.writeEndArray(); [EOL]     gen.close(); [EOL]     act = sw.toString().trim(); [EOL]     assertEquals("[false,13,-127]", act); [EOL] }
public void testArrayCount() throws Exception { [EOL]     final String EXP = "[6,[1,2,9(3)](2)]"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(6); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(1); [EOL]         gen.writeNumber(2); [EOL]         gen.writeNumber(9); [EOL]         gen.writeEndArray(); [EOL]         gen.writeEndArray(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString("UTF-8") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testArrayCount() throws Exception { [EOL]     final String EXP = "[6,[1,2,9(3)](2)]"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(6); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(1); [EOL]         gen.writeNumber(2); [EOL]         gen.writeNumber(9); [EOL]         gen.writeEndArray(); [EOL]         gen.writeEndArray(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString("UTF-8") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes("UTF-8"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes("UTF-8"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes("UTF-8"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testArrayCount() throws Exception { [EOL]     final String EXP = "[6,[1,2,9(3)](2)]"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(6); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(1); [EOL]         gen.writeNumber(2); [EOL]         gen.writeNumber(9); [EOL]         gen.writeEndArray(); [EOL]         gen.writeEndArray(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString("UTF-8") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testObjectCount() throws Exception { [EOL]     final String EXP = "{\"x\":{\"a\":1,\"b\":2(2)}(1)}"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartObject(); [EOL]         gen.writeFieldName("x"); [EOL]         gen.writeStartObject(); [EOL]         gen.writeNumberField("a", 1); [EOL]         gen.writeNumberField("b", 2); [EOL]         gen.writeEndObject(); [EOL]         gen.writeEndObject(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString("UTF-8") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testObjectCount() throws Exception { [EOL]     final String EXP = "{\"x\":{\"a\":1,\"b\":2(2)}(1)}"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartObject(); [EOL]         gen.writeFieldName("x"); [EOL]         gen.writeStartObject(); [EOL]         gen.writeNumberField("a", 1); [EOL]         gen.writeNumberField("b", 2); [EOL]         gen.writeEndObject(); [EOL]         gen.writeEndObject(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString("UTF-8") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testObjectCount() throws Exception { [EOL]     final String EXP = "{\"x\":{\"a\":1,\"b\":2(2)}(1)}"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartObject(); [EOL]         gen.writeFieldName("x"); [EOL]         gen.writeStartObject(); [EOL]         gen.writeNumberField("a", 1); [EOL]         gen.writeNumberField("b", 2); [EOL]         gen.writeEndObject(); [EOL]         gen.writeEndObject(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString("UTF-8") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testObjectCount() throws Exception { [EOL]     final String EXP = "{\"x\":{\"a\":1,\"b\":2(2)}(1)}"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartObject(); [EOL]         gen.writeFieldName("x"); [EOL]         gen.writeStartObject(); [EOL]         gen.writeNumberField("a", 1); [EOL]         gen.writeNumberField("b", 2); [EOL]         gen.writeEndObject(); [EOL]         gen.writeEndObject(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString("UTF-8") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testObjectCount() throws Exception { [EOL]     final String EXP = "{\"x\":{\"a\":1,\"b\":2(2)}(1)}"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartObject(); [EOL]         gen.writeFieldName("x"); [EOL]         gen.writeStartObject(); [EOL]         gen.writeNumberField("a", 1); [EOL]         gen.writeNumberField("b", 2); [EOL]         gen.writeEndObject(); [EOL]         gen.writeEndObject(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString("UTF-8") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testObjectCount() throws Exception { [EOL]     final String EXP = "{\"x\":{\"a\":1,\"b\":2(2)}(1)}"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartObject(); [EOL]         gen.writeFieldName("x"); [EOL]         gen.writeStartObject(); [EOL]         gen.writeNumberField("a", 1); [EOL]         gen.writeNumberField("b", 2); [EOL]         gen.writeEndObject(); [EOL]         gen.writeEndObject(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString("UTF-8") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes("UTF-8"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes("UTF-8"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes("UTF-8"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes("UTF-8"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes("UTF-8"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes("UTF-8"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes("UTF-8"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes("UTF-8"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes("UTF-8"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes("UTF-8"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes("UTF-8"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes("UTF-8"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes("UTF-8"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes("UTF-8"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes("UTF-8"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testObjectCount() throws Exception { [EOL]     final String EXP = "{\"x\":{\"a\":1,\"b\":2(2)}(1)}"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartObject(); [EOL]         gen.writeFieldName("x"); [EOL]         gen.writeStartObject(); [EOL]         gen.writeNumberField("a", 1); [EOL]         gen.writeNumberField("b", 2); [EOL]         gen.writeEndObject(); [EOL]         gen.writeEndObject(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString("UTF-8") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testObjectCount() throws Exception { [EOL]     final String EXP = "{\"x\":{\"a\":1,\"b\":2(2)}(1)}"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartObject(); [EOL]         gen.writeFieldName("x"); [EOL]         gen.writeStartObject(); [EOL]         gen.writeNumberField("a", 1); [EOL]         gen.writeNumberField("b", 2); [EOL]         gen.writeEndObject(); [EOL]         gen.writeEndObject(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString("UTF-8") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testObjectCount() throws Exception { [EOL]     final String EXP = "{\"x\":{\"a\":1,\"b\":2(2)}(1)}"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartObject(); [EOL]         gen.writeFieldName("x"); [EOL]         gen.writeStartObject(); [EOL]         gen.writeNumberField("a", 1); [EOL]         gen.writeNumberField("b", 2); [EOL]         gen.writeEndObject(); [EOL]         gen.writeEndObject(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString("UTF-8") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes("UTF-8"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes("UTF-8"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes("UTF-8"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes("UTF-8"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes("UTF-8"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes("UTF-8"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes("UTF-8"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes("UTF-8"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes("UTF-8"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testUtf8StringsWithEscaping() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 720000, true); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeUTF8String(str, 0, str.length); [EOL]         jgen.writeRaw('\n'); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes("UTF-8"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleInvalid() throws Exception { [EOL]     DataFormatDetector detector = new DataFormatDetector(new JsonFactory()); [EOL]     final String NON_JSON = "<root />"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(NON_JSON.getBytes("UTF-8"))); [EOL]     assertFalse(matcher.hasMatch()); [EOL]     assertEquals(MatchStrength.INCONCLUSIVE, matcher.getMatchStrength()); [EOL]     assertNull(matcher.createParserWithMatch()); [EOL] }
public void testSimpleValidString() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String JSON = "\"JSON!\""; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes("UTF-8"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals("JSON", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.WEAK_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals("JSON!", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimpleValidString() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String JSON = "\"JSON!\""; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes("UTF-8"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals("JSON", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.WEAK_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals("JSON!", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimpleInvalid() throws Exception { [EOL]     DataFormatDetector detector = new DataFormatDetector(new JsonFactory()); [EOL]     final String NON_JSON = "<root />"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(NON_JSON.getBytes("UTF-8"))); [EOL]     assertFalse(matcher.hasMatch()); [EOL]     assertEquals(MatchStrength.INCONCLUSIVE, matcher.getMatchStrength()); [EOL]     assertNull(matcher.createParserWithMatch()); [EOL] }
public void testSimpleValidString() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String JSON = "\"JSON!\""; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes("UTF-8"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals("JSON", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.WEAK_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals("JSON!", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimpleValidString() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String JSON = "\"JSON!\""; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes("UTF-8"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals("JSON", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.WEAK_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals("JSON!", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimpleInvalid() throws Exception { [EOL]     DataFormatDetector detector = new DataFormatDetector(new JsonFactory()); [EOL]     final String NON_JSON = "<root />"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(NON_JSON.getBytes("UTF-8"))); [EOL]     assertFalse(matcher.hasMatch()); [EOL]     assertEquals(MatchStrength.INCONCLUSIVE, matcher.getMatchStrength()); [EOL]     assertNull(matcher.createParserWithMatch()); [EOL] }
public void testSimpleValidString() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String JSON = "\"JSON!\""; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes("UTF-8"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals("JSON", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.WEAK_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals("JSON!", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimpleValidString() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String JSON = "\"JSON!\""; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes("UTF-8"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals("JSON", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.WEAK_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals("JSON!", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimpleValidString() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String JSON = "\"JSON!\""; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes("UTF-8"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals("JSON", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.WEAK_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals("JSON!", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimpleValidString() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String JSON = "\"JSON!\""; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes("UTF-8"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals("JSON", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.WEAK_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals("JSON!", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimpleValidString() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String JSON = "\"JSON!\""; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes("UTF-8"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals("JSON", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.WEAK_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals("JSON!", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimpleValidString() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String JSON = "\"JSON!\""; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes("UTF-8"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals("JSON", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.WEAK_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals("JSON!", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] }
public void testIntWrite() throws Exception { [EOL]     doTestIntWrite(false); [EOL]     doTestIntWrite(true); [EOL] }
public void testArrayCount() throws Exception { [EOL]     final String EXP = "[6,[1,2,9(3)](2)]"; [EOL]     final JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean useBytes = (i > 0); [EOL]         ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]         StringWriter sw = new StringWriter(); [EOL]         JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw); [EOL]         gen.setPrettyPrinter(new CountPrinter()); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(6); [EOL]         gen.writeStartArray(); [EOL]         gen.writeNumber(1); [EOL]         gen.writeNumber(2); [EOL]         gen.writeNumber(9); [EOL]         gen.writeEndArray(); [EOL]         gen.writeEndArray(); [EOL]         gen.close(); [EOL]         String json = useBytes ? bytes.toString("UTF-8") : sw.toString(); [EOL]         assertEquals(EXP, json); [EOL]     } [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testSimple() { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(sw); [EOL]     _writeSimple(jgen); [EOL]     jgen.close(); [EOL]     String json = sw.toString(); [EOL]     _verifySimple(jf.createParser(json)); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     _writeSimple(jgen); [EOL]     jgen.close(); [EOL]     byte[] jsonB = out.toByteArray(); [EOL]     _verifySimple(jf.createParser(jsonB)); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testWithEscaped() throws IOException { [EOL]     _testEscaped(false); [EOL]     _testEscaped(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testCharEncoding() throws Exception { [EOL]     Base64Variant std = Base64Variants.MIME; [EOL]     assertEquals(Base64Variant.BASE64_VALUE_INVALID, std.decodeBase64Char('?')); [EOL]     assertEquals(Base64Variant.BASE64_VALUE_INVALID, std.decodeBase64Char((int) '?')); [EOL]     assertEquals(Base64Variant.BASE64_VALUE_INVALID, std.decodeBase64Char((byte) '?')); [EOL]     assertEquals(0, std.decodeBase64Char('A')); [EOL]     assertEquals(1, std.decodeBase64Char((int) 'B')); [EOL]     assertEquals(2, std.decodeBase64Char((byte) 'C')); [EOL]     assertEquals('/', std.encodeBase64BitsAsByte(63)); [EOL]     assertEquals((byte) 'b', std.encodeBase64BitsAsByte(27)); [EOL]     String EXP_STR = "HwdJ"; [EOL]     int TRIPLET = 0x1F0749; [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     std.encodeBase64Chunk(sb, TRIPLET); [EOL]     assertEquals(EXP_STR, sb.toString()); [EOL]     byte[] exp = EXP_STR.getBytes("UTF-8"); [EOL]     byte[] act = new byte[exp.length]; [EOL]     std.encodeBase64Chunk(TRIPLET, act, 0); [EOL]     Assert.assertArrayEquals(exp, act); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testStreaming() throws IOException { [EOL]     _testStreaming(false); [EOL]     _testStreaming(true); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { "1234.00", "2.1101567E-16", "1.0e5", "2.5e+5", "9e4", "-12e-3", "0.25" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = "[" + STR + "]"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, "UTF-8"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { "1234.00", "2.1101567E-16", "1.0e5", "2.5e+5", "9e4", "-12e-3", "0.25" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = "[" + STR + "]"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, "UTF-8"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { "1234.00", "2.1101567E-16", "1.0e5", "2.5e+5", "9e4", "-12e-3", "0.25" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = "[" + STR + "]"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, "UTF-8"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { "1234.00", "2.1101567E-16", "1.0e5", "2.5e+5", "9e4", "-12e-3", "0.25" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = "[" + STR + "]"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, "UTF-8"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { "1234.00", "2.1101567E-16", "1.0e5", "2.5e+5", "9e4", "-12e-3", "0.25" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = "[" + STR + "]"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, "UTF-8"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { "1234.00", "2.1101567E-16", "1.0e5", "2.5e+5", "9e4", "-12e-3", "0.25" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = "[" + STR + "]"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, "UTF-8"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { "1234.00", "2.1101567E-16", "1.0e5", "2.5e+5", "9e4", "-12e-3", "0.25" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = "[" + STR + "]"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, "UTF-8"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { "1234.00", "2.1101567E-16", "1.0e5", "2.5e+5", "9e4", "-12e-3", "0.25" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = "[" + STR + "]"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, "UTF-8"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { "1234.00", "2.1101567E-16", "1.0e5", "2.5e+5", "9e4", "-12e-3", "0.25" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = "[" + STR + "]"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, "UTF-8"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { "1234.00", "2.1101567E-16", "1.0e5", "2.5e+5", "9e4", "-12e-3", "0.25" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = "[" + STR + "]"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, "UTF-8"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { "1234.00", "2.1101567E-16", "1.0e5", "2.5e+5", "9e4", "-12e-3", "0.25" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = "[" + STR + "]"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, "UTF-8"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal("0.1"); [EOL]     final String TEXT = "\"some\nString!\""; [EOL]     gen.writeNullField("null"); [EOL]     gen.writeBooleanField("bt", true); [EOL]     gen.writeBooleanField("bf", false); [EOL]     gen.writeNumberField("int", -1289); [EOL]     gen.writeNumberField("dec", dec); [EOL]     gen.writeObjectFieldStart("ob"); [EOL]     gen.writeStringField("str", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart("arr"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("null", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("bt", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("bf", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("int", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { "1234.00", "2.1101567E-16", "1.0e5", "2.5e+5", "9e4", "-12e-3", "0.25" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = "[" + STR + "]"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, "UTF-8"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal("0.1"); [EOL]     final String TEXT = "\"some\nString!\""; [EOL]     gen.writeNullField("null"); [EOL]     gen.writeBooleanField("bt", true); [EOL]     gen.writeBooleanField("bf", false); [EOL]     gen.writeNumberField("int", -1289); [EOL]     gen.writeNumberField("dec", dec); [EOL]     gen.writeObjectFieldStart("ob"); [EOL]     gen.writeStringField("str", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart("arr"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("null", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("bt", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("bf", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("int", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal("0.1"); [EOL]     final String TEXT = "\"some\nString!\""; [EOL]     gen.writeNullField("null"); [EOL]     gen.writeBooleanField("bt", true); [EOL]     gen.writeBooleanField("bf", false); [EOL]     gen.writeNumberField("int", -1289); [EOL]     gen.writeNumberField("dec", dec); [EOL]     gen.writeObjectFieldStart("ob"); [EOL]     gen.writeStringField("str", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart("arr"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("null", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("bt", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("bf", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("int", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal("0.1"); [EOL]     final String TEXT = "\"some\nString!\""; [EOL]     gen.writeNullField("null"); [EOL]     gen.writeBooleanField("bt", true); [EOL]     gen.writeBooleanField("bf", false); [EOL]     gen.writeNumberField("int", -1289); [EOL]     gen.writeNumberField("dec", dec); [EOL]     gen.writeObjectFieldStart("ob"); [EOL]     gen.writeStringField("str", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart("arr"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("null", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("bt", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("bf", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("int", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { "1234.00", "2.1101567E-16", "1.0e5", "2.5e+5", "9e4", "-12e-3", "0.25" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = "[" + STR + "]"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, "UTF-8"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { "1234.00", "2.1101567E-16", "1.0e5", "2.5e+5", "9e4", "-12e-3", "0.25" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = "[" + STR + "]"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, "UTF-8"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { "1234.00", "2.1101567E-16", "1.0e5", "2.5e+5", "9e4", "-12e-3", "0.25" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = "[" + STR + "]"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, "UTF-8"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { "1234.00", "2.1101567E-16", "1.0e5", "2.5e+5", "9e4", "-12e-3", "0.25" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = "[" + STR + "]"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, "UTF-8"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { "1234.00", "2.1101567E-16", "1.0e5", "2.5e+5", "9e4", "-12e-3", "0.25" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = "[" + STR + "]"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, "UTF-8"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { "1234.00", "2.1101567E-16", "1.0e5", "2.5e+5", "9e4", "-12e-3", "0.25" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = "[" + STR + "]"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, "UTF-8"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { "1234.00", "2.1101567E-16", "1.0e5", "2.5e+5", "9e4", "-12e-3", "0.25" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = "[" + STR + "]"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, "UTF-8"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal("0.1"); [EOL]     final String TEXT = "\"some\nString!\""; [EOL]     gen.writeNullField("null"); [EOL]     gen.writeBooleanField("bt", true); [EOL]     gen.writeBooleanField("bf", false); [EOL]     gen.writeNumberField("int", -1289); [EOL]     gen.writeNumberField("dec", dec); [EOL]     gen.writeObjectFieldStart("ob"); [EOL]     gen.writeStringField("str", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart("arr"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("null", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("bt", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("bf", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("int", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testCommentsWithEOF() throws Exception { [EOL]     final String JSON = "[ nil ]"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp = (i == 0) ? createParserUsingReader(JSON) : createParserUsingStream(JSON, "UTF-8"); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         try { [EOL]             jp.nextToken(); [EOL]             fail("Expected an exception for EOF"); [EOL]         } catch (EOFException e) { [EOL]             verifyException(e, "was expecting either * for a comment"); [EOL]         } [EOL]         jp.close(); [EOL]     } [EOL] }
public void testCommentsWithEOF() throws Exception { [EOL]     final String JSON = "[ nil ]"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp = (i == 0) ? createParserUsingReader(JSON) : createParserUsingStream(JSON, "UTF-8"); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         try { [EOL]             jp.nextToken(); [EOL]             fail("Expected an exception for EOF"); [EOL]         } catch (EOFException e) { [EOL]             verifyException(e, "was expecting either * for a comment"); [EOL]         } [EOL]         jp.close(); [EOL]     } [EOL] }
public void testCommentsWithEOF() throws Exception { [EOL]     final String JSON = "[ nil ]"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp = (i == 0) ? createParserUsingReader(JSON) : createParserUsingStream(JSON, "UTF-8"); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         try { [EOL]             jp.nextToken(); [EOL]             fail("Expected an exception for EOF"); [EOL]         } catch (EOFException e) { [EOL]             verifyException(e, "was expecting either * for a comment"); [EOL]         } [EOL]         jp.close(); [EOL]     } [EOL] }
public void testCommentsWithEOF() throws Exception { [EOL]     final String JSON = "[ nil ]"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp = (i == 0) ? createParserUsingReader(JSON) : createParserUsingStream(JSON, "UTF-8"); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         try { [EOL]             jp.nextToken(); [EOL]             fail("Expected an exception for EOF"); [EOL]         } catch (EOFException e) { [EOL]             verifyException(e, "was expecting either * for a comment"); [EOL]         } [EOL]         jp.close(); [EOL]     } [EOL] }
public void testCommentsWithEOF() throws Exception { [EOL]     final String JSON = "[ nil ]"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp = (i == 0) ? createParserUsingReader(JSON) : createParserUsingStream(JSON, "UTF-8"); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         try { [EOL]             jp.nextToken(); [EOL]             fail("Expected an exception for EOF"); [EOL]         } catch (EOFException e) { [EOL]             verifyException(e, "was expecting either * for a comment"); [EOL]         } [EOL]         jp.close(); [EOL]     } [EOL] }
public void testCommentsWithEOF() throws Exception { [EOL]     final String JSON = "[ 1, 3, [ true, null ], 3, { \"a\":\"b\" }, [ [ ] ], { } ]"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp = (i == 0) ? createParserUsingReader(JSON) : createParserUsingStream(JSON, "UTF-8"); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         try { [EOL]             jp.nextToken(); [EOL]             fail("Expected an exception for EOF"); [EOL]         } catch (JsonParseException jpe) { [EOL]             verifyException(jpe, "Unexpected end-of-input"); [EOL]         } [EOL]         jp.close(); [EOL]     } [EOL] }
public void testCommentsWithEOF() throws Exception { [EOL]     final String JSON = "[ 1, 3, [ true, null ], 3, { \"a\":\"b\" }, [ [ ] ], { } ]"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(JSON); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(JSON, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getIntValue()); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         jp.close(); [EOL]         assertEquals(0, jp.getIntValue()); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testCommentsWithUTF8() throws Exception { [EOL]     final String JSON = "[ 1, 3, [ true, null ], 3, { \"a\":\"b\" }, [ [ ] ], { } ]"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp = (i == 0) ? createParserUsingReader(JSON) : createParserUsingStream(JSON, "UTF-8"); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         try { [EOL]             jp.nextToken(); [EOL]             fail("Expected an exception for weird token"); [EOL]         } catch (JsonParseException jpe) { [EOL]             verifyException(jpe, "Unrecognized token"); [EOL]         } [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { "1234.00", "2.1101567E-16", "1.0e5", "2.5e+5", "9e4", "-12e-3", "0.25" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = "[" + STR + "]"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, "UTF-8"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { "1234.00", "2.1101567E-16", "1.0e5", "2.5e+5", "9e4", "-12e-3", "0.25" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = "[" + STR + "]"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, "UTF-8"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testCommentsWithUTF8() throws Exception { [EOL]     final String JSON = "[ 1, 3, [ true, null ], 3, { \"a\":\"b\" }, [ [ ] ], { } ]"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp = (i == 0) ? createParserUsingReader(JSON) : createParserUsingStream(JSON, "UTF-8"); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         try { [EOL]             jp.nextToken(); [EOL]             fail("Expected an exception for weird token"); [EOL]         } catch (JsonParseException jpe) { [EOL]             verifyException(jpe, "Unrecognized token"); [EOL]         } [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { "1234.00", "2.1101567E-16", "1.0e5", "2.5e+5", "9e4", "-12e-3", "0.25" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = "[" + STR + "]"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, "UTF-8"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { "1234.00", "2.1101567E-16", "1.0e5", "2.5e+5", "9e4", "-12e-3", "0.25" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = "[" + STR + "]"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, "UTF-8"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { "1234.00", "2.1101567E-16", "1.0e5", "2.5e+5", "9e4", "-12e-3", "0.25" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = "[" + STR + "]"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, "UTF-8"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testCommentsWithUTF8() throws Exception { [EOL]     final String JSON = "[ 1, 3, [ true, null ], 3, { \"a\":\"b\" }, [ [ ] ], { } ]"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp = (i == 0) ? createParserUsingReader(JSON) : createParserUsingStream(JSON, "UTF-8"); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         try { [EOL]             jp.nextToken(); [EOL]             fail("Expected an exception for weird token"); [EOL]         } catch (JsonParseException jpe) { [EOL]             verifyException(jpe, "Unrecognized token"); [EOL]         } [EOL]         jp.close(); [EOL]     } [EOL] }
public void testCommentsWithUTF8() throws Exception { [EOL]     final String JSON = "[ 1, 3, [ true, null ], 3, { \"a\":\"b\" }, [ [ ] ], { } ]"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp = (i == 0) ? createParserUsingReader(JSON) : createParserUsingStream(JSON, "UTF-8"); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         try { [EOL]             jp.nextToken(); [EOL]             fail("Expected an exception for weird token"); [EOL]         } catch (JsonParseException jpe) { [EOL]             verifyException(jpe, "Unrecognized token"); [EOL]         } [EOL]         jp.close(); [EOL]     } [EOL] }
public void testCommentsWithUTF8() throws Exception { [EOL]     final String JSON = "[ 1, 3, [ true, null ], 3, { \"a\":\"b\" }, [ [ ] ], { } ]"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp = (i == 0) ? createParserUsingReader(JSON) : createParserUsingStream(JSON, "UTF-8"); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         try { [EOL]             jp.nextToken(); [EOL]             fail("Expected an exception for weird token"); [EOL]         } catch (JsonParseException jpe) { [EOL]             verifyException(jpe, "Unrecognized token"); [EOL]         } [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { "1234.00", "2.1101567E-16", "1.0e5", "2.5e+5", "9e4", "-12e-3", "0.25" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = "[" + STR + "]"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, "UTF-8"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testCRLF() throws Exception { [EOL]     _testLinefeeds("\r\n", true); [EOL]     _testLinefeeds("\r\n", false); [EOL] }
public void testCommentsWithEOF() throws Exception { [EOL]     final String JSON = "[ 1, 3, [ true, null ], 3, { \"a\":\"b\" }, [ [ ] ], { } ]"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(JSON); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(JSON, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(1, jp.getIntValue()); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         jp.close(); [EOL]         assertEquals(0, jp.getIntValue()); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testCRLF() throws Exception { [EOL]     _testLinefeeds("\r\n", true); [EOL]     _testLinefeeds("\r\n", false); [EOL] }
public void testCRLF() throws Exception { [EOL]     _testLinefeeds("\r\n", true); [EOL]     _testLinefeeds("\r\n", false); [EOL] }
public void testCRLF() throws Exception { [EOL]     _testLinefeeds("\r\n", true); [EOL]     _testLinefeeds("\r\n", false); [EOL] }
public void testCRLF() throws Exception { [EOL]     _testLinefeeds("\r\n", true); [EOL]     _testLinefeeds("\r\n", false); [EOL] }
public void testCRLF() throws Exception { [EOL]     _testLinefeeds("\r\n", true); [EOL]     _testLinefeeds("\r\n", false); [EOL] }
public void testCRLF() throws Exception { [EOL]     _testLinefeeds("\r\n", true); [EOL]     _testLinefeeds("\r\n", false); [EOL] }
public void testStringWrite() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String[] inputStrings = new String[] { "", "X", "1234567890" }; [EOL]     for (int useReader = 0; useReader < 2; ++useReader) { [EOL]         for (int writeString = 0; writeString < 2; ++writeString) { [EOL]             for (int strIx = 0; strIx < inputStrings.length; ++strIx) { [EOL]                 String input = inputStrings[strIx]; [EOL]                 JsonGenerator gen; [EOL]                 ByteArrayOutputStream bout = new ByteArrayOutputStream(); [EOL]                 if (useReader != 0) { [EOL]                     gen = jf.createGenerator(new OutputStreamWriter(bout, "UTF-8")); [EOL]                 } else { [EOL]                     gen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]                 } [EOL]                 if (writeString > 0) { [EOL]                     gen.writeString(input); [EOL]                 } else { [EOL]                     int len = input.length(); [EOL]                     char[] buffer = new char[len + 20]; [EOL]                     input.getChars(0, len, buffer, strIx); [EOL]                     gen.writeString(buffer, strIx, len); [EOL]                 } [EOL]                 gen.flush(); [EOL]                 gen.close(); [EOL]                 JsonParser jp = jf.createParser(new ByteArrayInputStream(bout.toByteArray())); [EOL]                 JsonToken t = jp.nextToken(); [EOL]                 assertNotNull("Document \"" + bout.toString("UTF-8") + "\" yielded no tokens", t); [EOL]                 assertEquals(JsonToken.VALUE_STRING, t); [EOL]                 assertEquals(input, jp.getText()); [EOL]                 assertEquals(null, jp.nextToken()); [EOL]                 jp.close(); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void testStringWrite() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String[] inputStrings = new String[] { "", "X", "1234567890" }; [EOL]     for (int useReader = 0; useReader < 2; ++useReader) { [EOL]         for (int writeString = 0; writeString < 2; ++writeString) { [EOL]             for (int strIx = 0; strIx < inputStrings.length; ++strIx) { [EOL]                 String input = inputStrings[strIx]; [EOL]                 JsonGenerator gen; [EOL]                 ByteArrayOutputStream bout = new ByteArrayOutputStream(); [EOL]                 if (useReader != 0) { [EOL]                     gen = jf.createGenerator(new OutputStreamWriter(bout, "UTF-8")); [EOL]                 } else { [EOL]                     gen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]                 } [EOL]                 if (writeString > 0) { [EOL]                     gen.writeString(input); [EOL]                 } else { [EOL]                     int len = input.length(); [EOL]                     char[] buffer = new char[len + 20]; [EOL]                     input.getChars(0, len, buffer, strIx); [EOL]                     gen.writeString(buffer, strIx, len); [EOL]                 } [EOL]                 gen.flush(); [EOL]                 gen.close(); [EOL]                 JsonParser jp = jf.createParser(new ByteArrayInputStream(bout.toByteArray())); [EOL]                 JsonToken t = jp.nextToken(); [EOL]                 assertNotNull("Document \"" + bout.toString("UTF-8") + "\" yielded no tokens", t); [EOL]                 assertEquals(JsonToken.VALUE_STRING, t); [EOL]                 assertEquals(input, jp.getText()); [EOL]                 assertEquals(null, jp.nextToken()); [EOL]                 jp.close(); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void testStringWrite() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String[] inputStrings = new String[] { "", "X", "1234567890" }; [EOL]     for (int useReader = 0; useReader < 2; ++useReader) { [EOL]         for (int writeString = 0; writeString < 2; ++writeString) { [EOL]             for (int strIx = 0; strIx < inputStrings.length; ++strIx) { [EOL]                 String input = inputStrings[strIx]; [EOL]                 JsonGenerator gen; [EOL]                 ByteArrayOutputStream bout = new ByteArrayOutputStream(); [EOL]                 if (useReader != 0) { [EOL]                     gen = jf.createGenerator(new OutputStreamWriter(bout, "UTF-8")); [EOL]                 } else { [EOL]                     gen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]                 } [EOL]                 if (writeString > 0) { [EOL]                     gen.writeString(input); [EOL]                 } else { [EOL]                     int len = input.length(); [EOL]                     char[] buffer = new char[len + 20]; [EOL]                     input.getChars(0, len, buffer, strIx); [EOL]                     gen.writeString(buffer, strIx, len); [EOL]                 } [EOL]                 gen.flush(); [EOL]                 gen.close(); [EOL]                 JsonParser jp = jf.createParser(new ByteArrayInputStream(bout.toByteArray())); [EOL]                 JsonToken t = jp.nextToken(); [EOL]                 assertNotNull("Document \"" + bout.toString("UTF-8") + "\" yielded no tokens", t); [EOL]                 assertEquals(JsonToken.VALUE_STRING, t); [EOL]                 assertEquals(input, jp.getText()); [EOL]                 assertEquals(null, jp.nextToken()); [EOL]                 jp.close(); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void testStringWrite() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String[] inputStrings = new String[] { "", "X", "1234567890" }; [EOL]     for (int useReader = 0; useReader < 2; ++useReader) { [EOL]         for (int writeString = 0; writeString < 2; ++writeString) { [EOL]             for (int strIx = 0; strIx < inputStrings.length; ++strIx) { [EOL]                 String input = inputStrings[strIx]; [EOL]                 JsonGenerator gen; [EOL]                 ByteArrayOutputStream bout = new ByteArrayOutputStream(); [EOL]                 if (useReader != 0) { [EOL]                     gen = jf.createGenerator(new OutputStreamWriter(bout, "UTF-8")); [EOL]                 } else { [EOL]                     gen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]                 } [EOL]                 if (writeString > 0) { [EOL]                     gen.writeString(input); [EOL]                 } else { [EOL]                     int len = input.length(); [EOL]                     char[] buffer = new char[len + 20]; [EOL]                     input.getChars(0, len, buffer, strIx); [EOL]                     gen.writeString(buffer, strIx, len); [EOL]                 } [EOL]                 gen.flush(); [EOL]                 gen.close(); [EOL]                 JsonParser jp = jf.createParser(new ByteArrayInputStream(bout.toByteArray())); [EOL]                 JsonToken t = jp.nextToken(); [EOL]                 assertNotNull("Document \"" + bout.toString("UTF-8") + "\" yielded no tokens", t); [EOL]                 assertEquals(JsonToken.VALUE_STRING, t); [EOL]                 assertEquals(input, jp.getText()); [EOL]                 assertEquals(null, jp.nextToken()); [EOL]                 jp.close(); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void testStringWrite() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String[] inputStrings = new String[] { "", "X", "1234567890" }; [EOL]     for (int useReader = 0; useReader < 2; ++useReader) { [EOL]         for (int writeString = 0; writeString < 2; ++writeString) { [EOL]             for (int strIx = 0; strIx < inputStrings.length; ++strIx) { [EOL]                 String input = inputStrings[strIx]; [EOL]                 JsonGenerator gen; [EOL]                 ByteArrayOutputStream bout = new ByteArrayOutputStream(); [EOL]                 if (useReader != 0) { [EOL]                     gen = jf.createGenerator(new OutputStreamWriter(bout, "UTF-8")); [EOL]                 } else { [EOL]                     gen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]                 } [EOL]                 if (writeString > 0) { [EOL]                     gen.writeString(input); [EOL]                 } else { [EOL]                     int len = input.length(); [EOL]                     char[] buffer = new char[len + 20]; [EOL]                     input.getChars(0, len, buffer, strIx); [EOL]                     gen.writeString(buffer, strIx, len); [EOL]                 } [EOL]                 gen.flush(); [EOL]                 gen.close(); [EOL]                 JsonParser jp = jf.createParser(new ByteArrayInputStream(bout.toByteArray())); [EOL]                 JsonToken t = jp.nextToken(); [EOL]                 assertNotNull("Document \"" + bout.toString("UTF-8") + "\" yielded no tokens", t); [EOL]                 assertEquals(JsonToken.VALUE_STRING, t); [EOL]                 assertEquals(input, jp.getText()); [EOL]                 assertEquals(null, jp.nextToken()); [EOL]                 jp.close(); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void testInvalidObjectWrite() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     try { [EOL]         gen.writeEndArray(); [EOL]         fail("Expected an exception for mismatched array/object write"); [EOL]     } catch (JsonGenerationException e) { [EOL]         verifyException(e, "Current context not an array"); [EOL]     } [EOL]     gen.close(); [EOL] }
public void testStringWrite() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String[] inputStrings = new String[] { "", "X", "1234567890" }; [EOL]     for (int useReader = 0; useReader < 2; ++useReader) { [EOL]         for (int writeString = 0; writeString < 2; ++writeString) { [EOL]             for (int strIx = 0; strIx < inputStrings.length; ++strIx) { [EOL]                 String input = inputStrings[strIx]; [EOL]                 JsonGenerator gen; [EOL]                 ByteArrayOutputStream bout = new ByteArrayOutputStream(); [EOL]                 if (useReader != 0) { [EOL]                     gen = jf.createGenerator(new OutputStreamWriter(bout, "UTF-8")); [EOL]                 } else { [EOL]                     gen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]                 } [EOL]                 if (writeString > 0) { [EOL]                     gen.writeString(input); [EOL]                 } else { [EOL]                     int len = input.length(); [EOL]                     char[] buffer = new char[len + 20]; [EOL]                     input.getChars(0, len, buffer, strIx); [EOL]                     gen.writeString(buffer, strIx, len); [EOL]                 } [EOL]                 gen.flush(); [EOL]                 gen.close(); [EOL]                 JsonParser jp = jf.createParser(new ByteArrayInputStream(bout.toByteArray())); [EOL]                 JsonToken t = jp.nextToken(); [EOL]                 assertNotNull("Document \"" + bout.toString("UTF-8") + "\" yielded no tokens", t); [EOL]                 assertEquals(JsonToken.VALUE_STRING, t); [EOL]                 assertEquals(input, jp.getText()); [EOL]                 assertEquals(null, jp.nextToken()); [EOL]                 jp.close(); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void testStringWrite() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String[] inputStrings = new String[] { "", "X", "1234567890" }; [EOL]     for (int useReader = 0; useReader < 2; ++useReader) { [EOL]         for (int writeString = 0; writeString < 2; ++writeString) { [EOL]             for (int strIx = 0; strIx < inputStrings.length; ++strIx) { [EOL]                 String input = inputStrings[strIx]; [EOL]                 JsonGenerator gen; [EOL]                 ByteArrayOutputStream bout = new ByteArrayOutputStream(); [EOL]                 if (useReader != 0) { [EOL]                     gen = jf.createGenerator(new OutputStreamWriter(bout, "UTF-8")); [EOL]                 } else { [EOL]                     gen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]                 } [EOL]                 if (writeString > 0) { [EOL]                     gen.writeString(input); [EOL]                 } else { [EOL]                     int len = input.length(); [EOL]                     char[] buffer = new char[len + 20]; [EOL]                     input.getChars(0, len, buffer, strIx); [EOL]                     gen.writeString(buffer, strIx, len); [EOL]                 } [EOL]                 gen.flush(); [EOL]                 gen.close(); [EOL]                 JsonParser jp = jf.createParser(new ByteArrayInputStream(bout.toByteArray())); [EOL]                 JsonToken t = jp.nextToken(); [EOL]                 assertNotNull("Document \"" + bout.toString("UTF-8") + "\" yielded no tokens", t); [EOL]                 assertEquals(JsonToken.VALUE_STRING, t); [EOL]                 assertEquals(input, jp.getText()); [EOL]                 assertEquals(null, jp.nextToken()); [EOL]                 jp.close(); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void testStringWrite() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String[] inputStrings = new String[] { "", "X", "1234567890" }; [EOL]     for (int useReader = 0; useReader < 2; ++useReader) { [EOL]         for (int writeString = 0; writeString < 2; ++writeString) { [EOL]             for (int strIx = 0; strIx < inputStrings.length; ++strIx) { [EOL]                 String input = inputStrings[strIx]; [EOL]                 JsonGenerator gen; [EOL]                 ByteArrayOutputStream bout = new ByteArrayOutputStream(); [EOL]                 if (useReader != 0) { [EOL]                     gen = jf.createGenerator(new OutputStreamWriter(bout, "UTF-8")); [EOL]                 } else { [EOL]                     gen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]                 } [EOL]                 if (writeString > 0) { [EOL]                     gen.writeString(input); [EOL]                 } else { [EOL]                     int len = input.length(); [EOL]                     char[] buffer = new char[len + 20]; [EOL]                     input.getChars(0, len, buffer, strIx); [EOL]                     gen.writeString(buffer, strIx, len); [EOL]                 } [EOL]                 gen.flush(); [EOL]                 gen.close(); [EOL]                 JsonParser jp = jf.createParser(new ByteArrayInputStream(bout.toByteArray())); [EOL]                 JsonToken t = jp.nextToken(); [EOL]                 assertNotNull("Document \"" + bout.toString("UTF-8") + "\" yielded no tokens", t); [EOL]                 assertEquals(JsonToken.VALUE_STRING, t); [EOL]                 assertEquals(input, jp.getText()); [EOL]                 assertEquals(null, jp.nextToken()); [EOL]                 jp.close(); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void testStringWrite() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String[] inputStrings = new String[] { "", "X", "1234567890" }; [EOL]     for (int useReader = 0; useReader < 2; ++useReader) { [EOL]         for (int writeString = 0; writeString < 2; ++writeString) { [EOL]             for (int strIx = 0; strIx < inputStrings.length; ++strIx) { [EOL]                 String input = inputStrings[strIx]; [EOL]                 JsonGenerator gen; [EOL]                 ByteArrayOutputStream bout = new ByteArrayOutputStream(); [EOL]                 if (useReader != 0) { [EOL]                     gen = jf.createGenerator(new OutputStreamWriter(bout, "UTF-8")); [EOL]                 } else { [EOL]                     gen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]                 } [EOL]                 if (writeString > 0) { [EOL]                     gen.writeString(input); [EOL]                 } else { [EOL]                     int len = input.length(); [EOL]                     char[] buffer = new char[len + 20]; [EOL]                     input.getChars(0, len, buffer, strIx); [EOL]                     gen.writeString(buffer, strIx, len); [EOL]                 } [EOL]                 gen.flush(); [EOL]                 gen.close(); [EOL]                 JsonParser jp = jf.createParser(new ByteArrayInputStream(bout.toByteArray())); [EOL]                 JsonToken t = jp.nextToken(); [EOL]                 assertNotNull("Document \"" + bout.toString("UTF-8") + "\" yielded no tokens", t); [EOL]                 assertEquals(JsonToken.VALUE_STRING, t); [EOL]                 assertEquals(input, jp.getText()); [EOL]                 assertEquals(null, jp.nextToken()); [EOL]                 jp.close(); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void testSimple() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(sw); [EOL]     _writeSimple(jgen); [EOL]     jgen.close(); [EOL]     String json = sw.toString(); [EOL]     _verifySimple(jf.createParser(json)); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     _writeSimple(jgen); [EOL]     jgen.close(); [EOL]     byte[] jsonB = out.toByteArray(); [EOL]     _verifySimple(jf.createParser(jsonB)); [EOL] }
public void testStringWrite() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String[] inputStrings = new String[] { "", "X", "1234567890" }; [EOL]     for (int useReader = 0; useReader < 2; ++useReader) { [EOL]         for (int writeString = 0; writeString < 2; ++writeString) { [EOL]             for (int strIx = 0; strIx < inputStrings.length; ++strIx) { [EOL]                 String input = inputStrings[strIx]; [EOL]                 JsonGenerator gen; [EOL]                 ByteArrayOutputStream bout = new ByteArrayOutputStream(); [EOL]                 if (useReader != 0) { [EOL]                     gen = jf.createGenerator(new OutputStreamWriter(bout, "UTF-8")); [EOL]                 } else { [EOL]                     gen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]                 } [EOL]                 if (writeString > 0) { [EOL]                     gen.writeString(input); [EOL]                 } else { [EOL]                     int len = input.length(); [EOL]                     char[] buffer = new char[len + 20]; [EOL]                     input.getChars(0, len, buffer, strIx); [EOL]                     gen.writeString(buffer, strIx, len); [EOL]                 } [EOL]                 gen.flush(); [EOL]                 gen.close(); [EOL]                 JsonParser jp = jf.createParser(new ByteArrayInputStream(bout.toByteArray())); [EOL]                 JsonToken t = jp.nextToken(); [EOL]                 assertNotNull("Document \"" + bout.toString("UTF-8") + "\" yielded no tokens", t); [EOL]                 assertEquals(JsonToken.VALUE_STRING, t); [EOL]                 assertEquals(input, jp.getText()); [EOL]                 assertEquals(null, jp.nextToken()); [EOL]                 jp.close(); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void testStringWrite() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String[] inputStrings = new String[] { "", "X", "1234567890" }; [EOL]     for (int useReader = 0; useReader < 2; ++useReader) { [EOL]         for (int writeString = 0; writeString < 2; ++writeString) { [EOL]             for (int strIx = 0; strIx < inputStrings.length; ++strIx) { [EOL]                 String input = inputStrings[strIx]; [EOL]                 JsonGenerator gen; [EOL]                 ByteArrayOutputStream bout = new ByteArrayOutputStream(); [EOL]                 if (useReader != 0) { [EOL]                     gen = jf.createGenerator(new OutputStreamWriter(bout, "UTF-8")); [EOL]                 } else { [EOL]                     gen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]                 } [EOL]                 if (writeString > 0) { [EOL]                     gen.writeString(input); [EOL]                 } else { [EOL]                     int len = input.length(); [EOL]                     char[] buffer = new char[len + 20]; [EOL]                     input.getChars(0, len, buffer, strIx); [EOL]                     gen.writeString(buffer, strIx, len); [EOL]                 } [EOL]                 gen.flush(); [EOL]                 gen.close(); [EOL]                 JsonParser jp = jf.createParser(new ByteArrayInputStream(bout.toByteArray())); [EOL]                 JsonToken t = jp.nextToken(); [EOL]                 assertNotNull("Document \"" + bout.toString("UTF-8") + "\" yielded no tokens", t); [EOL]                 assertEquals(JsonToken.VALUE_STRING, t); [EOL]                 assertEquals(input, jp.getText()); [EOL]                 assertEquals(null, jp.nextToken()); [EOL]                 jp.close(); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void testStringWrite() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String[] inputStrings = new String[] { "", "X", "1234567890" }; [EOL]     for (int useReader = 0; useReader < 2; ++useReader) { [EOL]         for (int writeString = 0; writeString < 2; ++writeString) { [EOL]             for (int strIx = 0; strIx < inputStrings.length; ++strIx) { [EOL]                 String input = inputStrings[strIx]; [EOL]                 JsonGenerator gen; [EOL]                 ByteArrayOutputStream bout = new ByteArrayOutputStream(); [EOL]                 if (useReader != 0) { [EOL]                     gen = jf.createGenerator(new OutputStreamWriter(bout, "UTF-8")); [EOL]                 } else { [EOL]                     gen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]                 } [EOL]                 if (writeString > 0) { [EOL]                     gen.writeString(input); [EOL]                 } else { [EOL]                     int len = input.length(); [EOL]                     char[] buffer = new char[len + 20]; [EOL]                     input.getChars(0, len, buffer, strIx); [EOL]                     gen.writeString(buffer, strIx, len); [EOL]                 } [EOL]                 gen.flush(); [EOL]                 gen.close(); [EOL]                 JsonParser jp = jf.createParser(new ByteArrayInputStream(bout.toByteArray())); [EOL]                 JsonToken t = jp.nextToken(); [EOL]                 assertNotNull("Document \"" + bout.toString("UTF-8") + "\" yielded no tokens", t); [EOL]                 assertEquals(JsonToken.VALUE_STRING, t); [EOL]                 assertEquals(input, jp.getText()); [EOL]                 assertEquals(null, jp.nextToken()); [EOL]                 jp.close(); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void testStringWrite() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String[] inputStrings = new String[] { "", "X", "1234567890" }; [EOL]     for (int useReader = 0; useReader < 2; ++useReader) { [EOL]         for (int writeString = 0; writeString < 2; ++writeString) { [EOL]             for (int strIx = 0; strIx < inputStrings.length; ++strIx) { [EOL]                 String input = inputStrings[strIx]; [EOL]                 JsonGenerator gen; [EOL]                 ByteArrayOutputStream bout = new ByteArrayOutputStream(); [EOL]                 if (useReader != 0) { [EOL]                     gen = jf.createGenerator(new OutputStreamWriter(bout, "UTF-8")); [EOL]                 } else { [EOL]                     gen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]                 } [EOL]                 if (writeString > 0) { [EOL]                     gen.writeString(input); [EOL]                 } else { [EOL]                     int len = input.length(); [EOL]                     char[] buffer = new char[len + 20]; [EOL]                     input.getChars(0, len, buffer, strIx); [EOL]                     gen.writeString(buffer, strIx, len); [EOL]                 } [EOL]                 gen.flush(); [EOL]                 gen.close(); [EOL]                 JsonParser jp = jf.createParser(new ByteArrayInputStream(bout.toByteArray())); [EOL]                 JsonToken t = jp.nextToken(); [EOL]                 assertNotNull("Document \"" + bout.toString("UTF-8") + "\" yielded no tokens", t); [EOL]                 assertEquals(JsonToken.VALUE_STRING, t); [EOL]                 assertEquals(input, jp.getText()); [EOL]                 assertEquals(null, jp.nextToken()); [EOL]                 jp.close(); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void testStringWrite() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String[] inputStrings = new String[] { "", "X", "1234567890" }; [EOL]     for (int useReader = 0; useReader < 2; ++useReader) { [EOL]         for (int writeString = 0; writeString < 2; ++writeString) { [EOL]             for (int strIx = 0; strIx < inputStrings.length; ++strIx) { [EOL]                 String input = inputStrings[strIx]; [EOL]                 JsonGenerator gen; [EOL]                 ByteArrayOutputStream bout = new ByteArrayOutputStream(); [EOL]                 if (useReader != 0) { [EOL]                     gen = jf.createGenerator(new OutputStreamWriter(bout, "UTF-8")); [EOL]                 } else { [EOL]                     gen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]                 } [EOL]                 if (writeString > 0) { [EOL]                     gen.writeString(input); [EOL]                 } else { [EOL]                     int len = input.length(); [EOL]                     char[] buffer = new char[len + 20]; [EOL]                     input.getChars(0, len, buffer, strIx); [EOL]                     gen.writeString(buffer, strIx, len); [EOL]                 } [EOL]                 gen.flush(); [EOL]                 gen.close(); [EOL]                 JsonParser jp = jf.createParser(new ByteArrayInputStream(bout.toByteArray())); [EOL]                 JsonToken t = jp.nextToken(); [EOL]                 assertNotNull("Document \"" + bout.toString("UTF-8") + "\" yielded no tokens", t); [EOL]                 assertEquals(JsonToken.VALUE_STRING, t); [EOL]                 assertEquals(input, jp.getText()); [EOL]                 assertEquals(null, jp.nextToken()); [EOL]                 jp.close(); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void testStringWrite() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String[] inputStrings = new String[] { "", "X", "1234567890" }; [EOL]     for (int useReader = 0; useReader < 2; ++useReader) { [EOL]         for (int writeString = 0; writeString < 2; ++writeString) { [EOL]             for (int strIx = 0; strIx < inputStrings.length; ++strIx) { [EOL]                 String input = inputStrings[strIx]; [EOL]                 JsonGenerator gen; [EOL]                 ByteArrayOutputStream bout = new ByteArrayOutputStream(); [EOL]                 if (useReader != 0) { [EOL]                     gen = jf.createGenerator(new OutputStreamWriter(bout, "UTF-8")); [EOL]                 } else { [EOL]                     gen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]                 } [EOL]                 if (writeString > 0) { [EOL]                     gen.writeString(input); [EOL]                 } else { [EOL]                     int len = input.length(); [EOL]                     char[] buffer = new char[len + 20]; [EOL]                     input.getChars(0, len, buffer, strIx); [EOL]                     gen.writeString(buffer, strIx, len); [EOL]                 } [EOL]                 gen.flush(); [EOL]                 gen.close(); [EOL]                 JsonParser jp = jf.createParser(new ByteArrayInputStream(bout.toByteArray())); [EOL]                 JsonToken t = jp.nextToken(); [EOL]                 assertNotNull("Document \"" + bout.toString("UTF-8") + "\" yielded no tokens", t); [EOL]                 assertEquals(JsonToken.VALUE_STRING, t); [EOL]                 assertEquals(input, jp.getText()); [EOL]                 assertEquals(null, jp.nextToken()); [EOL]                 jp.close(); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void testStringWrite() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String[] inputStrings = new String[] { "", "X", "1234567890" }; [EOL]     for (int useReader = 0; useReader < 2; ++useReader) { [EOL]         for (int writeString = 0; writeString < 2; ++writeString) { [EOL]             for (int strIx = 0; strIx < inputStrings.length; ++strIx) { [EOL]                 String input = inputStrings[strIx]; [EOL]                 JsonGenerator gen; [EOL]                 ByteArrayOutputStream bout = new ByteArrayOutputStream(); [EOL]                 if (useReader != 0) { [EOL]                     gen = jf.createGenerator(new OutputStreamWriter(bout, "UTF-8")); [EOL]                 } else { [EOL]                     gen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]                 } [EOL]                 if (writeString > 0) { [EOL]                     gen.writeString(input); [EOL]                 } else { [EOL]                     int len = input.length(); [EOL]                     char[] buffer = new char[len + 20]; [EOL]                     input.getChars(0, len, buffer, strIx); [EOL]                     gen.writeString(buffer, strIx, len); [EOL]                 } [EOL]                 gen.flush(); [EOL]                 gen.close(); [EOL]                 JsonParser jp = jf.createParser(new ByteArrayInputStream(bout.toByteArray())); [EOL]                 JsonToken t = jp.nextToken(); [EOL]                 assertNotNull("Document \"" + bout.toString("UTF-8") + "\" yielded no tokens", t); [EOL]                 assertEquals(JsonToken.VALUE_STRING, t); [EOL]                 assertEquals(input, jp.getText()); [EOL]                 assertEquals(null, jp.nextToken()); [EOL]                 jp.close(); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void testStringWrite() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String[] inputStrings = new String[] { "", "X", "1234567890" }; [EOL]     for (int useReader = 0; useReader < 2; ++useReader) { [EOL]         for (int writeString = 0; writeString < 2; ++writeString) { [EOL]             for (int strIx = 0; strIx < inputStrings.length; ++strIx) { [EOL]                 String input = inputStrings[strIx]; [EOL]                 JsonGenerator gen; [EOL]                 ByteArrayOutputStream bout = new ByteArrayOutputStream(); [EOL]                 if (useReader != 0) { [EOL]                     gen = jf.createGenerator(new OutputStreamWriter(bout, "UTF-8")); [EOL]                 } else { [EOL]                     gen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]                 } [EOL]                 if (writeString > 0) { [EOL]                     gen.writeString(input); [EOL]                 } else { [EOL]                     int len = input.length(); [EOL]                     char[] buffer = new char[len + 20]; [EOL]                     input.getChars(0, len, buffer, strIx); [EOL]                     gen.writeString(buffer, strIx, len); [EOL]                 } [EOL]                 gen.flush(); [EOL]                 gen.close(); [EOL]                 JsonParser jp = jf.createParser(new ByteArrayInputStream(bout.toByteArray())); [EOL]                 JsonToken t = jp.nextToken(); [EOL]                 assertNotNull("Document \"" + bout.toString("UTF-8") + "\" yielded no tokens", t); [EOL]                 assertEquals(JsonToken.VALUE_STRING, t); [EOL]                 assertEquals(input, jp.getText()); [EOL]                 assertEquals(null, jp.nextToken()); [EOL]                 jp.close(); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void testStringWrite() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String[] inputStrings = new String[] { "", "X", "1234567890" }; [EOL]     for (int useReader = 0; useReader < 2; ++useReader) { [EOL]         for (int writeString = 0; writeString < 2; ++writeString) { [EOL]             for (int strIx = 0; strIx < inputStrings.length; ++strIx) { [EOL]                 String input = inputStrings[strIx]; [EOL]                 JsonGenerator gen; [EOL]                 ByteArrayOutputStream bout = new ByteArrayOutputStream(); [EOL]                 if (useReader != 0) { [EOL]                     gen = jf.createGenerator(new OutputStreamWriter(bout, "UTF-8")); [EOL]                 } else { [EOL]                     gen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]                 } [EOL]                 if (writeString > 0) { [EOL]                     gen.writeString(input); [EOL]                 } else { [EOL]                     int len = input.length(); [EOL]                     char[] buffer = new char[len + 20]; [EOL]                     input.getChars(0, len, buffer, strIx); [EOL]                     gen.writeString(buffer, strIx, len); [EOL]                 } [EOL]                 gen.flush(); [EOL]                 gen.close(); [EOL]                 JsonParser jp = jf.createParser(new ByteArrayInputStream(bout.toByteArray())); [EOL]                 JsonToken t = jp.nextToken(); [EOL]                 assertNotNull("Document \"" + bout.toString("UTF-8") + "\" yielded no tokens", t); [EOL]                 assertEquals(JsonToken.VALUE_STRING, t); [EOL]                 assertEquals(input, jp.getText()); [EOL]                 assertEquals(null, jp.nextToken()); [EOL]                 jp.close(); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void testSimple() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(sw); [EOL]     _writeSimple(jgen); [EOL]     jgen.close(); [EOL]     String json = sw.toString(); [EOL]     _verifySimple(jf.createParser(json)); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     _writeSimple(jgen); [EOL]     jgen.close(); [EOL]     byte[] jsonB = out.toByteArray(); [EOL]     _verifySimple(jf.createParser(jsonB)); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testSimpleDocWithDefault() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.useDefaultPrettyPrinter(); [EOL]     _verifyPrettyPrinter(gen, sw); [EOL]     gen.close(); [EOL] }
public void testWriteLongCustomEscapes() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setCharacterEscapes(ESC_627); [EOL]     StringBuilder longString = new StringBuilder(); [EOL]     while (longString.length() < 2000) { [EOL]         longString.append("\u65e5\u672c\u8a9e"); [EOL]     } [EOL]     StringWriter writer = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(writer); [EOL]     jgen.setHighestNonEscapedChar(127); [EOL]     jgen.writeString(longString.toString()); [EOL]     jgen.close(); [EOL] }
public void testWriteLongCustomEscapes() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setCharacterEscapes(ESC_627); [EOL]     StringBuilder longString = new StringBuilder(); [EOL]     while (longString.length() < 2000) { [EOL]         longString.append("\u65e5\u672c\u8a9e"); [EOL]     } [EOL]     StringWriter writer = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(writer); [EOL]     jgen.setHighestNonEscapedChar(127); [EOL]     jgen.writeString(longString.toString()); [EOL]     jgen.close(); [EOL] }
public void testStringWrite() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String[] inputStrings = new String[] { "", "X", "1234567890" }; [EOL]     for (int useReader = 0; useReader < 2; ++useReader) { [EOL]         for (int writeString = 0; writeString < 2; ++writeString) { [EOL]             for (int strIx = 0; strIx < inputStrings.length; ++strIx) { [EOL]                 String input = inputStrings[strIx]; [EOL]                 JsonGenerator gen; [EOL]                 ByteArrayOutputStream bout = new ByteArrayOutputStream(); [EOL]                 if (useReader != 0) { [EOL]                     gen = jf.createGenerator(new OutputStreamWriter(bout, "UTF-8")); [EOL]                 } else { [EOL]                     gen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]                 } [EOL]                 if (writeString > 0) { [EOL]                     gen.writeString(input); [EOL]                 } else { [EOL]                     int len = input.length(); [EOL]                     char[] buffer = new char[len + 20]; [EOL]                     input.getChars(0, len, buffer, strIx); [EOL]                     gen.writeString(buffer, strIx, len); [EOL]                 } [EOL]                 gen.flush(); [EOL]                 gen.close(); [EOL]                 JsonParser jp = jf.createParser(new ByteArrayInputStream(bout.toByteArray())); [EOL]                 JsonToken t = jp.nextToken(); [EOL]                 assertNotNull("Document \"" + bout.toString("UTF-8") + "\" yielded no tokens", t); [EOL]                 assertEquals(JsonToken.VALUE_STRING, t); [EOL]                 assertEquals(input, jp.getText()); [EOL]                 assertEquals(null, jp.nextToken()); [EOL]                 jp.close(); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void testStringWrite() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String[] inputStrings = new String[] { "", "X", "1234567890" }; [EOL]     for (int useReader = 0; useReader < 2; ++useReader) { [EOL]         for (int writeString = 0; writeString < 2; ++writeString) { [EOL]             for (int strIx = 0; strIx < inputStrings.length; ++strIx) { [EOL]                 String input = inputStrings[strIx]; [EOL]                 JsonGenerator gen; [EOL]                 ByteArrayOutputStream bout = new ByteArrayOutputStream(); [EOL]                 if (useReader != 0) { [EOL]                     gen = jf.createGenerator(new OutputStreamWriter(bout, "UTF-8")); [EOL]                 } else { [EOL]                     gen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]                 } [EOL]                 if (writeString > 0) { [EOL]                     gen.writeString(input); [EOL]                 } else { [EOL]                     int len = input.length(); [EOL]                     char[] buffer = new char[len + 20]; [EOL]                     input.getChars(0, len, buffer, strIx); [EOL]                     gen.writeString(buffer, strIx, len); [EOL]                 } [EOL]                 gen.flush(); [EOL]                 gen.close(); [EOL]                 JsonParser jp = jf.createParser(new ByteArrayInputStream(bout.toByteArray())); [EOL]                 JsonToken t = jp.nextToken(); [EOL]                 assertNotNull("Document \"" + bout.toString("UTF-8") + "\" yielded no tokens", t); [EOL]                 assertEquals(JsonToken.VALUE_STRING, t); [EOL]                 assertEquals(input, jp.getText()); [EOL]                 assertEquals(null, jp.nextToken()); [EOL]                 jp.close(); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void testStringWrite() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String[] inputStrings = new String[] { "", "X", "1234567890" }; [EOL]     for (int useReader = 0; useReader < 2; ++useReader) { [EOL]         for (int writeString = 0; writeString < 2; ++writeString) { [EOL]             for (int strIx = 0; strIx < inputStrings.length; ++strIx) { [EOL]                 String input = inputStrings[strIx]; [EOL]                 JsonGenerator gen; [EOL]                 ByteArrayOutputStream bout = new ByteArrayOutputStream(); [EOL]                 if (useReader != 0) { [EOL]                     gen = jf.createGenerator(new OutputStreamWriter(bout, "UTF-8")); [EOL]                 } else { [EOL]                     gen = jf.createGenerator(bout, JsonEncoding.UTF8); [EOL]                 } [EOL]                 if (writeString > 0) { [EOL]                     gen.writeString(input); [EOL]                 } else { [EOL]                     int len = input.length(); [EOL]                     char[] buffer = new char[len + 20]; [EOL]                     input.getChars(0, len, buffer, strIx); [EOL]                     gen.writeString(buffer, strIx, len); [EOL]                 } [EOL]                 gen.flush(); [EOL]                 gen.close(); [EOL]                 JsonParser jp = jf.createParser(new ByteArrayInputStream(bout.toByteArray())); [EOL]                 JsonToken t = jp.nextToken(); [EOL]                 assertNotNull("Document \"" + bout.toString("UTF-8") + "\" yielded no tokens", t); [EOL]                 assertEquals(JsonToken.VALUE_STRING, t); [EOL]                 assertEquals(input, jp.getText()); [EOL]                 assertEquals(null, jp.nextToken()); [EOL]                 jp.close(); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testSimpleUnquoted() throws Exception { [EOL]     _testSimpleUnquoted(false); [EOL]     _testSimpleUnquoted(true); [EOL] }
public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('"'); [EOL]         sb2.append("\\\""); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     char[] result = encoder.quoteAsString(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }
public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('"'); [EOL]         sb2.append("\\\""); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     char[] result = encoder.quoteAsString(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }
public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('"'); [EOL]         sb2.append("\\\""); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     char[] result = encoder.quoteAsString(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }
public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('"'); [EOL]         sb2.append("\\\""); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     char[] result = encoder.quoteAsString(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }
public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('"'); [EOL]         sb2.append("\\\""); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     byte[] result = encoder.quoteAsUTF8(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }
public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('"'); [EOL]         sb2.append("\\\""); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     byte[] result = encoder.quoteAsUTF8(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }
public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('"'); [EOL]         sb2.append("\\\""); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     byte[] result = encoder.quoteAsUTF8(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }
public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('"'); [EOL]         sb2.append("\\\""); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     byte[] result = encoder.quoteAsUTF8(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }
public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('"'); [EOL]         sb2.append("\\\""); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     byte[] result = encoder.quoteAsUTF8(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }
public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('"'); [EOL]         sb2.append("\\\""); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     byte[] result = encoder.quoteAsUTF8(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }
public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('"'); [EOL]         sb2.append("\\\""); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     byte[] result = encoder.quoteAsUTF8(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }
public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('"'); [EOL]         sb2.append("\\\""); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     byte[] result = encoder.quoteAsUTF8(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }
public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('"'); [EOL]         sb2.append("\\\""); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     byte[] result = encoder.quoteAsUTF8(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }
public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('"'); [EOL]         sb2.append("\\\""); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     byte[] result = encoder.quoteAsUTF8(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }
public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('"'); [EOL]         sb2.append("\\\""); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     byte[] result = encoder.quoteAsUTF8(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }
public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('"'); [EOL]         sb2.append("\\\""); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     byte[] result = encoder.quoteAsUTF8(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }
public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('"'); [EOL]         sb2.append("\\\""); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     byte[] result = encoder.quoteAsUTF8(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }
public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('"'); [EOL]         sb2.append("\\\""); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     byte[] result = encoder.quoteAsUTF8(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }
public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('"'); [EOL]         sb2.append("\\\""); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     byte[] result = encoder.quoteAsUTF8(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }
public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('"'); [EOL]         sb2.append("\\\""); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     byte[] result = encoder.quoteAsUTF8(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }
public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('"'); [EOL]         sb2.append("\\\""); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     byte[] result = encoder.quoteAsUTF8(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }
public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('"'); [EOL]         sb2.append("\\\""); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     byte[] result = encoder.quoteAsUTF8(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }
public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('"'); [EOL]         sb2.append("\\\""); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     byte[] result = encoder.quoteAsUTF8(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }
public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('"'); [EOL]         sb2.append("\\\""); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     byte[] result = encoder.quoteAsUTF8(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }
public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('"'); [EOL]         sb2.append("\\\""); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     byte[] result = encoder.quoteAsUTF8(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }
public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('"'); [EOL]         sb2.append("\\\""); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     byte[] result = encoder.quoteAsUTF8(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }
public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('"'); [EOL]         sb2.append("\\\""); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     byte[] result = encoder.quoteAsUTF8(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }
public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('"'); [EOL]         sb2.append("\\\""); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     byte[] result = encoder.quoteAsUTF8(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }
public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('"'); [EOL]         sb2.append("\\\""); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     byte[] result = encoder.quoteAsUTF8(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }
public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('"'); [EOL]         sb2.append("\\\""); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     byte[] result = encoder.quoteAsUTF8(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }
public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('"'); [EOL]         sb2.append("\\\""); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     byte[] result = encoder.quoteAsUTF8(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }
public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('"'); [EOL]         sb2.append("\\\""); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     byte[] result = encoder.quoteAsUTF8(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }
public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('"'); [EOL]         sb2.append("\\\""); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     byte[] result = encoder.quoteAsUTF8(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }
public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('"'); [EOL]         sb2.append("\\\""); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     byte[] result = encoder.quoteAsUTF8(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }
public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('"'); [EOL]         sb2.append("\\\""); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     byte[] result = encoder.quoteAsUTF8(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }
public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('"'); [EOL]         sb2.append("\\\""); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     byte[] result = encoder.quoteAsUTF8(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }
public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('"'); [EOL]         sb2.append("\\\""); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     byte[] result = encoder.quoteAsUTF8(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }
public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('"'); [EOL]         sb2.append("\\\""); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     byte[] result = encoder.quoteAsUTF8(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }
public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('"'); [EOL]         sb2.append("\\\""); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     byte[] result = encoder.quoteAsUTF8(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }
public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('"'); [EOL]         sb2.append("\\\""); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     byte[] result = encoder.quoteAsUTF8(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }
public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('"'); [EOL]         sb2.append("\\\""); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     byte[] result = encoder.quoteAsUTF8(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }
public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('"'); [EOL]         sb2.append("\\\""); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     byte[] result = encoder.quoteAsUTF8(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }
public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('"'); [EOL]         sb2.append("\\\""); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     byte[] result = encoder.quoteAsUTF8(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }
public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('"'); [EOL]         sb2.append("\\\""); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     byte[] result = encoder.quoteAsUTF8(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }
public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('"'); [EOL]         sb2.append("\\\""); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     byte[] result = encoder.quoteAsUTF8(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }
public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('"'); [EOL]         sb2.append("\\\""); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     byte[] result = encoder.quoteAsUTF8(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }
public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     StringBuilder sb3 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('"'); [EOL]         sb2.append("\\\""); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     char[] result = encoder.quoteAsString(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }
public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     StringBuilder sb3 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('"'); [EOL]         sb2.append("\\\""); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     char[] result = encoder.quoteAsString(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }
public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     StringBuilder sb3 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('"'); [EOL]         sb2.append("\\\""); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     char[] result = encoder.quoteAsString(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }
public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     StringBuilder sb3 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('"'); [EOL]         sb2.append("\\\""); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     char[] result = encoder.quoteAsString(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }
public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     StringBuilder sb3 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('"'); [EOL]         sb2.append("\\\""); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     char[] result = encoder.quoteAsString(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }
public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     StringBuilder sb3 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('"'); [EOL]         sb2.append("\\\""); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     char[] result = encoder.quoteAsString(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }
public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     StringBuilder sb3 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('"'); [EOL]         sb2.append("\\\""); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     char[] result = encoder.quoteAsString(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }
public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     StringBuilder sb3 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('"'); [EOL]         sb2.append("\\\""); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     char[] result = encoder.quoteAsString(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }
public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     StringBuilder sb3 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('"'); [EOL]         sb2.append("\\\""); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     char[] result = encoder.quoteAsString(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }
public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     StringBuilder sb3 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('"'); [EOL]         sb2.append("\\\""); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     char[] result = encoder.quoteAsString(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }
public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     StringBuilder sb3 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('"'); [EOL]         sb2.append("\\\""); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     char[] result = encoder.quoteAsString(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }
public void testQuoteLongAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     StringBuilder sb2 = new StringBuilder(); [EOL]     StringBuilder sb3 = new StringBuilder(); [EOL]     for (int i = 0; i < 1111; ++i) { [EOL]         sb.append('"'); [EOL]         sb2.append("\\\""); [EOL]     } [EOL]     String input = sb.toString(); [EOL]     String exp = sb2.toString(); [EOL]     char[] result = encoder.quoteAsString(input); [EOL]     assertEquals(2 * input.length(), result.length); [EOL]     assertEquals(exp, new String(result)); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testInvalidIntAccess() throws Exception { [EOL]     JsonParser jp = createParserUsingReader("[ \"abc\" ]"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getIntValue(); [EOL]         fail("Expected error trying to call getIntValue on non-numeric value"); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, "can not use numeric value accessors"); [EOL]     } [EOL]     jp.close(); [EOL] }
public void testInvalidIntAccess() throws Exception { [EOL]     JsonParser jp = createParserUsingReader("[ \"abc\" ]"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getIntValue(); [EOL]         fail("Expected error trying to call getIntValue on non-numeric value"); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, "can not use numeric value accessors"); [EOL]     } [EOL]     jp.close(); [EOL] }
public void testInvalidIntAccess() throws Exception { [EOL]     JsonParser jp = createParserUsingReader("[ \"abc\" ]"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getIntValue(); [EOL]         fail("Expected error trying to call getIntValue on non-numeric value"); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, "can not use numeric value accessors"); [EOL]     } [EOL]     jp.close(); [EOL] }
public void testInvalidIntAccess() throws Exception { [EOL]     JsonParser jp = createParserUsingReader("[ \"abc\" ]"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getIntValue(); [EOL]         fail("Expected error trying to call getIntValue on non-numeric value"); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, "can not use numeric value accessors"); [EOL]     } [EOL]     jp.close(); [EOL] }
public void testInvalidIntAccess() throws Exception { [EOL]     JsonParser jp = createParserUsingReader("[ \"abc\" ]"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getIntValue(); [EOL]         fail("Expected error trying to call getIntValue on non-numeric value"); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, "can not use numeric value accessors"); [EOL]     } [EOL]     jp.close(); [EOL] }
public void testInvalidIntAccess() throws Exception { [EOL]     JsonParser jp = createParserUsingReader("[ \"abc\" ]"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getIntValue(); [EOL]         fail("Expected error trying to call getIntValue on non-numeric value"); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, "can not use numeric value accessors"); [EOL]     } [EOL]     jp.close(); [EOL] }
public void testInvalidIntAccess() throws Exception { [EOL]     JsonParser jp = createParserUsingReader("[ \"abc\" ]"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getIntValue(); [EOL]         fail("Expected error trying to call getIntValue on non-numeric value"); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, "can not use numeric value accessors"); [EOL]     } [EOL]     jp.close(); [EOL] }
public void testUnquoted() throws Exception { [EOL]     _testUnquoted(false); [EOL]     _testUnquoted(true); [EOL] }
public void testAllowUnquoted() throws Exception { [EOL]     _testAllowUnquoted(false); [EOL]     _testAllowUnquoted(true); [EOL] }
public void testUnquoted() throws Exception { [EOL]     _testUnquoted(false); [EOL]     _testUnquoted(true); [EOL] }
public void testUnquoted() throws Exception { [EOL]     _testUnquoted(false); [EOL]     _testUnquoted(true); [EOL] }
public void testUnquoted() throws Exception { [EOL]     _testUnquoted(false); [EOL]     _testUnquoted(true); [EOL] }
public void testSimple() throws Exception { [EOL]     JsonParser jp = createParserUsingReader("[ 1, true ]"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertEquals("[", jp.getText()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertTrue(jp.getBooleanValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL]     assertEquals("[", jp.getText()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testInvalidIntAccess() throws Exception { [EOL]     JsonParser jp = createParserUsingReader("[ \"abc\" ]"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getIntValue(); [EOL]         fail("Expected error trying to call getIntValue on non-numeric value"); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, "can not use numeric value accessors"); [EOL]     } [EOL]     jp.close(); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testInvalidIntAccess() throws Exception { [EOL]     JsonParser jp = createParserUsingReader("[ \"abc\" ]"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getIntValue(); [EOL]         fail("Expected error trying to call getIntValue on non-numeric value"); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, "can not use numeric value accessors"); [EOL]     } [EOL]     jp.close(); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testIsClosed() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonGenerator jg = stream ? jf.createGenerator(new StringWriter()) : jf.createGenerator(new ByteArrayOutputStream(), JsonEncoding.UTF8); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.writeStartArray(); [EOL]         jg.writeNumber(-1); [EOL]         jg.writeEndArray(); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]     } [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal("0.1"); [EOL]     final String TEXT = "\"some\nString!\""; [EOL]     gen.writeNullField("null"); [EOL]     gen.writeBooleanField("bt", true); [EOL]     gen.writeBooleanField("bf", false); [EOL]     gen.writeNumberField("int", -1289); [EOL]     gen.writeNumberField("dec", dec); [EOL]     gen.writeObjectFieldStart("ob"); [EOL]     gen.writeStringField("str", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart("arr"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("null", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("bt", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("bf", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("int", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal("0.1"); [EOL]     final String TEXT = "\"some\nString!\""; [EOL]     gen.writeNullField("null"); [EOL]     gen.writeBooleanField("bt", true); [EOL]     gen.writeBooleanField("bf", false); [EOL]     gen.writeNumberField("int", -1289); [EOL]     gen.writeNumberField("dec", dec); [EOL]     gen.writeObjectFieldStart("ob"); [EOL]     gen.writeStringField("str", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart("arr"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("null", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("bt", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("bf", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("int", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.
public void testIsClosed() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonGenerator jg = stream ? jf.createGenerator(new StringWriter()) : jf.createGenerator(new ByteArrayOutputStream(), JsonEncoding.UTF8); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.writeStartArray(); [EOL]         jg.writeNumber(-1); [EOL]         jg.writeEndArray(); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]     } [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal("0.1"); [EOL]     final String TEXT = "\"some\nString!\""; [EOL]     gen.writeNullField("null"); [EOL]     gen.writeBooleanField("bt", true); [EOL]     gen.writeBooleanField("bf", false); [EOL]     gen.writeNumberField("int", -1289); [EOL]     gen.writeNumberField("dec", dec); [EOL]     gen.writeObjectFieldStart("ob"); [EOL]     gen.writeStringField("str", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart("arr"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("null", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("bt", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("bf", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("int", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.
public void testIsClosed() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonGenerator jg = stream ? jf.createGenerator(new StringWriter()) : jf.createGenerator(new ByteArrayOutputStream(), JsonEncoding.UTF8); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.writeStartArray(); [EOL]         jg.writeNumber(-1); [EOL]         jg.writeEndArray(); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]     } [EOL] }
public void testConvenienceMethods() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal("0.1"); [EOL]     final String TEXT = "\"some\nString!\""; [EOL]     gen.writeNullField("null"); [EOL]     gen.writeBooleanField("bt", true); [EOL]     gen.writeBooleanField("bf", false); [EOL]     gen.writeNumberField("int", -1289); [EOL]     gen.writeNumberField("dec", dec); [EOL]     gen.writeObjectFieldStart("ob"); [EOL]     gen.writeStringField("str", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart("arr"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("null", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("bt", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("bf", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("int", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = "{\"simple\":[1,true,{}]}"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = "{\"simple\":[1,true,{}]}"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = "{\"simple\":[1,true,{}]}"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = "{\"simple\":[1,true,{}]}"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = "{\"simple\":[1,true,{}]}"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = "{\"simple\":[1,true,{}]}"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = "{\"simple\":[1,true,{}]}"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = "{\"simple\":[1,true,{}]}"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = "{\"simple\":[1,true,{}]}"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = "{\"simple\":[1,true,{}]}"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = "{\"simple\":[1,true,{}]}"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = "{\"simple\":[1,true,{}]}"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testJsonWithFiles() throws Exception { [EOL]     File file = File.createTempFile("jackson-test", null); [EOL]     file.deleteOnExit(); [EOL]     JsonFactory f = new JsonFactory(); [EOL]     JsonGenerator jg = f.createGenerator(file, JsonEncoding.UTF16_LE); [EOL]     jg.writeStartObject(); [EOL]     jg.writeRaw("   "); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     JsonParser jp = f.createParser(file); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     jp = f.createParser(file.toURI().toURL()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     file.delete(); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = "{\"simple\":[1,true,{}]}"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = "{\"simple\":[1,true,{}]}"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testParserFeatures() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     assertNull(f.getCodec()); [EOL]     f.configure(JsonFactory.Feature.INTERN_FIELD_NAMES, true); [EOL]     assertTrue(f.isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES)); [EOL]     f.configure(JsonFactory.Feature.INTERN_FIELD_NAMES, false); [EOL]     assertFalse(f.isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES)); [EOL] }
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testParserFeatures() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     assertNull(f.getCodec()); [EOL]     f.configure(JsonFactory.Feature.INTERN_FIELD_NAMES, true); [EOL]     assertTrue(f.isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES)); [EOL]     f.configure(JsonFactory.Feature.INTERN_FIELD_NAMES, false); [EOL]     assertFalse(f.isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES)); [EOL] }
public void testParserFeatures() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     assertNull(f.getCodec()); [EOL]     f.configure(JsonFactory.Feature.INTERN_FIELD_NAMES, true); [EOL]     assertTrue(f.isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES)); [EOL]     f.configure(JsonFactory.Feature.INTERN_FIELD_NAMES, false); [EOL]     assertFalse(f.isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES)); [EOL] }
public void testParserFeatures() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     assertNull(f.getCodec()); [EOL]     f.configure(JsonFactory.Feature.INTERN_FIELD_NAMES, true); [EOL]     assertTrue(f.isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES)); [EOL]     f.configure(JsonFactory.Feature.INTERN_FIELD_NAMES, false); [EOL]     assertFalse(f.isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES)); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = "{\"simple\":[1,true,{}]}"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = "{\"simple\":[1,true,{}]}"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = "{\"simple\":[1,true,{}]}"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = "{\"simple\":[1,true,{}]}"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = "{\"simple\":[1,true,{}]}"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testParserFeatures() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     assertNull(f.getCodec()); [EOL]     f.configure(JsonFactory.Feature.INTERN_FIELD_NAMES, true); [EOL]     assertTrue(f.isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES)); [EOL]     f.configure(JsonFactory.Feature.INTERN_FIELD_NAMES, false); [EOL]     assertFalse(f.isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES)); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = "{\"simple\":[1,true,{}]}"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = "{\"simple\":[1,true,{}]}"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = "{\"simple\":[1,true,{}]}"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testJsonFactorySerializable() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     String origJson = "{\"simple\":[1,true,{}]}"; [EOL]     assertEquals(origJson, _copyJson(f, origJson, false)); [EOL]     byte[] frozen = jdkSerialize(f); [EOL]     JsonFactory f2 = jdkDeserialize(frozen); [EOL]     assertNotNull(f2); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, false)); [EOL]     assertEquals(origJson, _copyJson(f2, origJson, true)); [EOL] }
public void testNameEscaping() throws IOException { [EOL]     _testNameEscaping(false); [EOL]     _testNameEscaping(true); [EOL] }
public void testSharedSymbols() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     String DOC0 = "{ \"a\" : 1, \"x\" : [ ] }"; [EOL]     JsonParser jp0 = createParser(jf, DOC0); [EOL]     while (jp0.nextToken() != JsonToken.START_ARRAY) { [EOL]     } [EOL]     String doc1 = createDoc(FIELD_NAMES, true); [EOL]     String doc2 = createDoc(FIELD_NAMES, false); [EOL]     for (int x = 0; x < 2; ++x) { [EOL]         JsonParser jp1 = createParser(jf, doc1); [EOL]         JsonParser jp2 = createParser(jf, doc2); [EOL]         assertToken(JsonToken.START_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.START_OBJECT, jp2.nextToken()); [EOL]         int len = FIELD_NAMES.length; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             assertToken(JsonToken.FIELD_NAME, jp1.nextToken()); [EOL]             assertToken(JsonToken.FIELD_NAME, jp2.nextToken()); [EOL]             assertEquals(FIELD_NAMES[i], jp1.getCurrentName()); [EOL]             assertEquals(FIELD_NAMES[len - (i + 1)], jp2.getCurrentName()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken()); [EOL]             assertEquals(i, jp1.getIntValue()); [EOL]             assertEquals(i, jp2.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_OBJECT, jp1.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp2.nextToken()); [EOL]         jp1.close(); [EOL]         jp2.close(); [EOL]     } [EOL]     jp0.close(); [EOL] }
public void testAuxMethods() throws IOException { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     final BigDecimal dec = new BigDecimal("0.1"); [EOL]     final String TEXT = "\"some\nString!\""; [EOL]     gen.writeNullField("null"); [EOL]     gen.writeBooleanField("bt", true); [EOL]     gen.writeBooleanField("bf", false); [EOL]     gen.writeNumberField("int", -1289); [EOL]     gen.writeNumberField("dec", dec); [EOL]     gen.writeObjectFieldStart("ob"); [EOL]     gen.writeStringField("str", TEXT); [EOL]     gen.writeEndObject(); [EOL]     gen.writeArrayFieldStart("arr"); [EOL]     gen.writeEndArray(); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("null", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("bt", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("bf", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("int", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.
public void testNameEscaping() throws IOException { [EOL]     _testNameEscaping(false); [EOL]     _testNameEscaping(true); [EOL] }
