@Test public void testIsAnnotationBundle() { JacksonAnnotationIntrospector jacksonAnnotationIntrospector = new JacksonAnnotationIntrospector(); jacksonAnnotationIntrospector.setVersion(JacksonAnnotationIntrospector.Version.VERSION_3); jacksonAnnotationIntrospector.setIgnoreMissingFields(true); jacksonAnnotationIntrospector.setIgnoreUnknownFields(true); jacksonAnnotationIntrospector.setIgnoreUnknownFields(true); assertTrue(jacksonAnnotationIntrospector.isAnnotationBundle(jacksonAnnotationIntrospector.findAnnotation(Object.class))); assertTrue(jacksonAnnotationIntrospector.isAnnotationBundle(jacksonAnnotationIntrospector.findAnnotation
@Test public void testIsAnnotationBundle() { JacksonAnnotationIntrospector jacksonAnnotationIntrospector = new JacksonAnnotationIntrospector(); jacksonAnnotationIntrospector.setVersion(JacksonAnnotationIntrospector.Version.VERSION_3); jacksonAnnotationIntrospector.setIgnoreMissingProperties(true); jacksonAnnotationIntrospector.setIgnoreUnknownProperties(true); jacksonAnnotationIntrospector.setIgnoreUnknownProperties(true); assertTrue(jacksonAnnotationIntrospector.isAnnotationBundle(jacksonAnnotationIntrospector.findAnnotation(Object.class))); assertTrue(jacksonAnnotationIntrospector.isAnnotationBundle(jacksonAnnotationIntrospector.findAnnotation
@Test public void testFindPropertiesToIgnore() { String[] props = new JacksonAnnotationIntrospector().findPropertiesToIgnore(AnnotatedClass.class.getDeclaredField("ignore")); assertNull(props); props = new JacksonAnnotationIntrospector().findPropertiesToIgnore(AnnotatedClass.class.getDeclaredField("ignore")); assertNull(props); props = new JacksonAnnotationIntrospector().findPropertiesToIgnore(AnnotatedClass.class.getDeclaredField("ignore")); assertNull(props); props = new JacksonAnnotationIntrospector().findPropertiesToIgnore(AnnotatedClass.class.getDeclaredField("ignore")); assertNull(props); }
@Test public void testFindIgnorePropertiesToIgnore() { JacksonAnnotationIntrospector jacksonAnnotationIntrospector = new JacksonAnnotationIntrospector(); jacksonAnnotationIntrospector.setIgnoreIgnore(true); String[] ignore = jacksonAnnotationIntrospector.findPropertiesToIgnore(AnnotatedClass.class.getDeclaredField("ignore")); assertNull(ignore); ignore = jacksonAnnotationIntrospector.findPropertiesToIgnore(AnnotatedClass.class.getDeclaredField("ignore")); assertNull(ignore); ignore = jacksonAnnotationIntrospector.findPropertiesToIgnore(AnnotatedClass.class.getDeclaredField("ignore")); assertNull(ignore); ignore = jacksonAnnotationIntrospect
@Test public void testIgnore() { String[] ignore = jacksonAnnotationIntrospector.findPropertiesToIgnore(AnnotatedClass.class.getDeclaredField("ignore")); assertNull(ignore); ignore = jacksonAnnotationIntrospector.findPropertiesToIgnore(AnnotatedClass.class.getDeclaredField("ignore")); assertEquals("ignore", ignore[0]); ignore = jacksonAnnotationIntrospector.findPropertiesToIgnore(AnnotatedClass.class.getDeclaredField("ignore")); assertEquals("ignore", ignore[0]); ignore = jacksonAnnotationIntrospector.findPropertiesToIgnore(AnnotatedClass.class.getDeclaredField("ignore")); assertNull(ignore); }
@Test public void testFindIgnoreUnknownProperties() { Set<String> properties = new HashSet<String>(); properties.add("prop1"); properties.add("prop2"); properties.add("prop3"); properties.add("prop4"); Set<String> ignore = new HashSet<String>(); ignore.add("prop1"); ignore.add("prop2"); ignore.add("prop3"); Set<String> ignore2 = new HashSet<String>(); ignore2.add("prop4"); ignore2.add("prop5"); ignore2.add("prop6"); Set<String> ignore3 = new HashSet<String>(); ignore3.add("prop7"); ignore3.add("prop
@Test public void testIgnoreUnknownProperties() { JacksonAnnotationIntrospector jacksonAnnotationIntrospector = new JacksonAnnotationIntrospector(); jacksonAnnotationIntrospector.setIgnoreUnknownProperties(true); assertTrue(jacksonAnnotationIntrospector.findIgnoreUnknownProperties(AnnotatedClass.class)); jacksonAnnotationIntrospector.setIgnoreUnknownProperties(false); assertFalse(jacksonAnnotationIntrospector.findIgnoreUnknownProperties(AnnotatedClass.class)); jacksonAnnotationIntrospector.setIgnoreUnknownProperties(true); assertTrue(jacksonAnnotationIntrospector.findIgnoreUnknownProperties(AnnotatedClass.class)); jacksonAnnotationIntrospector.setIgnoreUnknownProperties(false); assert
@Test public void testIgnoreUnknownProperties() { JacksonAnnotationIntrospector jacksonAnnotationIntrospector = new JacksonAnnotationIntrospector(); jacksonAnnotationIntrospector.setIgnoreUnknownProperties(true); assertTrue(jacksonAnnotationIntrospector.findIgnoreUnknownProperties(AnnotatedClass.class).isNull()); jacksonAnnotationIntrospector.setIgnoreUnknownProperties(false); assertFalse(jacksonAnnotationIntrospector.findIgnoreUnknownProperties(AnnotatedClass.class).isNull()); jacksonAnnotationIntrospector.setIgnoreUnknownProperties(true); assertTrue(jacksonAnnotationIntrospector.findIgnoreUnknownProperties(AnnotatedClass.class).isNull()); jacksonAnnotationIntrospector
@Test public void testIgnorableType() { try { JacksonAnnotationIntrospector jacksonAnnotationIntrospector = new JacksonAnnotationIntrospector(); jacksonAnnotationIntrospector.setIgnoreUnknownProperties(true); jacksonAnnotationIntrospector.setIgnoreType(true); jacksonAnnotationIntrospector.setIgnoreType(true); jacksonAnnotationIntrospector.setIgnoreType(true); jacksonAnnotationIntrospector.setIgnoreType(true); assertEquals(true, jacksonAnnotationIntrospector.isIgnorableType(AnnotatedClass.class)); assertEquals(true, jacksonAnnotationIntrospector.isIgnorableType(AnnotatedClass.class)); assertEquals
@Test public void testIgnorableType() { JacksonAnnotationIntrospector jacksonAnnotationIntrospector = new JacksonAnnotationIntrospector(); jacksonAnnotationIntrospector.setIgnoreIgnore(true); jacksonAnnotationIntrospector.setIgnoreUnknownProperties(true); jacksonAnnotationIntrospector.setIgnoreType(true); assertTrue(jacksonAnnotationIntrospector.isIgnorableType(AnnotatedClass.class)); assertTrue(jacksonAnnotationIntrospector.isIgnoreUnknownProperties(AnnotatedClass.class)); assertTrue(jacksonAnnotationIntrospector.isIgnoreType(AnnotatedClass.class)); assertTrue(jacksonAnnotationIntrospector.isIgnoreType(AnnotatedClass
@Test public void testIgnorableType() { JacksonAnnotationIntrospector jacksonAnnotationIntrospector = new JacksonAnnotationIntrospector(); jacksonAnnotationIntrospector.setIgnoreIgnorableType(true); assertTrue(jacksonAnnotationIntrospector.isIgnorableType(getClass())); jacksonAnnotationIntrospector.setIgnoreIgnorableType(false); assertFalse(jacksonAnnotationIntrospector.isIgnorableType(getClass())); jacksonAnnotationIntrospector.setIgnoreIgnorableType(true); assertFalse(jacksonAnnotationIntrospector.isIgnorableType(getClass())); jacksonAnnotationIntrospector.set
@Test public void testFindFilterId() { JacksonAnnotationIntrospector jacksonAnnotationIntrospector = new JacksonAnnotationIntrospector(); jacksonAnnotationIntrospector.setVersion(JacksonAnnotationIntrospector.Version.VERSION_3); jacksonAnnotationIntrospector.setIgnoreUnknownProperties(true); jacksonAnnotationIntrospector.setIgnoreUnknownPropertiesToIgnore(true); jacksonAnnotationIntrospector.setIgnoreUnknownPropertiesToIgnore(true); jacksonAnnotationIntrospector.setIgnoreUnknownPropertiesToIgnore(true); jacksonAnnotationIntrospector.setIgnoreUnknownPropertiesToIgnore(true); jacksonAnnotationIntrospector.setIgnoreUnknownPropertiesToIgnore(true);
@Test public void testFindFilterId() { JacksonAnnotationIntrospector jacksonAnnotationIntrospector = new JacksonAnnotationIntrospector(); jacksonAnnotationIntrospector.setVersion(JacksonAnnotationIntrospector.Version.VERSION_3); jacksonAnnotationIntrospector.setIgnoreUnknownProperties(true); jacksonAnnotationIntrospector.setIgnoreUnknownType(true); jacksonAnnotationIntrospector.setIgnoreUnwrappingValueIds(true); assertNull(jacksonAnnotationIntrospector.findFilterId(AnnotatedClass.class)); assertNull(jacksonAnnotationIntrospector.findFilterId(AnnotatedClass.class)); assertNull(jacksonAnnotationIntrospector.find
@Test public void testFindFilterId() { JacksonAnnotationIntrospector jacksonAnnotationIntrospector = new JacksonAnnotationIntrospector(); jacksonAnnotationIntrospector.setVersion(JacksonAnnotationIntrospector.Version.VERSION_3); jacksonAnnotationIntrospector.setIgnoreUnknownProperties(true); jacksonAnnotationIntrospector.setIgnoreUnknownPropertiesToIgnore(true); jacksonAnnotationIntrospector.setIgnoreUnknownPropertiesToIgnore(true); jacksonAnnotationIntrospector.setIgnoreUnknownPropertiesToIgnore(true); jacksonAnnotationIntrospector.setIgnoreUnknownPropertiesToIgnore(true); jacksonAnnotationIntrospector.setIgnoreUnknownPropertiesToIgnore(true);
@Test public void testFindFilterId() { JacksonAnnotationIntrospector jacksonAnnotationIntrospector = new JacksonAnnotationIntrospector(); jacksonAnnotationIntrospector.setVersion(JacksonAnnotationIntrospector.Version.VERSION_3); jacksonAnnotationIntrospector.setIgnoreUnknownProperties(true); jacksonAnnotationIntrospector.setIgnoreUnknownPropertiesToIgnore(true); jacksonAnnotationIntrospector.setIgnoreUnknownPropertiesToIgnore(true); jacksonAnnotationIntrospector.setIgnoreUnknownPropertiesToIgnore(true); jacksonAnnotationIntrospector.setIgnoreUnknownPropertiesToIgnore(true); jacksonAnnotationIntrospector.setIgnoreUnknownPropertiesToIgnore(true);
@Test public void testFindReferenceType() throws Exception { { JacksonAnnotationIntrospector jacksonAnnotationIntrospector = new JacksonAnnotationIntrospector(); JacksonAnnotations annotations = jacksonAnnotationIntrospector.findAnnotations(TestClass.class); ReferenceProperty type = jacksonAnnotationIntrospector.findReferenceType(annotations.get(0)); assertNotNull(type); } { JacksonAnnotationIntrospector jacksonAnnotationIntrospector = new JacksonAnnotationIntrospector(); ReferenceProperty type = jacksonAnnotationIntrospector.findReferenceType(annotations.get(1)); assertNotNull(type); } { JacksonAnnotationIntrospector jacksonAnnotationIntrospector = new JacksonAnnotationIntrospect
@Test public void testFindReferenceType() throws Exception { JacksonAnnotationIntrospector jacksonAnnotationIntrospector = new JacksonAnnotationIntrospector(); JacksonAnnotations annotations = jacksonAnnotationIntrospector.findAnnotations(TestClass.class); ReferenceProperty type = jacksonAnnotationIntrospector.findReferenceType(annotations.get(0)); assertNull(type); type = jacksonAnnotationIntrospector.findReferenceType(annotations.get(1)); assertNull(type); type = jacksonAnnotationIntrospector.findReferenceType(annotations.get(2)); assertNull(type); type = jacksonAnnotationIntrospector.findReferenceType(annotations.get(3)); assertNull
@Test public void testFindReferenceType() throws Exception { JacksonAnnotationIntrospector jacksonAnnotationIntrospector = new JacksonAnnotationIntrospector(); JacksonAnnotations annotations = jacksonAnnotationIntrospector.findAnnotations(TestClass.class); ReferenceProperty type = jacksonAnnotationIntrospector.findReferenceType(annotations.get(0)); assertNull(type); type = jacksonAnnotationIntrospector.findReferenceType(annotations.get(1)); assertNull(type); type = jacksonAnnotationIntrospector.findReferenceType(annotations.get(2)); assertNull(type); type = jacksonAnnotationIntrospector.findReferenceType(annotations.get(3)); assertNull
@Test public void testFindReferenceType() throws Exception { JacksonAnnotationIntrospector jacksonAnnotationIntrospector = new JacksonAnnotationIntrospector(); JacksonAnnotations annotations = jacksonAnnotationIntrospector.findAnnotations(TestClass.class); ReferenceProperty type = jacksonAnnotationIntrospector.findReferenceType(annotations.get(0)); assertNull(type); type = jacksonAnnotationIntrospector.findReferenceType(annotations.get(1)); assertNull(type); type = jacksonAnnotationIntrospector.findReferenceType(annotations.get(2)); assertNull(type); type = jacksonAnnotationIntrospector.findReferenceType(annotations.get(3)); assertNull
@Test public void testFindReferenceType() throws Exception { JacksonAnnotationIntrospector jacksonAnnotationIntrospector = new JacksonAnnotationIntrospector(); JacksonAnnotations annotations = jacksonAnnotationIntrospector.findAnnotations(TestClass.class); ReferenceProperty type = jacksonAnnotationIntrospector.findReferenceType(annotations.get(0)); assertNull(type); type = jacksonAnnotationIntrospector.findReferenceType(annotations.get(1)); assertNull(type); type = jacksonAnnotationIntrospector.findReferenceType(annotations.get(2)); assertNull(type); type = jacksonAnnotationIntrospector.findReferenceType(annotations.get(3)); assertNull
@Test public void testFindReferenceType() throws Exception { JacksonAnnotationIntrospector jacksonAnnotationIntrospector = new JacksonAnnotationIntrospector(); JacksonAnnotations annotations = jacksonAnnotationIntrospector.findAnnotations(); ReferenceProperty type = jacksonAnnotationIntrospector.findReferenceType(annotations.get(0)); assertNull(type); type = jacksonAnnotationIntrospector.findReferenceType(annotations.get(1)); assertNull(type); type = jacksonAnnotationIntrospector.findReferenceType(annotations.get(2)); assertNull(type); type = jacksonAnnotationIntrospector.findReferenceType(annotations.get(3)); assertNull(type); }
@Test public void testFindUnwrappingNameTransformer() { var ts = new JacksonAnnotationIntrospector(); var transformer = ts.findUnwrappingNameTransformer(MyAnnotatedClass.class.getDeclaredField("jsonUnwrapped")); assertNull(transformer); ts = new JacksonAnnotationIntrospector(); transformer = ts.findUnwrappingNameTransformer(MyAnnotatedClass.class.getDeclaredField("jsonUnwrapped")); assertNull(transformer); ts = new JacksonAnnotationIntrospector(); transformer = ts.findUnwrappingNameTransformer(MyAnnotatedClass.class.getDeclaredField("jsonUnwrapped")); assertNull(transformer); ts = new JacksonAnnotationIntrospector();
@Test public void testFindUnwrappingNameTransformer() { JsonUnwrapped test = new JsonUnwrapped() { @Override public boolean enabled() { return true; } @Override public String prefix() { return "testPrefix"; } @Override public String suffix() { return "testSuffix"; } }; JacksonAnnotationIntrospector jacksonAnnotationIntrospector = new JacksonAnnotationIntrospector(); jacksonAnnotationIntrospector.setMember(test.getClass().getDeclaredField("test")); jacksonAnnotationIntrospector.findUnwrappingNameTransformer(test.getClass().getDeclaredField("test")); assertNull(jacksonAnnotationIntrospector.findUnwrappingNameTransformer
@Test public void testFindUnwrappingNameTransformer() { JacksonAnnotationIntrospector jacksonAnnotationIntrospector = new JacksonAnnotationIntrospector(); jacksonAnnotationIntrospector.setVersion(JacksonAnnotationIntrospector.Version.V3); jacksonAnnotationIntrospector.setPrefix("prefix"); jacksonAnnotationIntrospector.setSuffix("suffix"); NameTransformer transformer = jacksonAnnotationIntrospector.findUnwrappingNameTransformer(MyAnnotatedClass.class); assertNull(transformer); transformer = jacksonAnnotationIntrospector.findUnwrappingNameTransformer(MyAnnotatedClass.class); assertNull(transformer); transformer = jacksonAnnotationIntrospector.findUnwrap
@Test public void testFindUnwrappingNameTransformer() { JacksonAnnotationIntrospector jacksonAnnotationIntrospector = new JacksonAnnotationIntrospector(); NameTransformer transformer = jacksonAnnotationIntrospector.findUnwrappingNameTransformer(jacksonAnnotationIntrospector.getMember(JsonUnwrapped.class)); assertNull(transformer); transformer = jacksonAnnotationIntrospector.findUnwrappingNameTransformer(jacksonAnnotationIntrospector.getMember(JsonUnwrapped.class)); assertNull(transformer); transformer = jacksonAnnotationIntrospector.findUnwrappingNameTransformer(jacksonAnnotationIntrospector.getMember(JsonUnwrapped.class)); assertNull(transformer); }
@Test public void testHasRequiredMarker() { try { JacksonAnnotationIntrospector jacksonAnnotationIntrospector = new JacksonAnnotationIntrospector(); jacksonAnnotationIntrospector.setVersion(JacksonAnnotationIntrospector.Version.VERSION_3); jacksonAnnotationIntrospector.setIgnoreMetadata(true); JacksonAnnotations annotations = jacksonAnnotationIntrospector.getAnnotations(); for (JsonProperty cp : annotations.getAnnotations()) { if (cp.isRequired()) { assertTrue(jacksonAnnotationIntrospector.hasRequiredMarker(cp)); } else { assertFalse(jacksonAnnotationIntrospector.hasRequiredMarker(cp)); } } } catch (JacksonException ex
@Test public void testHasRequiredMarker() throws Exception { JacksonAnnotationIntrospector jacksonAnnotationIntrospector = new JacksonAnnotationIntrospector(); jacksonAnnotationIntrospector.setVersion(JacksonAnnotationIntrospector.Version.VERSION_3); jacksonAnnotationIntrospector.setIgnoreMetadata(true); JacksonAnnotations annotations = jacksonAnnotationIntrospector.getAnnotations(); List<AnnotatedMember> members = annotations.getDeclaredMembers(); for (AnnotatedMember m : members) { if (m.isAnnotation(JsonProperty.class)) { assertTrue(jacksonAnnotationIntrospector.hasRequiredMarker(m)); } else { assertFalse(jacksonAnnotationIntrospector.
@Test public void testHasRequiredMarker() { JacksonAnnotationIntrospector jacksonAnnotationIntrospector = new JacksonAnnotationIntrospector(); jacksonAnnotationIntrospector.setVersion(JacksonAnnotationIntrospector.Version.VERSION_3); jacksonAnnotationIntrospector.setIgnoreMetadata(true); assertTrue(jacksonAnnotationIntrospector.hasRequiredMarker(getClass().getDeclaredField("requiredMarker"))); assertTrue(jacksonAnnotationIntrospector.hasRequiredMarker(getClass().getDeclaredField("notRequiredMarker"))); assertFalse(jacksonAnnotationIntrospector.hasRequiredMarker(getClass().getDeclaredField("notRequiredMarker"))); }
@Test public void testHasRequiredMarker() { JacksonAnnotationIntrospector jacksonAnnotationIntrospector = new JacksonAnnotationIntrospector(); jacksonAnnotationIntrospector.setVersion(JacksonAnnotationIntrospector.Version.VERSION_3); jacksonAnnotationIntrospector.setIgnoreMetadata(true); assertTrue(jacksonAnnotationIntrospector.hasRequiredMarker(AnnotatedClass.class.getDeclaredField("field1"))); assertTrue(jacksonAnnotationIntrospector.hasRequiredMarker(AnnotatedClass.class.getDeclaredField("field2"))); assertTrue(jacksonAnnotationIntrospector.hasRequiredMarker(AnnotatedClass.class.getDeclaredField("field3
@Test public void testHasRequiredMarker() { JacksonAnnotationIntrospector jacksonAnnotationIntrospector = new JacksonAnnotationIntrospector(); jacksonAnnotationIntrospector.setVersion(JacksonAnnotationIntrospector.Version.VERSION_3); jacksonAnnotationIntrospector.setIgnoreMetadata(true); assertTrue(jacksonAnnotationIntrospector.hasRequiredMarker(AnnotatedClass.class.getDeclaredField("field1"))); assertTrue(jacksonAnnotationIntrospector.hasRequiredMarker(AnnotatedClass.class.getDeclaredField("field2"))); assertTrue(jacksonAnnotationIntrospector.hasRequiredMarker(AnnotatedClass.class.getDeclaredField("field3
@Test public void testFindPropertyTypeResolver() { Class<?>[] types = new Class<?>[2]; for (int i = 0; i < types.length; i++) { types[i] = mock(JavaType.class); } when(baseType.isContainerType()).thenReturn(true); when(baseType.getMethods()).thenReturn(types); TypeResolverBuilder<?> resolver = findPropertyTypeResolver(null, null, baseType); assertNotNull(resolver); resolver = findPropertyTypeResolver(null, null, baseType); assertNotNull(resolver); resolver = findPropertyTypeResolver(null, null, null); assertNotNull(resolver); resolver = findPropertyTypeResolver(null, null, null); assertNotNull(resolver);
@Test public void testGetPropertyTypeResolver() { Class<?> type = getClass(); TypeResolverBuilder<?> resolver = TypeResolver.findPropertyTypeResolver(null, null, type); assertNull(resolver); resolver = TypeResolver.findPropertyTypeResolver(null, null, type); assertNull(resolver); resolver = TypeResolver.findPropertyTypeResolver(null, null, type); assertNull(resolver); resolver = TypeResolver.findPropertyTypeResolver(null, null, type); assertNull(resolver); resolver = TypeResolver.findPropertyTypeResolver(null, null, type); assertNull(resolver); resolver = TypeResolver.findPropertyTypeResolver(null, null, type); assertNull(resolver); resolver = TypeResolver.find
@Test public void testTypeResolver() { Class<?>[] types = new Class<?>[2]; for (int i = 0; i < types.length; i++) { types[i] = SimpleTypes.class; } TypeResolverBuilder<?> resolver = TypeResolver.findPropertyTypeResolver(null, null, SimpleTypes.class); Assert.assertNotNull(resolver); resolver = TypeResolver.findPropertyTypeResolver(null, null, SimpleTypes.class); Assert.assertNotNull(resolver); resolver = TypeResolver.findPropertyTypeResolver(null, null, SimpleTypes.class); Assert.assertNotNull(resolver); resolver = TypeResolver.findPropertyTypeResolver(null, null, SimpleTypes.class); Assert.
@Test public void testGetPropertyTypeResolver() { Class<?> type = getClass(); TypeResolver<?> resolver = findPropertyContentTypeResolver(null, null, type); assertNotNull(resolver); assertTrue(resolver.supports(String.class)); assertTrue(resolver.supports(Integer.class)); assertTrue(resolver.supports(Long.class)); assertTrue(resolver.supports(Float.class)); assertTrue(resolver.supports(Double.class)); resolver = findPropertyContentTypeResolver(null, null, type); assertNotNull(resolver); assertTrue(resolver.supports(String.class)); assertTrue(resolver.supports(Long.class)); assertTrue(resolver.supports(Float.class)); assertTrue(resolver.
@Test public void testGetPropertyTypeResolver() { JavaType ts = TypeResolverBuilder.defaultResolver().getContainerType(); TypeResolver<?> resolver = ts.findTypeResolver(null, null, ts); assertNotNull(resolver); assertEquals(String.class, resolver.findPropertyTypeResolver(null, null, ts).getClass()); resolver = ts.findTypeResolver(null, null, ts); assertNotNull(resolver); assertEquals(String.class, resolver.findPropertyTypeResolver(null, null, ts).getClass()); resolver = ts.findTypeResolver(null, null, ts); assertNotNull(resolver); assertEquals(String.class, resolver.findPropertyTypeResolver(null, null, ts).getClass
@Test public void testTypeResolver() { Class<?>[] types = new Class<?>[] { SimpleType.class, SimpleType2.class }; for (int i = 0; i < types.length; i++) { for (Class<?> type : types) { if (type == SimpleType2.class) continue; Map<String, Object> props = new HashMap<String, Object>(); props.put("prop1", "value1"); props.put("prop2", "value2"); TypeResolver rt = TypeResolver.findTypeResolver(null, null, type).getTypeResolver(); assertTrue(rt instanceof SimpleType2); } } }
@Test public void testFindSubtypes() { Set<String> names = new HashSet<String>(); for (JsonSubTypes.Type type : JsonSubTypes.Type.values()) { names.add(type.name()); } Set<String> expected = new HashSet<String>(); for (JsonSubTypes.Type type : JsonSubTypes.Type.values()) { expected.add(type.name()); } Set<String> actual = new HashSet<String>(); for (JsonSubTypes.Type type : JsonSubTypes.Type.values()) { actual.add(type.name()); } Set<String> actual2 = new HashSet<String>(); for (JsonSubTypes.Type type
@Test public void testFindSubtypes() throws Exception { JacksonAnnotationIntrospector jacksonAnnotationIntrospector = new JacksonAnnotationIntrospector(); jacksonAnnotationIntrospector.setVersion(JacksonAnnotationIntrospector.Version.VERSION_3); jacksonAnnotationIntrospector.findRootName(AnnotatedClass.class); jacksonAnnotationIntrospector.findSubtypes(AnnotatedClass.class.getDeclaredMethod("getProperty")); jacksonAnnotationIntrospector.findSubtypes(AnnotatedClass.class.getDeclaredMethod("getProperty2")); jacksonAnnotationIntrospector.findSubtypes(AnnotatedClass.class.getDeclaredMethod("getProperty3")); jackson
@Test public void testFindSubtypes() { JacksonAnnotationIntrospector jacksonAnnotationIntrospector = new JacksonAnnotationIntrospector(); jacksonAnnotationIntrospector.setVersion(JacksonAnnotationIntrospector.Version.VERSION_3); jacksonAnnotationIntrospector.setIgnoreUnknownProperties(true); List<NamedType> types = jacksonAnnotationIntrospector.findSubtypes(SampleAnnotatedClass.class); assertEquals(2, types.size()); NamedType t = types.get(0); assertEquals(String.class, t.getType()); assertEquals(String.class, t.getSerializer().getClass()); t = types.get(1); assertEquals
@Test public void testFindTypeName() { String[][] tests = new String[][] { new String[] { "a", "b", "c" }, new String[] { "a", "b", "c", "d" }, new String[] { "a", "b", "c", "d" }, new String[] { "a", "b", "c", "d" }, new String[] { "a", "b", "c", "d" }, new String[] { "a", "b", "c", "d" }, new String[] { "a", "b", "c", "d" }, new String[] { "a", "b", "
@Test public void testFindTypeName() { JacksonAnnotationIntrospector jacksonAnnotationIntrospector = new JacksonAnnotationIntrospector(); jacksonAnnotationIntrospector.setVersion(JacksonAnnotationIntrospector.Version.VERSION_3); jacksonAnnotationIntrospector.setIgnoreUnknownProperties(true); jacksonAnnotationIntrospector.setIgnoreUnknownKeys(true); jacksonAnnotationIntrospector.setIgnoreUnknownValues(true); jacksonAnnotationIntrospector.setIgnoreKeys(true); assertEquals("string", jacksonAnnotationIntrospector.findTypeName(AnnotatedClass.class)); assertEquals("int", jacksonAnnotationIntrospector.findTypeName(AnnotatedClass.class,
@Test public void testFindTypeName() { JacksonAnnotationIntrospector jacksonAnnotationIntrospector = new JacksonAnnotationIntrospector(); jacksonAnnotationIntrospector.setVersion(JacksonAnnotationIntrospector.Version.VERSION_3); assertNull(jacksonAnnotationIntrospector.findTypeName(null)); assertNull(jacksonAnnotationIntrospector.findTypeName(AnnotatedClass.class)); jacksonAnnotationIntrospector.setVersion(JacksonAnnotationIntrospector.Version.VERSION_4); assertNull(jacksonAnnotationIntrospector.findTypeName(AnnotatedClass.class)); jacksonAnnotationIntrospector.setVersion(JacksonAnnotationIntrospector.Version.VERSION_
@Test public void testFindSerializer() { JacksonAnnotationIntrospector jacksonAnnotationIntrospector = new JacksonAnnotationIntrospector(); jacksonAnnotationIntrospector.setVersion(JacksonAnnotationIntrospector.Version.VERSION_3); jacksonAnnotationIntrospector.findRootName(AnnotatedClass.class); jacksonAnnotationIntrospector.findKeySerializer(AnnotatedClass.class); jacksonAnnotationIntrospector.findKeySerializer(AnnotatedClass.class); jacksonAnnotationIntrospector.findKeySerializer(AnnotatedClass.class); jacksonAnnotationIntrospector.findKeySerializer(AnnotatedClass.class); jacksonAnnotationIntrospector.findKeySerializer(AnnotatedClass.class
@Test public void testFindSerializer() { JacksonAnnotationIntrospector jacksonAnnotationIntrospector = new JacksonAnnotationIntrospector(); jacksonAnnotationIntrospector.setDefaultPrettyPrinting(true); jacksonAnnotationIntrospector.setDefaultPrettyPrintingEnabled(true); jacksonAnnotationIntrospector.setDefaultPrettyPrintingEnabled(true); jacksonAnnotationIntrospector.setDefaultPrettyPrintingEnabled(true); jacksonAnnotationIntrospector.setDefaultPrettyPrintingEnabled(true); jacksonAnnotationIntrospector.setDefaultPrettyPrintingEnabled(true); SimpleSerializer<String> s = (SimpleSerializer<String>) jacksonAnnotationIntrospector.findSerializer(
@Test public void testFindSerializer() throws Exception { JacksonAnnotationIntrospector jacksonAnnotationIntrospector = new JacksonAnnotationIntrospector(); jacksonAnnotationIntrospector.setDefaultPrettyPrinter(new DefaultPrettyPrinter()); jacksonAnnotationIntrospector.setDefaultPrettyPrinter(new DefaultPrettyPrinter()); jacksonAnnotationIntrospector.setDefaultPrettyPrinter(new DefaultPrettyPrinter()); jacksonAnnotationIntrospector.setDefaultPrettyPrinter(new DefaultPrettyPrinter()); jacksonAnnotationIntrospector.setDefaultPrettyPrinter(new DefaultPrettyPrinter()); jacksonAnnotationIntrospector.setDefaultPrettyPrinter(new DefaultPrettyPrinter()); jacksonAnnotationIntrospector.setDefaultPrettyPrinter(new Default
@Test public void testFindContentSerializer() { JacksonAnnotationIntrospector jacksonAnnotationIntrospector = new JacksonAnnotationIntrospector(); jacksonAnnotationIntrospector.setDefaultPrettyPrinting(true); jacksonAnnotationIntrospector.setDefaultPrettyPrinting(true); jacksonAnnotationIntrospector.setDefaultPrettyPrinting(true); Class<?> serializer = jacksonAnnotationIntrospector.findContentSerializer(this.getClass().getDeclaredField("jsonSerializer")); assertEquals(String.class, serializer); serializer = jacksonAnnotationIntrospector.findContentSerializer(this.getClass().getDeclaredField("keySerializer")); assertEquals(String.class, serializer
@Test public void testFindContentSerializer() { JacksonAnnotationIntrospector jacksonAnnotationIntrospector = new JacksonAnnotationIntrospector(); jacksonAnnotationIntrospector.setVersion(JacksonAnnotationIntrospector.Version.V3); jacksonAnnotationIntrospector.findRootName(AnnotatedClass.class); jacksonAnnotationIntrospector.findKeySerializer(AnnotatedClass.class); jacksonAnnotationIntrospector.findKeySerializer(AnnotatedClass.class); jacksonAnnotationIntrospector.findKeySerializer(AnnotatedClass.class); jacksonAnnotationIntrospector.findKeySerializer(AnnotatedClass.class); jacksonAnnotationIntrospector.findKeySerializer(AnnotatedClass.class
@Test public void testFindContentSerializer() { JacksonAnnotationIntrospector jacksonAnnotationIntrospector = new JacksonAnnotationIntrospector(); jacksonAnnotationIntrospector.setVersion(JacksonAnnotationIntrospector.Version.VERSION_3); jacksonAnnotationIntrospector.findRootName(AnnotatedClass.class); jacksonAnnotationIntrospector.findKeySerializer(AnnotatedClass.class); jacksonAnnotationIntrospector.findKeySerializer(AnnotatedClass.class); jacksonAnnotationIntrospector.findKeySerializer(AnnotatedClass.class); jacksonAnnotationIntrospector.findKeySerializer(AnnotatedClass.class); jacksonAnnotationIntrospector.findKeySerializer(AnnotatedClass.
@Test public void testFindContentSerializer() { JacksonAnnotationIntrospector jacksonAnnotationIntrospector = new JacksonAnnotationIntrospector(); jacksonAnnotationIntrospector.setVersion(JacksonAnnotationIntrospector.Version.VERSION_3); jacksonAnnotationIntrospector.findRootName(AnnotatedClass.class); jacksonAnnotationIntrospector.findKeySerializer(AnnotatedClass.class); jacksonAnnotationIntrospector.findKeySerializer(AnnotatedClass.class); jacksonAnnotationIntrospector.findKeySerializer(AnnotatedClass.class); jacksonAnnotationIntrospector.findKeySerializer(AnnotatedClass.class); jacksonAnnotationIntrospector.findKeySerializer(AnnotatedClass.
@Test public void testSerializationInclusion() { String json = "{\\n" + " \\"type\\": \\"object\\",\\n" + " \\"properties\\": [\\n" + " {\\n" + " \\"type\\": \\"string\\"\\n" + " },\\n" + " {\\n" + " \\"type\\": \\"string\\"\\n" + " },\\n" + " {\\n" + " \\"type\\": \\"string\\"\\n" + " },\\n" + " {\\n" + " \\"type\\": \\"string\\"\\n" + " },\\n" +
@Test public void testFindSerializationInclusion() { try { new JacksonAnnotationIntrospector().findSerializationInclusion(null, null); fail(); } catch (NullPointerException e) { } try { new JacksonAnnotationIntrospector().findSerializationInclusion(new AnnotatedClass(), null); fail(); } catch (NullPointerException e) { } try { new JacksonAnnotationIntrospector().findSerializationInclusion(new AnnotatedClass(), null); fail(); } catch (NullPointerException e) { } try { new JacksonAnnotationIntrospector().findSerializationInclusion(new AnnotatedClass(), null); fail(); } catch (NullPointerException e) { } try { new JacksonAnnotationIntrospector().find
@Test public void testFindSerializationInclusion() { try { new JacksonAnnotationIntrospector().findSerializationInclusion(null, null); fail(); } catch (NullPointerException e) { } try { new JacksonAnnotationIntrospector().findSerializationInclusion(null, null); fail(); } catch (NullPointerException e) { } try { new JacksonAnnotationIntrospector().findSerializationInclusion(new AnnotatedClass(), null); fail(); } catch (NullPointerException e) { } try { new JacksonAnnotationIntrospector().findSerializationInclusion(new AnnotatedClass(), null); fail(); } catch (NullPointerException e) { } try { new JacksonAnnotationIntrospector().findSerializationIn
@Test public void testFindSerializationInclusion() { JacksonAnnotationIntrospector jacksonAnnotationIntrospector = new JacksonAnnotationIntrospector(); jacksonAnnotationIntrospector.version = new JacksonAnnotationIntrospector.Version(); jacksonAnnotationIntrospector.findRootName(Foo.class); jacksonAnnotationIntrospector.findPropertyInclusion(Foo.class.getDeclaredField("foo"), null); jacksonAnnotationIntrospector.findPropertyInclusion(Foo.class.getDeclaredField("bar"), null); jacksonAnnotationIntrospector.findPropertyInclusion(Foo.class.getDeclaredField("baz"), null); jackson
@Test public void testFindSerializationInclusion() { try { new JacksonAnnotationIntrospector().findSerializationInclusion(null, null); fail(); } catch (NullPointerException e) { } try { new JacksonAnnotationIntrospector().findSerializationInclusion(null, null); fail(); } catch (NullPointerException e) { } try { new JacksonAnnotationIntrospector().findSerializationInclusion(new AnnotatedClass(), null); fail(); } catch (NullPointerException e) { } try { new JacksonAnnotationIntrospector().findSerializationInclusion(new AnnotatedClass(), null); fail(); } catch (NullPointerException e) { } try { new JacksonAnnotationIntrospector().findSerializationIn
@Test public void testFindSerializationInclusion() { String json = "{\\n" + " \\"foo\\": \\"bar\\",\\n" + " \\"baz\\": [\\n" + " {\\n" + " \\"a\\": 1,\\n" + " \\"b\\": 2,\\n" + " \\"c\\": 3,\\n" + " \\"d\\": 4,\\n" + " \\"e\\": 5,\\n" + " \\"f\\": 6,\\n" + " \\"g\\": 7,\\n" + " \\"h\\": 8,\\n" +
@Test public void testFindSerializationInclusion() { try { new JacksonAnnotationIntrospector().findSerializationInclusion(null, null); fail(); } catch (NullPointerException e) { } try { new JacksonAnnotationIntrospector().findSerializationInclusion(new AnnotatedClass(), null); fail(); } catch (NullPointerException e) { } try { new JacksonAnnotationIntrospector().findSerializationInclusion(new AnnotatedClass(), null); fail(); } catch (NullPointerException e) { } try { new JacksonAnnotationIntrospector().findSerializationInclusion(new AnnotatedClass(), null); fail(); } catch (NullPointerException e) { } try { new JacksonAnnotationIntrospector().find
@Test public void testFindSerializationInclusion() { try { new JacksonAnnotationIntrospector().findSerializationInclusion(null, null); fail(); } catch (NullPointerException e) { } try { new JacksonAnnotationIntrospector().findSerializationInclusion(new AnnotatedClass(), null); fail(); } catch (NullPointerException e) { } try { new JacksonAnnotationIntrospector().findSerializationInclusion(new AnnotatedClass(), null); fail(); } catch (NullPointerException e) { } try { new JacksonAnnotationIntrospector().findSerializationInclusion(new AnnotatedClass(), null); fail(); } catch (NullPointerException e) { } try { new JacksonAnnotationIntrospector().find
@Test public void testFindSerializationInclusion() { try { new JacksonAnnotationIntrospector().findSerializationInclusion(null, null); fail(); } catch (NullPointerException e) { } try { new JacksonAnnotationIntrospector().findSerializationInclusion(new AnnotatedClass(), null); fail(); } catch (NullPointerException e) { } try { new JacksonAnnotationIntrospector().findSerializationInclusion(new AnnotatedClass(), null); fail(); } catch (NullPointerException e) { } try { new JacksonAnnotationIntrospector().findSerializationInclusion(new AnnotatedClass(), null); fail(); } catch (NullPointerException e) { } try { new JacksonAnnotationIntrospector().find
@Test public void testFindSerializationInclusion() { try { new JacksonAnnotationIntrospector().findSerializationInclusion(null, null); fail(); } catch (NullPointerException e) { } try { new JacksonAnnotationIntrospector().findSerializationInclusion(new AnnotatedClass(), null); fail(); } catch (NullPointerException e) { } try { new JacksonAnnotationIntrospector().findSerializationInclusion(new AnnotatedClass(), null); fail(); } catch (NullPointerException e) { } try { new JacksonAnnotationIntrospector().findSerializationInclusion(new AnnotatedClass(), null); fail(); } catch (NullPointerException e) { } try { new JacksonAnnotationIntrospector().find
@Test public void testFindSerializationType() { JacksonAnnotationIntrospector jacksonAnnotationIntrospector = new JacksonAnnotationIntrospector(); jacksonAnnotationIntrospector.setVersion(JacksonAnnotationIntrospector.Version.VERSION_3); jacksonAnnotationIntrospector.setIgnoreUnknownProperties(true); jacksonAnnotationIntrospector.setIgnoreUnknownKeys(true); jacksonAnnotationIntrospector.setIgnoreUnknownValues(true); Class<?> cls = jacksonAnnotationIntrospector.findSerializationType(this.getClass().getDeclaredField("ignoreUnknownKeys")); assertNull(cls); cls = jacksonAnnotationIntrospector.findSerializationType(this.getClass
@Test public void testFindSerializationType() { JacksonAnnotationIntrospector jacksonAnnotationIntrospector = new JacksonAnnotationIntrospector(); jacksonAnnotationIntrospector.setVersion(JacksonAnnotationIntrospector.Version.VERSION_3); jacksonAnnotationIntrospector.setIgnoreUnknownProperties(true); jacksonAnnotationIntrospector.setIgnoreUnknownPropertiesToIgnore(true); jacksonAnnotationIntrospector.setIgnoreUnknownPropertiesToIgnore(true); jacksonAnnotationIntrospector.setIgnoreUnknownPropertiesToIgnore(true); jacksonAnnotationIntrospector.setIgnoreUnknownPropertiesToIgnore(true); jacksonAnnotationIntrospector.setIgnoreUnknownPropertiesToIgnore(true);
@Test public void testFindSerializationKeyType() { Class<?> type; type = findSerializationKeyType(getClass(), JavaType.getDefault()); assertEquals(String.class, type); type = findSerializationKeyType(getClass(), String.class); assertEquals(String.class, type); type = findSerializationKeyType(getClass(), String.class); assertEquals(String.class, type); type = findSerializationKeyType(getClass(), List.class); assertEquals(List.class, type); type = findSerializationKeyType(getClass(), List.class); assertEquals(List.class, type); type = findSerializationKeyType(getClass(), Map.class); assertEquals(Map.class, type
@Test public void testDefaultSerializer() { Class<?> cls = jacksonAnnotationIntrospector.findSerializationKeyType(getClass().getDeclaredField("defaultSerializer"), JavaType.getDefault()); assertEquals(DefaultSerializer.class, cls); }
@Test public void testFindSerializationKeyType() { JacksonAnnotationIntrospector jacksonAnnotationIntrospector = new JacksonAnnotationIntrospector(); jacksonAnnotationIntrospector.setVersion(JacksonAnnotationIntrospector.Version.VERSION_3); jacksonAnnotationIntrospector.setIgnoreUnknownProperties(true); jacksonAnnotationIntrospector.setIgnoreUnknownKeys(true); jacksonAnnotationIntrospector.setIgnoreUnknownTypes(true); Class<?> cls = jacksonAnnotationIntrospector.findSerializationKeyType(jacksonAnnotationIntrospector.findAnnotation(JsonSerialize.class), JavaType.getDefault()); assertEquals(String.class, cls); }
@Test public void testFindSerializationKeyType() { JacksonAnnotationIntrospector jacksonAnnotationIntrospector = new JacksonAnnotationIntrospector(); jacksonAnnotationIntrospector.setVersion(JacksonAnnotationIntrospector.Version.VERSION_3); jacksonAnnotationIntrospector.setIgnoreUnknownProperties(true); jacksonAnnotationIntrospector.setIgnoreUnknownKeys(true); jacksonAnnotationIntrospector.setIgnoreUnknownTypes(true); Class<?> type = jacksonAnnotationIntrospector.findSerializationKeyType(jacksonAnnotationIntrospector.findMethod( "getObject"), javaType); assertEquals(Object.class, type); type = jacksonAnnotationIntrospector.find
@Test public void testGetSerializationContentType() { Class<?> cls = jacksonAnnotationIntrospector.findSerializationContentType(getClass().getDeclaredField("jsonSerialize"), JavaType.getDefault()); assertEquals(String.class, cls); }
@Test public void testNoClass() { JacksonAnnotationIntrospector jacksonAnnotationIntrospector = new JacksonAnnotationIntrospector(); jacksonAnnotationIntrospector.setVersion(JacksonAnnotationIntrospector.Version.VERSION_3); jacksonAnnotationIntrospector.findRootName(AnnotatedClass.class); jacksonAnnotationIntrospector.findRootName(AnnotatedClass.class); jacksonAnnotationIntrospector.findSerializer(AnnotatedClass.class); jacksonAnnotationIntrospector.findSerializer(AnnotatedClass.class); jacksonAnnotationIntrospector.findSerializer(AnnotatedClass.class); jacksonAnnotationIntrospector.findSerializer(AnnotatedClass.class); jacksonAnnotation
@Test public void testFindSerializationContentType() { JacksonAnnotationIntrospector jacksonAnnotationIntrospector = new JacksonAnnotationIntrospector(); jacksonAnnotationIntrospector.setVersion(JacksonAnnotationIntrospector.Version.VERSION_3); jacksonAnnotationIntrospector.setIgnoreUnknownProperties(true); jacksonAnnotationIntrospector.setIgnoreUnknownKeys(true); jacksonAnnotationIntrospector.setIgnoreValues(true); Class<?> cls = jacksonAnnotationIntrospector.findSerializationContentType(getClass().getDeclaredField("jsonSerialize"), JavaType.getDefault()); assertEquals(String.class, cls); }
@Test public void testFindSerializationContentType() { JacksonAnnotationIntrospector jacksonAnnotationIntrospector = new JacksonAnnotationIntrospector(); jacksonAnnotationIntrospector.setVersion(JacksonAnnotationIntrospector.Version.VERSION_3); jacksonAnnotationIntrospector.setIgnoreUnknownProperties(true); jacksonAnnotationIntrospector.setIgnoreUnknownType(true); jacksonAnnotationIntrospector.setIgnoreUnknownSerializer(true); jacksonAnnotationIntrospector.setIgnoreUnknownType(true); jacksonAnnotationIntrospector.setIgnoreUnknownSerializerType(true); Class<?> cls = jacksonAnnotationIntrospector.findSerializationContentType(jacksonAnnotationIntrospector.
@Test public void testFindSerializationTyping() { Class<?> type = TestClass.class; JsonSerializer.Typing ts = new JsonSerializer.Typing() { @Override public Class<? extends Annotation> annotationType() { return type; } @Override public Class<? extends Annotation> annotationType() { return this.getClass(); } @Override public Class<? extends Annotation> annotationType() { return this.getClass(); } }; JsonSerializer.Typing ts2 = new JsonSerializer.Typing() { @Override public Class<? extends Annotation> annotationType() { return type; } @Override public Class<? extends Annotation> annotationType() { return this.getClass(); } @Override public Class<? extends Annotation> annotationType()
@Test public void testTyping() throws Exception { Class<?> type = TestClass.class; JsonSerializer.Typing ts = new JsonSerializer.Typing() { @Override public Class<? extends Annotation> annotationType() { return type; } @Override public Class<? extends Annotation> annotationType() { return this.getClass(); } @Override public Class<? extends Annotation> annotationType() { return this.getClass(); } }; JsonSerializer.Typing ts2 = new JsonSerializer.Typing() { @Override public Class<? extends Annotation> annotationType() { return type; } @Override public Class<? extends Annotation> annotationType() { return this.getClass(); } @Override public Class<? extends Annotation> annotationType()
@Test public void testTyping() { JacksonAnnotationIntrospector jacksonAnnotationIntrospector = new JacksonAnnotationIntrospector(); assertNull(jacksonAnnotationIntrospector.findSerializationTyping(null)); assertNull(jacksonAnnotationIntrospector.findSerializerType(null)); assertNull(jacksonAnnotationIntrospector.findKeySerializer(null)); assertNull(jacksonAnnotationIntrospector.findContentSerializer(null)); assertNull(jacksonAnnotationIntrospector.findSerializerType(null)); assertNull(jacksonAnnotationIntrospector.findKeySerializer(null)); assertNull(jacksonAnnotationIntrospector.findContentSerializer(null)); assertNull(jackson
@Test public void testFindSerializationConverter() { JacksonAnnotationIntrospector jacksonAnnotationIntrospector = new JacksonAnnotationIntrospector(); jacksonAnnotationIntrospector.setVersion(JacksonAnnotationIntrospector.Version.VERSION_3); jacksonAnnotationIntrospector.setIgnoreUnknownProperties(true); jacksonAnnotationIntrospector.setIgnoreUnknownSerializerType(true); jacksonAnnotationIntrospector.setIgnoreUnwrappingValueId(true); jacksonAnnotationIntrospector.setIgnoreUnknownSerializerType(true); jacksonAnnotationIntrospector.setIgnoreUnwrappingValueId(true); jacksonAnnotationIntrospector.setIgnoreSerializerType(true); jackson
@Test public void testFindSerializationConverter() { JacksonAnnotationIntrospector jacksonAnnotationIntrospector = new JacksonAnnotationIntrospector(); jacksonAnnotationIntrospector.setDefaultPrettyPrinting(true); jacksonAnnotationIntrospector.setDefaultPrettyPrinting(true); jacksonAnnotationIntrospector.setDefaultPrettyPrinting(true); jacksonAnnotationIntrospector.setDefaultPrettyPrinting(true); jacksonAnnotationIntrospector.setDefaultPrettyPrinting(true); jacksonAnnotationIntrospector.setDefaultPrettyPrinting(true); jacksonAnnotationIntrospector.setDefaultPrettyPrinting(true); jacksonAnnotationIntrospector.setDefaultPrettyPrinting
@Test public void testFindSerializationContentConverter() { Class<?> type = this.getClass().getDeclaredField("jsonSerialize"); assertTrue(type.isAnnotation(JsonSerialize.class)); assertEquals(Converter.None.class, type.findSerializationContentConverter(type)); type = this.getClass().getDeclaredField("jsonSerialize"); assertTrue(type.isAnnotation(JsonSerialize.class)); assertEquals(Converter.None.class, type.findSerializationContentConverter(type)); type = this.getClass().getDeclaredField("jsonSerialize"); assertTrue(type.isAnnotation(JsonSerialize.class)); assertEquals(Converter.None.class, type.findSerializationContentConverter(type
@Test public void testFindSerializationContentConverter() { JacksonAnnotationIntrospector jacksonAnnotationIntrospector = new JacksonAnnotationIntrospector(); jacksonAnnotationIntrospector.setVersion(JacksonAnnotationIntrospector.Version.VERSION_3); jacksonAnnotationIntrospector.findRootName(AnnotatedClass.class); jacksonAnnotationIntrospector.findRootValue(AnnotatedClass.class); jacksonAnnotationIntrospector.findSerializer(AnnotatedClass.class); jacksonAnnotationIntrospector.findSerializer(AnnotatedClass.class); jacksonAnnotationIntrospector.findSerializer(AnnotatedClass.class); jacksonAnnotationIntrospector.findSerializer(AnnotatedClass.class); j
@Test public void testFindSerializationContentConverter() { JacksonAnnotationIntrospector jacksonAnnotationIntrospector = new JacksonAnnotationIntrospector(); jacksonAnnotationIntrospector.setVersion(JacksonAnnotationIntrospector.Version.VERSION_3); jacksonAnnotationIntrospector.findRootName(AnnotatedClass.class); jacksonAnnotationIntrospector.findRootValue(AnnotatedClass.class); jacksonAnnotationIntrospector.findSerializer(AnnotatedClass.class); jacksonAnnotationIntrospector.findSerializer(AnnotatedClass.class); jacksonAnnotationIntrospector.findSerializer(AnnotatedClass.class); jacksonAnnotationIntrospector.findSerializer(AnnotatedClass.class); j
@Test public void testFindSerializationContentConverter() { JacksonAnnotationIntrospector jacksonAnnotationIntrospector = new JacksonAnnotationIntrospector(); jacksonAnnotationIntrospector.setDefaultPrettyPrinting(true); jacksonAnnotationIntrospector.setDefaultPrettyPrinting(true); jacksonAnnotationIntrospector.setDefaultPrettyPrinting(true); jacksonAnnotationIntrospector.setDefaultPrettyPrinting(true); assertNull(jacksonAnnotationIntrospector.findSerializationContentConverter(getClass().getDeclaredField("jsonSerialize"))); assertNull(jacksonAnnotationIntrospector.findSerializationContentConverter(getClass().getDeclaredField("contentConverter"))); assertNull
@Test public void testFindViews() { Class<?>[] views = new JacksonAnnotationIntrospector().findViews(AnnotatedClass.class); assertEquals(String.class, views[0]); views = new JacksonAnnotationIntrospector().findViews(AnnotatedClass.class); assertNull(views[0]); }
@Test public void testFindViews() { JacksonAnnotationIntrospector jacksonAnnotationIntrospector = new JacksonAnnotationIntrospector(); jacksonAnnotationIntrospector.setVersion(JacksonAnnotationIntrospector.Version.V2); jacksonAnnotationIntrospector.setIgnoreUnknownProperties(true); jacksonAnnotationIntrospector.setIgnoreUnknownKeys(true); jacksonAnnotationIntrospector.setIgnoreValues(true); Class<?>[] views = jacksonAnnotationIntrospector.findViews(AnnotatedClass.class); Assert.assertNotNull(views); Assert.assertEquals(String.class, views[0]); views = jacksonAnnotationIntrospector.findViews(AnnotatedClass
@Test public void testFindViews() { JacksonAnnotationIntrospector jacksonAnnotationIntrospector = new JacksonAnnotationIntrospector(); jacksonAnnotationIntrospector.setVersion(JacksonAnnotationIntrospector.Version.VERSION_3); Class<?>[] views = jacksonAnnotationIntrospector.findViews(AnnotatedClass.class.getDeclaredField("jsonView")); assertEquals(String.class, views[0]); views = jacksonAnnotationIntrospector.findViews(AnnotatedClass.class.getDeclaredField("jsonView2")); assertEquals(String.class, views[0]); views = jacksonAnnotationIntrospector.findViews(AnnotatedClass.class.get
@Test public void testIsTypeId() { Set<String> types = new HashSet<String>(Arrays.asList("a", "b", "c")); Set<String> types2 = new HashSet<String>(Arrays.asList("d", "e", "f")); Set<String> types3 = new HashSet<String>(Arrays.asList("a", "b", "c", "d", "e", "f")); Set<String> types4 = new HashSet<String>(Arrays.asList("a", "b", "c", "d", "e", "f")); Set<String> types5 = new HashSet<String>(Arrays
@Test public void testIsTypeId() { Set<String> types = new HashSet<String>(Arrays.asList("a", "b", "c")); Set<String> types2 = new HashSet<String>(Arrays.asList("d", "e", "f")); Set<String> types3 = new HashSet<String>(Arrays.asList("a", "b", "c", "d", "e", "f")); Set<String> types4 = new HashSet<String>(Arrays.asList("a", "b", "c", "d", "e", "f")); Set<String> types5 = new HashSet<String>(Arrays
@Test public void testFindObjectReferenceInfo() { assertNotNull(new JacksonAnnotationIntrospector().findObjectReferenceInfo(getClass().getAnnotation(JsonIdentityReference.class), new ObjectIdInfo())); assertNotNull(new JacksonAnnotationIntrospector().findObjectReferenceInfo(getClass().getAnnotation(JsonIdentityReference.class), new ObjectIdInfo())); assertNotNull(new JacksonAnnotationIntrospector().findObjectReferenceInfo(getClass().getAnnotation(JsonIdentityReference.class), new ObjectIdInfo())); assertNotNull(new JacksonAnnotationIntrospector().findObjectReferenceInfo(getClass().getAnnotation(JsonIdentityReference.class), new ObjectIdInfo())); assertNotNull(new JacksonAnnotationIntrospector().findObjectReferenceInfo(
@Test public void testFindNameForSerialization() { @SuppressWarnings("deprecation") JacksonAnnotationIntrospector jacksonAnnotationIntrospector = new JacksonAnnotationIntrospector(); PropertyName name = jacksonAnnotationIntrospector.findNameForSerialization(getClass().getDeclaredField("objectField")); assertNull(name); name = jacksonAnnotationIntrospector.findNameForSerialization(getClass().getDeclaredMethod("setObjectField")); assertNull(name); name = jacksonAnnotationIntrospector.findNameForSerialization(getClass().getDeclaredMethod("setObjectField")); assertNull(name); name = jacksonAnnotationIntrospector.findNameForSerialization(getClass
@Test public void testFindNameForSerialization() { @SuppressWarnings("deprecation") JacksonAnnotationIntrospector jacksonAnnotationIntrospector = new JacksonAnnotationIntrospector(); PropertyName name = jacksonAnnotationIntrospector.findNameForSerialization(getClass().getDeclaredField("objectField")); assertNull(name); name = jacksonAnnotationIntrospector.findNameForSerialization(getClass().getDeclaredMethod("setObjectField")); assertNull(name); name = jacksonAnnotationIntrospector.findNameForSerialization(getClass().getDeclaredMethod("setObjectField")); assertNull(name); name = jacksonAnnotationIntrospector.findNameForSerialization(getClass
@Test public void testFindNameForSerialization() { @SuppressWarnings("deprecation") JacksonAnnotationIntrospector jacksonAnnotationIntrospector = new JacksonAnnotationIntrospector(); PropertyName name = jacksonAnnotationIntrospector.findNameForSerialization(getClass().getDeclaredField("objectField")); assertEquals("objectField", name.getName()); assertTrue(name.isUseDefault()); name = jacksonAnnotationIntrospector.findNameForSerialization(getClass().getDeclaredMethod("setObjectField")); assertEquals("objectField", name.getName()); assertTrue(name.isUseDefault()); name = jacksonAnnotationIntrospector.findNameForSerialization(getClass().getDeclared
@Test public void testGetSerializationName() throws Exception { JacksonAnnotationIntrospector jacksonAnnotationIntrospector = new JacksonAnnotationIntrospector(); jacksonAnnotationIntrospector.setVersion(JacksonAnnotationIntrospector.Version.VERSION_3); jacksonAnnotationIntrospector.setDefaultPrettyPrinting(true); jacksonAnnotationIntrospector.setDefaultPrettyPrinting(true); assertEquals("", jacksonAnnotationIntrospector.findSerializationName(getMethod("getProperty"))); assertEquals("", jacksonAnnotationIntrospector.findSerializationName(getMethod("getProperty2"))); assertEquals("", jacksonAnnotationIntrospector.findSerializationName(
@Test public void testGetSerializationName() throws Exception { assertEquals("", findSerializationName(AnnotatedClass.class.getDeclaredMethod("getProperty"))); assertNull(findSerializationName(AnnotatedClass.class.getDeclaredMethod("setProperty"))); assertNull(findSerializationName(AnnotatedClass.class.getDeclaredMethod("setProperty2"))); assertNull(findSerializationName(AnnotatedClass.class.getDeclaredMethod("setProperty3"))); assertNull(findSerializationName(AnnotatedClass.class.getDeclaredMethod("setProperty4"))); assertNull(findSerializationName(AnnotatedClass.class.getDeclaredMethod("setProperty5"))); assertNull(findSerialization
@Test public void testFindDeserializer() { JacksonAnnotationIntrospector jacksonAnnotationIntrospector = new JacksonAnnotationIntrospector(); jacksonAnnotationIntrospector.setVersion(JacksonAnnotationIntrospector.Version.VERSION_3); jacksonAnnotationIntrospector.setIgnoreUnknownProperties(true); jacksonAnnotationIntrospector.setIgnoreUnknownKeys(true); jacksonAnnotationIntrospector.setIgnoreValues(true); Class<?> deserializer = jacksonAnnotationIntrospector.findDeserializer(AnnotatedClass.class); assertEquals(String.class, deserializer); deserializer = jacksonAnnotationIntrospector.findDeserializer(AnnotatedClass.class); assertNull(deserializer); deserializer =
@Test public void testFindDeserializer() { JacksonAnnotationIntrospector jacksonAnnotationIntrospector = new JacksonAnnotationIntrospector(); jacksonAnnotationIntrospector.setVersion(JacksonAnnotationIntrospector.Version.VERSION_3); jacksonAnnotationIntrospector.setIgnoreUnknownProperties(true); jacksonAnnotationIntrospector.setIgnoreUnknownPropertiesToIgnore(true); jacksonAnnotationIntrospector.setIgnoreUnknownPropertiesToIgnore(true); jacksonAnnotationIntrospector.setIgnoreUnknownPropertiesToIgnore(true); jacksonAnnotationIntrospector.setIgnoreUnknownPropertiesToIgnore(true); jacksonAnnotationIntrospector.setIgnoreUnknownPropertiesToIgnore(true); j
@Test public void testFindDeserializer() { JacksonAnnotationIntrospector jacksonAnnotationIntrospector = new JacksonAnnotationIntrospector(); jacksonAnnotationIntrospector.setIgnoreMissingFields(true); jacksonAnnotationIntrospector.setIgnoreUnknownFields(true); jacksonAnnotationIntrospector.setIgnoreUnknownFields(true); jacksonAnnotationIntrospector.setIgnoreUnknownFields(true); jacksonAnnotationIntrospector.setIgnoreUnknownFields(true); jacksonAnnotationIntrospector.setIgnoreUnknownFields(true); jacksonAnnotationIntrospector.setIgnoreUnknownFields(true); jacksonAnnotationIntrospector.setIgnoreUnknownFields(true); jacksonAnnotationIntrospector
@Test public void testFindContentDeserializer() { Class<?> deserializer = new JacksonAnnotationIntrospector().findContentDeserializer(AnnotatedClass.class); assertEquals(JsonDeserializer.class, deserializer); deserializer = new JacksonAnnotationIntrospector().findContentDeserializer(AnnotatedClass.class); assertNull(deserializer); deserializer = new JacksonAnnotationIntrospector().findContentDeserializer(AnnotatedClass.class); assertNull(deserializer); deserializer = new JacksonAnnotationIntrospector().findContentDeserializer(AnnotatedClass.class); assertNull(deserializer); deserializer = new JacksonAnnotationIntrospector().findContentDeserializer(AnnotatedClass.class); assertNull(deserializer); }
@Test public void testFindContentDeserializer() { JacksonAnnotationIntrospector jacksonAnnotationIntrospector = new JacksonAnnotationIntrospector(); jacksonAnnotationIntrospector.setVersion(JacksonAnnotationIntrospector.Version.VERSION_3); jacksonAnnotationIntrospector.findRootName(AnnotatedClass.class); jacksonAnnotationIntrospector.findKeySerializer(AnnotatedClass.class); jacksonAnnotationIntrospector.findKeySerializer(AnnotatedClass.class); jacksonAnnotationIntrospector.findContentDeserializer(AnnotatedClass.class); jacksonAnnotationIntrospector.findContentDeserializer(AnnotatedClass.class); jacksonAnnotationIntrospector.findContentDeserializer(AnnotatedClass.
@Test public void testFindContentDeserializer() { JacksonAnnotationIntrospector jacksonAnnotationIntrospector = new JacksonAnnotationIntrospector(); jacksonAnnotationIntrospector.setVersion(JacksonAnnotationIntrospector.Version.VERSION_3); jacksonAnnotationIntrospector.findRootName(AnnotatedClass.class); jacksonAnnotationIntrospector.findKeySerializer(AnnotatedClass.class); jacksonAnnotationIntrospector.findKeySerializer(AnnotatedClass.class); jacksonAnnotationIntrospector.findContentDeserializer(AnnotatedClass.class); jacksonAnnotationIntrospector.findContentDeserializer(AnnotatedClass.class); jacksonAnnotationIntrospector.findContentDeserializer(AnnotatedClass.
@Test public void testFindContentDeserializer() { JacksonAnnotationIntrospector jacksonAnnotationIntrospector = new JacksonAnnotationIntrospector(); jacksonAnnotationIntrospector.setVersion(JacksonAnnotationIntrospector.Version.VERSION_3); jacksonAnnotationIntrospector.findRootName(AnnotatedClass.class); jacksonAnnotationIntrospector.findKeySerializer(AnnotatedClass.class); jacksonAnnotationIntrospector.findKeySerializer(AnnotatedClass.class); jacksonAnnotationIntrospector.findContentDeserializer(AnnotatedClass.class); jacksonAnnotationIntrospector.findContentDeserializer(AnnotatedClass.class); jacksonAnnotationIntrospector.findContentDeserializer(AnnotatedClass.
@Test public void testFindDeserializationType() { JacksonAnnotationIntrospector jacksonAnnotationIntrospector = new JacksonAnnotationIntrospector(); jacksonAnnotationIntrospector.setVersion(JacksonAnnotationIntrospector.Version.VERSION_3); jacksonAnnotationIntrospector.setIgnoreUnknownProperties(true); Class<?> cls = jacksonAnnotationIntrospector.findDeserializationType(getClass().getDeclaredField("object"), JavaType.getDefault()); assertEquals(Object.class, cls); }
@Test public void testFindDeserializationType() { JacksonAnnotationIntrospector jacksonAnnotationIntrospector = new JacksonAnnotationIntrospector(); jacksonAnnotationIntrospector.setVersion(JacksonAnnotationIntrospector.Version.VERSION_3); jacksonAnnotationIntrospector.setIgnoreUnknownProperties(true); jacksonAnnotationIntrospector.setIgnoreUnknownPropertiesToIgnore(true); jacksonAnnotationIntrospector.setIgnoreUnknownPropertiesToIgnore(true); jacksonAnnotationIntrospector.setIgnoreUnknownPropertiesToIgnore(true); jacksonAnnotationIntrospector.setIgnoreUnknownPropertiesToIgnore(true); jacksonAnnotationIntrospector.setIgnoreUnknownPropertiesToIgnore(true
@Test public void testFindDeserializationType() { JacksonAnnotationIntrospector jacksonAnnotationIntrospector = new JacksonAnnotationIntrospector(); jacksonAnnotationIntrospector.setVersion(JacksonAnnotationIntrospector.Version.VERSION_3); jacksonAnnotationIntrospector.setIgnoreUnknownProperties(true); jacksonAnnotationIntrospector.setIgnoreUnknownProperties(false); Class<?> cls = jacksonAnnotationIntrospector.findDeserializationType(getClass().getMethod("getObject"), JavaType.getDefault()); assertEquals(Object.class, cls); }
@Test public void testFindDeserializationKeyType() { Class<?> type = jacksonAnnotationIntrospector.findDeserializationKeyType(getClass(), JavaType.getDefault()); assertEquals(String.class, type); type = jacksonAnnotationIntrospector.findDeserializationKeyType(getClass(), JavaType.getDefault()); assertNull(type); type = jacksonAnnotationIntrospector.findDeserializationKeyType(getClass(), null); assertNull(type); type = jacksonAnnotationIntrospector.findDeserializationKeyType(getClass(), JavaType.getDefault()); assertNull(type); type = jacksonAnnotationIntrospector.findDeserializationKeyType(getClass(), null); assertNull(
@Test public void testDeserializationKeyType() { Class<?> type = jacksonAnnotationIntrospector.findDeserializationKeyType(getClass().getDeclaredField("jsonDeserializationKeyType"), JavaType.BOOLEAN); assertEquals(Boolean.class, type); type = jacksonAnnotationIntrospector.findDeserializationKeyType(getClass().getDeclaredField("jsonDeserializationKeyType"), JavaType.BOOLEAN); assertEquals(Byte.class, type); type = jacksonAnnotationIntrospector.findDeserializationKeyType(getClass().getDeclaredField("jsonDeserializationKeyType"), JavaType.BYTE); assertEquals(Byte.class, type); type = jacksonAnnotationIntrospector.findDeserialization
@Test public void testFindDeserializationKeyType() { JacksonAnnotationIntrospector jacksonAnnotationIntrospector = new JacksonAnnotationIntrospector(); jacksonAnnotationIntrospector.setVersion(JacksonAnnotationIntrospector.Version.VERSION_3); jacksonAnnotationIntrospector.setIgnoreUnknownProperties(true); jacksonAnnotationIntrospector.setIgnoreUnknownProperties(false); Class<?> type = jacksonAnnotationIntrospector.findDeserializationKeyType(getClass(), JavaType.getDefault()); assertEquals(String.class, type); type = jacksonAnnotationIntrospector.findDeserializationKeyType(getClass(), JavaType.getDefault()); assertNull(type); type =
@Test public void testFindDeserializationKeyType() { Class<?> type = jacksonAnnotationIntrospector.findDeserializationKeyType(getClass(), JavaType.getDefault()); assertNull(type); type = jacksonAnnotationIntrospector.findDeserializationKeyType(getClass(), JavaType.getDefault()); assertNull(type); type = jacksonAnnotationIntrospector.findDeserializationKeyType(getClass(), JavaType.getDefault()); assertNull(type); type = jacksonAnnotationIntrospector.findDeserializationKeyType(getClass(), JavaType.getDefault()); assertNull(type); type = jacksonAnnotationIntrospector.findDeserializationKeyType(getClass(), JavaType.getDefault
@Test public void testFindDeserializationContentType() { Class<?> cls = jacksonAnnotationIntrospector.findDeserializationContentType(this.getClass().getDeclaredField("jsonDeserialization"), JavaType.STRING); assertEquals(String.class, cls); cls = jacksonAnnotationIntrospector.findDeserializationContentType(this.getClass().getDeclaredField("jsonDeserialization"), JavaType.BOOLEAN); assertEquals(Boolean.class, cls); cls = jacksonAnnotationIntrospector.findDeserializationContentType(this.getClass().getDeclaredField("jsonDeserialization"), JavaType.BYTE); assertEquals(Byte.class, cls); }
@Test public void testDeserialize() { JacksonAnnotationIntrospector jacksonAnnotationIntrospector = new JacksonAnnotationIntrospector(); jacksonAnnotationIntrospector.setVersion(JacksonAnnotationIntrospector.Version.VERSION_3); jacksonAnnotationIntrospector.setIgnoreUnknownProperties(true); jacksonAnnotationIntrospector.setIgnoreUnknownProperties(true); jacksonAnnotationIntrospector.setIgnoreUnknownProperties(true); jacksonAnnotationIntrospector.setIgnoreUnknownProperties(true); jacksonAnnotationIntrospector.setIgnoreUnknownProperties(true); jacksonAnnotationIntrospector.setIgnoreUnknownProperties(true); jacksonAnnotationIntrospector.setIgnoreUnknownProperties(
@Test public void testFindDeserializationContentType() { JacksonAnnotationIntrospector jacksonAnnotationIntrospector = new JacksonAnnotationIntrospector(); jacksonAnnotationIntrospector.setVersion(JacksonAnnotationIntrospector.Version.VERSION_3); jacksonAnnotationIntrospector.findRootName(AnnotatedClass.class); jacksonAnnotationIntrospector.findRootValue(AnnotatedClass.class); jacksonAnnotationIntrospector.findTypeSerializer(AnnotatedClass.class); jacksonAnnotationIntrospector.findTypeSerializer(AnnotatedClass.class); jacksonAnnotationIntrospector.findTypeSerializer(AnnotatedClass.class); jacksonAnnotationIntrospector.findTypeSerializer(AnnotatedClass
@Test public void testFindDeserializationContentType() { JacksonAnnotationIntrospector jacksonAnnotationIntrospector = new JacksonAnnotationIntrospector(); jacksonAnnotationIntrospector.setVersion(JacksonAnnotationIntrospector.Version.VERSION_3); jacksonAnnotationIntrospector.setIgnoreUnknownProperties(true); jacksonAnnotationIntrospector.setIgnoreUnknownProperties(true); jacksonAnnotationIntrospector.setIgnoreUnknownProperties(true); jacksonAnnotationIntrospector.setIgnoreUnknownProperties(true); jacksonAnnotationIntrospector.setIgnoreUnknownProperties(true); Class<?> cls = jacksonAnnotationIntrospector.findDeserializationContentType(jacksonAnnotationIntrospector
@Test public void testFindDeserializationContentType() { JacksonAnnotationIntrospector jacksonAnnotationIntrospector = new JacksonAnnotationIntrospector(); jacksonAnnotationIntrospector.setVersion(JacksonAnnotationIntrospector.Version.VERSION_3); jacksonAnnotationIntrospector.findDeserializationContentType(getClass().getDeclaredField("jsonDeserialization"), JavaType.getDefault()); jacksonAnnotationIntrospector.findDeserializationContentType(getClass().getDeclaredField("objectSerializer"), JavaType.getDefault()); jacksonAnnotationIntrospector.findDeserializationContentType(getClass().getDeclaredField("keySerializer"), JavaType.getDefault()); jacksonAnnotationIntrospect
@Test public void testFindDeserializationConverter() { JacksonAnnotationIntrospector jacksonAnnotationIntrospector = new JacksonAnnotationIntrospector(); jacksonAnnotationIntrospector.setVersion(JacksonAnnotationIntrospector.Version.VERSION_3); jacksonAnnotationIntrospector.findDeserializationConverter(AnnotatedClass.class); jacksonAnnotationIntrospector.findDeserializationConverter(AnnotatedClass.class); jacksonAnnotationIntrospector.findDeserializationConverter(AnnotatedClass.class); jacksonAnnotationIntrospector.findDeserializationConverter(AnnotatedClass.class); jacksonAnnotationIntrospector.findDeserializationConverter(AnnotatedClass.class); jacksonAnnotationIntrospector.find
@Test public void testFindDeserializationContentConverter() { Class<?> type = this.getClass().getDeclaredMethod("getDeserializationContentConverter"); assertTrue(type.isAnnotation(JsonDeserialize.class)); assertEquals(Converter.None.class, type.findDeserializationContentConverter(type)); type = this.getClass().getDeclaredMethod("getDeserializationContentConverter"); assertTrue(type.isAnnotation(JsonDeserialize.class)); assertEquals(Converter.None.class, type.findDeserializationContentConverter(type)); type = this.getClass().getDeclaredMethod("getDeserializationContentConverter"); assertTrue(type.isAnnotation(JsonDeserialize.class)); assertEquals(Converter.
@Test public void testFindDeserializationContentConverter() { JacksonAnnotationIntrospector jacksonAnnotationIntrospector = new JacksonAnnotationIntrospector(); jacksonAnnotationIntrospector.setVersion(JacksonAnnotationIntrospector.Version.VERSION_3); jacksonAnnotationIntrospector.findDeserializationContentConverter(AnnotatedClass.class.getDeclaredField("contentConverter")); jacksonAnnotationIntrospector.findDeserializationContentConverter(AnnotatedClass.class.getDeclaredField("keySerializer")); jacksonAnnotationIntrospector.findDeserializationContentConverter(AnnotatedClass.class.getDeclaredField("keySerializer2")); jacksonAnnotationIntrospector.findDeserializationContentConverter(
@Test public void testFindDeserializationContentConverter() { JacksonAnnotationIntrospector jacksonAnnotationIntrospector = new JacksonAnnotationIntrospector(); jacksonAnnotationIntrospector.setVersion(JacksonAnnotationIntrospector.Version.VERSION_3); jacksonAnnotationIntrospector.setIgnoreUnknownProperties(true); jacksonAnnotationIntrospector.setIgnoreUnknownType(true); assertNull(jacksonAnnotationIntrospector.findDeserializationContentConverter(null)); assertNull(jacksonAnnotationIntrospector.findDeserializationContentConverter(getClass())); jacksonAnnotationIntrospector.setIgnoreUnknownProperties(false); assertNull(jacksonAnnotationIntrospector.findDeserial
@Test public void testFindDeserializationContentConverter() { Class<?> type = this.getClass().getDeclaredField("getDeserializationContentConverter"); assertNull(this.getClass().getAnnotation(JsonDeserialize.class).contentConverter()); assertNull(this.getClass().getAnnotation(JsonDeserialize.class).contentConverter(type)); type = this.getClass().getDeclaredField("getDeserializationContentConverter"); assertNull(this.getClass().getAnnotation(JsonDeserialize.class).contentConverter(type)); assertNull(this.getClass().getAnnotation(JsonDeserialize.class).contentConverter(type)); type = this.getClass().getDeclaredField("getDeserializationContentConverter");
@Test public void testFindValueInstantiator() { Map<String, Object> result = (Map<String, Object>) new JacksonAnnotationIntrospector().findValueInstantiator(AnnotatedClass.class).value(); assertTrue(result.isEmpty()); result = (Map<String, Object>) new JacksonAnnotationIntrospector().findValueInstantiator(AnnotatedClass.class).value(); assertTrue(result.isEmpty()); result = (Map<String, Object>) new JacksonAnnotationIntrospector().findValueInstantiator(AnnotatedClass.class).value(); assertTrue(result.isEmpty()); result = (Map<String, Object>) new JacksonAnnotationIntrospector().findValueInstant
@Test public void testFindValueInstantiator() { JacksonAnnotationIntrospector jacksonAnnotationIntrospector = new JacksonAnnotationIntrospector(); jacksonAnnotationIntrospector.setVersion(JacksonAnnotationIntrospector.Version.V2); jacksonAnnotationIntrospector.setIgnoreUnknownProperties(true); jacksonAnnotationIntrospector.setIgnoreUnknownProperties(false); jacksonAnnotationIntrospector.setIgnoreUnknownProperties(true); jacksonAnnotationIntrospector.setIgnoreUnknownProperties(false); assertNull(jacksonAnnotationIntrospector.findValueInstantiator(AnnotatedClass.class)); assertNull(jacksonAnnotationIntrospector.findValueInstantiator(AnnotatedClass.
@Test public void testFindValueInstantiator() { JacksonAnnotationIntrospector jacksonAnnotationIntrospector = new JacksonAnnotationIntrospector(); jacksonAnnotationIntrospector.setVersion(JacksonAnnotationIntrospector.Version.VERSION_3); assertNull(jacksonAnnotationIntrospector.findValueInstantiator(null)); assertNull(jacksonAnnotationIntrospector.findValueInstantiator(getClass())); jacksonAnnotationIntrospector.setVersion(JacksonAnnotationIntrospector.Version.VERSION_4); assertNull(jacksonAnnotationIntrospector.findValueInstantiator(getClass())); jacksonAnnotationIntrospector.setVersion(JacksonAnnotationIntrospect
@Test public void testFindNameForDeserialization() { @SuppressWarnings("deprecation") JacksonAnnotationIntrospector jacksonAnnotationIntrospector = new JacksonAnnotationIntrospector(); assertNull(jacksonAnnotationIntrospector.findNameForDeserialization(null)); assertNull(jacksonAnnotationIntrospector.findNameForDeserialization(getClass().getDeclaredField("objectField"))); assertNull(jacksonAnnotationIntrospector.findNameForDeserialization(getClass().getDeclaredMethod("setObjectField"))); assertNull(jacksonAnnotationIntrospector.findNameForDeserialization(getClass().getDeclaredMethod("setObjectField"))); assertNull(jackson
@Test public void testFindNameForDeserialization() { @SuppressWarnings("deprecation") JacksonAnnotationIntrospector jacksonAnnotationIntrospector = new JacksonAnnotationIntrospector(); PropertyName name = jacksonAnnotationIntrospector.findNameForDeserialization(getClass().getDeclaredField("objectField")); assertNull(name); name = jacksonAnnotationIntrospector.findNameForDeserialization(getClass().getDeclaredMethod("setObjectField")); assertNull(name); name = jacksonAnnotationIntrospector.findNameForDeserialization(getClass().getDeclaredMethod("setObjectField")); assertNull(name); name = jacksonAnnotationIntrospector.findNameFor
@Test public void testFindNameForDeserialization() { SimpleMappedClass c = new SimpleMappedClass(); Method m = c.getClass().getMethods()[0]; PropertyName ps = p.findNameForDeserialization(m); assertTrue(ps.isDefault()); ps = p.findNameForDeserialization(m); assertFalse(ps.isDefault()); ps = p.findNameForDeserialization(m); assertFalse(ps.isDefault()); ps = p.findNameForDeserialization(m); assertFalse(ps.isDefault()); ps = p.findNameForDeserialization(m); assertFalse(ps.isDefault()); ps = p.findNameForDeserialization(
@Test public void testFindDeserializationName() { Map<String, Object> properties = new HashMap<String, Object>(); properties.put("prop1", "val1"); properties.put("prop2", "val2"); properties.put("prop3", "val3"); properties.put("prop4", "val4"); properties.put("prop5", "val5"); properties.put("prop6", "val6"); properties.put("prop7", "val7"); properties.put("prop8", "val8"); properties.put("prop9", "val9"); properties.put("prop10", "val10"); properties.put("prop11", "val11");
@Test public void testFindDeserializationName() throws Exception { assertEquals("", findDeserializationName(AnnotatedClass.class.getDeclaredMethod("setObjectField", Object.class))); assertEquals("", findDeserializationName(AnnotatedClass.class.getDeclaredMethod("setListField", List.class))); assertEquals("", findDeserializationName(AnnotatedClass.class.getDeclaredMethod("setListField", List.class))); assertEquals("", findDeserializationName(AnnotatedClass.class.getDeclaredMethod("setListField", List.class))); assertEquals("", findDeserializationName(AnnotatedClass.class.getDeclaredMethod("setListField", List.class)));
@Test public void testHasAnySetterAnnotation() { Set<String> set = new HashSet<String>(); set.add("a"); set.add("b"); set.add("c"); Set<String> set2 = new HashSet<String>(); set2.add("d"); set2.add("e"); set2.add("f"); Set<String> set3 = new HashSet<String>(); set3.add("g"); set3.add("h"); set.add("i"); set.add("j"); Set<String> set4 = new HashSet<String>(); set4.add("a"); set.add("b"); set.add("c"); set.
@Test public void testHasAnySetterAnnotation() { Set<String> set = new HashSet<String>(); set.add("a"); set.add("b"); set.add("c"); Set<String> set2 = new HashSet<String>(); set2.add("d"); set2.add("e"); set2.add("f"); set2.add("g"); Set<String> set3 = new HashSet<String>(); set3.add("e"); set3.add("f"); set3.add("g"); set.add("h"); set.add("i"); set.add("j"); Set<String> set4 = new HashSet<String>(); set
@Test(expected = MappingException.class) public void no_type_resolver() { SimpleTypeRegistry.getInstance().registerOfType(NoTypeResolver.class, SimpleTypeResolver.class); SimpleTypeRegistry.getInstance().registerOfType(NoTypeResolver.class, SimpleTypeResolver.class); SimpleTypeRegistry.getInstance().registerOfType(NoTypeResolver.class, SimpleTypeResolver.class); SimpleTypeRegistry.getInstance().registerOfType(NoTypeResolver.class, SimpleTypeResolver.class); SimpleTypeRegistry.getInstance().registerOfType(NoTypeResolver.class, SimpleTypeResolver.class); SimpleTypeRegistry.getInstance().registerOfType(NoTypeResolver.class, SimpleTypeResolver.
@Test(expected = MappingException.class) public void no_type_resolver() { SimpleTypeRegistry.getInstance().registerOfType(NoTypeResolver.class, SimpleTypeResolver.class); SimpleTypeRegistry.getInstance().registerOfType(NoTypeResolver.class, SimpleTypeResolver.class); SimpleTypeRegistry.getInstance().registerOfType(NoTypeResolver.class, NoTypeResolver.class); SimpleTypeRegistry.getInstance().registerOfType(NoTypeResolver.class, NoTypeResolver.class); SimpleTypeRegistry.getInstance().registerOfType(NoTypeResolver.class, NoTypeResolver.class); SimpleTypeRegistry.getInstance().registerOfType(NoTypeResolver.class, NoTypeResolver.
@Test(expected = MappingException.class) public void noTypeResolverBuilder() { SimpleCodecRegistry registry = new SimpleCodecRegistry(); SimpleCodecRegistry.setDefaultCodecRegistry(registry); SimpleCodecRegistry.setDefaultCodecRegistry(registry); SimpleCodecRegistry.setDefaultCodecRegistry(registry); SimpleCodecRegistry.setDefaultCodecRegistry(registry); SimpleCodecRegistry.setDefaultCodecRegistry(registry); SimpleCodecRegistry.setDefaultCodecRegistry(registry); SimpleCodecRegistry.setDefaultCodecRegistry(registry); SimpleCodecRegistry.setDefaultCodecRegistry(registry); SimpleCodecRegistry.setDefaultCodecRegistry(registry); SimpleCodecRegistry.setDefaultCodecRegistry(registry); SimpleCodecRegistry.setDefaultCodecRegistry(registry);
@Test(expected = MappingException.class) public void no_type_resolver() { SimpleTypeRegistry.getInstance().registerOfType(NoTypeResolver.class, Object.class); SimpleTypeRegistry.getInstance().registerOfType(NoTypeResolver.class, Object.class); SimpleTypeRegistry.getInstance().registerOfType(String.class, String.class); SimpleTypeRegistry.getInstance().registerOfType(Integer.class, Integer.class); SimpleTypeRegistry.getInstance().registerOfType(Long.class, Long.class); SimpleTypeRegistry.getInstance().registerOfType(Float.class, Float.class); SimpleTypeRegistry.getInstance().registerOfType(Double.class, Double.class);
@Test(expected = MappingException.class) public void no_type_resolver() { SimpleTypeRegistry.getInstance().registerOfType(NoTypeResolver.class, SimpleTypeResolver.class); SimpleTypeRegistry.getInstance().registerOfType(String.class, String.class); SimpleTypeRegistry.getInstance().registerOfType(Integer.class, Integer.class); SimpleTypeRegistry.getInstance().registerOfType(Long.class, Long.class); SimpleTypeRegistry.getInstance().registerOfType(Float.class, Float.class); SimpleTypeRegistry.getInstance().registerOfType(Double.class, Double.class); SimpleTypeRegistry.getInstance().registerOfType(Float.class, Float.class);
@Test(expected = MappingException.class) public void no_type_resolver() { SimpleTypeRegistry.getInstance().registerOfType(NoTypeResolver.class, SimpleTypeResolver.class); SimpleTypeRegistry.getInstance().registerOfType(NoTypeResolver.class, SimpleTypeResolver.class); SimpleTypeRegistry.getInstance().registerOfType(NoTypeResolver.class, SimpleTypeResolver.class); SimpleTypeRegistry.getInstance().registerOfType(NoTypeResolver.class, SimpleTypeResolver.class); SimpleTypeRegistry.getInstance().registerOfType(NoTypeResolver.class, SimpleTypeResolver.class); SimpleTypeRegistry.getInstance().registerOfType(NoTypeResolver.class, SimpleTypeResolver.
@Test(expected = MappingException.class) public void no_type_resolver() { SimpleTypeRegistry.getInstance().registerOfType(NoTypeResolver.class, SimpleTypeResolver.class); SimpleTypeRegistry.getInstance().registerOfType(NoTypeResolver.class, SimpleTypeResolver.class); SimpleTypeRegistry.getInstance().registerOfType(NoTypeResolver.class, SimpleTypeResolver.class); SimpleTypeRegistry.getInstance().registerOfType(NoTypeResolver.class, SimpleTypeResolver.class); SimpleTypeRegistry.getInstance().registerOfType(NoTypeResolver.class, SimpleTypeResolver.class); SimpleTypeRegistry.getInstance().registerOfType(NoTypeResolver.class, SimpleTypeResolver.
@Test(expected = MappingException.class) public void no_type_resolver() { TypeResolverBuilder<?> typeResolverBuilder = _findTypeResolver(new SimpleMapperConfig<NoTypeResolver>(), NoTypeResolver.class.getAnnotation(JsonTypeInfo.class), JavaType.class); }
@Test(expected = MappingException.class) public void noTypeResolverBuilder() { SimpleTypeRegistry.getInstance().registerOfType(NoTypeResolver.class, SimpleTypeResolver.class); SimpleTypeRegistry.getInstance().registerOfType(NoTypeResolver.class, NoTypeResolver.class); SimpleTypeRegistry.getInstance().registerOfType(NoTypeResolver.class, NoTypeResolver.class); SimpleTypeRegistry.getInstance().registerOfType(NoTypeResolver.class, NoTypeResolver.class); SimpleTypeRegistry.getInstance().registerOfType(NoTypeResolver.class, NoTypeResolver.class); SimpleTypeRegistry.getInstance().registerOfType(NoTypeResolver.class, NoTypeResolver.class
@Test(expected = MappingException.class) public void noTypeResolverBuilder() { SimpleCodecRegistry registry = new SimpleCodecRegistry(); SimpleCodecRegistry.setDefaultCodecRegistry(registry); SimpleCodecRegistry.setDefaultCodecRegistry(registry); SimpleCodecRegistry.setDefaultCodecRegistry(registry); SimpleCodecRegistry.setDefaultCodecRegistry(registry); SimpleCodecRegistry.setDefaultCodecRegistry(registry); SimpleCodecRegistry.setDefaultCodecRegistry(registry); SimpleCodecRegistry.setDefaultCodecRegistry(registry); SimpleCodecRegistry.setDefaultCodecRegistry(registry); SimpleCodecRegistry.setDefaultCodecRegistry(registry); SimpleCodecRegistry.setDefaultCodecRegistry(registry); SimpleCodecRegistry.setDefaultCodecRegistry(registry);
@Test(expected = MappingException.class) public void no_type_resolver() { SimpleTypeRegistry.getInstance().registerOfType(NoTypeResolver.class, SimpleTypeResolver.class); SimpleTypeRegistry.getInstance().registerOfType(NoTypeResolver.class, NoTypeResolver.class); SimpleTypeRegistry.getInstance().registerOfType(NoTypeResolver.class, NoTypeResolver.class); SimpleTypeRegistry.getInstance().registerOfType(NoTypeResolver.class, NoTypeResolver.class); SimpleTypeRegistry.getInstance().registerOfType(NoTypeResolver.class, NoTypeResolver.class); SimpleTypeRegistry.getInstance().registerOfType(NoTypeResolver.class, NoTypeResolver.
@Test(expected = MappingException.class) public void no_type_resolver() { SimpleTypeRegistry.getInstance().registerOfType(NoTypeResolver.class, SimpleTypeResolver.class); SimpleTypeRegistry.getInstance().registerOfType(NoTypeResolver.class, SimpleTypeResolver.class); SimpleTypeRegistry.getInstance().registerOfType(String.class, String.class); SimpleTypeRegistry.getInstance().registerOfType(Integer.class, Integer.class); SimpleTypeRegistry.getInstance().registerOfType(Long.class, Long.class); SimpleTypeRegistry.getInstance().registerOfType(Float.class, Float.class); SimpleTypeRegistry.getInstance().registerOfType(Double.class,
@Test(expected = MappingException.class) public void no_type_resolver() { SimpleTypeRegistry.getInstance().get(SimpleTypeRegistry.class); SimpleTypeRegistry.getInstance().get(SimpleTypeRegistry.class); SimpleTypeRegistry.getInstance().clear(); SimpleTypeRegistry.getInstance().add(SimpleTypeRegistry.class); SimpleTypeRegistry.getInstance().add(SimpleTypeRegistry.class); SimpleTypeRegistry.getInstance().add(SimpleTypeRegistry.class); SimpleTypeRegistry.getInstance().clear(); SimpleTypeRegistry.getInstance().add(SimpleTypeRegistry.class); SimpleTypeRegistry.getInstance().add(SimpleTypeRegistry.class); SimpleTypeRegistry.getInstance().
@Test(expected = MappingException.class) public void noTypeResolverBuilder() { SimpleCodecRegistry registry = new SimpleCodecRegistry(); SimpleCodecRegistry.setDefaultCodecRegistry(registry); SimpleCodecRegistry.setDefaultCodecRegistry(registry); SimpleCodecRegistry.setDefaultCodecRegistry(registry); SimpleCodecRegistry.setDefaultCodecRegistry(registry); SimpleCodecRegistry.setDefaultCodecRegistry(registry); SimpleCodecRegistry.setDefaultCodecRegistry(registry); SimpleCodecRegistry.setDefaultCodecRegistry(registry); SimpleCodecRegistry.setDefaultCodecRegistry(registry); SimpleCodecRegistry.setDefaultCodecRegistry(registry); SimpleCodecRegistry.setDefaultCodecRegistry(registry); SimpleCodecRegistry.setDefaultCodecRegistry(registry);
@Test(expected = MappingException.class) public void no_type_resolver() { SimpleTypeRegistry.getInstance().registerOfType(NoTypeResolver.class, SimpleTypeResolver.class); SimpleTypeRegistry.getInstance().registerOfType(NoTypeResolver.class, SimpleTypeResolver.class); SimpleTypeRegistry.getInstance().registerOfType(NoTypeResolver.class, NoTypeResolver.class); SimpleTypeRegistry.getInstance().registerOfType(NoTypeResolver.class, NoTypeResolver.class); SimpleTypeRegistry.getInstance().registerOfType(NoTypeResolver.class, NoTypeResolver.class); SimpleTypeRegistry.getInstance().registerOfType(NoTypeResolver.class, NoTypeResolver.
@Test(expected = MappingException.class) public void noTypeResolverBuilder() { SimpleCodecRegistry registry = new SimpleCodecRegistry(); SimpleCodecRegistry.setDefaultCodecRegistry(registry); SimpleCodecRegistry.setDefaultCodecRegistry(registry); SimpleCodecRegistry.setDefaultCodecRegistry(registry); SimpleCodecRegistry.setDefaultCodecRegistry(registry); SimpleCodecRegistry.setDefaultCodecRegistry(registry); SimpleCodecRegistry.setDefaultCodecRegistry(registry); SimpleCodecRegistry.setDefaultCodecRegistry(registry); SimpleCodecRegistry.setDefaultCodecRegistry(registry); SimpleCodecRegistry.setDefaultCodecRegistry(registry); SimpleCodecRegistry.setDefaultCodecRegistry(registry); SimpleCodecRegistry.setDefaultCodecRegistry(registry);
@Test public void test_constructStdTypeResolverBuilder() { StdTypeResolverBuilder builder = _constructStdTypeResolverBuilder(); assertNotNull(builder); }
@Test public void testStdTypeResolverBuilder() { Map<String, Object> props = new HashMap<String, Object>(); props.put("prop1", "prop1_value"); props.put("prop2", "prop2_value"); props.put("prop3", "prop3_value"); Map<String, Object> props2 = new HashMap<String, Object>(); props2.put("prop1", "prop1_value"); props2.put("prop2", "prop2_value"); Map<String, Object> props3 = new HashMap<String, Object>(); props3.put("prop1", "prop1_value"); props3.put("prop
@Test public void testStdScalarSerializer() throws Exception { ObjectMapper mapper = new ObjectMapper(); Map<String, Object> map = new HashMap<String, Object>(); map.put("key1", "value1"); map.put("key2", "value2"); Map<String, Object> map2 = new HashMap<String, Object>(); map2.put("key1", "value1"); map2.put("key2", "value2"); Map<String, Object> map3 = new HashMap<String, Object>(); map3.put("key1", "value1"); map3.put("key2", "value2"); map3.put("key3", "value
@Test public void testStdScalarSerializer() throws Exception { ObjectMapper mapper = new ObjectMapper(); Map<String, Object> map = new HashMap<String, Object>(); map.put("key1", "value1"); map.put("key2", "value2"); mapper.setSerializationInclusion(Include.NON_NULL); mapper.setSerializationInclusion(Include.NON_NULL); Map<String, Object> map2 = new HashMap<String, Object>(); map2.put("key1", "value1"); map2.put("key2", "value2"); mapper.setSerializationInclusion(Include.NON_NULL); mapper.setSerializationInclusion(Include.NON_NULL
@Test public void testDeserializationContext() { MockDeserializerFactory factory = new MockDeserializerFactory(); DeserializationContext context = new DeserializationContext(factory, new SimpleDeserializationConfig(), new JsonParser(), new InjectableValues()); context.findRootValueDeserializer(JavaType.class); context.findRootValueDeserializer(JavaType.class); context.findRootValueDeserializer(JavaType.class); context.findRootValueDeserializer(JavaType.class); context.findRootValueDeserializer(JavaType.class); context.findRootValueDeserializer(JavaType.class); context.findRootValueDeserializer(JavaType.class); context.findRootValueDeserializer(JavaType.class); context.findRootValueDeserializer(JavaType.class);
@Test public void testDeserializationContext() { MockDeserializerFactory factory = new MockDeserializerFactory(); DeserializationContext ctx = new DeserializationContext(new SimpleDeserializationContext("test"), factory); Assert.assertEquals(ctx.getFactory(), factory); Assert.assertEquals(ctx.getConfig(), config); Assert.assertEquals(ctx.getFeatureFlags(), featureFlags); Assert.assertEquals(ctx.getView(), view); Assert.assertEquals(ctx.getParser(), parser); Assert.assertEquals(ctx.getInjectableValues(), injectableValues); Assert.assertEquals(ctx.findRootValueDeserializer(JavaType.class), rootValueDeserializer); Assert.assertEquals(ctx.
@Test public void testDeserializationContext() { DeserializationContext ctx = new DeserializationContext(null, null, null, null); assertNull(ctx.getFactory()); assertNull(ctx.getConfig()); assertNull(ctx.getFeatureFlags()); assertNull(ctx.getView()); assertNull(ctx.getParser()); assertNull(ctx.getInjectableValues()); assertNull(ctx.findRootValueDeserializer(JavaType.BOOLEAN)); assertEquals(BooleanDeserializer.class, ctx.findRootValueDeserializer(JavaType.BOOLEAN).getClass()); assertEquals(BooleanDeserializer.class, ctx.findRootValueDeserializer(JavaType.BOOLEAN).getClass()); assertEquals(BooleanDeserializer.class, ctx
@Test public void testDeserializationContext() { DeserializationContext ctx = new DeserializationContext(null, null, null, null); assertNull(ctx.getFactory()); assertNull(ctx.getConfig()); assertNull(ctx.getFeatureFlags()); assertNull(ctx.getView()); assertNull(ctx.getParser()); assertNull(ctx.getInjectableValues()); assertNull(ctx.findRootValueDeserializer(JavaType.BOOLEAN)); assertEquals(BooleanDeserializer.class, ctx.findRootValueDeserializer(JavaType.BOOLEAN).getClass()); assertEquals(BooleanDeserializer.class, ctx.findRootValueDeserializer(JavaType.BOOLEAN).getClass()); assertEquals(BooleanDeserializer.class, ctx
@Test public void testDeserializationContext() { DeserializationContext ctx = new DeserializationContext(null, null, null, null); assertNull(ctx.getFactory()); assertNull(ctx.getConfig()); assertNull(ctx.getFeatureFlags()); assertNull(ctx.getView()); assertNull(ctx.getParser()); assertNull(ctx.getInjectableValues()); assertNull(ctx.findRootValueDeserializer(JavaType.BOOLEAN)); assertEquals(BooleanDeserializer.class, ctx.findRootValueDeserializer(JavaType.BOOLEAN).getClass()); assertEquals(BooleanDeserializer.class, ctx.findRootValueDeserializer(JavaType.BOOLEAN).getClass()); assertEquals(BooleanDeserializer.class, ctx
@Test public void testDeserializationContext() { DeserializationContext ctx = new DeserializationContext(null, null, null, null); assertNull(ctx.getFactory()); assertNull(ctx.getView()); assertNull(ctx.getConfig()); assertNull(ctx.getFeatureFlags()); assertNull(ctx.getParser()); assertNull(ctx.getInjectableValues()); assertNull(ctx.findRootValueDeserializer(JavaType.get(String.class), null)); assertNull(ctx.findPropertyDeserializer(JavaType.get(String.class), null)); assertNull(ctx.findRootValueDeserializer(JavaType.get(Integer.class), null)); assertNull(ctx.findPropertyDeserializer
@Test public void testDeserializationContext() { DeserializationContext ctx = new DeserializationContext(null, null, null, null); assertNull(ctx.getFactory()); assertNull(ctx.getParser()); assertNull(ctx.getConfig()); assertNull(ctx.getFeatureFlags()); assertNull(ctx.getView()); assertNull(ctx.getParser()); assertNull(ctx.findRootValueDeserializer(JavaType.get(String.class), null)); assertNull(ctx.findPropertyDeserializer(JavaType.get(String.class), null)); assertNull(ctx.findRootValueDeserializer(JavaType.get(Integer.class), null)); assertNull(ctx.findPropertyDeserializer(JavaType
@Test public void testDeserializationContext() { DeserializationContext ctx = new DeserializationContext(null, null, null, null); assertNull(ctx.getFactory()); assertNull(ctx.getConfig()); assertNull(ctx.getFeatureFlags()); assertNull(ctx.getView()); assertNull(ctx.getParser()); assertNull(ctx.getInjectableValues()); assertNull(ctx.findRootValueDeserializer(JavaType.BOOLEAN)); assertNull(ctx.findRootValueDeserializer(JavaType.INTEGER)); assertNull(ctx.findRootValueDeserializer(JavaType.LONG)); assertNull(ctx.findRootValueDeserializer(JavaType.DOUBLE)); assertNull(ctx.findRootValueDeserializer(JavaType
@Test public void testGetTypeFactory() throws Exception { assertNotNull(new MockDeserializationContext().getTypeFactory()); assertNotNull(new MockDeserializationContext().getTypeFactory().getClass()); assertNotNull(new MockDeserializationContext().getTypeFactory().getClass(String.class)); assertNotNull(new MockDeserializationContext().getTypeFactory().getClass(Integer.class)); assertNotNull(new MockDeserializationContext().getTypeFactory().getClass(Long.class)); assertNotNull(new MockDeserializationContext().getTypeFactory().getClass(Float.class)); assertNotNull(new MockDeserializationContext().getTypeFactory().getClass(Double.class)); assertNotNull(new MockDeserializationContext().getTypeFactory().getClass
@Test public void testGetTypeFactory() { DeserializationConfig config = new DeserializationConfig() { @Override public TypeFactory getTypeFactory() { return new SimpleTypeFactory(); } }; DeserializationContext ctx = new DeserializationContext(config, null, null); assertSame(ctx.getConfig(), config.getTypeFactory()); assertSame(ctx.getTypeFactory(), config.getTypeFactory()); }
@Test public void testGetNodeFactory() { assertNotNull(new MockDeserializationContext().getNodeFactory()); }
@Test public void testGetNodeFactory() { DeserializationContext d = createContext(); d.getConfig().getNodeFactory().add(d.getNodeFactory()); assertEquals(d.getNodeFactory().getClass(), d.getNodeFactory().getClass()); d.getConfig().getNodeFactory().add(d.getNodeFactory().getClass()); assertEquals(d.getNodeFactory().getClass(), d.getNodeFactory().getClass()); d.getConfig().getNodeFactory().add(d.getNodeFactory().getClass()); assertEquals(d.getNodeFactory().getClass(), d.getNodeFactory().getClass()); }
@Test public void testGetLocale() { DeserializationContext d = new DeserializationContext(null, null, null, null); d.getConfig().setLocale(Locale.GERMAN); assertEquals(Locale.GERMAN, d.getLocale()); d.getConfig().setLocale(Locale.ENGLISH); assertEquals(Locale.ENGLISH, d.getLocale()); d.getConfig().setLocale(Locale.FRENCH); assertEquals(Locale.FRENCH, d.getLocale()); d.getConfig().setLocale(null); assertEquals(null, d.getLocale()); }
@Test public void testGetLocale() { DeserializationContext d = new DeserializationContext(null, null, null, null); d.getConfig().setLocale(Locale.US); assertEquals(Locale.US, d.getLocale()); d.getConfig().setLocale(Locale.GERMAN); assertEquals(Locale.GERMAN, d.getLocale()); d.getConfig().setLocale(Locale.FRENCH); assertEquals(Locale.FRENCH, d.getLocale()); d.getConfig().setLocale(Locale.ENGLISH); assertEquals(Locale.ENGLISH, d.getLocale()); }
@Test public void testFindClass() throws Exception { Class<?> c = ClassUtil.findClass("java.lang.String"); Assert.assertEquals(String.class, c); c = ClassUtil.findClass("java.lang.Integer"); Assert.assertEquals(Integer.class, c); c = ClassUtil.findClass("java.lang.Long"); Assert.assertEquals(Long.class, c); c = ClassUtil.findClass("java.lang.Float"); Assert.assertEquals(Float.class, c); c = ClassUtil.findClass("java.lang.Double"); Assert.assertEquals(Double.class, c); c = ClassUtil.findClass("java
@Test public void testFindClass() throws Exception { Class<?> c = ClassUtil.findClass("java.lang.String"); Assert.assertEquals(String.class, c); c = ClassUtil.findClass("java.lang.Integer"); Assert.assertEquals(Integer.class, c); c = ClassUtil.findClass("java.lang.Long"); Assert.assertEquals(Long.class, c); c = ClassUtil.findClass("java.lang.Float"); Assert.assertEquals(Float.class, c); c = ClassUtil.findClass("java.lang.Double"); Assert.assertEquals(Double.class, c); c = ClassUtil.findClass("java
@Test public void testConstructCalendar() { Date d = new Date(); Calendar c = context.constructCalendar(d); Assert.assertNotNull(c); Assert.assertEquals(d, c.getTime()); c = context.constructCalendar(null); Assert.assertNull(c); d = new Date(0); c = context.constructCalendar(d); Assert.assertNotNull(c); Assert.assertEquals(0, c.getTime()); c = context.constructCalendar(d); Assert.assertNull(c); d = new Date(1); c = context.constructCalendar(d); Assert.assertEquals(1, c.getTime()); c = context.constructCalendar(d);
@Test public void testConstructor() { DeserializationContext ctx = new DeserializationContext(null, null, null, null); Calendar c = Calendar.getInstance(TimeZone.getTimeZone("UTC")); c.setTime(new Date(0)); assertEquals(c, ctx.constructCalendar(new Date(0))); assertEquals(c, ctx.constructCalendar(new Date(1))); assertEquals(c, ctx.constructCalendar(new Date(2))); assertEquals(c, ctx.constructCalendar(new Date(3))); assertEquals(c, ctx.constructCalendar(new Date(4))); assertEquals(c, ctx.constructCalendar(new Date(5
@Test public void testConstructor() { DeserializationContext ctx = new DeserializationContext(null, null, null, null); Calendar c = ctx.constructCalendar(new Date()); assertEquals(c.get(Calendar.YEAR), 2015); assertEquals(c.get(Calendar.MONTH), Calendar.JANUARY); assertEquals(c.get(Calendar.DAY_OF_MONTH), 0); assertEquals(c.get(Calendar.HOUR_OF_DAY), 0); assertEquals(c.get(Calendar.MINUTE), 0); assertEquals(c.get(Calendar.SECOND), 0); assertEquals(c.get(Calendar.MILLISECOND), 0); }
@Test public void testConstructCalendar() throws Exception { Calendar c = Calendar.getInstance(TimeZone.getTimeZone("UTC")); c.setTime(new Date(0)); assertEquals(c.get(Calendar.YEAR), context.constructCalendar(new Date(0)).getYear()); assertEquals(c.get(Calendar.MONTH), context.constructCalendar(new Date(0)).getMonth()); assertEquals(c.get(Calendar.DAY_OF_MONTH), context.constructCalendar(new Date(0)).getDay()); assertEquals(c.get(Calendar.HOUR_OF_DAY), context.constructCalendar(new Date(0)).getHour()); assertEquals(
@Test public void testHandleUnknownProperty() throws Exception { DeserializationContext ctx1 = createContext(); DeserializationContext ctx2 = createContext(); ctx1.getConfig().addDeserializerFactory(SimpleJsonDeserializer.class); ctx1.getConfig().addDeserializerFactory(SimpleJsonDeserializer.class); ctx2.getConfig().addDeserializerFactory(SimpleJsonDeserializer.class); assertTrue(ctx1.handleUnknownProperty(null, null, null, null)); assertTrue(ctx2.handleUnknownProperty(null, null, null, null)); assertFalse(ctx1.handleUnknownProperty(null, null, null, null)); assertFalse(ctx2.handleUnknownProperty(null, null,
@Test(expected = UnrecognizedPropertyException.class) public void testReportUnknownProperty() { DeserializationContext d = createContext(); d.setEnabled(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES); d.reportUnknownProperty(d, "name", null); }
@Test(expected = UnrecognizedPropertyException.class) public void testUnknownProperty() { DeserializationContext d = createContext(); d.getConfig().addProperty(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, true); d.getConfig().addProperty(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, true); d.getConfig().addProperty(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, true); d.getConfig().addProperty(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, true); d.getConfig().addProperty(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, true); d.getConfig().addProperty(Deserialization
@Test(expected = UnrecognizedPropertyException.class) public void testReportUnknownProperty() { DeserializationContext d = createContext(); d.setEnabled(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES); d.reportUnknownProperty(d, "field1", null); d.reportUnknownProperty(d, "field2", null); d.reportUnknownProperty(d, "field3", null); d.reportUnknownProperty(d, "field4", null); d.reportUnknownProperty(d, "field5", null); d.reportUnknownProperty(d, "field6", null); d.reportUnknownProperty(d, "field7", null); }
@Test(expected = UnrecognizedPropertyException.class) public void testUnknownProperty() { DeserializationContext d = createContext(); d.getConfig().addProperty(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, true); d.getConfig().addProperty(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, true); d.getConfig().addProperty(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, true); d.getConfig().addProperty(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, true); d.getConfig().addProperty(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, true); d.getConfig().addProperty(Deserialization
@Test(expected = UnrecognizedPropertyException.class) public void testReportUnknownProperty() throws JsonMappingException { DeserializationContext d = createContext(); d.getConfig().addProperty(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, true); d.getConfig().addProperty(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, true); d.getConfig().addProperty(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false); d.getConfig().addProperty(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false); d.getConfig().addProperty(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false); d.getConfig().
@Test public void testErrorCodes() { String[][] tests = new String[][] { new String[][] { new String[]{null, "", ""}, new String[]{null, "foo", "bar"}, new String[]{null, "foo", "bar", "baz"}, new String[]{null, "foo", "bar", "baz"}, new String[]{null, "foo", "bar", "baz"}, new String[]{null, "foo", "bar", "baz"}, new String[]{null, "foo", "bar", "baz"}, new String[]{null, "foo", "bar", "b
@Test(expected = JsonMappingException.class) public void testBadKeyException() { DeserializationContext d = new DeserializationContext(null, null); d.getConfig().addDeserializerFactory(SimpleDeserializerFactory.class); d.getConfig().addDeserializerFactory(SimpleDeserializerFactory.class); d.findKeyDeserializer(JavaType.valueOf(String.class), null); d.findKeyDeserializer(JavaType.valueOf(String.class), null); d.findKeyDeserializer(JavaType.valueOf(String.class), null); d.findKeyDeserializer(JavaType.valueOf(String.class), null); d.findKeyDeserializer(JavaType.valueOf(String.class), null
@Test public void testWrongTokenException() throws Exception { JsonParser jp = Mockito.mock(JsonParser.class); JsonToken token = Mockito.mock(JsonToken.class); Mockito.when(jp.getCurrentToken()).thenReturn(token); String msg = "message"; JsonMappingException ex = d.wrongTokenException(jp, token, msg); assertEquals("Unexpected token (" + token + "), expected " + token + ": message", ex.getMessage()); }
@Test public void testWrongTokenException() throws Exception { JsonParser jp = mock(JsonParser.class); when(jp.getCurrentToken()).thenReturn("a"); DeserializationContext ctx = new DeserializationContext(jp, null, null, null); try { ctx.wrongTokenException(jp, JsonToken.VALUE_NULL, "message"); fail(); } catch (JsonMappingException e) { assertTrue(e.getMessage().contains("a")); assertTrue(e.getMessage().contains("message")); } }
@Test public void testGetDateFormat() { DateFormat df = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); df.setTimeZone(TimeZone.getTimeZone("UTC")); DeserializationConfig config = new DeserializationConfig(); config.setDateFormat(df); DeserializationContext ctx = new DeserializationContext(null, config, null, null); Assert.assertEquals(df, ctx.getDateFormat()); }
@Test public void testParse() throws ParseException { Date date = new Date(); SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); format.setTimeZone(TimeZone.getTimeZone("UTC")); Calendar cal = Calendar.getInstance(); cal.setTime(date); assertEquals(cal.get(Calendar.YEAR), cal.get(Calendar.YEAR)); assertEquals(cal.get(Calendar.MONTH), cal.get(Calendar.MONTH)); assertEquals(cal.get(Calendar.DAY_OF_MONTH), cal.get(Calendar.DAY_OF_MONTH)); assertEquals(cal.get(Calendar.HOUR_OF_
@Test public void testParse() throws ParseException { Date date = new Date(); SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); format.setTimeZone(TimeZone.getTimeZone("UTC")); Calendar cal = Calendar.getInstance(); cal.setTime(date); assertEquals(cal.get(Calendar.YEAR), cal.get(Calendar.YEAR)); assertEquals(cal.get(Calendar.MONTH), cal.get(Calendar.MONTH)); assertEquals(cal.get(Calendar.DAY_OF_MONTH), cal.get(Calendar.DAY_OF_MONTH)); assertEquals(cal.get(Calendar.HOUR_OF_
@Test public void testParse() throws ParseException { Date date = new Date(); SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); format.setTimeZone(TimeZone.getTimeZone("UTC")); Calendar cal = Calendar.getInstance(); cal.setTime(date); assertEquals(cal.get(Calendar.YEAR), cal.get(Calendar.YEAR)); assertEquals(cal.get(Calendar.MONTH), cal.get(Calendar.MONTH)); assertEquals(cal.get(Calendar.DAY_OF_MONTH), cal.get(Calendar.DAY_OF_MONTH)); assertEquals(cal.get(Calendar.HOUR_OF_
@Test public void testDefaultDeserializationContext() { DefaultDeserializationContext ctx = new DefaultDeserializationContext(mock(DeserializerFactory.class), mock(DeserializerCache.class)); assertSame(ctx, ctx.with(mock(DeserializerFactory.class))); assertSame(ctx, ctx.with(mock(DeserializerFactory.class))); assertSame(ctx, ctx.with(mock(DeserializerFactory.class))); assertSame(ctx, ctx.with(mock(DeserializerFactory.class))); assertSame(ctx, ctx.with(mock(DeserializerFactory.class))); assertSame(ctx, ctx.with(mock(DeserializerFactory.class))); assertSame(ctx, ctx.with(
@Test public void testDefaultDeserializerFactory() { DeserializerFactory df = mock(DeserializerFactory.class); DefaultDeserializationContext ctx = new DefaultDeserializationContext(df, null); assertSame(df, ctx.with(df)); assertSame(ctx, ctx.with(df)); assertSame(ctx, ctx.with(df)); assertSame(ctx, ctx.with(df)); assertSame(ctx, ctx.with(df)); assertSame(ctx, ctx.with(df)); assertSame(ctx, ctx.with(df)); assertSame(ctx, ctx.with(df)); assertSame(ctx, ctx.with(df)); assertSame(ctx, ctx.with(df));
@Test(expected = IllegalStateException.class) public void testKeyDeserializerNoClass() { DeserializationConfig config = new DeserializationConfig(); config.setHandlerInstantiator(new MyKeyDeserializerInstantiator()); DefaultDeserializationContext ctx = new DefaultDeserializationContext(null, config, null, null); ctx.keyDeserializerInstance(null, new MyKeyDeserializer()); }
@Test public void testMyDeserializerFactory() { DeserializerFactory df = new DeserializerFactory() { @Override public Class<? extends Annotation> annotationType() { return MyDeserializer.class; } @Override public Deserializer<Object> deserializerInstance(Annotated annotated, JsonParser jp) { return new MyDeserializer(); } @Override public Class<? extends Annotation> annotationType() { return MyDeserializer.class; } }; MyDeserializer myObj = new MyDeserializer(df); assertEquals(myObj.getClass(), MyDeserializer.class); assertEquals(myObj.getFoo(), MyDeserializer.Foo.class); assertEquals(myObj.getBar(), MyDeserializer.Bar.class); assertEquals(myObj
@Test public void testMultiLine() { DeserializationConfig config = mock(DeserializationConfig.class); JsonParser jp = mock(JsonParser.class); InjectableValues values = mock(InjectableValues.class); DeserializerFactory df = mock(DeserializerFactory.class); when(df.createDeserializer(any(String.class), any(JsonParser.class), any(InjectableValues.class))).thenReturn(mock(Deserializer.class)); when(df.createDeserializer(any(String.class), any(JsonParser.class), any(InjectableValues.class))).thenReturn(mock(Deserializer.class)); when(values.createInstance(any(Annotated.class),
@Test public void testWith() { DeserializationConfig config = mock(DeserializationConfig.class); JsonParser jp = mock(JsonParser.class); InjectableValues values = mock(InjectableValues.class); DeserializerFactory df = mock(DeserializerFactory.class); when(df.createDeserializerInstance(any(Annotated.class), any(JsonParser.class), any(InjectableValues.class))).thenReturn(mock(Deserializer.class)); when(df.createDeserializerInstance(any(Annotated.class), any(JsonParser.class), any(InjectableValues.class))).thenReturn(mock(Deserializer.class)); when(values.createInstance(any(Annotated.class
@Test public void testCustomDeserializerFactory() { DeserializationConfig config = mock(DeserializationConfig.class); JsonParser jp = mock(JsonParser.class); InjectableValues values = mock(InjectableValues.class); DeserializerFactory df1 = mock(DeserializerFactory.class); DeserializerFactory df2 = mock(DeserializerFactory.class); when(df1.createDeserializer(any(Annotated.class), any(JsonParser.class), any(InjectableValues.class))).thenReturn(mock(Deserializer.class)); when(df2.createDeserializer(any(Annotated.class), any(JsonParser.class), any(InjectableValues.class))).thenReturn(mock(
@Test public void testJsonValueSerializer() throws Exception { TestBean bean1 = new TestBean(); TestBean bean2 = new TestBean(); TestBean bean3 = new TestBean(); TestBean bean4 = new TestBean(); TestBean bean5 = new TestBean(); List<TestBean> list = Arrays.asList(bean1, bean2, bean3, bean4); List<TestBean> list2 = Arrays.asList(bean1, bean2, bean3, bean4); List<TestBean> list3 = Arrays.asList(bean1, bean2, bean3, bean4); List<TestBean> list4 = Arrays.asList(bean1, bean
@Test public void testJsonValueSerializer() throws Exception { MockBean bean1 = new MockBean(); MockBean bean2 = new MockBean(); MockBeanBean bean3 = new MockBeanBean(); MockBeanBean bean4 = new MockBeanBean(); MockBeanBean bean5 = new MockBeanBean(); MockBeanBean bean6 = new MockBeanBean(); MockBeanBean bean7 = new MockBeanBean(); MockBeanBean bean8 = new MockBeanBean(); MockBeanBean bean9 = new MockBeanBean(); MockBeanBean bean10 = new MockBeanBean(); MockBeanBean bean11 = new MockBeanBean(); MockBeanBean bean12 = new MockBeanBean(); MockBeanBean bean13 = new Mock
@Test public void testJsonValueSerializer() throws IOException, JsonMappingException { SerializerProvider provider = Mockito.mock(SerializerProvider.class); MockBean bean1 = new MockBean(); MockBean bean2 = new MockBean(); MockBeanBean bean3 = new MockBeanBean(); MockBeanBean bean4 = new MockBeanBean(); MockBeanBean bean5 = new MockBeanBean(); MockBeanBean bean6 = new MockBeanBean(); MockBeanBean bean7 = new MockBeanBean(); MockBeanBean bean8 = new MockBeanBean(); MockBeanBean bean9 = new MockBeanBean(); MockBeanBean bean10 = new MockBeanBean(); MockBeanBean bean11 = new MockBeanBean(); Mock
@Test public void testJsonValueSerializer() throws Exception { MockBean bean1 = new MockBean(); MockBean bean2 = new MockBean(); MockBeanBean bean3 = new MockBeanBean(); MockBeanBean bean4 = new MockBeanBean(); MockBeanBean bean5 = new MockBeanBean(); MockBeanBean bean6 = new MockBeanBean(); MockBeanBean bean7 = new MockBeanBean(); MockBeanBean bean8 = new MockBeanBean(); MockBeanBean bean9 = new MockBeanBean(); MockBeanBean bean10 = new MockBeanBean(); MockBeanBean bean11 = new MockBeanBean(); MockBeanBean bean12 = new MockBeanBean(); MockBeanBean bean13 = new Mock
@Test public void testJsonValueSerializer() throws Exception { MockBean bean = new MockBean(); MockSerializerProvider provider = new MockSerializerProvider(); JsonValueSerializer serializer = new JsonValueSerializer(String.class.getDeclaredMethod("length"), provider); serializer.serialize(bean, new JsonGeneratorImpl(), provider); serializer.serializeWithType(bean, new JsonGeneratorImpl(), provider); serializer.serializeWithType(bean, new JsonGeneratorImpl(), provider); serializer.serializeWithType(bean, new JsonGeneratorImpl(), provider); serializer.serializeWithType(bean, new JsonGeneratorImpl(), provider); serializer.serializeWithType(bean, new JsonGeneratorImpl(), provider); }
@Test public void testJsonValueSerializer() throws Exception { MockBean bean = new MockBean(); MockSerializerProvider provider = new MockSerializerProvider(); JsonValueSerializer serializer = new JsonValueSerializer(String.class.getMethod("length"), provider); serializer.serialize(bean, new JsonGeneratorAdapter(), provider); serializer.serializeWithType(bean, new JsonGeneratorAdapter(), provider); serializer.serializeWithType(bean, new JsonGeneratorAdapter(), provider); serializer.serializeWithType(bean, new JsonGeneratorAdapter(), provider); serializer.serializeWithType(bean, new JsonGeneratorAdapter(), provider); serializer.serializeWithType(bean, new JsonGeneratorAdapter(), provider); serializer.serializeWithType(bean,
@Test public void testJsonValueSerializer() throws Exception { TestBean bean1 = new TestBean(); TestBean bean2 = new TestBean(); TestBean bean3 = new TestBean(); TestBean bean4 = new TestBean(); TestBean bean5 = new TestBean(); TestBean bean6 = new TestBean(); List<TestBean> list = Arrays.asList(bean1, bean2, bean3, bean4, bean5); List<TestBean> list2 = Arrays.asList(bean2, bean3, bean4, bean5); List<TestBean> list3 = Arrays.asList(bean3, bean4, bean5); List<TestBean> list4 =
@Test public void testJsonValueSerializer() throws IOException, JsonMappingException { SerializerProvider provider = Mockito.mock(SerializerProvider.class); MockBean bean1 = new MockBean(); MockBean bean2 = new MockBean(); MockBeanBean bean3 = new MockBeanBean(); MockBeanBean bean4 = new MockBeanBean(); MockBeanBean bean5 = new MockBeanBean(); MockBeanBean bean6 = new MockBeanBean(); MockBeanBean bean7 = new MockBeanBean(); MockBeanBean bean8 = new MockBeanBean(); MockBeanBean bean9 = new MockBeanBean(); MockBeanBean bean10 = new MockBeanBean(); MockBeanBean bean11 = new MockBeanBean(); Mock
@Test public void testJsonValueSerializer() throws IOException, JsonMappingException { SimpleSerializerProvider provider = new SimpleSerializerProvider(); TestBean bean1 = new TestBean(); TestBean bean2 = new TestBean(); TestBean bean3 = new TestBean(); TestBean bean4 = new TestBean(); List<TestBean> list1 = Arrays.asList(bean1, bean2, bean3, bean4); List<TestBean> list2 = Arrays.asList(bean1, bean2, bean3, bean4); List<TestBean> list3 = Arrays.asList(bean1, bean3, bean4); List<TestBean> list4 = Arrays.asList(bean
@Test public void testJsonValueSerializer() throws Exception { MockBean bean1 = new MockBean(); MockBean bean2 = new MockBean(); MockBeanBean bean3 = new MockBeanBean(); MockBeanBean bean4 = new MockBeanBean(); MockBeanBean bean5 = new MockBeanBean(); MockBeanBean bean6 = new MockBeanBean(); MockBeanBean bean7 = new MockBeanBean(); MockBeanBean bean8 = new MockBeanBean(); MockBeanBean bean9 = new MockBeanBean(); MockBeanBean bean10 = new MockBeanBean(); MockBeanBean bean11 = new MockBeanBean(); MockBeanBean bean12 = new MockBeanBean(); MockBeanBean bean13 = new Mock
@Test public void testJsonValueSerializer() throws Exception { MockBean bean = new MockBean(); MockSerializerProvider provider = new MockSerializerProvider(); JsonValueSerializer ser1 = new JsonValueSerializer(bean.getClass().getDeclaredMethod("getValue1"), provider, null); JsonValueSerializer ser2 = new JsonValueSerializer(bean.getClass().getDeclaredMethod("getValue2"), provider, null); JsonValueSerializer ser3 = new JsonValueSerializer(bean.getClass().getDeclaredMethod("getValue3"), provider, null); JsonValueSerializer ser4 = new JsonValueSerializer(bean.getClass().getDeclaredMethod("getValue4"), provider, null); ser1.serialize(bean
@Test public void testJsonValueSerializer() throws IOException, JsonMappingException { MockBean bean1 = new MockBean(); MockBean bean2 = new MockBean(); MockBeanBean bean3 = new MockBeanBean(); MockBeanBean bean4 = new MockBeanBean(); MockBeanBean bean5 = new MockBeanBean(); MockBeanBean bean6 = new MockBeanBean(); MockBeanBean bean7 = new MockBeanBean(); MockBeanBean bean8 = new MockBeanBean(); MockBeanBean bean9 = new MockBeanBean(); MockBeanBean bean10 = new MockBeanBean(); MockBeanBean bean11 = new MockBeanBean(); MockBeanBean bean12 = new MockBeanBean(); MockBeanBean bean
@Test public void test_notNullClass() throws Exception { Class<?> cls = null; assertSame(cls, _notNullClass(cls)); assertSame(Object.class, _notNullClass(null)); assertSame(Object.class, _notNullClass(null)); assertSame(Boolean.class, _notNullClass(Boolean.class)); assertSame(Boolean.class, _notNullClass(Boolean.class)); assertSame(Object.class, _notNullClass(Object.class)); assertSame(Object.class, _notNullClass(Object.class)); assertSame(Object.class, _notNullClass(Object.class)); assertSame(Object.class, _
@Test public void _notNullClass() { Class<Object> cls = null; assertSame(cls, _notNullClass(cls)); assertSame(Object.class, _notNullClass(null)); assertSame(Object.class, _notNullClass(Object.class)); assertSame(Object.class, _notNullClass(null)); assertSame(Object.class, _notNullClass(Object.class)); assertSame(Object.class, _notNullClass(Object.class)); assertSame(Object.class, _notNullClass(Object.class)); assertSame(Object.class, _notNullClass(Object.class)); assertSame(Object.class, _notNull
@Test public void testWithResolved() throws Exception { MockBean bean = new MockBean(); bean.setDate(new Date()); BeanProperty property = new BeanProperty("date", Date.class); JsonValueSerializer serializer1 = new JsonValueSerializer(bean.getDate(), property, null, false); JsonValueSerializer serializer2 = new JsonValueSerializer(bean.getDate(), property, null, false); JsonValueSerializer serializer3 = new JsonValueSerializer(bean.getDate(), property, null, true); serializer1.withResolved(property, serializer2, true); serializer2.withResolved(property, serializer3, true); serializer3.withResolved(bean.getDate(), serializer1, true
@Test public void testWithResolved() throws Exception { MockBean bean = new MockBean(); BeanProperty property = new BeanProperty("firstName", String.class); JsonValueSerializer serializer1 = new JsonValueSerializer(bean.getFirstName(), property, null, false); JsonValueSerializer serializer2 = new JsonValueSerializer(bean.getSecondName(), property, null, false); JsonValueSerializer serializer3 = new JsonValueSerializer(bean.getFirstName(), property, null, false); JsonValueSerializer serializer4 = new JsonValueSerializer(bean.getSecondName(), property, null, false); JsonValueSerializer serializer5 = new JsonValueSerializer(bean.getFirstName(), property, null, false
@Test public void testBooleanSerializer() throws Exception { JsonValueSerializer bs = new JsonValueSerializer(String.class.getDeclaredMethod("length"), new JsonSerializer<Object>() { @Override public void serialize(Object bean, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonMappingException { } @Override public void serializeWithType(JsonValue bean, JsonGenerator jgen, TypeHint typeHint) throws IOException, JsonProcessingException { } }); bs.withResolved(new BooleanSerializer(true), new JsonSerializer<Boolean>() { @Override public void serializeWithType(JsonValue bean, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonMappingException { } @Override public void
@Test public void createContextual() throws IOException, JsonMappingException { SimpleSerializerProvider provider = new SimpleSerializerProvider(); SimpleBean bean = new SimpleBean(); bean.setIntegerProperty(123); bean.setBooleanProperty(true); provider.addSerializer(new JsonValueSerializer(String.class, String.class)); provider.addSerializer(new JsonValueSerializer(Integer.class, Integer.class)); provider.addSerializer(new JsonValueSerializer(String.class, Integer.class)); provider.addSerializer(new JsonValueSerializer(String.class, String.class)); provider.addSerializer(new JsonValueSerializer(Integer.class, Integer.class)); provider.addSerializer(new JsonValueSerializer
@Test public void createContextual() throws IOException, JsonMappingException { SimpleSerializerProvider provider = new SimpleSerializerProvider(); BeanProperty property = new BeanProperty("id", Integer.class); BeanValueSerializer js = new JsonValueSerializer(String.class.getDeclaredMethod("length"), js, false); js.setSerializerProvider(provider); js.createContextual(provider, property); }
@Test public void testCreateContextual() throws IOException, JsonMappingException { SimpleSerializerProvider provider = new SimpleSerializerProvider(); provider.enable(MapperFeature.USE_STATIC_TYPING); MockBean bean = new MockBean(); bean.setDate(new Date()); BeanProperty property = new BeanProperty("dateTime", Date.class); serializer.serialize(bean, provider, provider); Assert.assertEquals("\\"dateTime\\"", serializer.toString()); provider.disable(MapperFeature.USE_STATIC_TYPING); provider.disable(MapperFeature.USE_STATIC_TYPING); serializer.serialize(bean, provider, provider); Assert.assertEquals("\\"dateTime\\"", serializer.toString()); provider
@Test public void createContextual() throws IOException, JsonMappingException { SimpleSerializerProvider provider = new SimpleSerializerProvider(); provider.addSerializer(SimpleType.class, new SimpleSerializer(SimpleType.class)); provider.addSerializer(SimpleType.class, new SimpleSerializer(SimpleType.class)); provider.addSerializer(SimpleType.class, new SimpleSerializer(SimpleType.class)); provider.addSerializer(SimpleType.class, new SimpleSerializer(SimpleType.class)); provider.addSerializer(SimpleType.class, new SimpleSerializer(SimpleType.class)); SimpleType mockType = mock(SimpleType.class); when(mockType.getGenericReturnType()).thenReturn(mockType);
@Test public void testCreateContextual() throws IOException, JsonMappingException { SimpleSerializerProvider provider = new SimpleSerializerProvider(); provider.addSerializer(SimpleType.class); provider.addSerializer(SimpleType.class); provider.addSerializer(SimpleType.class); provider.addSerializer(SimpleType.class); SimpleType mockType = mock(SimpleType.class); when(mockType.getGenericReturnType()).thenReturn(mockType); SimpleType mockType2 = mock(SimpleType.class); when(mockType2.getGenericReturnType()).thenReturn(mockType); SimpleType mockType3 = mock(SimpleType.class); when(mockType3.getGenericReturnType()).
@Test public void createContextual() throws Exception { MockBean bean = new MockBean(); MockSerializerProvider provider = new MockSerializerProvider(); provider.addSerializerForClass(MockBean.class, MockBean.class); provider.addSerializerForClass(MockBean2.class, MockBean2.class); provider.addSerializerForClass(MockBean3.class, MockBean3.class); provider.addSerializerForClass(MockBean4.class, MockBean4.class); provider.addSerializerForClass(MockBean1.class, MockBean1.class); provider.addSerializerForClass(MockBean2.class, MockBean2.class); provider.addSerializerForClass(MockBean3.class, Mock
@Test public void createContextual() throws Exception { MockBean bean = new MockBean(); MockSerializerProvider provider = new MockSerializerProvider(); provider.addSerializerForClass(MockBean.class, MockBean.class); provider.addSerializerForClass(MockBean2.class, MockBean2.class); provider.addSerializerForClass(MockBean3.class, MockBean3.class); provider.addSerializerForClass(MockBean4.class, MockBean4.class); provider.addSerializerForClass(MockBean1.class, MockBean1.class); provider.addSerializerForClass(MockBean2.class, MockBean2.class); provider.addSerializerForClass(MockBean3.class, Mock
@Test public void testCreateContextual() throws IOException, JsonMappingException { SimpleSerializerProvider provider = new SimpleSerializerProvider(); provider.addSerializer(SimpleType.class, new SimpleSerializer(SimpleType.class)); provider.addSerializer(SimpleType.class, new SimpleSerializer(String.class)); provider.addSerializer(SimpleType.class, new SimpleSerializer(Integer.class)); provider.addSerializer(SimpleType.class, new SimpleSerializer(Long.class)); provider.addSerializer(SimpleType.class, new SimpleSerializer(Float.class)); provider.addSerializer(SimpleType.class, new SimpleSerializer(Long.class)); provider.addSerializer(SimpleType.class, new SimpleSerializer
@Test public void testCreateContextual() throws IOException, JsonMappingException { final SimpleSerializerProvider provider = new SimpleSerializerProvider(); final SimpleBean bean = new SimpleBean(); bean.setDate(new Date()); provider.addSerializer(bean); final JsonValueSerializer js = new JsonValueSerializer(String.class.getDeclaredMethod("length"), js); final JsonValueSerializer js2 = js.createContextual(provider, new BeanProperty("date")); js2.serialize(bean, new JsonGeneratorAdapter(), provider); js.close(); final String expected = "{\\"date\\":\\"1970-01-01T00:00:00.000Z\\"}"; Assert.assertEquals(
@Test public void createContextual() throws IOException, JsonMappingException { SimpleSerializerProvider provider = new SimpleSerializerProvider(); BeanProperty property = new BeanProperty("id", Integer.class); JsonValueSerializer js = new JsonValueSerializer(String.class.getDeclaredMethod("length"), js, true); js.setSerializerProvider(provider); js.createContextual(provider, property); js.close(); }
@Test public void testSerializability() throws IOException, JsonGenerationException { MockBean bean = new MockBean(); SimpleSerializerProvider provider = new SimpleSerializerProvider(); provider.setSerializerClass(MockBean.class); provider.setResolved(true); JsonValueSerializer ser = new JsonValueSerializer(MockBean.class.getDeclaredMethod("setObjectValue", Object.class), null, null); ser.serialize(bean, provider); Assert.assertNotNull(provider.getObjectValue("objectValue")); provider.setResolved(false); ser.serialize(bean, provider); Assert.assertNotNull(provider.getObjectValue("objectValue")); provider.setResolved(true); ser.serialize(bean
@Test public void serializabilityTest() throws IOException, JsonGenerationException { final SimpleSerializerProvider provider = new SimpleSerializerProvider(); final SimpleBean bean = new SimpleBean(); bean.setDate(new Date()); final JsonValueSerializer js = new JsonValueSerializer(bean.getClass().getDeclaredMethod("setDate", Date.class), provider); final JsonGenerator jgen = mock(JsonGenerator.class); final SerializerProvider sp = new SimpleSerializerProvider(bean.getClass().getDeclaredMethod("setDate", Date.class)); js.setSerializerProvider(sp); js.serialize(bean, jgen, sp); verify(js).setDate(new Date()); js.serialize(bean, j
@Test public void testSerializability() throws IOException, JsonGenerationException { final SimpleSerializerProvider provider = new SimpleSerializerProvider(); final SimpleBean bean = new SimpleBean(); bean.setDate(new Date()); final JsonValueSerializer js = new JsonValueSerializer(bean.getClass().getDeclaredMethod("setDate", Date.class), provider); js.serialize(bean, jgen, provider); js.flush(); final String expected = "{\\"date\\":\\"1970-01-01T00:00:00.000Z\\",\\"dateTime\\":\\"1970-01-01T00:00:00.000Z\\"}"; Assert.assertEquals(expected, jgen
@Test public void testNullValue() throws IOException, JsonGenerationException { final SimpleSerializerProvider provider = new SimpleSerializerProvider(); final SimpleBean bean = new SimpleBean(); bean.setDate(new Date()); final JsonValueSerializer js = new JsonValueSerializer(bean.getClass().getDeclaredMethod("setDate", Date.class), provider); js.serialize(bean, jgen, provider); js.flush(); final String expected = "{\\"date\\":\\"1970-01-01T00:00:00.000Z\\"}"; Assert.assertEquals(expected, jgen.toString()); }
@Test public void testEnumSerializer() throws IOException, JsonGenerationException { SimpleEnumBean bean = new SimpleEnumBean(); bean.setA("bla"); JsonValueSerializer ser = new JsonValueSerializer(BeanPropertyHelper.getMethod(SimpleEnumBean.class, "a"), new JsonValueSerializer(BeanPropertyHelper.getMethod(SimpleEnumBean.class, "b"), true, null)); ser.serialize(bean, gen, null); gen.flush(); String expected = "{\\"a\\":\\"bla\\",\\"b\\":\\"bla\\"}"; Assert.assertEquals(expected, "{\\"a\\":\\"bla\\",\\"b\\":\\"bla\\"
@Test public void testSerializability() throws IOException, JsonGenerationException { MockBean bean = new MockBean(); SimpleSerializerProvider provider = new SimpleSerializerProvider(); provider.setSerializationInclusion(JsonInclude.Include.NON_NULL); provider.setSerializationInclusion(JsonInclude.Include.NON_NULL); serializer.serialize(bean, jgen, provider); jgen.flush(); String expected = "{\\n" + " \\"a\\": 1,\\n" + " \\"b\\": 2,\\n" + " \\"c\\": 3,\\n" + " \\"d\\": 4,\\n" + " \\"e\\": 5,\\n
@Test public void serializabilityTest() throws IOException, JsonGenerationException { final SimpleSerializerProvider provider = new SimpleSerializerProvider(); final SimpleBean bean = new SimpleBean(); bean.setDate(new Date()); final JsonValueSerializer js = new JsonValueSerializer(bean.getClass().getDeclaredMethod("setDate", Date.class), provider); js.serialize(bean, jgen, provider); js.flush(); final String expected = "{\\"date\\":\\"1970-01-01T00:00:00.000Z\\",\\"dateTime\\":\\"1970-01-01T00:00:00.000Z\\"}"; Assert.assertEquals(expected, jgen
@Test public void testSerializability() throws IOException, JsonGenerationException { MockBean bean = new MockBean(); bean.setDate(new Date()); JsonValueSerializer ser = new JsonValueSerializer(BeanPropertyHelper.getMethod(MockBean.class, "dateValue"), new JsonValueSerializer(BeanPropertyHelper.getMethod(MockBean.class, "dateValue"), true)); ser.serialize(bean, jgen, new MockSerializerProvider()); jgen.flush(); String expected = "{\\"dateValue\\":\\"1970-01-01T00:00:00.000Z\\",\\"dateTime\\":\\"1970-01-01T00:00:00.
@Test public void serializabilityTest() throws IOException, JsonGenerationException { final SimpleSerializerProvider provider = new SimpleSerializerProvider(); final SimpleBean bean = new SimpleBean(); bean.setDate(new Date()); final JsonValueSerializer ser = new JsonValueSerializer(bean.getClass().getDeclaredMethod("setDate", Date.class), provider); ser.serialize(bean, jgen, provider); jgen.flush(); final String expected = "{\\"date\\":\\"2000-01-01T00:00:00.000Z\\",\\"dateTime\\":\\"2000-01-01T00:00:00.000Z\\"}"; Assert.assertEquals(expected, jgen.
@Test public void serializeWithType() throws IOException, JsonProcessingException { final SimpleBean bean = new SimpleBean(); final Method method = SimpleBean.class.getDeclaredMethod("getValue"); final JsonValueSerializer ser1 = new JsonValueSerializer(method, null); final JsonValueSerializer ser2 = new JsonValueSerializer(method, null); ser1.serializeWithType(bean, jgen, new DefaultSerializerProvider(), ser2); ser2.serializeWithType(bean, jgen, new DefaultSerializerProvider(), ser1); ser1.serializeWithType(bean, jgen, new DefaultSerializerProvider(), ser2); ser2.serializeWithType(bean, jgen, new DefaultSerializerProvider(), ser
@Test public void serializeWithType() throws IOException { final SimpleTypeBean bean = new SimpleTypeBean(); bean.setIntegerValue(1); final SimpleTypeBean bean2 = new SimpleTypeBean(); bean2.setIntegerValue(2); final SimpleTypeBean bean3 = new SimpleTypeBean(); bean3.setIntegerValue(3); final SimpleTypeBean bean4 = new SimpleTypeBean(); bean4.setIntegerValue(4); final SimpleTypeBean bean5 = new SimpleTypeBean(); bean5.setIntegerValue(5); bean4.setIntegerValue(6); final SimpleTypeBean bean6 = new SimpleTypeBean(); bean6.setIntegerValue(7); bean6.set
@Test public void serializeWithType() throws IOException { final SimpleBean bean = new SimpleBean(); final Method method = SimpleBean.class.getDeclaredMethod("getValue"); final JsonValueSerializer ser = new JsonValueSerializer(method, null); ser.serializeWithType(bean, jgen, new DefaultSerializerProvider(), null); Assert.assertEquals("\\"getValue\\"", jgen.toString()); ser = new JsonValueSerializer(method, null); ser.serializeWithType(bean, jgen, new DefaultSerializerProvider(), null); Assert.assertEquals("\\"getValue\\"", jgen.toString()); ser = new JsonValueSerializer(method, null); ser.serializeWithType(bean, jgen, new
@Test public void serializeWithType() throws IOException { final SimpleTypeBean bean = new SimpleTypeBean(); bean.setIntegerValue(1); final SimpleTypeBean bean2 = new SimpleTypeBean(); bean2.setIntegerValue(2); final SimpleTypeBean bean3 = new SimpleTypeBean(); bean3.setIntegerValue(3); final SimpleTypeBean bean4 = new SimpleTypeBean(); bean4.setIntegerValue(4); final SimpleTypeBean bean5 = new SimpleTypeBean(); bean5.setIntegerValue(5); final SimpleTypeBean bean6 = new SimpleTypeBean(); bean6.setIntegerValue(6); final SimpleTypeBean bean7 = new SimpleTypeBean(); bean
@Test public void serializeWithType() throws IOException { MockBean bean = new MockBean(); BeanProperty property = new BeanProperty("one", Integer.class); JsonValueSerializer ser = new JsonValueSerializer(bean.getClass().getDeclaredMethod("one"), null); ser.serializeWithType(bean, jgen, new DefaultSerializerProvider(), ser); Assert.assertEquals("\\"one\\":1", jgen.toString()); ser = new JsonValueSerializer(bean.getClass().getDeclaredMethod("two"), null); ser.serializeWithType(bean, jgen, new DefaultSerializerProvider(), ser); Assert.assertEquals("\\"two\\":2", jgen.toString()); }
@Test public void isNaturalTypeWithStdHandling() throws Exception { JsonSerializer<Object> ser = new JsonSerializer<Object>() { @Override public void serialize(Object bean, JsonGenerator jgen, SerializerProvider provider, JsonSerializer<?> ser) throws IOException, JsonMappingException { } @Override public void serializeWithType(Object bean, JsonGenerator jgen, SerializerProvider provider, JsonSerializer<?> ser) throws IOException, JsonGenerationException, JsonProcessingException { } }; Assert.assertTrue(new TestBean().isNaturalTypeWithStdHandling(Integer.TYPE, ser)); Assert.assertTrue(new TestBean().isNaturalTypeWithStdHandling(Boolean.TYPE, ser)); Assert
@Test public void testBooleanSerializer() throws Exception { JsonSerializer<Boolean> ser = new JsonSerializer<Boolean>() { @Override public void serializeWithType(Object bean, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonMappingException { } @Override public void serializeWithType(Object bean, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonProcessingException { } }; assertTrue(ser.getSerializer(Boolean.TYPE) instanceof BooleanSerializer); assertTrue(ser.getSerializer(Boolean.TYPE) instanceof BooleanSerializer); assertTrue(ser.getSerializer(Byte.TYPE) instanceof ByteSerializer); assertTrue(ser.getSerializer(Byte.TYPE) instanceof ByteSerializer); assert
@Test public void primitiveTypes() throws Exception { JsonSerializer<Integer> ser = new JsonSerializer<Integer>() { @Override public boolean isNaturalTypeWithStdHandling(Class<?> rawType, JsonSerializer<?> ser) { return false; } @Override public boolean isDefaultSerializer(JsonValueSerializer src) { return true; } @Override public JsonValueSerializer withResolved(BeanProperty property, JsonValueSerializer src2, JsonGenerator jgen, SerializerProvider provider) throws JsonMappingException, JsonProcessingException { return true; } @Override public JsonNode getSchema(SerializerProvider provider, Class<?> rawType) throws JsonMappingException, IOException { return null; } @Override public JsonSerializer<?> createContextual(Serializer
@Test public void defaultSerializer() throws Exception { JsonSerializer<Object> ser = new JsonSerializer<Object>() { @Override public JsonNode serialize(Object bean, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonMappingException { return null; } @Override public boolean isNaturalTypeWithStdHandling(Class<?> rawType, JsonSerializer<?> ser) throws IOException, JsonProcessingException { return false; } }; assertTrue(ser.isDefaultSerializer(Object.class)); assertFalse(ser.isDefaultSerializer(Boolean.class)); assertFalse(ser.isDefaultSerializer(Double.class)); assertFalse(ser.isDefaultSerializer(String.class)); assertFalse(ser.isDefault
@Test public void testInternalName() { POJOPropertyBuilder builder = new POJOPropertyBuilder("hoge", new AnnotationIntrospector.Default(), false); assertEquals("hoge", builder.getInternalName()); builder.withInternalName("hoge"); assertEquals("hoge", builder.getInternalName()); builder.withInternalName("hoge"); assertEquals("hoge", builder.getInternalName()); builder.withInternalName("hoge"); assertEquals("hoge", builder.getInternalName()); builder.withInternalName("hoge"); assertEquals("hoge", builder.getInternalName()); }
@Test public void testInternalName() { POJOPropertyBuilder builder = new POJOPropertyBuilder("prop1", new AnnotationIntrospector(), true); builder.withName("prop1"); assertEquals("prop1", builder.getInternalName()); builder.withName("prop2"); assertEquals("prop2", builder.getInternalName()); builder.withName("prop3"); assertEquals("prop3", builder.getInternalName()); builder.withName("prop4"); assertEquals("prop4", builder.getInternalName()); builder.withName("prop5"); assertEquals("prop5", builder.getInternalName()); builder.withName("prop6"); assertEquals("prop6", builder.
@Test public void testGetGetter() throws Exception { TestPOJOPropertyBuilder builder = new TestPOJOPropertyBuilder("test", new AnnotationIntrospectorImpl(), false); builder.withName("test"); builder.withGetter("getFoo"); builder.withGetter("getBar"); builder.withGetter("getBaz"); assertEquals("getFoo", builder.getGetter().getFullName()); assertEquals("getBar", builder.getGetter().getMethodName()); assertEquals("getBaz", builder.getGetter().getParameterTypes()[0]); assertEquals("getBar", builder.getGetter().getParameterTypes()[1]); assertEquals("getBaz", builder.getGetter().get
@Test public void testGetGetter() throws Exception { POJOPropertyBuilder builder = new POJOPropertyBuilder("foo", AnnotationIntrospector.default(), false); builder.withName("foo"); builder.withGetter("getBar"); assertEquals("getBar", builder.getGetter().getFullName()); builder.withGetter("getBaz"); assertEquals("getBaz", builder.getGetter().getFullName()); builder.withGetter("getBaz2"); assertEquals("getBaz2", builder.getGetter().getFullName()); builder.withGetter("getBaz3"); assertEquals("getBaz3", builder.getGetter().getFullName()); builder.withGetter("getBaz4
@Test public void testGetGetter() throws Exception { POJOPropertyBuilder builder = new POJOPropertyBuilder("foo", AnnotationIntrospector.default(), false); builder.withName("foo"); builder.withGetter("getBar"); assertEquals("getBar", builder.getGetter().getFullName()); builder.withGetter("getBaz"); assertEquals("getBaz", builder.getGetter().getFullName()); builder.withGetter("getFoo"); assertEquals("getFoo", builder.getGetter().getFullName()); builder.withGetter("getBar2"); assertEquals("getFoo2", builder.getGetter().getFullName()); builder.withGetter("getFoo3"); assertEquals
@Test public void testGetGetter() throws Exception { POJOPropertyBuilder builder = new POJOPropertyBuilder("foo", AnnotationIntrospector.default(), false); builder.withName("bar"); builder.withGetter("getFoo"); builder.withSetter("getBar"); builder.withGetter("getBaz"); assertEquals("getFoo", builder.getGetter().getFullName()); assertEquals("getBar", builder.getGetter().getFullName()); assertEquals("getBaz", builder.getGetter().getFullName()); assertEquals("getBaz", builder.getGetter().getFullName()); builder.withName("baz"); assertEquals("baz", builder.getGetter().getFullName());
@Test public void testGetGetter() throws Exception { POJOPropertyBuilder b = new POJOPropertyBuilder("foo", AnnotationIntrospector.default(), false); b.withName("foo"); b.withGetter(b.getGetter()); b.withGetter(b.getGetter()); b.withGetter(b.getGetter()); b.withGetter(b.getGetter()); b.withGetter(b.getGetter()); b.withGetter(b.getGetter()); b.withGetter(b.getGetter()); b.withGetter(b.getGetter()); b.withGetter(b.getGetter()); b.withGetter(b.getGetter()); b.withGetter(b.
@Test public void testConstructorParameter() throws Exception { POJOPropertyBuilder builder = new POJOPropertyBuilder("foo", AnnotationIntrospector.Default(), true); builder.withName("bar"); builder.withField(getClass().getDeclaredField("foo"), "foo", true, true); builder.withField(getClass().getDeclaredField("bar"), "bar", true, true); builder.withField(getClass().getDeclaredField("baz"), "baz", true, true); builder.withField(getClass().getDeclaredField("baz"), "baz", true, true); builder.withField(getClass().getDeclaredField("baz"
@Test public void testConstructorParameter() throws Exception { TestPOJOPropertyBuilder builder = new TestPOJOPropertyBuilder("foo", AnnotationIntrospector.DEFAULT, false); builder.withConstructorParameter(new AnnotatedParameter("bar", List.class)); builder.withConstructorParameter(new AnnotatedParameter("baz", List.class)); builder.withConstructorParameter(new AnnotatedParameter("baz", List.class)); builder.withConstructorParameter(new AnnotatedParameter("baz", List.class)); builder.withConstructorParameter(new AnnotatedParameter("baz", List.class)); builder.withConstructorParameter(new AnnotatedParameter("baz", List.class)); builder.withConstructorParameter(new AnnotatedParameter("b
@Test public void testFindRenamed() throws Exception { TestPOJOPropertyBuilder builder = new TestPOJOPropertyBuilder("foo", AnnotationIntrospector.getDefault(), false); builder.withName("bar"); List<AnnotatedMember> members = new ArrayList<AnnotatedMember>(); members.add(new AnnotatedMember("baz")); List<AnnotatedMember> renamed = new ArrayList<AnnotatedMember>(); renamed.add(new AnnotatedMember("baz")); Linked<AnnotatedMember> nodes = new Linked<AnnotatedMember>(); nodes.add(builder.withName("foo")); nodes.add(builder.withName("bar")); nodes.add(builder.withName("baz"));
@Test public void testDoubleNode() { DoubleNode node = new DoubleNode(1.0); assertEquals(1.0, node.doubleValue(), 0.0); assertEquals("1.0", node.asText()); node = new DoubleNode(2.0); assertEquals(2.0, node.doubleValue(), 0.0); assertEquals("2.0", node.asText()); node = new DoubleNode(3.0); assertEquals(3.0, node.doubleValue(), 0.0); assertEquals("3.0", node.asText()); node = new DoubleNode(4.0); assertEquals(4.0, node.doubleValue(), 0
@Test public void testValueOf() { DoubleNode node = DoubleNode.valueOf(0.0); assertEquals("0.0", node.toString()); node = DoubleNode.valueOf(1.0); assertEquals("1.0", node.toString()); node = DoubleNode.valueOf(2.0); assertEquals("2.0", node.toString()); node = DoubleNode.valueOf(3.0); assertEquals("3.0", node.toString()); node = DoubleNode.valueOf(4.0); assertEquals("4.0", node.toString()); node = DoubleNode.valueOf(5.0); assertEquals("5.0", node.toString
@Test public void testAsToken() { Assert.assertEquals(JsonToken.VALUE_NUMBER_FLOAT, new DoubleNode(0.0).asToken()); Assert.assertEquals(JsonToken.VALUE_NUMBER_FLOAT, new DoubleNode(1.0).asToken()); Assert.assertEquals(JsonToken.VALUE_NUMBER_FLOAT, new DoubleNode(2.0).asToken()); Assert.assertEquals(JsonToken.VALUE_NUMBER_FLOAT, new DoubleNode(3.0).asToken()); Assert.assertEquals(JsonToken.VALUE_NUMBER_FLOAT, new DoubleNode(4.0).asToken()); Assert.assertEquals(JsonToken.VALUE_NUMBER_FLOAT,
@Test public void testPropertyBasedCreator() { SettableBeanProperty[] props = new SettableBeanProperty[1]; props[0] = new PropertyBasedCreator() { @Override public Object build(DeserializationContext ctxt, DeserializationContext ctxt2, ObjectIdReader oir) throws JsonMappingException, IOException { return null; } }; Object[] defaultValues = new Object[1]; defaultValues[0] = new Object(); PropertyBasedCreator creator = new PropertyBasedCreator() { @Override public Object build(DeserializationContext ctxt, DeserializationContext ctxt1, ObjectIdReader oir) throws JsonMappingException, IOException { return null; } }; PropertyBasedCreator creator2 = new PropertyBasedCreator() {
@Test public void testPropertyBasedCreator() { SettableBeanProperty[] props = new SettableBeanProperty[1]; props[0] = new PropertyBasedCreator() { @Override public Object build(DeserializationContext ctxt, DeserializationContext ctxt2, ObjectIdReader oir) throws JsonMappingException, IOException { return null; } }; Object[] defaultValues = new Object[1]; defaultValues[0] = new Object(); PropertyBasedCreator creator = new PropertyBasedCreator() { @Override public Object build(DeserializationContext ctxt, DeserializationContext ctxt1, ObjectIdReader oir) throws JsonMappingException, IOException { return null; } }; PropertyBasedCreator creator2 = new PropertyBasedCreator() {
@Test public void testPropertyBasedCreator() { Map<String, SettableBeanProperty> props = new HashMap<String, SettableBeanProperty>(); props.put("firstName", new SettableBeanProperty("firstName", "firstName")); props.put("lastName", new SettableBeanProperty("lastName", "lastName")); SettableBeanProperty first = new SettableBeanProperty("firstName", "firstName"); SettableBeanProperty second = new SettableBeanProperty("secondName", "secondName"); SettableBeanProperty third = new SettableBeanProperty("thirdName", "thirdName"); props.put("fourth", first); props.put("f
@Test public void testPropertyBasedCreator() { SettableBeanProperty[] props = new SettableBeanProperty[1]; props[0] = new PropertyBasedCreator() { @Override public Object build(DeserializationContext ctxt, DeserializationContext ctxt2, ObjectIdReader oir) throws JsonMappingException, IOException { return null; } }; Object[] defaultValues = new Object[1]; defaultValues[0] = 1; PropertyBasedCreator creator = new PropertyBasedCreator() { @Override public Object build(DeserializationContext ctxt, DeserializationContext ctxt1, ObjectIdReader oir) throws JsonMappingException, IOException { return null; } }; PropertyBasedCreator creator2 = new PropertyBasedCreator() { @
@Test public void testPropertyBasedCreator() { SettableBeanProperty[] props = new SettableBeanProperty[1]; props[0] = new PropertyBasedCreator() { @Override public Object build(DeserializationContext ctxt, DeserializationContext ctxt2, ObjectIdReader oir) throws JsonMappingException, IOException { return null; } }; Object[] defaultValues = new Object[1]; defaultValues[0] = 1; PropertyBasedCreator creator = new PropertyBasedCreator() { @Override public String getName() { return "test1"; } @Override public Object build(DeserializationContext ctxt, DeserializationContext ctxt2, ObjectIdReader oir) throws JsonMappingException, IOException { return null; } };
@Test public void testPropertyBasedCreator() { SettableBeanProperty[] props = new SettableBeanProperty[1]; props[0] = new PropertyBasedCreator() { @Override public Object build(DeserializationContext ctxt, DeserializationContext ctxt2, ObjectIdReader oir) throws JsonMappingException, IOException { return null; } }; Object[] defaultValues = new Object[1]; defaultValues[0] = new Object(); PropertyBasedCreator creator = new PropertyBasedCreator() { @Override public Map<String, SettableBeanProperty> properties() { Map<String, SettableBeanProperty> propertiesWithInjectables = new HashMap<String, SettableBeanProperty>(); propertiesWithInjectables.put("b
@Test public void testPropertyBasedCreator() { SettableBeanProperty[] props = new SettableBeanProperty[1]; props[0] = new PropertyBasedCreator() { @Override public Object build(DeserializationContext jp, DeserializationContext ctxt, ObjectIdReader oir) throws JsonMappingException, IOException { return null; } }; Object[] defaultValues = new Object[1]; defaultValues[0] = 1; PropertyBasedCreator creator = new PropertyBasedCreator() { @Override public Object build(DeserializationContext jp, DeserializationContext ctxt, ObjectIdReader oir) throws JsonMappingException, IOException { return null; } }; PropertyBasedCreator copy = new PropertyBasedCreator() { @Override public void
@Test public void testPropertyBasedCreator() { SettableBeanProperty[] props = new SettableBeanProperty[1]; props[0] = new PropertyBasedCreator() { @Override public String getName() { return "test1"; } @Override public Object build(DeserializationContext ctxt, DeserializationContext ctxt, ObjectIdReader oir) throws JsonMappingException, IOException { return null; } }; Object[] defaultValues = new Object[1]; defaultValues[0] = 1; PropertyBasedCreator creator = new PropertyBasedCreator() { @Override public String getName() { return "test2"; } @Override public Object build(DeserializationContext ctxt, DeserializationContext ctxt, ObjectIdReader oir) throws Json
@Test public void testPropertyBasedCreator() { SettableBeanProperty[] props = new SettableBeanProperty[1]; props[0] = new PropertyBasedCreator() { @Override public String getName() { return "a"; } @Override public Object build(DeserializationContext ctxt, DeserializationContext ctxt, ObjectIdReader oir) throws JsonMappingException, IOException { return "b"; } }; Object[] defaultValues = new Object[1]; defaultValues[0] = 1; PropertyBasedCreator creator = new PropertyBasedCreator() { @Override public String getName() { return "c"; } @Override public Object build(DeserializationContext ctxt, DeserializationContext ctxt, ObjectIdReader oir) throws JsonMapping
@Test public void testPropertyBasedCreator() { SettableBeanProperty[] props = new SettableBeanProperty[1]; props[0] = new PropertyBasedCreator() { @Override public Object build(DeserializationContext ctxt, DeserializationContext ctxt2, ObjectIdReader oir) throws JsonMappingException, IOException { return null; } }; Object[] defaultValues = new Object[1]; defaultValues[0] = new Object(); PropertyBasedCreator creator = new PropertyBasedCreator() { @Override public Object build(DeserializationContext ctxt, DeserializationContext ctxt1, ObjectIdReader oir) throws JsonMappingException, IOException { return null; } }; PropertyBasedCreator creator2 = new PropertyBasedCreator() {
@Test public void testPropertyBasedCreator() { SettableBeanProperty[] props = new SettableBeanProperty[1]; props[0] = new PropertyBasedCreator() { @Override public Object build(DeserializationContext ctxt, DeserializationContext ctxt2, ObjectIdReader oir) throws JsonMappingException, IOException { return null; } }; Object[] defaultValues = new Object[1]; defaultValues[0] = new Object(); PropertyBasedCreator creator = new PropertyBasedCreator() { @Override public Object build(DeserializationContext ctxt, DeserializationContext ctxt1, ObjectIdReader oir) throws JsonMappingException, IOException { return null; } }; PropertyBasedCreator creator2 = new PropertyBasedCreator() {
@Test public void testPropertyBasedCreator() { SettableBeanProperty[] props = new SettableBeanProperty[]{properties1, properties2, properties3}; Object[] defaultValues = new Object[]{1, 2, 3}; PropertyBasedCreator creator = new PropertyBasedCreator(_valueInstantiator, props, defaultValues); assertEquals(2, creator.properties().length); assertEquals(1, creator.properties()[0].getPropertyName()); assertEquals(2, creator.properties()[0].getPropertyType()); assertEquals(3, creator.properties()[1].getPropertyName()); assertEquals(1, creator.properties()[1].getPropertyType()); assertEquals(2, creator.properties()[1].
@Test public void testPropertyBasedCreator() { SettableBeanProperty[] props = new SettableBeanProperty[1]; props[0] = new PropertyBasedCreator() { @Override public Object build(DeserializationContext ctxt, DeserializationContext ctxt2, ObjectIdReader oir) throws JsonMappingException, IOException { return null; } }; Object[] defaultValues = new Object[1]; defaultValues[0] = 1; PropertyBasedCreator creator = new PropertyBasedCreator() { @Override public Map<String, SettableBeanProperty> propertiesWithInjectables() { Map<String, SettableBeanProperty> propertiesWithInjectables = new HashMap<String, SettableBeanProperty>(); propertiesWithInjectables.put
@Test public void testConstruct() throws JsonMappingException, IOException { SettableBeanProperty[] props = new SettableBeanProperty[1]; props[0] = new PropertyBasedBeanProperty(); props[0].setName("a"); props[1] = new PropertyBasedBeanProperty(); props[1].setName("b"); props[2] = new PropertyBasedBeanProperty(); props[2].setName("c"); props[3] = new PropertyBasedBeanProperty(); props[3].setName("d"); props[4] = new PropertyBasedBeanProperty(); props[4].setName("e"); props[5] = new PropertyBasedBeanProperty(); props[5].setName("f
@Test public void testConstruct() throws Exception { SettableBeanProperty[] props = new SettableBeanProperty[1]; props[0] = new PropertyBasedCreator(); props[0].setName("a"); props[1] = new PropertyBasedCreator(); props[1].setName("b"); props[2] = new PropertyBasedCreator(); props[2].setName("c"); props[3] = new PropertyBasedCreator(); props[3].setName("d"); props[4] = new PropertyBasedCreator(); props[4].setName("e"); props[5] = new PropertyBasedCreator(); props[5].setName("f"); props[6] = new PropertyBasedCreator
@Test public void testConstruct() throws Exception { SettableBeanProperty[] props = new SettableBeanProperty[1]; props[0] = new PropertyBasedCreator(new JsonValueInstantiator(), new JsonValueInstantiator() { @Override public JsonValueInstantiator findContextualValueDeserializer(Class type, SettableBeanProperty prop) throws JsonMappingException { return new JsonValueInstantiator() { @Override public JsonValueInstantiator findContextualValueDeserializer(Class type, SettableBeanProperty prop) throws JsonMappingException { return new JsonValueInstantiator() { @Override public JsonValueInstantiator findContextualValueDeserializer(Class type, SettableBeanProperty prop) throws JsonMappingException { return new Json
@Test public void testConstruct() throws Exception { Map<String, SettableBeanProperty> props = new HashMap<String, SettableBeanProperty>(); props.put("a", SettableBeanPropertyImpl.class.getName()); props.put("b", SettableBeanPropertyImpl.class.getName()); props.put("c", SettableBeanPropertyImpl.class.getName()); props.put("d", SettableBeanPropertyImpl.class.getName()); props.put("e", SettableBeanPropertyImpl.class.getName()); props.put("f", SettableBeanPropertyImpl.class.getName()); props.put("g", SettableBeanPropertyImpl.class.getName()); DeserializationContext
@Test public void testConstruct() throws JsonMappingException, IOException { SettableBeanProperty[] srcProps = new SettableBeanProperty[1]; srcProps[0] = new BeanPropertyImpl(String.class); srcProps[1] = new BeanPropertyImpl(Integer.class); srcProps[2] = new BeanPropertyImpl(Long.class); srcProps[3] = new BeanPropertyImpl(Float.class); srcProps[4] = new BeanPropertyImpl(Double.class); srcProps[5] = new BeanPropertyImpl(Double.class); srcProps[6] = new BeanPropertyImpl(String.class); srcProps[7] = new BeanPropertyImpl(Integer.
@Test public void testConstruct() throws Exception { SettableBeanProperty[] props = new SettableBeanProperty[1]; props[0] = new PropertyBasedCreator(new JsonValueInstantiator(), new JsonValueInstantiator(), props); SettableBeanProperty p1 = new PropertyBasedCreator(new JsonValueInstantiator(), new JsonValueInstantiator(), props); SettableBeanProperty p2 = new PropertyBasedCreator(new JsonValueInstantiator(), new JsonValueInstantiator(), props); SettableBeanProperty p3 = new PropertyBasedCreator(new JsonValueInstantiator(), new JsonValueInstantiator(), props); SettableBeanProperty p4 = new PropertyBasedCreator(new JsonValueInstantiator(), new JsonValue
@Test public void testConstruct() throws JsonMappingException { SettableBeanProperty[] props = new SettableBeanProperty[1]; props[0] = new PropertyBasedCreator(); props[0].setName("a"); props[1] = new PropertyBasedCreator(); props[1].setName("b"); props[2] = new PropertyBasedCreator(); props[2].setName("c"); props[3] = new PropertyBasedCreator(); props[3].setName("d"); props[4] = new PropertyBasedCreator(); props[4].setName("e"); props[5] = new PropertyBasedCreator(); props[5].setName("f"); props[6] = new Property
@Test public void testConstruct() throws Exception { SettableBeanProperty[] srcProps = new SettableBeanProperty[1]; srcProps[0] = new BeanPropertyImpl(Date.class, "date", new Date()); srcProps[1] = new BeanPropertyImpl(Date.class, "date", new Date()); srcProps[2] = new BeanPropertyImpl(Date.class, "date", new Date()); srcProps[3] = new BeanPropertyImpl(Date.class, "date", new Date()); srcProps[4] = new BeanPropertyImpl(Date.class, "date", new Date()); srcProps[5] = new BeanPropertyImpl(Date.class, "date
@Test public void testConstruct() throws Exception { SettableBeanProperty[] props = new SettableBeanProperty[1]; props[0] = new PropertyBasedCreator(); props[0].setName("a"); props[1] = new PropertyBasedCreator(); props[1].setName("b"); props[2] = new PropertyBasedCreator(); props[2].setName("c"); props[3] = new PropertyBasedCreator(); props[3].setName("d"); props[4] = new PropertyBasedCreator(); props[4].setName("e"); props[5] = new PropertyBasedCreator(); props[5].setName("f"); props[6] = new PropertyBasedCreator
@Test public void testConstruct() throws Exception { SettableBeanProperty[] props = new SettableBeanProperty[1]; props[0] = new PropertyBasedCreator(); props[0].setName("a"); props[1] = new PropertyBasedCreator(); props[1].setName("b"); props[2] = new PropertyBasedCreator(); props[2].setName("c"); props[3] = new PropertyBasedCreator(); props[3].setName("d"); props[4] = new PropertyBasedCreator(); props[4].setName("e"); props[5] = new PropertyBasedCreator(); props[5].setName("f"); props[6] = new PropertyBasedCreator
@Test public void testConstruct() throws Exception { SettableBeanProperty[] props = new SettableBeanProperty[1]; props[0] = new PropertyBasedCreator(); props[0].setName("a"); props[0].setValueType(Integer.class); props[1] = new PropertyBasedCreator(); props[1].setName("b"); props[1].setValueType(Long.class); props[1].setValueType(Float.class); PropertyBasedCreator creator = (PropertyBasedCreator) PropertyBasedCreator.construct(new DefaultDeserializationContext(), new DefaultValueInstantiator(), props); Assert.assertEquals(1, creator.properties().length); Assert.assertEquals("a", creator.
@Test public void testConstruct() throws JsonMappingException { SettableBeanProperty[] props = new SettableBeanProperty[1]; props[0] = new BeanPropertyImpl(String.class); props[1] = new BeanPropertyImpl(Integer.class); props[2] = new BeanPropertyImpl(Long.class); props[3] = new BeanPropertyImpl(Float.class); props[4] = new BeanPropertyImpl(Double.class); props[5] = new BeanPropertyImpl(Long.class); props[6] = new BeanPropertyImpl(Float.class); props[7] = new BeanPropertyImpl(Integer.class); props[8] = new BeanPropertyImpl
@Test public void testConstruct() throws JsonMappingException { SettableBeanProperty[] props = new SettableBeanProperty[1]; props[0] = new PropertyBasedCreator(); props[0].setName("a"); props[1] = new PropertyBasedCreator(); props[1].setName("b"); props[2] = new PropertyBasedCreator(); props[2].setName("c"); props[3] = new PropertyBasedCreator(); props[3].setName("d"); props[4] = new PropertyBasedCreator(); props[4].setName("e"); props[5] = new PropertyBasedCreator(); props[5].setName("f"); props[6] = new Property
@Test public void testConstruct() throws Exception { SettableBeanProperty[] props = new SettableBeanProperty[1]; props[0] = new PropertyBasedCreator(new JsonValueInstantiator(), new JsonValueInstantiator(), new Object[0]); props[1] = new PropertyBasedCreator(new JsonValueInstantiator(), new JsonValueInstantiator(), new Object[0]); props[2] = new PropertyBasedCreator(new JsonValueInstantiator(), new JsonValueInstantiator(), new Object[0]); props[3] = new PropertyBasedCreator(new JsonValueInstantiator(), new JsonValueInstantiator(), new Object[0]); props[4] = new PropertyBasedCreator(new JsonValueInstantiator
@Test public void testConstruct() throws Exception { Map<String, SettableBeanProperty> props = new HashMap<String, SettableBeanProperty>(); props.put("a", new BeanPropertyImpl(String.class, "a")); props.put("b", new BeanPropertyImpl(String.class, "b")); props.put("c", new BeanPropertyImpl(String.class, "c")); props.put("d", new BeanPropertyImpl(String.class, "d")); props.put("e", new BeanPropertyImpl(String.class, "e")); props.put("f", new BeanPropertyImpl(String.class, "f")); Settable
@Test public void testConstruct() throws Exception { SettableBeanProperty[] props = new SettableBeanProperty[1]; props[0] = new PropertyBasedCreator(); props[0].setName("a"); props[1] = new PropertyBasedCreator(); props[1].setName("b"); props[2] = new PropertyBasedCreator(); props[2].setName("c"); props[3] = new PropertyBasedCreator(); props[3].setName("d"); props[4] = new PropertyBasedCreator(); props[4].setName("e"); props[5] = new PropertyBasedCreator(); props[5].setName("f"); props[6] = new PropertyBasedCreator
@Test public void testConstruct() throws JsonMappingException, IOException { SettableBeanProperty[] props = new SettableBeanProperty[1]; props[0] = new BeanPropertyImpl(String.class); props[1] = new BeanPropertyImpl(Integer.class); props[2] = new BeanPropertyImpl(Long.class); props[3] = new BeanPropertyImpl(Float.class); props[4] = new BeanPropertyImpl(Double.class); props[5] = new BeanPropertyImpl(Long.class); props[6] = new BeanPropertyImpl(Float.class); props[7] = new BeanPropertyImpl(Integer.class); props[8] = new Bean
@Test public void testProperties() { Collection<SettableBeanProperty> props = creator1.properties(); assertEquals(2, props.size()); SettableBeanProperty p1 = props.iterator().next(); SettableBeanProperty p2 = props.iterator().next(); SettableBeanProperty p3 = props.iterator().next(); SettableBeanProperty p4 = props.iterator().next(); SettableBeanProperty p5 = props.iterator().next(); SettableBeanProperty p6 = props.iterator().next(); SettableBeanProperty p7 = props.iterator().next(); SettableBeanProperty p8 = props.iterator().next(); SettableBeanProperty p9 = props.iterator().next();
@Test public void testProperties() throws IOException { Collection<SettableBeanProperty> properties = creator.properties(); assertEquals(2, properties.size()); SettableBeanProperty p1 = properties.iterator().next(); SettableBeanProperty p2 = properties.iterator().next(); SettableBeanProperty p3 = properties.iterator().next(); SettableBeanProperty p4 = properties.iterator().next(); SettableBeanProperty p5 = properties.iterator().next(); assertEquals("id", p1.getName()); assertEquals("id", p2.getName()); assertEquals("id", p3.getName()); assertEquals("id", p4.getName()); assertEquals("id", p5.getName()); assert
@Test public void testSimple() throws IOException { SettableBeanProperty prop = creator.findCreatorProperty("id"); assertNotNull(prop); assertEquals("id", prop.getName()); assertEquals(2, prop.properties().length); assertEquals(2, prop.properties()[0].properties[0].type); assertEquals(2, prop.properties()[1].properties[0].type); assertEquals(2, prop.properties()[1].properties[0].type); assertEquals(3, prop.properties()[1].properties[1].type); assertEquals(3, prop.properties()[1].properties[1].type); assertEquals(3, prop.properties()[
@Test public void testSimple() throws IOException { SettableBeanProperty property1 = property("id", "1"); SettableBeanProperty property2 = property("id", "2"); SettableBeanProperty property3 = property("id", "3"); SettableBeanProperty property4 = property("id", "4"); SettableBeanProperty property5 = property("id", "5"); SettableBeanProperty property6 = property("id", "6"); SettableBeanProperty property7 = property("id", "7"); SettableBeanProperty property8 = property("id", "8"); SettableBeanProperty property9 = property("id", "9"); SettableBeanProperty property10 = property("id", "
@Test public void testStartBuilding() throws Exception { Map<String, SettableBeanProperty> propertiesWithInjectables = new HashMap<String, SettableBeanProperty>(); propertiesWithInjectables.put("id", new HashSet<Long>(Arrays.asList(1L, 2L, 3L))); propertiesWithInjectables.put("name", new HashSet<Long>(Arrays.asList(4L, 5L, 6L))); propertiesWithInjectables.put("age", new HashSet<Long>(Arrays.asList(7L, 8L))); propertiesWithInjectables.put("email", new HashSet<Long>(Arrays.asList(9L, 10L
@Test public void testBuilding() throws Exception { Map<String, SettableBeanProperty> properties = new HashMap<String, SettableBeanProperty>(); properties.put("firstName", new SettableBeanProperty("firstName", PropertyType.STRING)); properties.put("lastName", new SettableBeanProperty("lastName", PropertyType.STRING)); properties.put("age", new SettableBeanProperty("age", PropertyType.INT)); properties.put("age2", new SettableBeanProperty("age2", PropertyType.LONG)); properties.put("age3", new SettableBeanProperty("age3", PropertyType.DOUBLE)); properties.put("age4", new SettableBeanProperty("age4", PropertyType.
@Test public void testStartBuilding() throws Exception { Map<String, SettableBeanProperty> properties = new HashMap<String, SettableBeanProperty>(); properties.put("id", new HashSet<Long>(Arrays.asList(1L, 2L, 3L))); properties.put("firstName", new HashSet<Long>(Arrays.asList(4L, 5L))); properties.put("lastName", new HashSet<Long>(Arrays.asList(6L, 7L))); properties.put("age", new HashSet<Long>(Arrays.asList(7L, 8L))); properties.put("married", new HashSet<Long>(Arrays
@Test public void testStartBuilding() throws Exception { Map<String, SettableBeanProperty> properties = new HashMap<String, SettableBeanProperty>(); properties.put("firstName", new SettableBeanProperty("firstName", "firstName")); properties.put("lastName", new SettableBeanProperty("lastName", "lastName")); properties.put("age", new SettableBeanProperty("age", "age")); properties.put("age2", new SettableBeanProperty("age2", "age2")); SettableBeanProperty age3 = new SettableBeanProperty("age3", "age3"); properties.put("age4", new SettableBeanProperty("age
@Test public void testBeanBuilding() throws IOException { SettableBeanProperty prop1 = new SettableBeanProperty("id", PropertyType.INT); SettableBeanProperty prop2 = new SettableBeanProperty("name", PropertyType.STRING); SettableBeanProperty prop3 = new SettableBeanProperty("age", PropertyType.LONG); SettableBeanProperty prop4 = new SettableBeanProperty("address", PropertyType.STRING); SettableBeanProperty prop5 = new SettableBeanProperty("city", PropertyType.STRING); SettableBeanProperty[] props = new SettableBeanProperty[]{prop1, prop2, prop3, prop4, prop5}; MockDeserializationContext ctxt = new MockDeserializationContext(); ctxt
@Test public void testSimpleBean() throws IOException { SettableBeanProperty idProp = new SettableBeanProperty("id", PropertyType.INT); SettableBeanProperty[] props = new SettableBeanProperty[]{idProp}; SimpleDeserializationContext ctxt = new SimpleDeserializationContext(new SimpleDeserializationContext(new SimpleDeserializationContext(new SimpleDeserializationContext(new SimpleDeserializationContext(new SimpleDeserializationContext(new SimpleDeserializationContext(new SimpleDeserializationContext(new SimpleDeserializationContext(new SimpleDeserializationContext(new SimpleDeserializationContext(new SimpleDeserializationContext(new SimpleDeserializationContext(new SimpleDeserializationContext(new SimpleDeserializationContext(new SimpleDeserializationContext
@Test public void testBeanBuilding() throws IOException { SettableBeanProperty prop1 = new SettableBeanProperty("id", PropertyType.INT); SettableBeanProperty prop2 = new SettableBeanProperty("id2", PropertyType.STRING); SettableBeanProperty prop3 = new SettableBeanProperty("id3", PropertyType.STRING); SettableBeanProperty prop4 = new SettableBeanProperty("id4", PropertyType.STRING); SettableBeanProperty prop5 = new SettableBeanProperty("id5", PropertyType.STRING); SettableBeanProperty prop6 = new SettableBeanProperty("id6", PropertyType.STRING); SettableBeanProperty prop7 = new SettableBeanProperty("id7", PropertyType.
@Test public void testSimpleBean() throws IOException { SettableBeanProperty prop1 = new SettableBeanProperty("id", PropertyType.INT); SettableBeanProperty prop2 = new SettableBeanProperty("name", PropertyType.STRING); SettableBeanProperty prop3 = new SettableBeanProperty("age", PropertyType.LONG); SettableBeanProperty prop4 = new SettableBeanProperty("address", PropertyType.STRING); SettableBeanProperty[] props = new SettableBeanProperty[]{prop1, prop2, prop3, prop4}; SettableBeanInstantiator instantiator = new DefaultInstantiator(); SimpleDeserializationContext ctxt = createDeserializationContext(instantiator); PropertyValueBuffer buffer = new SimplePropertyValue
@Test public void testBeanBuilding() throws IOException { SettableBeanProperty prop1 = new SettableBeanProperty("id", PropertyType.INT); SettableBeanProperty prop2 = new SettableBeanProperty("firstName", PropertyType.STRING); SettableBeanProperty prop3 = new SettableBeanProperty("lastName", PropertyType.STRING); SettableBeanProperty prop4 = new SettableBeanProperty("firstName", PropertyType.STRING); SettableBeanProperty prop5 = new SettableBeanProperty("lastName", PropertyType.STRING); SettableBeanProperty prop6 = new SettableBeanProperty("firstName", PropertyType.STRING); SettableBeanProperty prop7 = new SettableBeanProperty("lastName", PropertyType.
@Test public void testIsArray() { assertTrue(JsonNodeFactory.instance.isArray()); assertTrue(JsonNodeFactory.instance.isArray("foo")); assertTrue(JsonNodeFactory.instance.isArray("foo\\n")); assertTrue(JsonNodeFactory.instance.isArray("foo\\n\\n")); assertTrue(JsonNodeFactory.instance.isArray("foo\\n\\n")); assertTrue(JsonNodeFactory.instance.isArray("foo\\n\\n")); assertTrue(JsonNodeFactory.instance.isArray("foo\\n\\n")); assertTrue(JsonNodeFactory.instance.isArray("foo\\n\\n"));
@Test public void testIsArray() { JsonNode node = JsonNodeFactory.instance.objectNode(); node.put("a", true); node.put("b", true); node.put("c", true); node.put("d", true); node.put("e", true); node.put("f", true); node.put("g", true); node.put("h", true); node.put("i", true); node.put("j", true); node.put("k", true); node.put("l", true); node.put("o", true); assertTrue(node.isArray()); assertTrue(node.getNodeType() == JsonNodeType.ARRAY); assertTrue
@Test public void testIsObject() { JsonNode node = JsonNodeFactory.instance.objectNode(); node.setNodeType(JsonNodeType.STRING); assertTrue(node.isObject()); node.setNodeType(JsonNodeType.NUMBER); assertTrue(node.isObject()); node.setNodeType(JsonNodeType.OBJECT); assertFalse(node.isObject()); }
@Test public void testGetNodeType() { JsonNode node = JsonNodeFactory.instance.objectNode(); node.setNodeType(JsonNodeType.STRING); assertEquals(JsonNodeType.STRING, node.getNodeType()); node.setNodeType(JsonNodeType.NUMBER); assertEquals(JsonNodeType.NUMBER, node.getNodeType()); node.setNodeType(JsonNodeType.BOOLEAN); assertEquals(JsonNodeType.BOOLEAN, node.getNodeType()); node.setNodeType(JsonNodeType.STRING); assertEquals(JsonNodeType.STRING, node.getNodeType()); node.setNodeType(JsonNodeType.BOOLEAN); assertEquals(JsonNodeType.BOOLEAN, node.getNodeType()); node.setNodeType(JsonNodeType.STRING); assertEquals(
@Test public void testIsFloatingPointNumber() { Assert.assertFalse(new MyJsonNode().isFloatingPointNumber()); }
@Test public void testIsTextual() { Set<JsonNode> lines = new HashSet<JsonNode>(); lines.add(JsonNodeFactory.instance.textNode("foo")); lines.add(JsonNodeFactory.instance.textNode("bar")); lines.add(JsonNodeFactory.instance.textNode("baz")); lines.add(JsonNodeFactory.instance.textNode("qux")); lines.add(JsonNodeFactory.instance.textNode("")); lines.add(JsonNodeFactory.instance.textNode("\\n")); lines.add(JsonNodeFactory.instance.textNode("\\r")); lines.add(JsonNodeFactory.instance
@Test public void testIsTextual() { JsonNode node = JsonNodeFactory.instance.objectNode(); node.setNodeType(JsonNodeType.STRING); assertTrue(node.isTextual()); node.setNodeType(JsonNodeType.STRING); assertFalse(node.isTextual()); node.setNodeType(JsonNodeType.STRING); assertFalse(node.isTextual()); node.setNodeType(JsonNodeType.STRING); assertTrue(node.isTextual()); node.setNodeType(JsonNodeType.STRING); assertTrue(node.isTextual()); node.setNodeType(JsonNodeType.STRING); assertTrue(node.isTextual()); node.setNodeType(JsonNodeType.STRING); assertTrue(
@Test public void testHas() { JsonNode node = JsonNodeFactory.instance.objectNode(); node.put("field1", JsonNodeFactory.instance.numberNode(1)); node.put("field2", JsonNodeFactory.instance.numberNode(2)); node.put("field3", JsonNodeFactory.instance.numberNode(3)); node.put("field4", JsonNodeFactory.instance.numberNode(4)); node.put("field5", JsonNodeFactory.instance.numberNode(5)); node.put("field6", JsonNodeFactory.instance.numberNode(6)); node.put("field7", JsonNodeFactory.instance.numberNode(7)); node.put("field8", JsonNodeFactory.
@Test public void testHas() { JsonNode node = JsonNodeFactory.instance.objectNode(); node.put("a", JsonNodeFactory.instance.textNode("foo")); node.put("b", JsonNodeFactory.instance.textNode("bar")); node.put("c", JsonNodeFactory.instance.textNode("baz")); Assert.assertTrue(node.has("a")); Assert.assertTrue(node.has("b")); Assert.assertTrue(node.has("c")); Assert.assertTrue(node.has("d")); Assert.assertTrue(node.has("e")); Assert.assertTrue(node.has("f")); Assert.assertTrue(
@Test public void testIterator() throws IOException { JsonNode node = JsonNodeFactory.instance.objectNode(); Iterator<JsonNode> it = node.iterator(); assertTrue(it.hasNext()); assertEquals(node, it.next()); assertTrue(it.hasNext()); assertEquals(node, it.next()); assertTrue(it.hasNext()); assertEquals(node, it.next()); assertTrue(it.hasNext()); assertEquals(node, it.next()); assertTrue(it.hasNext()); assertEquals(node, it.next()); assertTrue(it.hasNext()); assertEquals(node, it.next()); assertTrue(it.hasNext()); assertEquals(node, it
@Test public void testIterator() throws IOException { JsonNode node = JsonNodeFactory.instance.objectNode(); node.put("a", JsonNodeFactory.instance.textNode("a")); node.put("b", JsonNodeFactory.instance.textNode("b")); node.put("c", JsonNodeFactory.instance.textNode("c")); Iterator<JsonNode> it = node.iterator(); assertTrue(it.hasNext()); assertEquals("a", it.next().get("a").asText()); assertTrue(it.hasNext()); assertEquals("b", it.next().get("b").asText()); assertTrue(it.hasNext()); assertEquals("c", it.next().
@Test public void testFindValues() { JsonNode node = JsonNodeFactory.instance.objectNode(); node.put("x", JsonNodeFactory.instance.textNode("x")); node.put("y", JsonNodeFactory.instance.textNode("y")); node.put("z", JsonNodeFactory.instance.textNode("z")); List<JsonNode> findValues = node.findValues("x"); Assert.assertNotNull(findValues); Assert.assertEquals(2, findValues.size()); Assert.assertEquals("x", findValues.get(0).get("x").asText()); Assert.assertEquals("y", findValues.get(1).get("x").asText());
@Test public void testFindValues() throws IOException { JsonNode node = JsonNodeFactory.instance.objectNode(); node.put("x", JsonNodeFactory.instance.textNode("x")); node.put("y", JsonNodeFactory.instance.textNode("y")); node.put("z", JsonNodeFactory.instance.textNode("z")); List<JsonNode> findValues = new ArrayList<JsonNode>(); findValues.add(node.findValue("x")); findValues.add(node.findValue("y")); findValues.add(node.findValue("z")); findValues.add(node.findValue("z")); findValues.add(node.find
@Test public void testFindValues() { List<JsonNode> findValues = new ArrayList<JsonNode>(); findValues.add(JsonNodeFactory.instance.textNode("test")); findValues.add(JsonNodeFactory.instance.textNode("test2")); findValues.add(JsonNodeFactory.instance.textNode("test3")); findValues.add(JsonNodeFactory.instance.textNode("test4")); findValues.add(JsonNodeFactory.instance.textNode("test5")); findValues.add(JsonNodeFactory.instance.textNode("test6")); findValues.add(JsonNodeFactory.instance.textNode("test7")
@Test public void testFindValues() { List<JsonNode> findValues = new ArrayList<JsonNode>(); findValues.add(JsonNodeFactory.instance.objectNode()); findValues.add(JsonNodeFactory.instance.objectNode()); findValues.add(JsonNodeFactory.instance.objectNode()); findValues.add(JsonNodeFactory.instance.objectNode()); findValues.add(JsonNodeFactory.instance.objectNode()); findValues.add(JsonNodeFactory.instance.objectNode()); findValues.add(JsonNodeFactory.instance.objectNode()); findValues.add(JsonNodeFactory.instance.objectNode()); findValues.add(JsonNodeFactory.instance.object
@Test public void testFindParents() { JsonNode node1 = JsonNodeFactory.instance.objectNode(); node1.put("x", JsonNodeFactory.instance.numberNode(1)); node1.put("y", JsonNodeFactory.instance.numberNode(2)); node1.put("z", JsonNodeFactory.instance.numberNode(3)); JsonNode node2 = JsonNodeFactory.instance.objectNode(); node2.put("x", JsonNodeFactory.instance.numberNode(4)); node2.put("y", JsonNodeFactory.instance.numberNode(5)); node2.put("z", JsonNodeFactory.instance.numberNode(6)); JsonNode node3 = JsonNodeFactory.instance.objectNode(); node
@Test public void testFindParents() { JsonNode node1 = JsonNodeFactory.instance.objectNode(); node1.put("x", JsonNodeFactory.instance.numberNode(1)); node1.put("y", JsonNodeFactory.instance.numberNode(2)); node1.put("z", JsonNodeFactory.instance.numberNode(3)); JsonNode node2 = JsonNodeFactory.instance.objectNode(); node2.put("x", JsonNodeFactory.instance.numberNode(4)); node2.put("y", JsonNodeFactory.instance.numberNode(5)); node2.put("z", JsonNodeFactory.instance.numberNode(6)); JsonNode node3 = JsonNodeFactory.instance.objectNode(); node
@Test public void testFindParents() { JsonNode node1 = JsonNodeFactory.instance.objectNode(); node1.put("x", JsonNodeFactory.instance.numberNode(1)); node1.put("y", JsonNodeFactory.instance.numberNode(2)); node1.put("z", JsonNodeFactory.instance.numberNode(3)); JsonNode node2 = JsonNodeFactory.instance.objectNode(); node2.put("x", JsonNodeFactory.instance.numberNode(4)); node2.put("y", JsonNodeFactory.instance.numberNode(5)); node2.put("z", JsonNodeFactory.instance.numberNode(6)); JsonNode node3 = JsonNodeFactory.instance.objectNode(); node
@Test public void testFindParents() { List<JsonNode> parents = new ArrayList<JsonNode>(); parents.add(JsonNodeFactory.instance.objectNode()); parents.add(JsonNodeFactory.instance.objectNode()); parents.add(JsonNodeFactory.instance.objectNode()); parents.add(JsonNodeFactory.instance.objectNode()); parents.add(JsonNodeFactory.instance.objectNode()); parents.add(JsonNodeFactory.instance.objectNode()); parents.add(JsonNodeFactory.instance.objectNode()); parents.add(JsonNodeFactory.instance.objectNode()); parents.add(JsonNodeFactory.instance.objectNode()); parents.add(JsonNodeFactory.
@Test public void testFindClass() throws Exception { assertEquals(Integer.class, EnumTypeLocator.findClass(Integer.class.getName())); assertEquals(Integer.class, EnumTypeLocator.findClass(Integer.class.getName())); assertEquals(Long.class, EnumTypeLocator.findClass(Long.class.getName())); assertEquals(Long.class, EnumTypeLocator.findClass(Long.class.getName())); assertEquals(Float.class, EnumTypeLocator.findClass(Float.class.getName())); assertEquals(Float.class, EnumTypeLocator.findClass(Float.class.getName())); assertEquals(Float.class, EnumTypeLocator.
@Test public void testFindClass() throws Exception { assertEquals(Byte.class, EnumTypeLocator.findClass("byte")); assertEquals(Byte.class, EnumTypeLocator.findClass("java.lang.Byte")); assertEquals(Byte.class, EnumTypeLocator.findClass("java.lang.Byte")); assertEquals(Byte.class, EnumTypeLocator.findClass("java.lang.Byte")); assertEquals(Byte.class, EnumTypeLocator.findClass("java.lang.Byte")); assertEquals(Byte.class, EnumTypeLocator.findClass("java.lang.Byte")); assertEquals(Byte.class, EnumTypeLocator.findClass("java
@Test public void testFindClass() throws Exception { assertEquals(Float.class, EnumTypeLocator.findClass("float")); assertEquals(Float.class, EnumTypeLocator.findClass("java.lang.Float")); assertEquals(Float.class, EnumTypeLocator.findClass("java.lang.Float")); assertEquals(Float.class, EnumTypeLocator.findClass("java.lang.Float")); assertEquals(Float.class, EnumTypeLocator.findClass("java.lang.Float")); assertEquals(Float.class, EnumTypeLocator.findClass("java.lang.Float")); assertEquals(Float.class, EnumTypeLocator.findClass("java
@Test public void testFindClass() throws Exception { assertEquals(Integer.class, EnumTypeLocator.findClass(Integer.class.getName())); assertEquals(Integer.class, EnumTypeLocator.findClass(Integer.class.getName())); assertEquals(Long.class, EnumTypeLocator.findClass(Long.class.getName())); assertEquals(Long.class, EnumTypeLocator.findClass(Long.class.getName())); assertEquals(Float.class, EnumTypeLocator.findClass(Float.class.getName())); assertEquals(Float.class, EnumTypeLocator.findClass(Float.class.getName())); assertEquals(Float.class, EnumTypeLocator.
@Test public void testFindClass() throws Exception { assertEquals(Boolean.class, EnumTypeLocator.findClass(Boolean.class.getName())); assertEquals(Boolean.class, EnumTypeLocator.findClass(Boolean.class.getName())); assertEquals(Boolean.class, EnumTypeLocator.findClass(Boolean.class.getName())); assertEquals(Boolean.class, EnumTypeLocator.findClass(Boolean.class.getName())); assertEquals(Byte.class, EnumTypeLocator.findClass(Byte.class.getName())); assertEquals(Byte.class, EnumTypeLocator.findClass(Byte.class.getName())); assertEquals(Byte.class, EnumTypeLocator.
@Test public void testFindClass() throws Exception { assertEquals(Byte.class, EnumTypeLocator.findClass("byte")); assertEquals(Byte.class, EnumTypeLocator.findClass("java.lang.Byte")); assertEquals(Byte.class, EnumTypeLocator.findClass("java.lang.Byte")); assertEquals(Byte.class, EnumTypeLocator.findClass("java.lang.Byte")); assertEquals(Byte.class, EnumTypeLocator.findClass("java.lang.Byte")); assertEquals(Byte.class, EnumTypeLocator.findClass("java.lang.Byte")); assertEquals(Byte.class, EnumTypeLocator.findClass("java
@Test public void testFindClass() throws Exception { assertEquals(Integer.class, EnumTypeLocator.findClass(Integer.class.getName())); assertEquals(Integer.class, EnumTypeLocator.findClass(Integer.class.getName())); assertEquals(Integer.class, EnumTypeLocator.findClass(Integer.class.getName())); assertEquals(Long.class, EnumTypeLocator.findClass(Long.class.getName())); assertEquals(Float.class, EnumTypeLocator.findClass(Float.class.getName())); assertEquals(Double.class, EnumTypeLocator.findClass(Double.class.getName())); assertEquals(Boolean.class, EnumTypeLocator.
@Test public void testFindClass() throws Exception { assertEquals(Byte.class, EnumTypeLocator.findClass("byte")); assertEquals(Byte.class, EnumTypeLocator.findClass("java.lang.Byte")); assertEquals(Short.class, EnumTypeLocator.findClass("java.lang.Short")); assertEquals(Short.class, EnumTypeLocator.findClass("java.lang.Short")); assertEquals(Short.class, EnumTypeLocator.findClass("java.lang.Short")); assertEquals(Short.class, EnumTypeLocator.findClass("java.lang.Short")); assertEquals(Short.class, EnumTypeLocator.findClass("java
@Test public void testFindClass() throws Exception { assertEquals(Integer.class, EnumTypeLocator.findClass("int")); assertEquals(Integer.class, EnumTypeLocator.findClass("java.lang.Integer")); assertEquals(Integer.class, EnumTypeLocator.findClass("java.lang.Integer")); assertEquals(Long.class, EnumTypeLocator.findClass("java.lang.Long")); assertEquals(Float.class, EnumTypeLocator.findClass("java.lang.Float")); assertEquals(Double.class, EnumTypeLocator.findClass("java.lang.Double")); assertEquals(Boolean.class, EnumTypeLocator.findClass("java
@Test public void testGetRootCause() throws Exception { Exception e1 = new Exception("e1"); Exception e2 = new Exception("e2"); Exception e3 = new Exception("e3"); e1.initCause(e2); e2.initCause(e3); assertEquals(e1, EnumTypeLocator.getRootCause(e1)); assertEquals(e2, EnumTypeLocator.getRootCause(e2)); assertEquals(e3, EnumTypeLocator.getRootCause(e3)); }
@Test public void testGetRootCause() throws Exception { Throwable t1 = new Throwable(); Throwable t2 = new Throwable(); Throwable t3 = new Throwable(); t1.initCause(t2); t2.initCause(t3); t3.initCause(t1); t1.initCause(t2); t2.initCause(t3); assertEquals(t1, EnumTypeLocator.getRootCause(t1)); assertEquals(t2, EnumTypeLocator.getRootCause(t2)); assertEquals(t3, EnumTypeLocator.getRootCause(t3)); }
@Test public void testGetRootCause() throws Exception { Throwable t = new Throwable(); t.setStackTrace(new StackTraceElement[0]); t = new Throwable(t); t.setStackTrace(new StackTraceElement[0]); t = new Throwable(t); t.setStackTrace(new StackTraceElement[0]); t = new Throwable(t); t.setStackTrace(new StackTraceElement[0]); t = new Throwable(t); t.setStackTrace(new StackTraceElement[0]); t = new Throwable(t); t.setStackTrace(new StackTraceElement[0]); t = new Throwable(t); t.setStackTrace(new StackTraceElement[0]); t = new Throwable(t); t.setStackTrace(new StackTraceElement[0]); t
@Test public void testGetRootCause() { Throwable t = new Throwable(); t.setStackTrace(new StackTraceElement[0]); assertSame(t, EnumTypeLocator.getRootCause(t)); t.setStackTrace(new StackTraceElement[1]); assertSame(t, EnumTypeLocator.getRootCause(t)); t.setStackTrace(new StackTraceElement[2]); assertSame(t, EnumTypeLocator.getRootCause(t)); t.setStackTrace(new StackTraceElement[3]); assertSame(t, EnumTypeLocator.getRootCause(t)); t.setStackTrace(new StackTraceElement[4]); assertSame(t, EnumTypeLocator.getRootCause(t)); }
@Test public void testThrowAsIAE() throws Exception { try { EnumTypeLocator.throwAsIAE(new Exception(), "message"); } catch (Exception e) { Assert.assertEquals("message", e.getMessage()); } try { EnumTypeLocator.throwAsIAE(new Exception(), "message"); } catch (Exception e) { Assert.assertEquals("message", e.getMessage()); } try { EnumTypeLocator.throwAsIAE(new Exception(), "message"); } catch (Exception e) { Assert.assertEquals("message", e.getMessage()); } try { EnumTypeLocator.throwAsIAE(new Exception(), "message"); } catch (Exception e) { Assert.assert
@Test public void testRuntimeException() { try { throwAsIAE(new RuntimeException(), "message"); } catch (Exception e) { Assert.assertEquals("message", e.getMessage()); } try { throwAsIAE(new RuntimeException(), "message"); } catch (Exception e) { Assert.assertEquals("message", e.getMessage()); } try { throwAsIAE(new Error(), "message"); } catch (Exception e) { Assert.assertEquals("message", e.getMessage()); } try { throwAsIAE(new RuntimeException(), "message"); } catch (Exception e) { Assert.assertEquals("message", e.getMessage()); } }
@Test public void testRuntimeException() { try { throwAsIAE(new RuntimeException(), "test"); } catch (RuntimeException e) { assertEquals("test", e.getMessage()); } try { throwAsIAE(new Error(), "test"); } catch (Error e) { assertEquals("test", e.getMessage()); } try { throwAsIAE(new RuntimeException(), "test"); } catch (RuntimeException e) { assertEquals("test", e.getMessage()); } try { throwAsIAE(new RuntimeException(), "test"); } catch (Error e) { assertEquals("test", e.getMessage()); } }
@Test public void testUnwrapAndThrowAsIAE() throws Exception { try { EnumTypeLocator.unwrapAndThrowAsIAE(new Exception(), "message"); fail("Should have failed"); } catch (Exception e) { assertEquals("message", e.getMessage()); } try { EnumTypeLocator.throwAsIAE(new Exception(), "message"); fail("Should have failed"); } catch (Exception e) { assertEquals("message", e.getMessage()); } try { EnumTypeLocator.throwAsIAE(new Exception(), "message"); fail("Should have failed"); } catch (Exception e) { assertEquals("message", e.getMessage()); } try { EnumTypeLocator.throwAsIA
@Test public void testThrowAsIAE() throws Exception { try { EnumTypeLocator.throwAsIAE(Exception.class, "message"); fail(); } catch (Exception e) { } try { EnumTypeLocator.throwAsIAE(Exception.class, "message"); fail(); } catch (Exception e) { } try { EnumTypeLocator.throwAsIAE(Exception.class, "message"); fail(); } catch (Exception e) { } try { EnumTypeLocator.throwAsIAE(Exception.class, "message"); fail(); } catch (Exception e) { } try { EnumTypeLocator.throwAsIAE(Exception.class, "message"); fail(); } catch (
@Test public void testCreateInstance() throws Exception { MyEnum myEnum = EnumTypeLocator.createInstance(MyEnum.class, true); Assert.assertNotNull(myEnum); Assert.assertTrue(myEnum instanceof MyEnum); myEnum = EnumTypeLocator.createInstance(MyEnum.class, false); Assert.assertNotNull(myEnum); Assert.assertTrue(myEnum instanceof MyEnum); myEnum = EnumTypeLocator.createInstance(MyEnum.class, true); Assert.assertNotNull(myEnum); Assert.assertTrue(myEnum instanceof MyEnum); myEnum = EnumTypeLocator.createInstance(MyEnum.class, false); Assert.assertNotNull(myEnum); Assert.
@Test public void testCreateInstance() { MyClass myClass = EnumTypeLocator.createInstance(MyClass.class, true); Assert.assertNotNull(myClass); Assert.assertEquals("myClass", myClass.s); myClass = EnumTypeLocator.createInstance(MyClass.class, false); Assert.assertNotNull(myClass); Assert.assertEquals("myClass", myClass.s); myClass = EnumTypeLocator.createInstance(MyClass.class, true); Assert.assertNotNull(myClass); Assert.assertEquals("myClass", myClass.s); myClass = EnumTypeLocator.createInstance(MyClass.class, true); Assert.assertNotNull(my
@Test public void testCreateInstance() throws Exception { MyClass myClass = EnumTypeLocator.createInstance(MyClass.class, true); Assert.assertNotNull(myClass); Assert.assertEquals(MyClass.class, myClass.getClass()); myClass = EnumTypeLocator.createInstance(MyClass.class, false); Assert.assertNotNull(myClass); Assert.assertEquals(MyClass.class, myClass.getClass()); myClass = EnumTypeLocator.createInstance(MyClass.class, true); Assert.assertNotNull(myClass); Assert.assertEquals(MyClass.class, myClass.getClass()); myClass = EnumTypeLocator.createInstance(MyClass
@Test public void testCreateInstance() { try { EnumTypeLocator.createInstance(EnumTypeLocatorTest.class, true); Assert.fail(); } catch (IllegalArgumentException e) { } try { EnumTypeLocator.createInstance(EnumTypeLocatorTest.class, false); Assert.fail(); } catch (IllegalArgumentException e) { } try { EnumTypeLocator.createInstance(EnumTypeLocatorTest.class, true); Assert.fail(); } catch (IllegalArgumentException e) { } try { EnumTypeLocator.createInstance(EnumTypeLocatorTest.class, false); Assert.fail(); } catch (IllegalArgumentException e) { } try { EnumTypeLocator.createInstance(EnumTypeLocatorTest.class, true); Assert
@Test public void testCreateInstance() throws Exception { TestBean bean = EnumTypeLocator.createInstance(TestBean.class, true); Assert.assertNotNull(bean); }
@Test public void testCreateInstance() throws Exception { MyClass myClass = EnumTypeLocator.createInstance(MyClass.class, true); Assert.assertNotNull(myClass); Assert.assertEquals(MyClass.class, myClass.getClass()); myClass = EnumTypeLocator.createInstance(MyClass.class, false); Assert.assertNotNull(myClass); Assert.assertEquals(MyClass.class, myClass.getClass()); myClass = EnumTypeLocator.createInstance(MyClass.class, true); Assert.assertNotNull(myClass); Assert.assertEquals(MyClass.class, myClass.getClass()); myClass = EnumTypeLocator.createInstance(MyClass
@Test public void testCreateInstance() { try { EnumTypeLocator.createInstance(EnumTypeLocatorTest.class, true); fail(); } catch (IllegalArgumentException e) { } try { EnumTypeLocator.createInstance(EnumTypeLocatorTest.class, false); fail(); } catch (IllegalArgumentException e) { } try { EnumTypeLocator.createInstance(EnumTypeLocatorTest.class, true); fail(); } catch (IllegalArgumentException e) { } try { EnumTypeLocator.createInstance(EnumTypeLocatorTest.class, true); fail(); } catch (IllegalArgumentException e) { } try { EnumTypeLocator.createInstance(EnumTypeLocatorTest.class, false); fail(); } catch (IllegalArgumentException e) {
@Test public void testFindConstructor() throws Exception { Constructor<Foo> constructor = EnumTypeLocator.findConstructor(Foo.class, true); Assert.assertNotNull(constructor); }
@Test public void testFindConstructor() throws Exception { Constructor<EnumTypeLocatorTest> c = EnumTypeLocator.findConstructor(EnumTypeLocatorTest.class, true); Assert.assertNotNull(c); c = EnumTypeLocator.findConstructor(EnumTypeLocatorTest.class, false); Assert.assertNull(c); c = EnumTypeLocator.findConstructor(EnumTypeLocatorTest.class, true); Assert.assertNotNull(c); c = EnumTypeLocator.findConstructor(EnumTypeLocatorTest.class, false); Assert.assertNull(c); c = EnumTypeLocator.findConstructor(EnumTypeLocatorTest.class, true); Assert.assertNotNull(c); c = EnumTypeLocator
@Test public void testFindConstructor() throws Exception { Constructor<Foo> constructor = EnumTypeLocator.findConstructor(Foo.class, true); Assert.assertNotNull(constructor); }
@Test public void testFindConstructor() throws Exception { Constructor<EnumTypeLocatorTest> c = EnumTypeLocator.findConstructor(EnumTypeLocatorTest.class, true); Assert.assertNotNull(c); c = EnumTypeLocator.findConstructor(EnumTypeLocatorTest.class, false); Assert.assertNull(c); c = EnumTypeLocator.findConstructor(EnumTypeLocatorTest.class, true); Assert.assertNotNull(c); c = EnumTypeLocator.findConstructor(EnumTypeLocatorTest.class, true); Assert.assertNotNull(c); c = EnumTypeLocator.findConstructor(EnumTypeLocatorTest.class, false); Assert.assertNull(c); c = EnumTypeLocator
@Test public void testFindConstructor() throws Exception { Constructor<Foo> constructor = EnumTypeLocator.findConstructor(Foo.class, true); Assert.assertNotNull(constructor); Assert.assertEquals(Foo.class, constructor.getParameterTypes()[0]); constructor = EnumTypeLocator.findConstructor(Foo.class, false); Assert.assertNotNull(constructor); Assert.assertEquals(Foo.class, constructor.getParameterTypes()[0]); constructor = EnumTypeLocator.findConstructor(Foo.class, true); Assert.assertNotNull(constructor); Assert.assertEquals(Foo.class, constructor.getParameterTypes()[0]); constructor = EnumTypeLocator.
@Test public void testFindConstructor() { try { EnumTypeLocator.findConstructor(Object.class, true); fail("Expected IllegalArgumentException"); } catch (IllegalArgumentException e) { } try { EnumTypeLocator.findConstructor(Object.class, false); fail("Expected IllegalArgumentException"); } catch (IllegalArgumentException e) { } try { EnumTypeLocator.findConstructor(Object.class, true); fail("Expected IllegalArgumentException"); } catch (IllegalArgumentException e) { } try { EnumTypeLocator.findConstructor(Object.class, true); fail("Expected IllegalArgumentException"); } catch (IllegalArgumentException e) { } try { EnumTypeLocator.findConstructor(Object.class, false); fail("Expected IllegalArgumentException"); } catch (IllegalArgumentException e) {
@Test public void testFindConstructor() { try { EnumTypeLocator.findConstructor(EnumTypeLocatorTest.class, true); fail("Expected IllegalArgumentException"); } catch (IllegalArgumentException e) { } try { EnumTypeLocator.findConstructor(EnumTypeLocatorTest.class, false); fail("Expected IllegalArgumentException"); } catch (IllegalArgumentException e) { } try { EnumTypeLocator.findConstructor(EnumTypeLocatorTest.class, true); fail("Expected IllegalArgumentException"); } catch (IllegalArgumentException e) { } try { EnumTypeLocator.findConstructor(EnumTypeLocatorTest.class, false); fail("Expected IllegalArgumentException"); } catch (IllegalArgumentException e) { } try { EnumTypeLocator.findConstructor(EnumTypeLocatorTest.class
@Test public void testFindConstructor() throws Exception { Constructor<Foo> constructor = EnumTypeLocator.findConstructor(Foo.class, true); Assert.assertNotNull(constructor); }
@Test public void testFindConstructor() throws Exception { Constructor<EnumTypeLocatorTest> c = EnumTypeLocator.findConstructor(EnumTypeLocatorTest.class, true); Assert.assertNotNull(c); c = EnumTypeLocator.findConstructor(EnumTypeLocatorTest.class, false); Assert.assertNull(c); c = EnumTypeLocator.findConstructor(EnumTypeLocatorTest.class, true); Assert.assertNotNull(c); c = EnumTypeLocator.findConstructor(EnumTypeLocatorTest.class, true); Assert.assertNotNull(c); c = EnumTypeLocator.findConstructor(EnumTypeLocatorTest.class, false); Assert.assertNull(c); c = EnumTypeLocator
@Test public void testFindConstructor() { try { EnumTypeLocator.findConstructor(Object.class, true); fail("Expected IllegalArgumentException"); } catch (IllegalArgumentException e) { } try { EnumTypeLocator.findConstructor(Object.class, false); fail("Expected IllegalArgumentException"); } catch (IllegalArgumentException e) { } try { EnumTypeLocator.findConstructor(Object.class, true); fail("Expected IllegalArgumentException"); } catch (IllegalArgumentException e) { } try { EnumTypeLocator.findConstructor(Object.class, true); fail("Expected IllegalArgumentException"); } catch (IllegalArgumentException e) { } try { EnumTypeLocator.findConstructor(Object.class, false); fail("Expected IllegalArgumentException"); } catch (IllegalArgumentException e) {
@Test public void testFindConstructor() throws Exception { Constructor<Foo> constructor = EnumTypeLocator.findConstructor(Foo.class, true); Assert.assertNotNull(constructor); }
@Test public void test_wrapper_type() { assertEquals(Integer.class, EnumTypeLocator.wrapperType(Integer.TYPE)); assertEquals(Integer.class, EnumTypeLocator.wrapperType(Integer.TYPE)); assertEquals(Long.class, EnumTypeLocator.wrapperType(Long.TYPE)); assertEquals(Long.class, EnumTypeLocator.wrapperType(Long.TYPE)); assertEquals(Boolean.class, EnumTypeLocator.wrapperType(Boolean.TYPE)); assertEquals(Float.class, EnumTypeLocator.wrapperType(Float.TYPE)); assertEquals(Float.class, EnumTypeLocator.wrapperType(Float.TYPE)); assertEquals(Float.class, EnumTypeLocator.
@Test public void test() { assertEquals(Integer.class, EnumTypeLocator.wrapperType(Integer.TYPE)); assertEquals(Integer.class, EnumTypeLocator.wrapperType(Integer.TYPE)); assertEquals(Long.class, EnumTypeLocator.wrapperType(Long.TYPE)); assertEquals(Long.class, EnumTypeLocator.wrapperType(Long.TYPE)); assertEquals(Boolean.class, EnumTypeLocator.wrapperType(Boolean.TYPE)); assertEquals(Float.class, EnumTypeLocator.wrapperType(Float.TYPE)); assertEquals(Float.class, EnumTypeLocator.wrapperType(Float.TYPE)); assertEquals(Float.class, EnumTypeLocator.wrapperType(Float
@Test public void testWrapperType() { assertEquals(Integer.class, EnumTypeLocator.wrapperType(Integer.TYPE)); assertEquals(Integer.class, EnumTypeLocator.wrapperType(Integer.TYPE)); assertEquals(Long.class, EnumTypeLocator.wrapperType(Long.TYPE)); assertEquals(Long.class, EnumTypeLocator.wrapperType(Long.TYPE)); assertEquals(Boolean.class, EnumTypeLocator.wrapperType(Boolean.TYPE)); assertEquals(Float.class, EnumTypeLocator.wrapperType(Float.TYPE)); assertEquals(Float.class, EnumTypeLocator.wrapperType(Float.TYPE)); assertEquals(Float.class, EnumTypeLocator.wrapperType
@Test public void test_wrapper_type() { assertEquals(Integer.class, EnumTypeLocator.wrapperType(Integer.TYPE)); assertEquals(Integer.class, EnumTypeLocator.wrapperType(Integer.TYPE)); assertEquals(Long.class, EnumTypeLocator.wrapperType(Long.TYPE)); assertEquals(Long.class, EnumTypeLocator.wrapperType(Long.TYPE)); assertEquals(Boolean.class, EnumTypeLocator.wrapperType(Boolean.TYPE)); assertEquals(Float.class, EnumTypeLocator.wrapperType(Float.TYPE)); assertEquals(Float.class, EnumTypeLocator.wrapperType(Float.TYPE)); assertEquals(Float.class, EnumTypeLocator.
@Test public void test_wrapper_type() { assertEquals(Integer.class, EnumTypeLocator.wrapperType(Integer.TYPE)); assertEquals(Integer.class, EnumTypeLocator.wrapperType(Integer.TYPE)); assertEquals(Long.class, EnumTypeLocator.wrapperType(Long.TYPE)); assertEquals(Long.class, EnumTypeLocator.wrapperType(Long.TYPE)); assertEquals(Boolean.class, EnumTypeLocator.wrapperType(Boolean.TYPE)); assertEquals(Float.class, EnumTypeLocator.wrapperType(Float.TYPE)); assertEquals(Float.class, EnumTypeLocator.wrapperType(Float.TYPE)); assertEquals(Float.class, EnumTypeLocator.
@Test public void testCheckAndFixAccess() throws Exception { Method m = Foo.class.getDeclaredMethod("foo", int.class); try { EnumTypeLocator.checkAndFixAccess(m); Assert.fail(); } catch (IllegalArgumentException e) { } try { EnumTypeLocator.checkAndFixAccess(m); Assert.fail(); } catch (IllegalArgumentException e) { } try { EnumTypeLocator.checkAndFixAccess(m); Assert.fail(); } catch (IllegalArgumentException e) { } try { EnumTypeLocator.checkAndFixAccess(m); Assert.fail(); } catch (IllegalArgumentException e) { } try { EnumTypeLocator.checkAndFixAccess(m); Assert.fail(); }
@Test public void testCheckAndFixAccess() { MyClass myClass = new MyClass(); MyClass myClass1 = new MyClass(); MyClass myClass2 = new MyClass(); MyClass myClass3 = new MyClass(); MyClass myClass4 = new MyClass(); MyClass myClass5 = new MyClass(); MyClass myClass6 = new MyClass(); MyClass myClass7 = new MyClass(); MyClass myClass8 = new MyClass(); MyClass myClass9 = new MyClass(); MyClass myClass10 = new MyClass(); MyClass myClass11 = new MyClass(); MyClass myClass12 = new MyClass(); MyClass myClass21 = new My
@Test public void testCheckAndFixAccess() throws Exception { try { EnumTypeLocator.checkAndFixAccess(TestClass.class.getDeclaredMethod("method")); fail(); } catch (IllegalArgumentException e) { } try { EnumTypeLocator.checkAndFixAccess(TestClass.class.getDeclaredMethod("method2")); fail(); } catch (IllegalArgumentException e) { } try { EnumTypeLocator.checkAndFixAccess(TestClass.class.getDeclaredMethod("method3")); fail(); } catch (IllegalArgumentException e) { } try { EnumTypeLocator.checkAndFixAccess(TestClass.class.getDeclaredMethod("method4")); fail(); } catch (IllegalArgumentException e) { }
@Test public void testCheckAndFixAccess() throws Exception { MyClass myClass = new MyClass(); MyClass myClass2 = new MyClass(); MyClass myClass3 = new MyClass(); MyClass myClass4 = new MyClass(); MyClass myClass5 = new MyClass(); MyClass myClass6 = new MyClass(); MyClass myClass7 = new MyClass(); MyClass myClass8 = new MyClass(); MyClass myClass9 = new MyClass(); MyClass myClass10 = new MyClass(); MyClass myClass11 = new MyClass(); MyClass myClass12 = new MyClass(); MyClass myClass21 = new MyClass(); MyClass myClass22 =
@Test public void testEnumSetSerializer() { Set<String> expected = new HashSet<String>(); expected.addAll(Arrays.asList("ONE", "TWO", "THREE")); expected.addAll(Arrays.asList("ONE", "TWO", "THREE")); expected.addAll(Arrays.asList("ONE", "TWO", "THREE")); expected.addAll(Arrays.asList("ONE", "TWO", "THREE")); expected.addAll(Arrays.asList("ONE", "TWO", "THREE")); expected.addAll(Arrays.asList("ONE", "TWO", "THREE"));
@Test public void testEnumSetSerializer() throws Exception { Set<String> expected = new HashSet<String>(Arrays.asList("ONE", "TWO", "THREE")); expected.addAll(Arrays.asList("ONE", "TWO", "THREE")); expected.addAll(Arrays.asList("ONE", "TWO", "THREE")); expected.addAll(Arrays.asList("ONE", "TWO", "THREE")); expected.addAll(Arrays.asList("ONE", "TWO", "THREE")); expected.addAll(Arrays.asList("ONE", "TWO", "THREE")); expected.add
@Test public void testEnumSetSerializer() throws Exception { List<String> expected = Arrays.asList("1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21", "22", "23", "24", "25", "26", "26", "25", "26", "26", "26", "26", "26", "26", "26", "26", "26", "26", "26", "26", "26", "26",
@Test public void testEnumSetSerializer() throws JsonGenerationException, JsonMappingException, IOException { Set<EnumSet<TestEnum>> expected = new HashSet<EnumSet<TestEnum>>(); expected.add(TestEnum.ONE); expected.add(TestEnum.TWO); expected.add(TestEnum.THREE); expected.add(TestEnum.FOUR); expected.add(TestEnum.FOUR); TypeSerializer vts = new TypeSerializer(new MockTypeSerializer(TestEnum.class)); EnumSetSerializer bs = new EnumSetSerializer(vts, Property.TWO, vts, new JsonSerializer<TestEnum>() { @Override public void serializeContents(EnumSet<TestEnum
@Test public void withResolved() { BeanProperty property = mock(BeanProperty.class); TypeSerializer vts = mock(TypeSerializer.class); EnumSetSerializer bs1 = bs1._withResolved(property, vts, mock(JsonSerializer.class)); EnumSetSerializer bs2 = bs2._withResolved(property, vts, mock(JsonSerializer.class)); assertEquals(bs1, bs2); }
@Test public void withResolved() throws JsonGenerationException, IOException { Set<EnumSet<TestEnum>> expected = new HashSet<EnumSet<TestEnum>>(); expected.add(TestEnum.ONE); expected.add(TestEnum.TWO); expected.add(TestEnum.THREE); TypeSerializer vts = new TypeSerializer(new MockTypeSerializer(TestEnum.class)); BeanProperty property = mock(BeanProperty.class); EnumSetSerializer es = es.withResolved(property, vts, new JsonSerializer<TestEnum>() { @Override public void serializeContents(EnumSet<TestEnum> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { }
@Test public void testStdDelegatingDeserializer() throws Exception { Map<String, Object> testMap = new HashMap<String, Object>(); testMap.put("key1", "value1"); testMap.put("key2", "value2"); testMap.put("key3", "value3"); testMap.put("key4", "value4"); Map<String, Object> testMap2 = new HashMap<String, Object>(); testMap2.put("key1", "value1"); testMap2.put("key2", "value2"); testMap2.put("key3", "value3"); testMap2.put("key4", "value4");
@Test public void testStdDelegatingDeserializer() throws Exception { Map<String, Object> stringObjectMap = new HashMap<String, Object>(); stringObjectMap.put("foo", "bar"); Map<String, Object> stringObjectMap2 = new HashMap<String, Object>(); stringObjectMap2.put("foo", "bar"); Map<String, Object> stringObjectMap3 = new HashMap<String, Object>(); stringObjectMap3.put("foo", "bar"); Map<String, Object> stringObjectMap4 = new HashMap<String, Object>(); stringObjectMap4.put("foo", "bar"); stringObjectMap4.put("bar", "baz");
@Test public void testStdDelegatingDeserializer() throws Exception { Converter<String, String> converter = new Converter<String, String>() { @Override public String convert(String str) { return str; } }; JavaType type = JavaType.of(String.class, String.class); JsonDeserializer<String> delegate = new JsonDeserializer<String>() { @Override public String deserializeWithType(JsonParser jp, DeserializationContext ctxt, BeanProperty property) throws IOException, JsonMappingException { return str; } }; new StdDelegatingDeserializer<String>(converter, type, delegate) { @Override protected String convertValue(String str) { return str; } }.withDelegate
@Test public void testStdDelegatingDeserializer() throws Exception { Converter<String, String> stringConverter = new Converter<String, String>() { @Override public String convert(String str) { return str; } @Override public String convert(Integer integer) { return Integer.toString(integer); } }; JavaType delegateType = TypeFactory.defaultInstance().construct(String.class, String.class); JsonDelegatingDeserializer<String> deserializer = new StdDelegatingDeserializer<String>(stringConverter, delegateType, new JsonDeserializer<String>() { @Override public String deserializeWithType(JsonParser jp, DeserializationContext ctxt, BeanProperty property) throws IOException, JsonMappingException { return
@Test public void testStdDelegatingDeserializer() throws Exception { Map<String, Object> testMap = new HashMap<String, Object>(); testMap.put("key1", "value1"); testMap.put("key2", "value2"); testMap.put("key3", "value3"); Map<String, Object> testMap2 = new HashMap<String, Object>(); testMap2.put("key1", "value1"); testMap2.put("key2", "value2"); testMap2.put("key3", "value3"); Map<String, Object> testMap3 = new HashMap<String, Object>(); testMap3.put("key
@Test public void testResolve() throws Exception { Map<String, Object> map = new HashMap<String, Object>(); map.put("key1", "value1"); map.put("key2", "value2"); Map<String, Object> map2 = new HashMap<String, Object>(); map2.put("key1", "value1"); map2.put("key2", "value2"); map2.put("key3", "value3"); Map<String, Object> map3 = new HashMap<String, Object>(); map3.put("key1", "value1"); map3.put("key2", "value2"); map3.put("key
@Test public void testResolve() throws Exception { Map<String, Object> map = new HashMap<String, Object>(); map.put("key1", "value1"); map.put("key2", "value2"); Map<String, Object> map2 = new HashMap<String, Object>(); map2.put("key1", "value1"); map2.put("key2", "value2"); map2.put("key3", "value3"); Map<String, Object> map3 = new HashMap<String, Object>(); map3.put("key1", "value1"); map3.put("key2", "value2"); map3.put("key
@Test public void testContextualDeserializer() throws Exception { Map<String, Object> map = new HashMap<String, Object>(); map.put("key1", "value1"); map.put("key2", "value2"); Map<String, Object> map2 = new HashMap<String, Object>(); map2.put("key1", "value1"); map2.put("key2", "value2"); map2.put("key3", "value3"); Map<String, Object> map3 = new HashMap<String, Object>(); map3.put("key1", "value1"); map3.put("key2", "value2"); map3.put
@Test public void testContextualDeserializer() throws Exception { JsonDeserializer<String> deserializer = new JsonDeserializer<String>() { @Override public String deserialize(JsonParser jp, DeserializationContext ctxt, BeanProperty property) throws JsonMappingException, IOException { return "test"; } @Override public void resolve(JsonParser jp, DeserializationContext ctxt, BeanProperty property) throws JsonMappingException, IOException { } }; MockDeserializationContext ctxt = new MockDeserializationContext(); ctxt.setInputTypeFactory(new TypeFactory<String>() { }); MockDeserializationContext ctxt2 = new MockDeserializationContext(); ctxt2.setInputTypeFactory(new TypeFactory<String>() { }); Json
@Test public void testContextualDeserializer() throws Exception { ContextualDeserializer d1 = new ContextualDeserializer() { @Override public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException, IOException { return new JsonDeserializer<String>() { @Override public String deserialize(JsonParser jp, DeserializationContext ctxt, BeanProperty property) throws JsonMappingException, IOException { return "test"; } }; } }; ContextualDeserializer d2 = new ContextualDeserializer() { @Override public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException, IOException { return new JsonDeserializer<String>() { @Override public
@Test public void testCreateContextual() throws Exception { Map<String, Object> map = new HashMap<String, Object>(); map.put("key1", "value1"); map.put("key2", "value2"); Map<String, Object> map2 = new HashMap<String, Object>(); map2.put("key1", "value1"); map2.put("key2", "value2"); map2.put("key3", "value3"); Map<String, Object> map3 = new HashMap<String, Object>(); map3.put("key1", "value1"); map3.put("key2", "value2"); map3.put
@Test(expected = JsonMappingException.class) public void testBadDelegate() throws Exception { when(JsonDeserializer.deserialize(Matchers.any(JsonParser.class), Matchers.any(DeserializationContext.class))) .thenThrow(new JsonMappingException("bad delegate")); new StdDelegatingDeserializer<String>() { @Override public String convert(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonMappingException { throw new JsonMappingException("bad delegate"); } }.deserialize(jp, mock(DeserializationContext.class)); }
@Test public void test() throws Exception { Map<String, Object> map = new HashMap<String, Object>(); map.put("key1", "value1"); map.put("key2", "value2"); Map<String, Object> map2 = new HashMap<String, Object>(); map2.put("key1", "value1"); map2.put("key2", "value2"); map2.put("key3", "value3"); Map<String, Object> map3 = new HashMap<String, Object>(); map3.put("key1", "value1"); map3.put("key2", "value2"); map3.put("key3
@Test public void testCustomDeserializer() throws IOException, JsonMappingException { Map<String, Object> map = new HashMap<String, Object>(); map.put("key1", "value1"); map.put("key2", "value2"); Map<String, Object> map2 = new HashMap<String, Object>(); map2.put("key1", "value1"); map2.put("key2", "value2"); map2.put("key3", "value3"); Map<String, Object> map3 = new HashMap<String, Object>(); map3.put("key1", "value1"); map3.put("key2", "value2"); map
@Test public void testCustomConverter() throws IOException, JsonMappingException { Map<String, String> map = new HashMap<String, String>(); map.put("key1", "value1"); map.put("key2", "value2"); map.put("key3", "value3"); Map<String, String> expected = new HashMap<String, String>(); expected.put("key1", "value1"); expected.put("key2", "value2"); expected.put("key3", "value3"); Map<String, String> result = new HashMap<String, String>(); result.put("key1", "value1"); result.put("key2", "
@Test public void test() throws Exception { Map<String, String> stringMap = new HashMap<String, String>(); stringMap.put("key1", "value1"); stringMap.put("key2", "value2"); Map<String, String> stringMap2 = new HashMap<String, String>(); stringMap2.put("key1", "value1"); stringMap2.put("key2", "value2"); stringMap2.put("key3", "value3"); Map<String, String> stringMap3 = new HashMap<String, String>(); stringMap3.put("key1", "value1"); stringMap3.put("key2", "
@Test public void test() throws Exception { Map<String, String> stringMap = new HashMap<String, String>(); stringMap.put("key1", "value1"); stringMap.put("key2", "value2"); Map<String, String> stringMap2 = new HashMap<String, String>(); stringMap2.put("key1", "value1"); stringMap2.put("key2", "value2"); Map<String, String> stringMap3 = new HashMap<String, String>(); stringMap3.put("key1", "value1"); stringMap3.put("key2", "value2"); stringMap3.put("key3", "
@Test public void testGetSchema() throws JsonMappingException { SimpleSerializerProvider vts = new SimpleSerializerProvider(); TypeHint typeHint = new ParameterizedType() { @Override public Type getRawType() { return Object.class; } @Override public Type getRawType() { return Object.class; } @Override public Type getRawType() { return Object.class; } @Override public Type getRawType() { return Object.class; } @Override public Type getOwnerType() { return null; } @Override public Type getOwnerType() { return null; } @Override public Type getOwnerType() { return null; } @Override public Type getOwnerType() { return null; } @Override public Type getOwnerType() { return null; } @Override public
@Test public void testGetSchema() throws JsonMappingException { SimpleSerializerProvider vts = new SimpleSerializerProvider(); final EnumMapSerializer testee = new EnumMapSerializer(JavaType.valueOf(MyEnum.class), false, new EnumValues(), vts, new JsonSerializer<MyEnum>() { @Override public JsonSerializer<MyEnum> findValueSerializer(Class<?> clazz, BeanProperty prop) { return new JsonSerializer<MyEnum>() { @Override public JsonSchema<MyEnum> findValueSerializer(Class<?> clazz, BeanProperty prop) { return new JsonSchema<MyEnum>() { @Override public JsonSchema<MyEnum> getDefaultSchemaNode() { return new JsonSchema
@Test public void testGetSchema() throws JsonMappingException { SimpleSerializerProvider vts = new SimpleSerializerProvider(); TypeHint<MyEnum> typeHint = new TypeHint<MyEnum>() { @Override public Type getType() { return MyEnum.class; } @Override public Class<? extends Enum<?>> getRawType() { return MyEnum.class; } @Override public Class<? extends Enum<?>> getRawType() { return MyEnum.class; } @Override public Type getType() { return TypeHint.class; } @Override public Class<? extends Enum<?>> getRawType() { return MyEnum.class; } @Override public Class<? extends Annotation> annotationType() { return MyEnum.class; } @Override public
@Test public void testGetSchema() throws JsonMappingException { SimpleSerializerProvider vts = new SimpleSerializerProvider(); TypeHint[] typeHint = new TypeHint[2]; typeHint[0] = new TypeToken<List<String>>() { }.getType(); typeHint[1] = new TypeToken<List<String>>() { }.getType(); TypeHint[] typeHint2 = new TypeHint[3]; typeHint2[0] = new TypeToken<List<String>>() { }.getType(); typeHint2[1] = new TypeToken<List<String>>() { }.getType(); typeHint2[2] = new TypeToken<List<String>>() { }
@Test public void testGetSchema() throws JsonMappingException { SimpleSerializerProvider vts = new SimpleSerializerProvider(); final EnumMapSerializer testee = new EnumMapSerializer(JavaType.valueOf(MyEnum.class), false, new EnumValues(), vts, new JsonSerializer<MyEnum>() { @Override public JsonSerializer<MyEnum> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { return new JsonSerializer<MyEnum>() { @Override public JsonSchema<MyEnum> getSchema(SerializerProvider provider, TypeHint typeHint) throws JsonMappingException { return new JsonSchema<MyEnum>() { @Override public Class<?> getRawType() { return MyEnum.
@Test public void testGetSchema() throws Exception { SimpleSerializerProvider vts = new SimpleSerializerProvider(); final EnumMapSerializer testee = new EnumMapSerializer(JavaType.valueOf(MyEnum.class), false, new EnumValues(), vts, new JsonSerializer<MyEnum>() { @Override public JsonSerializer<MyEnum> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { return new JsonSerializer<MyEnum>() { @Override public JsonSchema<MyEnum> getSchema(SerializerProvider provider, TypeHint typeHint) throws JsonMappingException { return new JsonSchema<MyEnum>() { @Override public Class<?> getRawType() { return MyEnum.class;
@Test public void testGetSchema() throws JsonMappingException { SimpleSerializerProvider vts = new SimpleSerializerProvider(); final EnumMapSerializer testee = new EnumMapSerializer(JavaType.valueOf(MyEnum.class), false, new EnumValues(), vts, new JsonSerializer<MyEnum>() { @Override public JsonSerializer<MyEnum> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { return new JsonSerializer<MyEnum>() { @Override public JsonSchema<MyEnum> getSchema(SerializerProvider provider, TypeHint typeHint) throws JsonMappingException { return new JsonSchema<MyEnum>() { @Override public Class<?> getRawType() { return MyEnum.
@Test public void testGetSchema() throws JsonMappingException { SimpleSerializerProvider vts = new SimpleSerializerProvider(); final EnumMapSerializer testee = new EnumMapSerializer(JavaType.valueOf(MyEnum.class), false, new EnumValues(), vts, new JsonSerializer<MyEnum>() { @Override public JsonSerializer<MyEnum> findValueSerializer(Class<MyEnum> type, BeanProperty property) { return new MyEnumSerializer(type); } @Override public JsonSerializer<MyEnum> createContextual(SerializerProvider provider, BeanProperty property) { return new MyEnumSerializer(type); } @Override public JsonSerializer<MyEnum> withValueSerializer(BeanProperty property, JsonSerializer
@Test public void testGetSchema() throws JsonMappingException { SimpleSerializerProvider vts = new SimpleSerializerProvider(); EnumMapSerializer es = new EnumMapSerializer(JavaType.valueOf(TestEnum.class), false, new EnumValues(TestEnum.values()), vts, new JsonSerializer<TestEnum>() { @Override public JsonSerializer<TestEnum> createSerializer(SerializerProvider provider, TypeHint typeHint) { return new JsonSerializer<TestEnum>() { @Override public JsonSchema<TestEnum> createSchema(SerializerProvider provider, TypeHint typeHint) { return new JsonSchema<TestEnum>() { @Override public TestEnum value() { return TestEnum.ONE; } @
@Test public void testGetSchema() throws JsonMappingException { SimpleSerializerProvider vts = new SimpleSerializerProvider(); EnumMapSerializer es = new EnumMapSerializer(JavaType.valueOf(TestEnum.class), false, new EnumValues(TestEnum.values()), vts, new JsonSerializer<TestEnum>() { @Override public JsonSerializer<TestEnum> createSerializer(SerializerProvider provider, TypeHint typeHint) { return new JsonSerializer<TestEnum>() { @Override public JsonSchema<TestEnum> createSchema(SerializerProvider provider, TypeHint typeHint) { return new JsonSchema<TestEnum>() { @Override public TestEnum value() { return TestEnum.ONE; } @
@Test public void testGetSchema() throws Exception { SimpleSerializerProvider vts = new SimpleSerializerProvider(); TypeSerializer ts1 = new DefaultTypeSerializer(vts); TypeSerializer ts2 = new DefaultTypeSerializer(vts); SimpleSerializerProvider ts3 = new DefaultSerializerProvider(vts); SimpleSerializerProvider ts4 = new DefaultSerializerProvider(vts); SimpleSerializerProvider ts5 = new DefaultSerializerProvider(vts); SimpleSerializerProvider ts6 = new DefaultSerializerProvider(vts); SimpleSerializerProvider ts7 = new DefaultSerializerProvider(vts); SimpleSerializerProvider ts8 = new DefaultSerializerProvider(vts); SimpleSerializerProvider ts9 = new DefaultSerializerProvider(vts); SimpleSerializer
@Test public void testGetSchema() throws JsonMappingException { SimpleSerializerProvider vts = new SimpleSerializerProvider(); TypeHint typeHint = new ParameterizedType() { @Override public Type getRawType() { return Object.class; } @Override public Type getRawType() { return Object.class; } @Override public Type getRawType() { return Object.class; } @Override public Type getRawType() { return Object.class; } @Override public Type getOwnerType() { return null; } @Override public Type getOwnerType() { return null; } @Override public Type getOwnerType() { return null; } @Override public Type getOwnerType() { return null; } @Override public Type getOwnerType() { return null; } @Override public
@Test public void testGetSchema() throws JsonMappingException { SimpleSerializerProvider vts = new SimpleSerializerProvider(); final EnumMapSerializer testee = new EnumMapSerializer(JavaType.valueOf(TestEnum.class), false, new EnumValues(TestEnum.values()), vts, new JsonSerializer<TestEnum>() { @Override public JsonSerializer<TestEnum> createSerializer(SerializerProvider provider, TypeHint typeHint) { return new JsonSerializer<TestEnum>() { @Override public JsonSchema<TestEnum> getSchema(SerializerProvider provider, TypeHint typeHint) { return new JsonSchema<TestEnum>(TestEnum.values()); } @Override public boolean staticTyping() { return
@Test public void testGetSchema() throws JsonMappingException { SimpleSerializerProvider vts = new SimpleSerializerProvider(); TypeHint<MyEnum> typeHint = new TypeToken<MyEnum>() { }.getType(); JsonSerializer<MyEnum> ser = new JsonSerializer<MyEnum>() { @Override public MyEnum getSchema(SerializerProvider provider, TypeHint typeHint) { return MyEnum.ONE; } }; new EnumMapSerializer(typeHint, true, new EnumValues(), vts, ser).getSchema(typeHint, typeHint); }
@Test public void testGetSchema() throws JsonMappingException { SimpleSerializerProvider vts = new SimpleSerializerProvider(); TypeHint typeHint = new ParameterizedType() { @Override public Type getRawType() { return Object.class; } @Override public Type getRawType() { return Object.class; } @Override public Type getRawType() { return Object.class; } @Override public Type getRawType() { return Object.class; } @Override public Type getOwnerType() { return null; } @Override public Type getOwnerType() { return null; } @Override public Type getOwnerType() { return null; } @Override public Type getOwnerType() { return null; } @Override public Type getOwnerType() { return null; } @Override public
@Test public void testSerializerFactoryConfig() throws Exception { Serializers[] additionalSerializers = new Serializers[] { new Serializers("serializers1"), new Serializers("serializers2"), new Serializers("serializers3"), new Serializers("serializers4"), new Serializers("serializers5") }; Serializers[] keySerializers = new Serializers[] { new Serializers("serializers1"), new Serializers("serializers2"), new Serializers("serializers3"), new Serializers("serializers4") }; Serializers[] additionalKeySerializers = new Serializers[] { new Serializers("serializers1"), new Serializers("serializers2
@Test public void testAdditionalSerializers() throws Exception { Serializers[] additionalSerializers = new Serializers[] { new Serializers("serializers1"), new Serializers("serializers2"), new Serializers("serializers3"), new Serializers("serializers4") }; Serializers[] additionalKeySerializers = new Serializers[] { new Serializers("serializers1"), new Serializers("serializers2"), new Serializers("serializers3"), new Serializers("serializers4") }; Serializers[] additionalKeySerializers = new Serializers[] { new Serializers("serializers1"), new Serializers("serializers2"), new Serializers("serializers
@Test public void testAdditionalSerializers() { Serializers[] additionalSerializers = new Serializers[] { new Serializers("serializers1"), new Serializers("serializers2"), new Serializers("serializers3"), new Serializers("serializers4") }; Serializers[] keySerializers = new Serializers[] { new Serializers("serializers1"), new Serializers("serializers2"), new Serializers("serializers3"), new Serializers("serializers4") }; BeanSerializerModifier[] modifiers = new BeanSerializerModifier[] { new BeanSerializerModifier("serializers1"), new BeanSerializerModifier("serializers2"), new BeanSerializerModifier("serializers3
@Test public void testSerializers() { Serializers[] additionalSerializers = new Serializers[] { new Serializers("serializers1"), new Serializers("serializers2"), new Serializers("serializers3"), new Serializers("serializers4") }; Serializers[] keySerializers = new Serializers[] { new Serializers("serializers1"), new Serializers("serializers2"), new Serializers("serializers3"), new Serializers("serializers4") }; BeanSerializerModifier[] modifiers = new BeanSerializerModifier[] { BeanSerializerModifier.GET, BeanSerializerModifier.POST }; SerializerFactoryConfig config = new SerializerFactoryConfig(additionalSerializers, keySerial
@Test public void testWithSerializerModifier() { SimpleSerializerModifier modifier1 = new SimpleSerializerModifier(); SimpleSerializerModifier modifier2 = new SimpleSerializerModifier(); SimpleSerializerModifier modifier3 = new SimpleSerializerModifier(); SimpleSerializerModifier modifier4 = new SimpleSerializerModifier(); SimpleSerializerModifier modifier5 = new SimpleSerializerModifier(); SimpleSerializerModifier modifier6 = new SimpleSerializerModifier(); SimpleSerializerModifier modifier7 = new SimpleSerializerModifier(); SimpleSerializerModifier modifier8 = new SimpleSerializerModifier(); SimpleSerializerModifier modifier9 = new SimpleSerializerModifier(); SimpleSerializerModifier modifier10 = new SimpleSerializerModifier(); SimpleSerializerModifier modifier11 = new SimpleSerializerModifier(); SimpleSerializerModifier modifier12 = new SimpleSerializerModifier(); SimpleSerializerModifier modifier22 =
@Test public void withSerializerModifier() { SimpleSerializerModifier modifier = new SimpleSerializerModifier(); SimpleSerializerModifier secondModifier = new SimpleSerializerModifier(); SimpleSerializerModifier thirdModifier = new SimpleSerializerModifier(); SimpleSerializerModifier fourthModifier = new SimpleSerializerModifier(); SimpleSerializerModifier fifthModifier = new SimpleSerializerModifier(); SimpleSerializerModifier sixthModifier = new SimpleSerializerModifier(); SimpleSerializerModifier fivethModifier = new SimpleSerializerModifier(); SimpleSerializerModifier sixthModifier = new SimpleSerializerModifier(); SimpleSerializerModifier fifthModifier = new SimpleSerializerModifier(); SimpleSerializerModifier sixthModifier = new SimpleSerializerModifier(); SimpleSerializerModifier sixthModifier = new SimpleSerializerModifier(); SimpleSerializerModifier sixthModifier = new Simple
@Test(expected = IllegalArgumentException.class) public void testWithSerializerModifier_Null() { SimpleSerializerModifier modifier = new SimpleSerializerModifier(); SimpleSerializerModifier[] modifiers = new SimpleSerializerModifier[1]; modifiers[0] = modifier; Serializers[] additionalSerializers = new Serializers[] { new Serializers() }; Serializers[] additionalKeySerializers = new Serializers[] { new Serializers() }; SimpleSerializerModifier[] keySerializers = new SimpleSerializerModifier[] { modifier }; SerializerFactoryConfig cfg = new SerializerFactoryConfig(additionalSerializers, additionalKeySerializers, keySerializers); cfg.withSerializerModifier(null); }
@Test public void testWithSerializerModifier() { SimpleBeanSerializerModifier modifier = new SimpleBeanSerializerModifier(); SimpleSerializer simpleSerializers = new SimpleSerializer("testSerializers"); SimpleSerializer simpleKeySerializers = new SimpleSerializer("testKeySerializers"); SimpleSerializer simpleSerializers2 = new SimpleSerializer("testSerializers2"); SimpleSerializer simpleKeySerializer2 = new SimpleSerializer("testKeySerializers2"); SimpleSerializer simpleSerializers3 = new SimpleSerializer("testSerializers3"); SimpleSerializer simpleSerializers4 = new SimpleSerializer("testSerializers4"); SimpleSerializer simpleSerializers5 = new SimpleSerializer("testSerializers5"); SimpleSerializer simpleSerializers6 = new SimpleSerializer("testSerializers6
@Test public void testSerializerModifiers() { Iterable<BeanSerializerModifier> modifiers = new ArrayList<>(); for (BeanSerializerModifier modifier : modifiers) { modifiers.add(modifier); } assertThat(modifiers.iterator().next().hasSerializerModifier(), is(true)); assertThat(modifiers.iterator().next().hasSerializerModifier(), is(true)); assertThat(modifiers.iterator().next().serializers(), is(new Serializers[] {})); assertThat(modifiers.iterator().next().keySerializers(), is(new Serializers[] {})); assertThat(modifiers.iterator().next().serializers(), is(new Serializers[] {})); assertThat(modifiers.iterator().next().serializers(), is(new
@Test public void testSerializerModifiers() { SimpleSerializerModifier modifier1 = new SimpleSerializerModifier(); SimpleSerializerModifier modifier2 = new SimpleSerializerModifier(); SimpleSerializerModifier modifier3 = new SimpleSerializerModifier(); SimpleSerializerModifier modifier4 = new SimpleSerializerModifier(); SimpleSerializerModifier modifier5 = new SimpleSerializerModifier(); SimpleSerializerModifier modifier6 = new SimpleSerializerModifier(); SimpleSerializerModifier modifier7 = new SimpleSerializerModifier(); SimpleSerializerModifier modifier8 = new SimpleSerializerModifier(); SimpleSerializerModifier modifier9 = new SimpleSerializerModifier(); SimpleSerializerModifier modifier10 = new SimpleSerializerModifier(); SimpleSerializerModifier modifier11 = new SimpleSerializerModifier(); SimpleSerializerModifier modifier12 = new SimpleSerializerModifier(); SimpleSerializerModifier modifier22 = new
@Test public void testSimpleSerializers() { SimpleSerializers serializers = new SimpleSerializers(); assertTrue(serializers.findMapSerializer(null, null, null, null, null).isPresent()); assertTrue(serializers.findMapSerializer(null, null, null, null, null).isPresent()); assertTrue(serializers.findMapSerializer(null, null, null, null, null).isPresent()); assertTrue(serializers.findMapSerializer(null, null, null, null, null).isPresent()); assertTrue(serializers.findMapSerializer(null, null, null, null, null).isPresent()); assertTrue(serializers.findMapSerializer(null, null
@Test public void testAddSerializer() { SimpleSerializers serializers = new SimpleSerializers(); serializers.addSerializer(Object.class, new JsonSerializer<Object>() { @Override public JsonSerializer<Object> _createSerializer(SerializationConfig config, Class type, JsonSerializer<Object> elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) { return null; } }); serializers.addSerializer(Object.class, new JsonSerializer<Object>() { @Override public JsonSerializer<Object> _createSerializer(SerializationConfig config, Class type, JsonSerializer<Object> elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) { return null; } }); serializers.addSerializer(Object.class, new Json
@Test public void testAddSerializer() { SimpleSerializers serializers = new SimpleSerializers(); serializers.addSerializer(Object.class, new JsonSerializer<Object>() { @Override public JsonSerializer<Object> _addSerializer(Class<?> type, JsonSerializer<Object> ser) { return null; } }); serializers._addSerializer(Object.class, new JsonSerializer<Object>() { @Override public JsonSerializer<Object> _addSerializer(Class<?> type, JsonSerializer<Object> ser) { return null; } }); serializers._addSerializer(Object.class, new JsonSerializer<Object>() { @Override public JsonSerializer<Object> _addSerializer(Class<?> type, Json
@Test public void test_addSerializer() throws Exception { SimpleSerializers serializers = new SimpleSerializers(); List<JsonSerializer<?>> serializersList = new ArrayList<JsonSerializer<?>>(); serializersList.add(new JsonSerializer<Object>() { @Override public void serialize(Object obj, JsonWriter writer) throws IOException { writer.write("test"); } }); serializersList.add(new JsonSerializer<Object>() { @Override public void serialize(Object obj, JsonWriter writer) throws IOException { writer.write("test2"); } }); serializersList.add(new JsonSerializer<Object>() { @Override public void serialize(Object obj, JsonWriter writer) throws IOException { writer.write("test
@Test public void testSimpleSerializers() throws Exception { SimpleSerializers serializers = new SimpleSerializers(); List<JsonSerializer<?>> serializersList = new ArrayList<JsonSerializer<?>>(); serializersList.add(new JsonSerializer<Object>() { @Override public void serialize(Object obj, JsonWriter writer) throws IOException { writer.write("test"); } }); serializersList.add(new JsonSerializer<Object>() { @Override public void serialize(Object obj, JsonWriter writer) throws IOException { writer.write("test2"); } }); serializersList.add(new JsonSerializer<Object>() { @Override public void serialize(Object obj, JsonWriter writer) throws IOException { writer.write("test
@Test public void testAddSerializer() throws Exception { SimpleSerializers serializers = new SimpleSerializers(); List<JsonSerializer<?>> serializersList = new ArrayList<JsonSerializer<?>>(); serializersList.add(new JsonSerializer<Object>() { @Override public void serialize(Object obj, JsonWriter writer) throws IOException { writer.write("test"); } }); serializersList.add(new JsonSerializer<Object>() { @Override public void serialize(Object obj, JsonWriter writer) throws IOException { writer.write("test2"); } }); serializersList.add(new JsonSerializer<Object>() { @Override public void serialize(Object obj, JsonWriter writer) throws IOException { writer.write("test3
@Test public void testAddSerializer() throws Exception { SimpleSerializers serializers = new SimpleSerializers(); List<JsonSerializer<?>> serializersList = new ArrayList<JsonSerializer<?>>(); serializersList.add(new JsonSerializer<Object>() { @Override public void serialize(Object obj, JsonWriter writer) throws IOException { writer.write("test"); } }); serializersList.add(new JsonSerializer<Object>() { @Override public void serialize(Object obj, JsonWriter writer) throws IOException { writer.write("test2"); } }); serializersList.add(new JsonSerializer<Object>() { @Override public void serialize(Object obj, JsonWriter writer) throws IOException { writer.write("test3
@Test public void testSimpleSerializers() throws Exception { SimpleSerializers serializers = new SimpleSerializers(); List<JsonSerializer<?>> serializersList = new ArrayList<JsonSerializer<?>>(); serializersList.add(new JsonSerializer<Object>() { @Override public void serialize(Object obj, JsonWriter writer) throws IOException { writer.write("test"); } }); serializersList.add(new JsonSerializer<Object>() { @Override public void serialize(Object obj, JsonWriter writer) throws IOException { writer.write("test2"); } }); serializersList.add(new JsonSerializer<Object>() { @Override public void serialize(Object obj, JsonWriter writer) throws IOException { writer.write("test
@Test public void testSimpleSerializers() { SimpleSerializersserializers = new SimpleSerializers(); JsonSerializer<String> stringSerializer = new JsonSerializer<String>() { @Override public String serialize(Object obj, String s) { return s; } @Override public void write(Object obj, String s) { } @Override public void write(Object obj, String s) { } @Override public void write(Object obj, String s) { } @Override public void write(Object obj, String s) { } @Override public void write(Object obj, String s) { } @Override public void write(Object obj, String s) { } @Override public void write(Object obj, String
@Test public void testFindSerializer() { SimpleSerializers serializers = new SimpleSerializers(); serializers.addSerializer(Object.class, new JsonSerializer<Object>() { @Override public JsonSerializer<Object> addSerializer(SerializationConfig config, Class<?> type, JsonSerializer<Object> ser) { return null; } @Override public void addSerializer(Class<?> type, JsonSerializer<Object> ser) { } }); serializers.addSerializer(Object.class, new JsonSerializer<Object>() { @Override public JsonSerializer<Object> addSerializer(SerializationConfig config, Class<?> type, JsonSerializer<Object> ser) { return null; } @Override public void addSerializer(Class<?
@Test public void testSimpleSerializers() { SimpleSerializers serializers = new SimpleSerializers(); serializers.addSerializer(Object.class, new JsonSerializer<Object>() { @Override public JsonSerializer<Object> addSerializer(SerializationConfig config, Class<?> type, JsonSerializer<Object> ser) { return null; } @Override public void addSerializer(Class<?> type, JsonSerializer<Object> ser) { } }); serializers.addSerializer(Object.class, new JsonSerializer<Object>() { @Override public JsonSerializer<Object> addSerializer(SerializationConfig config, Class<?> type, JsonSerializer<Object> ser) { return null; } @Override public void addSerializer(Class
@Test public void testSimpleSerializers() { SimpleSerializers serializers = new SimpleSerializers(); serializers.addSerializer(Object.class, new JsonSerializer<Object>() { @Override public JsonSerializer<Object> addSerializer(SerializationConfig config, Class<?> type, JsonSerializer<Object> ser) { return null; } }); serializers.addSerializer(Object.class, new JsonSerializer<Object>() { @Override public JsonSerializer<Object> addSerializer(SerializationConfig config, Class<?> type, JsonSerializer<Object> ser) { return null; } }); serializers.addSerializer(Object.class, new JsonSerializer<Object>() { @Override public JsonSerializer<Object> addSerializer(
@Test public void testSimpleSerializers() { SimpleSerializersSerializersSerializersSerializersSerializers = new SimpleSerializersSerializers(); SimpleSerializer<Foo> fooSerializer = new SimpleSerializer<Foo>() { @Override public void addSerializer(Foo foo) { } @Override public void addSerializer(Foo bar) { } }; JsonSerializer<Foo> barSerializer = new SimpleSerializer<Foo>() { @Override public void addSerializer(Foo bar) { } @Override public void addSerializer(Foo bar) { } @Override public void addSerializer(Foo bar) { } @Override public void addSerializer(Foo bar) { } @Override public
@Test public void testSimpleSerializers() { SimpleSerializers serializers = new SimpleSerializers(); serializers.addSerializer(Object.class, new JsonSerializer<Object>() { @Override public JsonSerializer<Object> addSerializer(SerializationConfig config, Class<?> type, JsonSerializer<Object> ser) { return null; } }); serializers.addSerializer(Object.class, new JsonSerializer<Object>() { @Override public JsonSerializer<Object> addSerializer(SerializationConfig config, Class<?> type, JsonSerializer<Object> ser) { return null; } });serializers.addSerializer(Object.class, new JsonSerializer<Object>() { @Override public JsonSerializer<Object> addSerializer
@Test public void testSimpleSerializers() { SimpleSerializers serializers = new SimpleSerializers(); serializers.addSerializer(Object.class, new JsonSerializer<Object>() { @Override public JsonSerializer<Object> addSerializer(SerializationConfig config, Class<?> type, JsonSerializer<Object> ser) { return null; } }); serializers.addSerializer(Object.class, new JsonSerializer<Object>() { @Override public JsonSerializer<Object> addSerializer(SerializationConfig config, Class<?> type, JsonSerializer<Object> ser) { return null; } });serializers.addSerializer(Object.class, new JsonSerializer<Object>() { @Override public JsonSerializer<Object> addSerializer
@Test public void testSimpleSerializers() { SimpleSerializers serializers = new SimpleSerializers(); serializers.addSerializer(MyClass.class, new JsonSerializer<MyClass>() { @Override public JsonSerializer<MyClass> addSerializer(SerializationConfig config, Class<? extends MyClass> type, JsonSerializer<MyClass> ser) { return null; } }); serializers.addSerializer(MyClass.class, new JsonSerializer<MyClass>() { @Override public JsonSerializer<MyClass> addSerializer(SerializationConfig config, Class<? extends MyClass> type, JsonSerializer<MyClass> ser) { return null; } }); assertNull(serializers.findSerializer(new SimpleSerializationConfig(),
@Test public void testSimpleSerializers() { SimpleSerializers serializers = new SimpleSerializers(); serializers.addSerializer(Object.class, new JsonSerializer<Object>() { @Override public void addSerializer(SerializationConfig config, Class<?> type, JsonSerializer<Object> ser) { } @Override public void addSerializer(Class<?> type, JsonSerializer<Object> ser) { } @Override public void addSerializer(Class<?> type, JsonSerializer<Object> ser) { } @Override public void addSerializer(Class<?> type, JsonSerializer<Object> ser) { } @Override public void addSerializer(Class<?> type, JsonSerializer<Object> ser) { } @Override
@Test public void testSimpleSerializers() { SimpleSerializers serializers = new SimpleSerializers(); serializers.addSerializer(Object.class, new JsonSerializer<Object>() { @Override public JsonSerializer<Object> addSerializer(SerializationConfig config, Class<?> type, JsonSerializer<Object> ser) { return null; } }); serializers.addSerializer(Object.class, new JsonSerializer<Object>() { @Override public JsonSerializer<Object> addSerializer(SerializationConfig config, Class<?> type, JsonSerializer<Object> ser) { return null; } @Override public JsonSerializer<Object> addSerializer(SerializationConfig config, Class<?> type, JsonSerializer<Object> ser) { return
@Test public void testSimpleSerializers() { SimpleSerializers serializers = new SimpleSerializers(); serializers.addSerializer(Object.class, new JsonSerializer<Object>() { @Override public JsonSerializer<Object> createSerializer(SerializationConfig config, Class<?> type, BeanDescription beanDesc) { return null; } }); serializers.addSerializer(Object.class, new JsonSerializer<Object>() { @Override public JsonSerializer<Object> createSerializer(SerializationConfig config, Class<?> type, BeanDescription beanDesc) { return new JsonSerializer<Object>() { @Override public JsonSerializer<Object> createSerializer(SerializationConfig config, Class<?> type, BeanDescription beanDesc) { return new
@Test public void testSimpleSerializers() { SimpleSerializersSerializersSerializersSerializersSerializers = new SimpleSerializersSerializers(); SimpleSerializer<TestClass> s1 = new SimpleSerializer<TestClass>(TestClass.class); SimpleSerializer<TestClass> s2 = new SimpleSerializer<TestClass>(TestClass.class); s1.addSerializer(s1); s1.addSerializer(s2); SimpleSerializer<TestClass> s3 = new SimpleSerializer<TestClass>(TestClass.class); s2.addSerializer(s3); SimpleSerializer<TestClass> s4 = new SimpleSerializer<TestClass>(TestClass.class); s2.add
@Test public void testSimpleSerializers() { SimpleSerializers serializers = new SimpleSerializers(); serializers.addSerializer(MyClass.class, new JsonSerializer<MyClass>() { @Override public JsonSerializer<MyClass> addSerializer(SerializationConfig config, Class<? extends MyClass> type, JsonSerializer<MyClass> ser) { return null; } }); serializers.addSerializer(MyClass.class, new JsonSerializer<MyClass>() { @Override public JsonSerializer<MyClass> addSerializer(SerializationConfig config, Class<? extends MyClass> type, JsonSerializer<MyClass> ser) { return null; } }); assertNull(serializers.findSerializer(new SimpleSerializationConfig(),
@Test public void testSimpleSerializers() { SimpleSerializers serializers = new SimpleSerializers(); serializers.addSerializer(Object.class, new JsonSerializer<Object>() { @Override public void addSerializer(SerializationConfig config, Class<?> type, JsonSerializer<Object> ser) { } @Override public void addSerializer(Class<?> type, JsonSerializer<Object> ser) { } @Override public void addSerializer(Class<?> type, JsonSerializer<Object> ser) { } @Override public void addSerializer(Class<?> type, JsonSerializer<Object> ser) { } @Override public void addSerializer(Class<?> type, JsonSerializer<Object> ser) { } @Override
@Test public void testSimpleSerializers() { SimpleSerializers serializers = new SimpleSerializers(); serializers.addSerializer(Object.class, new JsonSerializer<Object>() { @Override public JsonSerializer<Object> addSerializer(SerializationConfig config, Class<?> type, JsonSerializer<Object> ser) { return null; } @Override public void addSerializer(Class<?> type, JsonSerializer<Object> ser) { } }); serializers.addSerializer(Object.class, new JsonSerializer<Object>() { @Override public JsonSerializer<Object> addSerializer(SerializationConfig config, Class<?> type, JsonSerializer<Object> ser) { return null; } @Override public void addSerializer(Class
@Test public void testFindSerializer() { SimpleSerializers serializers = new SimpleSerializers(); serializers.addSerializer(Object.class, new JsonSerializer<Object>() { @Override public JsonSerializer<Object> addSerializer(SerializationConfig config, Class<?> type, JsonSerializer<Object> ser) { return null; } @Override public void addSerializer(Class<?> type, JsonSerializer<Object> ser) { } }); serializers.addSerializer(Object.class, new JsonSerializer<Object>() { @Override public JsonSerializer<Object> addSerializer(SerializationConfig config, Class<?> type, JsonSerializer<Object> ser) { return null; } @Override public void addSerializer(Class<?
@Test public void testFindArraySerializer() { JsonSerializer<String> s1 = new JsonSerializer<String>(String.class); JsonSerializer<String> s2 = new JsonSerializer<String>(String.class); JsonSerializer<String> s3 = new JsonSerializer<String>(String.class); SimpleSerializers serializers = new SimpleSerializers(); serializers.addSerializer(s1); serializers.addSerializer(s2); serializers.addSerializer(s3); serializationConfig.addSerializer(String.class, s1); serializationConfig.addSerializer(String.class, s2); serializationConfig.addSerializer(String.class, s3); serializationConfig.addSerializer(String.
@Test public void testFindArraySerializer() { SimpleSerializers serializers = new SimpleSerializers(); serializers.addSerializer(String.class, new JsonSerializer<String>() { @Override public JsonSerializer<String> createSerializer(SerializationConfig config, MapType type, BeanDescription description, JsonSerializer<Object> elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) { return null; } }); serializers.addSerializer(Integer.class, new JsonSerializer<Integer>() { @Override public JsonSerializer<Integer> createSerializer(SerializationConfig config, MapType type, BeanDescription description, JsonSerializer<Object> elementValueSerializer) { return null; } }); serializers.addSerializer(Long.class, new JsonSerializer
@Test public void testFindMapSerializer() { JsonSerializer<Object> ser = new SimpleSerializers().findMapSerializer(null, null, null, null, null, null); assertTrue(ser.getClass() == null); ser = new SimpleSerializers().findMapSerializer(null, null, null, null, null, null); assertTrue(ser.getClass() == null); ser = new SimpleSerializers().findMapSerializer(null, null, null, null, null, null); assertTrue(ser.getClass() == null); ser = new SimpleSerializers().findMapSerializer(null, null, null, null, null, null); assertTrue(ser.getClass()
@Test public void testFindMapSerializer() { JsonSerializer<Object> ser = new SimpleSerializers().findMapSerializer(null, null, null, null, null, null); assertTrue(ser.getClass() == null); ser = new SimpleSerializers().findMapSerializer(null, null, null, null, null, null); assertTrue(ser.getClass() == null); ser = new SimpleSerializers().findMapSerializer(null, null, null, null, null, null); assertTrue(ser.getClass() == null); ser = new SimpleSerializers().findMapSerializer(null, null, null, null, null, null); assertTrue(ser.getClass()
@Test(expected = JsonMappingException.class) public void testGetSchema() throws JsonMappingException { SimpleSerializerProvider vts = new SimpleSerializerProvider(); AsArraySerializer<TestPojo> serialiser = new AsArraySerializer<TestPojo>( TestPojo.class, vts, false, null, TestPojo.PROPERTY_1, new TestPojoSerializer()); serialiser.withResolved(TestPojo.PROPERTY_1, new TestPojoSerializer()); serialiser.withResolved(TestPojo.PROPERTY_2, new TestPojoSerializer()); serialiser.withResolved(TestPojo.PROPERTY_3, new TestPojoSerializer()); serialiser.getSchema(v
@Test(expected = JsonMappingException.class) public void testGetSchema() throws JsonMappingException { SimpleSerializerProvider vts = new SimpleSerializerProvider(); AsArraySerializer<TestPojo> serialiser = new AsArraySerializer<TestPojo>( TestPojo.class, vts, false, null, null, null) { @Override public TestPojo getSchema(SerializerProvider provider, TypeHint typeHint) { return new TestPojo(); } }; serialiser.getSchema(vts, null); }
@Test(expected = JsonMappingException.class) public void testGetSchema() throws JsonMappingException { SimpleSerializerProvider vts = new SimpleSerializerProvider(); AsArraySerializer<TestPojo> serialiser = new AsArraySerializer<TestPojo>( TestPojo.class, vts, false, null, TestPojo.PROPERTY_1, new TestPojoSerializer()); serialiser.withResolved(TestPojo.PROPERTY_1, new TestPojoSerializer()); serialiser.withResolved(TestPojo.PROPERTY_2, new TestPojoSerializer()); serialiser.withResolved(TestPojo.PROPERTY_3, new TestPojoSerializer()); serialiser.getSchema(v
@Test(expected = JsonMappingException.class) public void testGetSchema() throws JsonMappingException { SimpleSerializerProvider vts = new SimpleSerializerProvider(); AsArraySerializer<TestPojo> serialiser = new AsArraySerializer<TestPojo>(TestPojo.class, vts, false, null, null, null) { @Override public TestPojo getSchema(SerializerProvider provider, TypeHint typeHint) { return new TestPojo(); } }; JsonSerializer<TestPojo> serialiser2 = new JsonSerializer<TestPojo>() { @Override public TestPojo getSchema(SerializerProvider provider, TypeHint typeHint) { return new TestPojo(); } }; serial
@Test(expected = JsonMappingException.class) public void testGetSchema() throws JsonMappingException { SimpleSerializerProvider vts = new SimpleSerializerProvider(); AsArraySerializer<TestPojo> serialiser = new AsArraySerializer<TestPojo>( TestPojo.class, vts, false, null, null, null) { @Override public JsonNode getSchema(SerializerProvider provider, TypeHint typeHint) throws JsonMappingException { throw new JsonMappingException(); } }; TestPojo obj = serialiser.build(TestPojo.class); Assert.assertNotNull(obj); Assert.assertNotNull(obj.getSchema()); Assert.assertNotNull(obj.getSchema().get("items")
@Test(expected = JsonMappingException.class) public void testGetSchema() throws JsonMappingException { SimpleSerializerProvider vts = new SimpleSerializerProvider(); AsArraySerializer<TestPojo> serialiser = new AsArraySerializer<TestPojo>( TestPojo.class, vts, false, null, new TestPojoSerializer(), null) { @Override public TestPojo getSchema(SerializerProvider provider, TypeHint typeHint) { return new TestPojo(); } }; JsonSerializer<TestPojo> jsonSchema = serialiser.getSchema(vts, null); Assert.assertNotNull(jsonSchema); Assert.assertNotNull(jsonSchema.get("items")); Assert.assert
@Test(expected = JsonMappingException.class) public void testGetSchema() throws JsonMappingException { SimpleSerializerProvider vts = new SimpleSerializerProvider(); SimpleSerializer<Integer> es = new SimpleSerializer<Integer>(Integer.class) { @Override public JsonNode getSchema(SerializerProvider provider, TypeHint typeHint) throws JsonMappingException { throw new JsonMappingException(); } }; AsArraySerializer<Integer> es2 = new AsArraySerializer<Integer>(Integer.class) { @Override public JsonNode getSchema(SerializerProvider provider, TypeHint typeHint) throws JsonMappingException { throw new JsonMappingException(); } }; es2.getSchema(es, null); }
@Test(expected = JsonMappingException.class) public void testGetSchema() throws JsonMappingException { SimpleSerializerProvider vts = new SimpleSerializerProvider(); AsArraySerializer<TestPojo> serialiser = new AsArraySerializer<TestPojo>(TestPojo.class, vts, false, null, null, null) { @Override public TestPojo getSchema(SerializerProvider provider, TypeHint typeHint) { return new TestPojo(); } }; JsonSerializer<TestPojo> jsonSchema = serialiser.getSchema(vts, null); Assert.assertNotNull(jsonSchema); Assert.assertNotNull(jsonSchema.get("items")); Assert.assertNotNull(jsonSchema
@Test(expected = JsonMappingException.class) public void testGetSchema() throws JsonMappingException { SimpleSerializerProvider vts = new SimpleSerializerProvider(); SimpleSerializer<Integer> es = new SimpleSerializer<Integer>(Integer.class) { @Override public JsonNode getSchema(SerializerProvider provider, TypeHint typeHint) throws JsonMappingException { throw new JsonMappingException(); } }; AsArraySerializer<Integer> es2 = new AsArraySerializer<Integer>(Integer.class, vts, false, null, null, null) { @Override public JsonNode getSchema(SerializerProvider provider, TypeHint typeHint) throws JsonMappingException { throw new JsonMappingException(); } }; es2.getSchema
@Test(expected = JsonMappingException.class) public void testGetSchema() throws JsonMappingException { SimpleSerializerProvider vts = new SimpleSerializerProvider(); AsArraySerializer<TestPojo> serialiser = new AsArraySerializer<TestPojo>( TestPojo.class, vts, false, new TypeSerializer<TestPojo>() {}, null) { @Override public TestPojo getSchema(SerializerProvider provider, TypeHint typeHint) { return new TestPojo(); } }; serialiser.getSchema(vts, null); }
@Test(expected = JsonMappingException.class) public void testGetSchema() throws JsonMappingException { SimpleSerializerProvider vts = new SimpleSerializerProvider(); AsArraySerializer<TestPojo> serialiser = new AsArraySerializer<TestPojo>( TestPojo.class, vts, false, null, null, new TestPojoSerializer()) { @Override public JsonNode getSchema(SerializerProvider provider, TypeHint typeHint) { return new TestPojo(); } @Override public Type getType() { return null; } }; serialiser.getSchema(vts, null); }
@Test public void testGetSchema() throws JsonMappingException { SimpleSerializerProvider vts = new SimpleSerializerProvider(); SimpleSerializer<String> s1 = new SimpleSerializer<String>(String.class); SimpleSerializer<String> s2 = new SimpleSerializer<String>(String.class); SimpleSerializer<String> s3 = new SimpleSerializer<String>(String.class); SimpleSerializer<String> s4 = new SimpleSerializer<String>(String.class); SimpleSerializer<String> s5 = new SimpleSerializer<String>(String.class); SimpleSerializer<String> s6 = new SimpleSerializer<String>(String.class); SimpleSerializer<String> s7 = new Simple
@Test(expected = JsonMappingException.class) public void testGetSchema() throws JsonMappingException { SimpleSerializerProvider vts = new SimpleSerializerProvider(); AsArraySerializer<TestPojo> serialiser = new AsArraySerializer<TestPojo>( TestPojo.class, vts, false, null, TestPojo.PROPERTY_1, new TestPojoSerializer()); serialiser.withResolved(TestPojo.PROPERTY_1, new TestPojoSerializer()); serialiser.withResolved(TestPojo.PROPERTY_2, new TestPojoSerializer()); serialiser.withResolved(TestPojo.PROPERTY_3, new TestPojoSerializer()); serialiser.getSchema(v
@Test(expected = JsonMappingException.class) public void testGetSchema() throws JsonMappingException { SimpleSerializerProvider vts = new SimpleSerializerProvider(); AsArraySerializer<TestPojo> serialiser = new AsArraySerializer<TestPojo>(TestPojo.class, vts, false, null, null, null) { @Override public TestPojo getSchema(SerializerProvider provider, TypeHint typeHint) { return new TestPojo(); } }; JsonSerializer<TestPojo> jsonSchema = serialiser.getSchema(vts, null); Assert.assertNotNull(jsonSchema); Assert.assertNotNull(jsonSchema.get("items")); Assert.assertNotNull(jsonSchema
@Test(expected = JsonMappingException.class) public void testGetSchema() throws JsonMappingException { SimpleSerializerProvider vts = new SimpleSerializerProvider(); AsArraySerializer<TestPojo> serialiser = new AsArraySerializer<TestPojo>( TestPojo.class, vts, false, null, TestPojo.PROPERTY_1, new TestPojoSerializer(TestPojo.class)); serialiser.withResolved(TestPojo.PROPERTY_1, new TestPojoSerializer(TestPojo.class)); serialiser.withResolved(TestPojo.PROPERTY_2, new TestPojoSerializer(TestPojo.class)); serialiser.getSchema(vts,
@Test public void testGetSchema() throws JsonMappingException { SimpleSerializerProvider vts = new SimpleSerializerProvider(); SimpleSerializer<String> s1 = new SimpleSerializer<String>(String.class); SimpleSerializer<String> s2 = new SimpleSerializer<String>(String.class); SimpleSerializer<String> s3 = new SimpleSerializer<String>(String.class); SimpleSerializer<String> s4 = new SimpleSerializer<String>(String.class); SimpleSerializer<String> s5 = new SimpleSerializer<String>(String.class); SimpleSerializer<String> s6 = new SimpleSerializer<String>(String.class); SimpleSerializer<String> s7 = new Simple
@Test(expected = JsonMappingException.class) public void schema() throws JsonMappingException { SimpleSerializerProvider vts = new SimpleSerializerProvider(); SimpleSerializer<String> s1 = new SimpleSerializer<String>(String.class, vts); SimpleSerializer<Integer> s2 = new SimpleSerializer<Integer>(Integer.class, vts); SimpleSerializer<String> s3 = new SimpleSerializer<String>(String.class, vts); SimpleSerializer<Integer> s4 = new SimpleSerializer<Integer>(Integer.class, vts); SimpleSerializer<String> s5 = new SimpleSerializer<String>(String.class, vts); SimpleSerializer<Integer> s6
@Test(expected = JsonMappingException.class) public void testGetSchema() throws JsonMappingException { SimpleSerializerProvider vts = new SimpleSerializerProvider(); SimpleSerializer s1 = new SimpleSerializer(String.class); SimpleSerializer s2 = new SimpleSerializer(Integer.class); SimpleSerializer s3 = new SimpleSerializer(Integer.class); SimpleSerializer s4 = new SimpleSerializer(String.class); SimpleSerializer s5 = new SimpleSerializer(String.class); SimpleSerializer s6 = new SimpleSerializer(String.class); SimpleSerializer s7 = new SimpleSerializer(String.class); SimpleSerializer s8 = new SimpleSerializer(String.class); SimpleSerializer s9 = new SimpleSerializer(String.
@Test(expected = JsonMappingException.class) public void testGetSchema() throws JsonMappingException { SimpleSerializerProvider vts = new SimpleSerializerProvider(); SimpleSerializer<Integer> es = new SimpleSerializer<Integer>(Integer.class) { @Override public JsonNode getSchema(SerializerProvider provider, TypeHint typeHint) throws JsonMappingException { throw new JsonMappingException(); } @Override public JsonNode getSchema(SerializerProvider provider, TypeHint typeHint) throws JsonMappingException { throw new JsonMappingException(); } @Override public JsonNode getSchema(SerializerProvider provider, TypeHint typeHint) throws JsonMappingException { throw new JsonMappingException(); } @Override public JsonNode getSchema(SerializerProvider provider, TypeHint typeHint)
@Test(expected = JsonMappingException.class) public void testGetSchema() throws JsonMappingException { SimpleSerializerProvider vts = new SimpleSerializerProvider(); AsArraySerializer<TestPojo> serialiser = new AsArraySerializer<TestPojo>( TestPojo.class, vts, false, new SimpleTypeSerializer<TestPojo>(TestPojo.class), null) { @Override public TestPojo getSchema(SerializerProvider provider, TypeHint typeHint) { return new TestPojo(); } }; JsonSerializer<TestPojo> jsonSchema = serialiser.getSchema(vts, null); Assert.assertNotNull(jsonSchema); Assert.assertNotNull(jsonSchema.
@Test public void testGetSchema() throws JsonMappingException { SimpleSerializerProvider vts = new SimpleSerializerProvider(); SimpleSerializer<String> s1 = new SimpleSerializer<String>(String.class); SimpleSerializer<String> s2 = new SimpleSerializer<String>(String.class); SimpleSerializer<String> s3 = new SimpleSerializer<String>(String.class); SimpleSerializer<String> s4 = new SimpleSerializer<String>(String.class); SimpleSerializer<String> s5 = new SimpleSerializer<String>(String.class); SimpleSerializer<String> s6 = new SimpleSerializer<String>(String.class); SimpleSerializer<String> s7 = new Simple
@Test(expected = JsonMappingException.class) public void testGetSchema() throws JsonMappingException { SimpleSerializerProvider vts = new SimpleSerializerProvider(); AsArraySerializer<TestPojo> serialiser = new AsArraySerializer<TestPojo>( TestPojo.class, vts, false, new SimpleTypeSerializer<TestPojo>(TestPojo.class), null) { @Override public TestPojo getSchema(SerializerProvider provider, TypeHint typeHint) { return new TestPojo(); } }; JsonSerializer<TestPojo> jsonSchema = serialiser.getSchema(vts, null); Assert.assertNotNull(jsonSchema); Assert.assertNotNull(jsonSchema.
@Test(expected = JsonMappingException.class) public void testGetSchema() throws JsonMappingException { SimpleSerializerProvider vts = new SimpleSerializerProvider(); AsArraySerializer<TestPojo> serialiser = new AsArraySerializer<TestPojo>(TestPojo.class, vts, false, null, null, null) { @Override public TestPojo getSchema(SerializerProvider provider, TypeHint typeHint) { return new TestPojo(); } }; JsonSerializer<TestPojo> jsonSchema = serialiser.getSchema(vts, null); Assert.assertNotNull(jsonSchema); Assert.assertNotNull(jsonSchema.get("items")); Assert.assertNotNull(jsonSchema
@Test(expected = IllegalArgumentException.class) public void testBadBaseSettings() { new DeserializationConfig(new File("src/test/resources/DeserializationConfigTest.testBadBaseSettings.cfg")).getBaseSettings(); }
@Test public void testWithout() { DeserializationConfig.Builder builder = new DeserializationConfig.Builder(getClass().getResource("deserialization/DeserializationConfigTest.class")); DeserializationConfig config = builder.build(); DeserializationFeature[] features = new DeserializationFeature[LINE].values(); for (int i = 0; i < lines.length; i++) { config = config.without(features[i]); assertEquals(lines[i], config.getMapperFeatures()); } }
@Test public void testWithout() { DeserializationConfig cfg = new DeserializationConfig(new BaseSettings(), SubtypeResolver.getDefault(), Collections.<ClassKey, Class<?>>emptyMap()); assertEquals(0, cfg.getMapperFeatures()); assertEquals(0, cfg.getDeserializationFeatures()); assertEquals(0, cfg.getDeserializationFeatures(SubtypeResolver.getDefault()).getMapperFeatures()); assertEquals(0, cfg.getDeserializationFeatures(SubtypeResolver.getDefault()).getDeserializationFeatureMap().size()); assertEquals(0, cfg.getDeserializationFeatures(SubtypeResolver.getDefault()).getDeserializationFeatureMap().size()); assertEquals(
@Test public void testWithout() { final DeserializationConfig cfg = new DeserializationConfig(new BaseSettings(), SubtypeResolver.getDefault(), Collections.<ClassKey, Class<?>>emptyMap()); assertEquals(0, cfg.getMapperFeatures()); final DeserializationConfig cfg2 = cfg.without(DeserializationFeature.class); assertEquals(1, cfg2.getMapperFeatures()); assertEquals(0, cfg2.getMapperFeatures()); final DeserializationConfig cfg3 = cfg.without(DeserializationFeature.class); assertEquals(2, cfg3.getMapperFeatures()); assertEquals(0, cfg3.getMapperFeatures()); final DeserializationConfig cfg4 = cfg.
@Test public void testParse() { Assert.assertEquals(Integer.class, parse("int").getClass()); Assert.assertEquals(Boolean.class, parse("boolean").getClass()); Assert.assertEquals(Long.class, parse("long").getClass()); Assert.assertEquals(Long.class, parse("long").getClass()); Assert.assertEquals(Long.class, parse("long").getClass()); Assert.assertEquals(Long.class, parse("long").getClass()); Assert.assertEquals(Long.class, parse("long").getClass()); Assert.assertEquals(Long.class, parse("long").getClass()); Assert.assertEquals(Long.class, parse("long
@Test public void testParse() { Assert.assertEquals(String.class, parse("String").getClass()); Assert.assertEquals(Integer.class, parse("Integer").getClass()); Assert.assertEquals(Long.class, parse("Long").getClass()); Assert.assertEquals(Long.class, parse("Long").getClass()); Assert.assertEquals(Long.class, parse("Long").getClass()); Assert.assertEquals(Double.class, parse("Double").getClass()); Assert.assertEquals(Double.class, parse("Double").getClass()); Assert.assertEquals(Double.class, parse("Double").getClass()); Assert.assertEquals(Double.class, parse("Double
@Test public void testParse() { Assert.assertEquals(String.class, parse("java.lang.String").getClass()); Assert.assertEquals(Integer.class, parse("int").getClass()); Assert.assertEquals(Long.class, parse("long").getClass()); Assert.assertEquals(Long.class, parse("long").getClass()); Assert.assertEquals(Long.class, parse("long").getClass()); Assert.assertEquals(Double.class, parse("double").getClass()); Assert.assertEquals(Double.class, parse("double").getClass()); Assert.assertEquals(Double.class, parse("double").getClass()); Assert.assertEquals(Double.class
@Test public void testParse() { Assert.assertEquals(Integer.class, parse("int").getClass()); Assert.assertEquals(Boolean.class, parse("boolean").getClass()); Assert.assertEquals(Long.class, parse("long").getClass()); Assert.assertEquals(Long.class, parse("long").getClass()); Assert.assertEquals(Long.class, parse("long").getClass()); Assert.assertEquals(Double.class, parse("double").getClass()); Assert.assertEquals(Double.class, parse("double").getClass()); Assert.assertEquals(Double.class, parse("double").getClass()); Assert.assertEquals(Double.class, parse("double
@Test public void testParse() { Assert.assertEquals(Integer.class, parse("int").getClass()); Assert.assertEquals(Boolean.class, parse("boolean").getClass()); Assert.assertEquals(Long.class, parse("long").getClass()); Assert.assertEquals(Long.class, parse("long").getClass()); Assert.assertEquals(Long.class, parse("long").getClass()); Assert.assertEquals(Double.class, parse("double").getClass()); Assert.assertEquals(Double.class, parse("double").getClass()); Assert.assertEquals(Double.class, parse("double").getClass()); Assert.assertEquals(Double.class, parse("double
@Test public void testParse() { Assert.assertEquals(Integer.class, parse("int").getClass()); Assert.assertEquals(Boolean.class, parse("boolean").getClass()); Assert.assertEquals(Long.class, parse("long").getClass()); Assert.assertEquals(Long.class, parse("long").getClass()); Assert.assertEquals(Long.class, parse("long").getClass()); Assert.assertEquals(Double.class, parse("double").getClass()); Assert.assertEquals(Double.class, parse("double").getClass()); Assert.assertEquals(Double.class, parse("double").getClass()); Assert.assertEquals(Double.class, parse("double
@Test public void testParseType() { Assert.assertEquals(String.class, parseType(String.class).getClass()); Assert.assertEquals(String.class, parseType(String.class.getSimpleName()).getClass()); Assert.assertEquals(String.class, parseType(String.class.getSimpleName() + "_String").getClass()); Assert.assertEquals(String.class, parseType(String.class.getSimpleName() + "_String").getClass()); Assert.assertEquals(String.class, parseType(String.class.getSimpleName() + "_String").getClass()); Assert.assertEquals(String.class, parseType(String.class
@Test public void testParseType() { Assert.assertEquals(String.class, parseType(String.class).getClass()); Assert.assertEquals(String.class, parseType(String.class.getSimpleName()).getClass()); Assert.assertEquals(String.class, parseType(String.class.getSimpleName() + "_String").getClass()); Assert.assertEquals(String.class, parseType(String.class.getSimpleName() + "_String").getClass()); Assert.assertEquals(String.class, parseType(String.class.getSimpleName() + "_String").getClass()); Assert.assertEquals(String.class, parseType(String.class
@Test public void testParseType() { Assert.assertEquals(String.class, parseType("String").getClass()); Assert.assertEquals(String.class, parseType("<String>").getClass()); Assert.assertEquals(String.class, parseType("<String>").getClass()); Assert.assertEquals(String.class, parseType("<String>").getClass()); Assert.assertEquals(String.class, parseType("<String>").getClass()); Assert.assertEquals(String.class, parseType("<String>").getClass()); Assert.assertEquals(String.class, parseType("<String>").getClass()); Assert.assertEquals(String.class
@Test public void testParseType() { Assert.assertEquals(String.class, parseType(String.class).getClass()); Assert.assertEquals(String.class, parseType(String.class.getSimpleName()).getClass()); Assert.assertEquals(String.class, parseType(String.class.getSimpleName() + "_String").getClass()); Assert.assertEquals(String.class, parseType(String.class.getSimpleName() + "_String").getClass()); Assert.assertEquals(String.class, parseType(String.class.getSimpleName() + "_String").getClass()); Assert.assertEquals(String.class, parseType(String.class
@Test public void testParseType() { Assert.assertEquals(String.class, _parser._fromClass(String.class, null).getClass()); Assert.assertEquals(String.class, _parser._fromClass(String.class, null).getClass()); Assert.assertEquals(String.class, _parser._fromClass(String.class, null).getClass()); Assert.assertEquals(String.class, _parser._fromClass(String.class, null).getClass()); Assert.assertEquals(String.class, _parser._fromClass(String.class, null).getClass()); Assert.assertEquals(String.class, _parser._fromClass(String.class,
@Test public void testFindClass() { Assert.assertEquals(String.class, ClassUtil.findClass("java.lang.String", new MyTokenizer("java.lang.String"))); Assert.assertEquals(String.class, ClassUtil.findClass("java.lang.String", new MyTokenizer("java.lang.String"))); Assert.assertEquals(String.class, ClassUtil.findClass("java.lang.String", new MyTokenizer("java.lang.String"))); Assert.assertEquals(String.class, ClassUtil.findClass("java.lang.String", new MyTokenizer("java.lang.String"))); Assert.assertEquals(String.
@Test(expected = IllegalArgumentException.class) public void testFindClass() throws Exception { Class<?> cls = ClassUtil.findClass("java.lang.String", new MyTokenizer("java.lang.String")); Assert.assertNotNull(cls); Assert.assertEquals(String.class, cls); cls = ClassUtil.findClass("java.lang.Integer", new MyTokenizer("java.lang.Integer")); Assert.assertNotNull(cls); Assert.assertEquals(Integer.class, cls); cls = ClassUtil.findClass("java.lang.Long", new MyTokenizer("java.lang.Long")); Assert.assertNotNull(cls); Assert.assertEquals(Long.class,
@Test public void testFindClass() { Assert.assertEquals(String.class, ClassUtil.findClass("java.lang.String", new MyTokenizer("java.lang.String"))); Assert.assertEquals(String.class, ClassUtil.findClass("java.lang.String", new MyTokenizer("java.lang.String"))); Assert.assertEquals(String.class, ClassUtil.findClass("java.lang.String", new MyTokenizer("java.lang.String"))); Assert.assertEquals(String.class, ClassUtil.findClass("java.lang.String", new MyTokenizer("java.lang.String"))); Assert.assertEquals(String.
@Test public void testMyTokenizer() { System.out.println("MyTokenizer.MyTokenizer.MyTokenizer.MyTokenizer.MyTokenizer.MyTokenizer.MyTokenizer.MyTokenizer.MyTokenizer.MyTokenizer.MyTokenizer.MyTokenizer.MyTokenizer.MyTokenizer.MyTokenizer.MyTokenizer.MyTokenizer.MyTokenizer.MyTokenizer.MyTokenizer.MyTokenizer.MyTokenizer.MyTokenizer.MyTokenizer.MyTokenizer.MyTokenizer.MyTokenizer.MyTokenizer.MyTokenizer.MyTokenizer.MyTokenizer.MyTokenizer.MyTokenizer.MyTokenizer.MyTokenizer.MyTokenizer.MyTokenizer.MyTokenizer.MyTokenizer.MyTokenizer.MyTokenizer.MyTokenizer.MyTokenizer.MyTokenizer.My
@Test public void testMyTokenizer() { System.out.println(MyTokenizer.class.getName()); System.out.println(MyTokenizer.getClass().getName()); System.out.println(MyTokenizer.getClass().getSimpleName()); System.out.println(MyTokenizer.getClass().getSimpleName() + ": " + MyTokenizer.getClass().getSimpleName()); System.out.println(MyTokenizer.getClass().getSimpleName() + ": " + MyTokenizer.getClass().getSimpleName()); System.out.println(MyTokenizer.getClass().getSimpleName() + ": " + MyTokenizer.getClass().getSimpleName()); MyTokenizer instance = new My
@Test public void testMyTokenizer() { System.out.println("MyTokenizer"); MyTokenizer instance = new MyTokenizer(this.getClass().getCanonicalName()); assertEquals(instance.getAllInput(), this.getClass().getCanonicalName()); assertEquals(instance.getUsedInput(), this.getClass().getCanonicalName()); assertEquals(instance.getParsedInput(), this.getClass().getCanonicalName()); assertTrue(instance.hasNext()); assertEquals(instance.nextToken(), this.getClass().getCanonicalName()); assertTrue(instance.hasNext()); assertEquals(instance.nextToken(), this.getClass().getCanonicalName()); assertTrue(instance.hasNext()); assert
@Test public void testNextToken() { Assert.assertTrue(new TypeParser(new DefaultTypeFactory()).nextToken()); Assert.assertTrue(new TypeParser(new DefaultTypeFactory()).nextToken()); Assert.assertTrue(new TypeParser(new DefaultTypeFactory()).nextToken()); Assert.assertTrue(new TypeParser(new DefaultTypeFactory()).nextToken()); Assert.assertTrue(new TypeParser(new DefaultTypeFactory()).nextToken()); Assert.assertTrue(new TypeParser(new DefaultTypeFactory()).nextToken()); Assert.assertTrue(new TypeParser(new DefaultTypeFactory()).nextToken()); Assert.assertTrue(new TypeParser(new DefaultTypeFactory
@Test public void testEnum() { Assert.assertTrue(TypeParser.INSTANCE.nextToken()); Assert.assertTrue(TypeParser.INSTANCE.nextToken()); Assert.assertTrue(TypeParser.INSTANCE.nextToken()); Assert.assertTrue(TypeParser.INSTANCE.nextToken()); Assert.assertTrue(TypeParser.INSTANCE.nextToken()); Assert.assertTrue(TypeParser.INSTANCE.nextToken()); Assert.assertTrue(TypeParser.INSTANCE.nextToken()); Assert.assertTrue(TypeParser.INSTANCE.nextToken()); Assert.assertTrue(TypeParser.INSTANCE.nextToken()); Assert.assertTrue(TypeParser.INSTANCE.nextToken()); Assert.assertTrue(TypeParser.INSTANCE.
@Test public void testNextToken() { TypeParser f = new TypeParser(new TypeFactory()); Assert.assertEquals("", f.nextToken()); Assert.assertEquals("a", f.nextToken()); Assert.assertEquals("b", f.nextToken()); Assert.assertEquals("c", f.nextToken()); Assert.assertEquals("d", f.nextToken()); Assert.assertEquals("e", f.nextToken()); Assert.assertEquals("f", f.nextToken()); Assert.assertEquals("g", f.nextToken()); Assert.assertEquals("h", f.nextToken()); Assert.assertEquals("i", f.nextToken()); Assert.assertEquals("j", f
@Test public void testTokenizer() { TypeParser t = new TypeParser(new TypeFactory() { @Override public String convert(String str) { return str; } }); t.nextToken(); t.nextToken(); t.nextToken(); t.nextToken(); t.nextToken(); t.nextToken(); t.nextToken(); t.nextToken(); t.nextToken(); t.nextToken(); t.nextToken(); t.nextToken(); t.nextToken(); t.nextToken(); t.nextToken(); t.nextToken(); t.nextToken(); t.nextToken(); t.nextToken(); t.nextToken(); t.nextToken(); t.nextToken(); t.
@Test public void testNextToken() { TypeParser t = new TypeParser(new TypeFactory()); Assert.assertEquals("a", t.nextToken()); Assert.assertEquals("b", t.nextToken()); Assert.assertEquals("c", t.nextToken()); Assert.assertEquals("d", t.nextToken()); Assert.assertEquals("e", t.nextToken()); Assert.assertEquals("f", t.nextToken()); Assert.assertEquals("g", t.nextToken()); Assert.assertEquals("h", t.nextToken()); Assert.assertEquals("i", t.nextToken()); Assert.assertEquals("j", t.nextToken()); Assert.assertEquals("k",
@Test public void testSimple() { TypeParser t = new TypeParser(new SimpleTypeFactory()); t.nextToken(); Assert.assertEquals("a", t.nextToken()); Assert.assertEquals("b", t.nextToken()); Assert.assertEquals("c", t.nextToken()); Assert.assertEquals("d", t.nextToken()); Assert.assertEquals("e", t.nextToken()); Assert.assertEquals("f", t.nextToken()); Assert.assertEquals("g", t.nextToken()); Assert.assertEquals("h", t.nextToken()); Assert.assertEquals("i", t.nextToken()); Assert.assertEquals("j", t.nextToken()); Assert.
@Test public void testNextToken() { TypeParser t = new TypeParser(new TypeFactory()); Assert.assertEquals("a", t.nextToken()); Assert.assertEquals("b", t.nextToken()); Assert.assertEquals("c", t.nextToken()); Assert.assertEquals("d", t.nextToken()); Assert.assertEquals("e", t.nextToken()); Assert.assertEquals("f", t.nextToken()); Assert.assertEquals("g", t.nextToken()); Assert.assertEquals("h", t.nextToken()); Assert.assertEquals("i", t.nextToken()); Assert.assertEquals("j", t.nextToken()); Assert.assertEquals("k",
@Test public void testNextToken() { TypeParser t = new TypeParser(new TypeFactory()); Assert.assertEquals("a", t.nextToken()); Assert.assertEquals("b", t.nextToken()); Assert.assertEquals("c", t.nextToken()); Assert.assertEquals("d", t.nextToken()); Assert.assertEquals("e", t.nextToken()); Assert.assertEquals("f", t.nextToken()); Assert.assertEquals("g", t.nextToken()); Assert.assertEquals("h", t.nextToken()); Assert.assertEquals("i", t.nextToken()); Assert.assertEquals("j", t.nextToken()); Assert.assertEquals("k",
@Test public void testReadableObjectId() throws IOException { Object id = new Object(); ReadableObjectId idLine = new ReadableObjectId(id); assertEquals(id, idLine.id); }
@Test public void testReadableObjectId() throws IOException { Object id = new Object(); ReadableObjectId o = new ReadableObjectId(id); assertSame(id, o.id); assertSame(id, o.item); o.bindItem(new Object()); assertSame(id, o.item); o.bindItem(new Object()); assertSame(id, o.item); }
@Test public void testBindItem() throws Exception { ReadableObjectId id = new ReadableObjectId("test"); try { id.bindItem(new Object()); fail(); } catch (IllegalStateException e) { assertEquals("Already had POJO for id (" + id + ")", e.getMessage()); } id.setItem(new Object()); try { id.bindItem(new Object()); fail(); } catch (IllegalStateException e) { assertEquals("Already had POJO for id (" + id + ")", e.getMessage()); } id.setItem(new Object()); try { id.bindItem(new Object()); fail(); } catch (IllegalStateException e) { assertEquals("Already had POJO for id (" +
@Test public void testBindItem() throws Exception { ReadableObjectId id = new ReadableObjectId("a"); ReadableObjectId b = new ReadableObjectId("b"); ReadableObjectId c = new ReadableObjectId("c"); assertNull(id.getItem()); assertNull(b.getItem()); assertNull(c.getItem()); b.bindItem(new Object()); assertSame(id, id.getItem()); assertSame(id, b.getItem()); b.bindItem(new Object()); assertSame(id, b.getItem()); assertSame(id, b.getItem()); b.bindItem(new Object()); assertSame(id, b.getItem()); assertSame(id, b.getItem
@Test public void testBindItem() throws Exception { ReadableObjectId<TestObject> id = new ReadableObjectId<TestObject>("test"); TestObject t1 = new TestObject(); TestObject t2 = new TestObject(); TestObject t3 = new TestObject(); TestObject t4 = new TestObject(); id.bindItem(t1); id.bindItem(t2); id.bindItem(t3); id.bindItem(t4); assertEquals(t1, id.item); assertEquals(t2, id.item2); assertEquals(t3, id.item3); assertEquals(t4, id.item4); }
@Test public void testIsUnwrappingSerializer() { assertThat(unwrapper.isUnwrappingSerializer(), is(false)); }
@Test public void testIsUnwrappingSerializer() { assertThat(unwrapper.isUnwrappingSerializer()).isFalse(); assertThat(delegatee.isUnwrappingSerializer()).isFalse(); }
@Test public void testStdDateFormat() throws ParseException { SimpleDateFormat f = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); TimeZone tz = TimeZone.getTimeZone("America/Los_Angeles"); StdDateFormat df = StdDateFormat.getInstance(tz); System.out.println(df.format(new Date(0))); System.out.println(df.format(new Date(1))); System.out.println(df.format(new Date(2))); System.out.println(df.format(new Date(3))); System.out.println(df.format(new Date(4))); System.out
@Test public void testStdDateFormat() throws ParseException { SimpleDateFormat f = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); TimeZone tz = TimeZone.getTimeZone("America/Los_Angeles"); StdDateFormat df = StdDateFormat.getInstance(tz); System.out.println(df.format(new Date(0))); System.out.println(df.format(new Date(1))); System.out.println(df.format(new Date(2))); System.out.println(df.format(new Date(3))); System.out.println(df.format(new Date(4))); System.out
@Test public void testWithTimeZone() { StdDateFormat df = new StdDateFormat().withTimeZone(TimeZone.getTimeZone("PST")); System.out.println(df.format(new Date(0))); System.out.println(df.format(new Date(1))); System.out.println(df.format(new Date(2))); System.out.println(df.format(new Date(3))); System.out.println(df.format(new Date(4))); System.out.println(df.format(new Date(5))); System.out.println(df.format(new Date(6))); System.out.println(df
@Test public void testWithTimeZone() { StdDateFormat df = new StdDateFormat().withTimeZone(TimeZone.getTimeZone("PST")); System.out.println(df.format(new Date(0))); System.out.println(df.format(new Date(1))); System.out.println(df.format(new Date(2))); System.out.println(df.format(new Date(3))); System.out.println(df.format(new Date(4))); System.out.println(df.format(new Date(5))); System.out.println(df.format(new Date(6))); System.out.println(df
@Test public void testWithTimeZone() throws ParseException { StdDateFormat df = new StdDateFormat().withTimeZone(TimeZone.getTimeZone("PST")); System.out.println(df.format(new Date(0))); System.out.println(df.format(new Date(1))); System.out.println(df.format(new Date(2))); System.out.println(df.format(new Date(3))); System.out.println(df.format(new Date(4))); System.out.println(df.format(new Date(5))); System.out.println(df.format(new Date(6))); System.out.println
@Test public void testParse() throws ParseException { Calendar cal = Calendar.getInstance(); cal.setTimeInMillis(0); cal.set(Calendar.HOUR_OF_DAY, 0); cal.set(Calendar.MINUTE, 0); cal.set(Calendar.SECOND, 0); Calendar cal2 = Calendar.getInstance(); cal2.setTimeInMillis(0); cal2.set(Calendar.HOUR_OF_DAY, 0); cal2.set(Calendar.MINUTE, 0); cal2.set(Calendar.SECOND, 0); Calendar cal3 = Calendar.getInstance(); cal3.setTimeInMillis(0); cal3.set(Calendar.HOUR_OF_DAY, 0);
@Test public void testParse() throws ParseException { Calendar cal = Calendar.getInstance(); cal.setTimeInMillis(0); cal.set(Calendar.HOUR_OF_DAY, 0); cal.set(Calendar.MINUTE, 0); cal.set(Calendar.SECOND, 0); Calendar cal2 = Calendar.getInstance(); cal2.setTimeInMillis(0); cal2.set(Calendar.HOUR_OF_DAY, 0); cal2.set(Calendar.MINUTE, 0); cal2.set(Calendar.SECOND, 0); Calendar cal3 = Calendar.getInstance(); cal3.setTimeInMillis(0); cal3.set(Calendar.HOUR_OF_DAY, 0);
@Test public void parseAsISO8601() throws ParseException { SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); format.setTimeZone(TimeZone.getTimeZone("UTC")); SimpleDateFormat format2 = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); format2.setTimeZone(TimeZone.getTimeZone("UTC")); DateFormat format3 = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); format3.setTimeZone(TimeZone.getTimeZone("UTC")); DateFormat format4 = new SimpleDateFormat("yyyy-MM-dd\'T\'
@Test public void parseAsISO8601() { DateFormat format = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); DateFormat format2 = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); DateFormat format3 = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); DateFormat format4 = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); DateFormat format5 = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); DateFormat format6 =
@Test public void parseAsISO8601() { DateFormat format = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); DateFormat format2 = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); DateFormat format3 = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); DateFormat format4 = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); DateFormat format5 = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); DateFormat format6 =
@Test public void parseAsISO8601() { DateFormat format = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); DateFormat format2 = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); DateFormat format3 = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); DateFormat format4 = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); DateFormat format5 = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); DateFormat format6 =
@Test public void parseAsISO8601() throws ParseException { SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); format.setTimeZone(TimeZone.getTimeZone("UTC")); SimpleDateFormat format2 = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); format2.setTimeZone(TimeZone.getTimeZone("UTC")); DateFormat format3 = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); format3.setTimeZone(TimeZone.getTimeZone("UTC")); DateFormat format4 = new SimpleDateFormat("yyyy-MM-dd\'T\'
@Test public void parseAsISO8601() { DateFormat format = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); DateFormat format2 = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); DateFormat format3 = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); DateFormat format4 = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); DateFormat format5 = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); DateFormat format6 =
@Test public void parseAsISO8601() { DateFormat format = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); DateFormat format2 = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); DateFormat format3 = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); DateFormat format4 = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); DateFormat format5 = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); DateFormat format6 =
@Test public void parseAsISO8601() throws ParseException { SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); format.setTimeZone(TimeZone.getTimeZone("UTC")); SimpleDateFormat format2 = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); format2.setTimeZone(TimeZone.getTimeZone("UTC")); DateFormat format3 = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); format3.setTimeZone(TimeZone.getTimeZone("UTC")); DateFormat format4 = new SimpleDateFormat("yyyy-MM-dd\'T\'
@Test public void parseAsISO8601() { DateFormat format = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); DateFormat format2 = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); DateFormat format3 = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); DateFormat format4 = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); DateFormat format5 = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); DateFormat format6 =
@Test public void parseAsISO8601() { DateFormat format = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); DateFormat format2 = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); DateFormat format3 = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); DateFormat format4 = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); DateFormat format5 = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); DateFormat format6 =
@Test public void parseAsISO8601() { DateFormat format = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); DateFormat format2 = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); DateFormat format3 = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); DateFormat format4 = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); DateFormat format5 = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); DateFormat format6 =
@Test public void parseAsISO8601() throws ParseException { DateFormat format = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); DateFormat format2 = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); DateFormat format3 = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); DateFormat format4 = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); DateFormat format5 = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); Date date
@Test public void parseAsISO8601() { DateFormat format = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); DateFormat format2 = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); DateFormat format3 = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); DateFormat format4 = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); DateFormat format5 = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); DateFormat format6 =
@Test public void parseAsISO8601() { DateFormat format = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); DateFormat format2 = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); DateFormat format3 = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); DateFormat format4 = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); DateFormat format5 = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); DateFormat format6 =
@Test public void parseAsISO8601() { DateFormat format = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); DateFormat format2 = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); DateFormat format3 = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); DateFormat format4 = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); DateFormat format5 = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); DateFormat format6 =
@Test public void parseAsISO8601() throws ParseException { DateFormat format = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); DateFormat format2 = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); DateFormat format3 = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); DateFormat format4 = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); DateFormat format5 = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); Date date
@Test public void testHasTimeZone() throws ParseException { System.out.println( StdDateFormat.getISO8601Format().format(new Date(0))); System.out.println( StdDateFormat.getISO8601Format().format(new Date(1))); System.out.println( StdDateFormat.getISO8601Format().format(new Date(2))); System.out.println( StdDateFormat.getISO8601Format().format(new Date(3))); System.out.println( StdDateFormat.getISO8601Format().format(new Date(4))); System.out.println( StdDateFormat.getISO8601Format().format(new Date(5))); System.out.println
@Test public void testGetJAXB8601Format() throws ParseException { SimpleDateFormat f = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); Date date = f.parse("2001-01-01T00:00:00.000Z"); System.out.println(date); assertEquals("2001-01-01T00:00:00.000Z", f.format(date)); date = f.parse("2001-01-01T00:00:00.000Z"); System.out.println(date); assertEquals("2001-01-01T00:00:00.000Z", f.format
@Test public void testHasTimeZone() throws ParseException { System.out.println( StdDateFormat.getISO8601Format().format(new Date(0))); System.out.println( StdDateFormat.getISO8601Format().format(new Date(1))); System.out.println( StdDateFormat.getISO8601Format().format(new Date(2))); System.out.println( StdDateFormat.getISO8601Format().format(new Date(3))); System.out.println( StdDateFormat.getISO8601Format().format(new Date(4))); System.out.println( StdDateFormat.getISO8601Format().format(new Date(5))); System.out.println
@Test public void testSimpleBeanPropertyFilter() throws IOException { SimpleBeanPropertyFilter filter = new SimpleBeanPropertyFilter() { @Override public boolean include(BeanPropertyWriter writer, ObjectNode propertiesNode, SerializerProvider provider) throws JsonMappingException, JsonMappingException { return true; } @Override public boolean include(BeanPropertyWriter writer, ObjectNode propertiesNode, SerializerProvider provider) throws JsonMappingException, JsonMappingException { return true; } @Override public boolean include(BeanPropertyWriter writer, ObjectNode propertiesNode, SerializerProvider provider) throws JsonMappingException, JsonMappingException { return true; } @Override public boolean include(BeanPropertyWriter writer, ObjectNode propertiesNode, SerializerProvider provider) throws JsonMapping
@Test public void testSerializeAllExcept() throws IOException { Set<String> properties = new HashSet<String>(); properties.add("foo"); properties.add("bar"); properties.add("baz"); SimpleBeanPropertyFilter filter = SimpleBeanPropertyFilter.serializeAllExcept(properties); ByteArrayOutputStream out = new ByteArrayOutputStream(); filter.serializeAsField(new SimpleBean(properties), new JsonGeneratorAdapter(), null, new DefaultSerializerProvider()); Assert.assertEquals(new String(out.toByteArray()), "[\\n" + " {\\n" + " \\"foo\\": \\"bar\\"\\n" + " },\\n" + " {\\n" + " \\"bar\\": \\
@Test public void testSerializeAllExcept() throws IOException { SimpleBeanPropertyFilter propertyFilter = SimpleBeanPropertyFilter.serializeAllExcept("id", "name", "age"); assertJsonEquals("{\\"id\\":\\"id\\",\\"name\\":\\"name\\",\\"age\\":30}", propertyFilter.serializeAllExcept("id", "name", "age").serialize()); assertJsonEquals("{\\"id\\":\\"id\\",\\"name\\":\\"name\\",\\"age\\":30}", propertyFilter.serializeAllExcept("id", "name").serialize()); assertJsonEquals("{\\"id\\":\\"id\\",\\"name\\":\\"name\\",\\"age\\":
@Test public void testSerializeAllExcept() throws IOException { SimpleBeanPropertyFilter filter = SimpleBeanPropertyFilter.serializeAllExcept("name", "age"); JsonGenerator jgen = mock(JsonGenerator.class); BeanPropertyWriter writer = mock(BeanPropertyWriter.class); filter.include(jgen, null, null, writer); verify(jgen).close(); verify(writer).beginObject(); verify(writer).write("{\\"name\\":\\"name\\",\\"age\\":30}"); verify(writer).endObject(); verify(writer).beginObject(); verify(writer).write("{\\"name\\":\\"age\\",\\"age\\":30}"); verify(writer).endObject
@Test public void serializeAllExcept() throws IOException { SimpleBeanPropertyFilter propertyFilter = SimpleBeanPropertyFilter.serializeAllExcept("id", "name"); assertThat(propertyFilter.include(writer), is(true)); assertThat(writer.toString(), equalTo("{\\"id\\":\\"name\\",\\"name\\":\\"name\\"}")); }
@Test public void serializeAsField() throws Exception { SimpleBeanPropertyWriter writer = new SimpleBeanPropertyWriter(); SimpleBeanPropertyFilter propertyFilter = new SimpleBeanPropertyFilter(); propertyFilter.include(writer); propertyFilter.serializeAsField(bean, jgen, provider, writer); assertThat(writer.getPropertyCount(), is(1)); }
@Test public void serializeAsField() throws Exception { SimpleBeanPropertyWriter writer = new SimpleBeanPropertyWriter(); SimpleBeanPropertyFilter f = SimpleBeanPropertyFilter.excludeAllExcept(Arrays.asList("id", "name")); f.serializeAsField(new Bean(), gen, provider, writer); assertThat(writer.getPropertyCount()).isEqualTo(1); assertThat(writer.getProperty("id").getAsString()).isEqualTo("id"); assertThat(writer.getProperty("name").getAsString()).isEqualTo("name"); f.serializeAsField(new Bean(), gen, provider, writer); assertThat(writer.getPropertyCount()).isEqualTo
@Test public void serializeAsField() throws Exception { SimpleBeanPropertyWriter writer = new SimpleBeanPropertyWriter(); SimpleBeanPropertyFilter propertyFilter = new SimpleBeanPropertyFilter(Arrays.asList("id", "name")); propertyFilter.include(writer); propertyFilter.serializeAsField("id", writer, null, new DefaultSerializerProvider()); Assertions.assertThat(writer.getPropertyCount()).isEqualTo(1); Assertions.assertThat(writer.getProperty("name").getAsString()).isEqualTo("id"); propertyFilter.serializeAsField("name", writer, null, new DefaultSerializerProvider()); Assertions.assertThat(writer.getPropertyCount()).isEqualTo
@Test public void depositSchemaProperty() throws Exception { SimpleBeanPropertyWriter w = new SimpleBeanPropertyWriter(); SimpleBeanPropertyFilter f = new SimpleBeanPropertyFilter(); f.include(w, new JsonFormatVisitor() { @Override public Object visitObject(Object object, JsonGenerator jgen, SerializerProvider provider) throws JsonMappingException { return null; } @Override public Object visitObject(Object object, JsonGenerator jgen, SerializerProvider provider) throws JsonMappingException { return null; } @Override public Object visitObject(Object object, JsonGenerator jgen, SerializerProvider provider) throws JsonMappingException { return null; } @Override public Object visitObject(Object object, JsonGenerator jgen, Serializer
@Test public void testDepositSchemaProperty() throws Exception { SimpleBeanPropertyWriter w = new SimpleBeanPropertyWriter(); Map<String, Object> properties = new LinkedHashMap<String, Object>(); properties.put("field1", "value1"); properties.put("field2", "value2"); properties.put("field3", "value3"); properties.put("field4", "value4"); SimpleBeanPropertyFilter f = SimpleBeanPropertyFilter.serializeAllExcept(properties); f.include(w); f.depositSchemaProperty(w, new ObjectMapper().createObjectNode(), new DefaultSerializerProvider()); f.depositSchemaProperty(w, new ObjectMapper().createObjectNode(), new DefaultSerializer
@Test public void depositSchemaProperty() throws Exception { SimpleBeanPropertyWriter writer = new SimpleBeanPropertyWriter(); SimpleBeanPropertyFilter f = new SimpleBeanPropertyFilter(); f.include(writer, new JsonFormatVisitor() { @Override public Object visitObject(Object object, JsonGenerator jgen, SerializerProvider provider) throws JsonMappingException { return null; } @Override public Object visitObject(Object object, JsonGenerator jgen, SerializerProvider provider) throws JsonMappingException { return null; } @Override public Object visitObject(Object object, JsonGenerator jgen, SerializerProvider provider) throws JsonMappingException { return null; } @Override public Object visitObject(Object object, JsonGenerator jgen, Serializer
@Test public void include() throws Exception { SimpleBeanPropertyWriter writer = createMock(SimpleBeanPropertyWriter.class); expect(writer.getName()).andReturn("someProperty"); expect(writer.isEmpty()).andReturn(false); replay(writer); FilterExceptFilter f = new FilterExceptFilter(ImmutableSet.of("someProperty")); assertThat(f.include(writer), is(true)); assertThat(writer.toString(), is("someProperty\\n")); verify(writer); }
@Test public void testInclude() throws Exception { Set<String> properties = new HashSet<String>(); properties.add("x"); properties.add("y"); properties.add("z"); SimpleBeanPropertyFilter propertyFilter = new SimpleBeanPropertyFilter(properties); Assert.assertTrue(propertyFilter.include(writer("x"))); Assert.assertTrue(propertyFilter.include(writer("y"))); Assert.assertTrue(propertyFilter.include(writer("z"))); Assert.assertFalse(propertyFilter.include(writer("x"))); Assert.assertFalse(propertyFilter.include(writer("z"))); }
@Test public void testSerializeExceptFilter() throws IOException { Set<String> properties = new HashSet<>(); properties.add("a"); properties.add("b"); properties.add("c"); properties.add("d"); properties.add("e"); properties.add("f"); properties.add("g"); properties.add("h"); SimpleBeanPropertyFilter instance = new SimpleBeanPropertyFilter() { @Override public boolean include(BeanPropertyWriter writer) throws JsonMappingException, JsonProcessingException { return true; } @Override public boolean include(BeanPropertyWriter writer) throws JsonMappingException, JsonProcessingException { return true; } @Override public boolean include(BeanPropertyWriter writer) throws JsonMappingException, JsonMappingException
@Test public void testSerializeExceptFilter() throws IOException { Set<String> properties = new HashSet<String>(); properties.add("a"); properties.add("b"); properties.add("c"); properties.add("d"); properties.add("e"); properties.add("f"); properties.add("g"); properties.add("h"); SimpleBeanPropertyFilter instance = new SimpleBeanPropertyFilter() { @Override public boolean include(BeanPropertyWriter writer) throws JsonMappingException, JsonProcessingException { return true; } @Override public boolean include(BeanPropertyWriter writer) throws JsonMappingException, JsonProcessingException { return true; } @Override public boolean include(BeanPropertyWriter writer) throws JsonMappingException, Json
@Test public void include() throws Exception { SimpleBeanPropertyWriter writer = createMock(SimpleBeanPropertyWriter.class); expect(writer.getName()).andReturn("x").anyTimes(); expect(writer.isEmpty()).andReturn(false).anyTimes(); replay(writer); FilterExceptFilter f = new FilterExceptFilter(ImmutableSet.of("x")); f.include(writer); verify(writer); }
@Test public void testInclude() throws Exception { Set<String> properties = new HashSet<String>(); properties.add("x"); properties.add("y"); properties.add("z"); SimpleBeanPropertyFilter propertyFilter = new SimpleBeanPropertyFilter(properties); Assert.assertTrue(propertyFilter.include(new DefaultBeanPropertyWriter("x"))); Assert.assertTrue(propertyFilter.include(new DefaultBeanPropertyWriter("y"))); Assert.assertFalse(propertyFilter.include(new DefaultBeanPropertyWriter("z"))); properties.clear(); properties.add("x"); properties.add("y"); propertyFilter = new SimpleBeanPropertyFilter(properties); Assert.assertTrue(property
@Test public void testGetContextAnnotation() throws Exception { SettableBeanProperty prop1 = new SettableBeanProperty("p1", TypeFactory.defaultInstance(), new PropertyName("p1"), TypeFactory.defaultInstance(), new Annotations()); SettableBeanProperty prop2 = new SettableBeanProperty("p2", TypeFactory.defaultInstance(), new PropertyName("p2"), TypeFactory.defaultInstance(), new Annotations()); SettableBeanProperty prop3 = new SettableBeanProperty("p3", TypeFactory.defaultInstance(), new PropertyName("p3"), TypeFactory.defaultInstance(), new Annotations()); SettableBeanProperty prop4 = new SettableBeanProperty("p4", TypeFactory.
@Test public void testGetContextAnnotation() throws IOException { SettableBeanProperty prop1 = new SettableBeanProperty("p1", TypeFactory.defaultInstance(), PropertyName.getByName("p1"), TypeFactory.defaultInstance(), new Annotations()); SettableBeanProperty prop2 = new SettableBeanProperty("p2", TypeFactory.defaultInstance(), PropertyName.getByName("p2"), TypeFactory.defaultInstance(), new Annotations()); SettableBeanProperty prop3 = new SettableBeanProperty("p3", TypeFactory.defaultInstance(), PropertyName.getByName("p3"), TypeFactory.defaultInstance(), new Annotations()); SettableBeanProperty prop4 = new SettableBeanProperty("
@Test public void testMethodProperty() throws Exception { MethodProperty src1 = new MethodProperty(this.propDef, this.type, this.typeDeser, this.contextAnnotations, this.method); MethodProperty src2 = new MethodProperty(this.propDef, this.type, this.typeDeser, this.contextAnnotations, this.method); MethodProperty src3 = new MethodProperty(this.propDef, this.type, this.typeDeser, this.contextAnnotations, this.method); MethodProperty src4 = new MethodProperty(this.propDef, this.type, this.typeDeser, this.contextAnnotations, this.method); MethodProperty src5 = new MethodProperty(
@Test public void testMethodProperty() throws IOException { ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(new ClassPathXmlApplicationContext(new ClassPathXmlApplicationContext(new ClassPathXmlApplicationContext(new ClassPathXmlApplicationContext(new ClassPathXmlApplicationContext(new ClassPathXmlApplicationContext(new ClassPathXmlApplicationContext(new ClassPathXmlApplicationContext(new ClassPathXmlApplicationContext(new ClassPathXmlApplicationContext(new ClassPathXmlApplicationContext(new ClassPathXmlApplicationContext(new ClassPathXmlApplicationContext.class)))))))))); MethodProperty src = new MethodProperty(new MethodProperty.Builder().withName("name").withValueDeserializer(new JsonDeserializer<String>() { @Override public String deserialize(JsonParser jp,
@Test public void testMethodProperty() throws IOException { ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(new ClassPathXmlApplicationContext(new ClassPathXmlApplicationContext(new ClassPathXmlApplicationContext(new ClassPathXmlApplicationContext(new ClassPathXmlApplicationContext(new ClassPathXmlApplicationContext(new ClassPathXmlApplicationContext(new ClassPathXmlApplicationContext(new ClassPathXmlApplicationContext(new ClassPathXmlApplicationContext(new ClassPathXmlApplicationContext.class)))))))); MethodProperty src = new MethodProperty(new BeanPropertyDefinition(new ClassPathXmlApplicationContext(new ClassPathXmlApplicationContext(new ClassPathXmlApplicationContext(new ClassPathXmlApplicationContext(new ClassPathXmlApplicationContext(new ClassPathXmlApplicationContext(new ClassPathXmlApplicationContext
@Test public void testMethodProperty() throws IOException { ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(new ClassPathXmlApplicationContext(new ClassPathXmlApplicationContext(new ClassPathXmlApplicationContext(new ClassPathXmlApplicationContext(new ClassPathXmlApplicationContext(new ClassPathXmlApplicationContext(new ClassPathXmlApplicationContext(new ClassPathXmlApplicationContext(new ClassPathXmlApplicationContext(new ClassPathXmlApplicationContext.class)))))))); MethodProperty src = new MethodProperty(new MethodProperty.Builder().withName("foo").withValueDeserializer(new JsonDeserializer<String>() { @Override public String deserialize(JsonParser jp, DeserializationContext ctxt, Object instance) throws IOException, JsonProcessingException { throw new IOException("
@Test public void testMethodProperty() { MethodProperty src = new MethodProperty(new MethodProperty("name", "name"), "value"); assertEquals("name", src.getName()); assertEquals("value", src.getValue()); src.withName("name"); assertEquals("name", src.getName()); assertEquals("value", src.getValue()); src.withValueDeserializer(new SimpleJsonDeserializer()); assertEquals("name", src.getName()); assertEquals("value", src.getValue()); src.withValueDeserializer(new SimpleJsonDeserializer()); assertEquals("name", src.getName()); assertEquals("value", src.getValue()); src.withValueDeserializer(new SimpleJsonDeserializer()); assertEquals("name", src
@Test public void testMethodProperty() { MethodProperty src = new MethodProperty(new MethodPropertyDefinition("name"), JavaType.STRING, TypeDeserializer.TYPE_DESERIALIZER, null, new AnnotatedMethod("value")); src.withName("name").withValueDeserializer(new JsonDeserializer<String>() { @Override public String deserialize(JsonParser jp, DeserializationContext ctxt, Object instance) throws IOException, JsonProcessingException { return "value"; } }); assertEquals("value", src.name); assertEquals("value", src.value); assertEquals("value", src.withValueDeserializer(new JsonDeserializer<String>() { @Override public String deserialize(JsonParser jp, Deserial
@Test public void testMethodProperty() throws IOException { SimpleType type = new SimpleType(); SimpleTypeDeserializer deserializer = new SimpleTypeDeserializer(type); MethodProperty prop1 = new MethodProperty(type.getMethod("property1"), deserializer) .withName("property1") .withValueDeserializer(deserializer); assertEquals("property1", prop1.getName()); assertEquals(type, prop1.getType()); assertEquals(type, prop1.getType()); assertEquals(deserializer, prop1.getValueDeserializer()); MethodProperty prop2 = new MethodProperty(type.getMethod("property2"), deserializer) .withName("property2") .withValueDeserializer(deserializer) .with
@Test public void testMethodProperty() { MethodProperty src = new MethodProperty(new MethodPropertyDefinition("name", SimpleType.STRING), new SimpleType(), null, null, new AnnotatedMethod("name")); src.withName("name").withValueDeserializer(new JsonDeserializer<String>() { @Override public String deserialize(JsonParser jp, DeserializationContext ctxt, Object instance) throws IOException, JsonProcessingException { return "value"; } }); src.setAndReturn(new Object(), "value"); assertEquals("value", src.getName()); assertEquals("value", src.getValue()); }
@Test public void testWithValueDeserializer() { MethodProperty prop1 = new MethodProperty(new BeanPropertyDefinition(), JavaType.STRING, TypeDeserializer.NULL_TYPE_DESERIALIZER, null, new AnnotatedMethod("property1")); MethodProperty prop2 = prop1.withValueDeserializer(new JsonDeserializer<String>() { @Override public String deserialize(JsonParser jp, DeserializationContext ctxt, Object value) throws IOException, JsonProcessingException { throw new AssertionError(); } }); assertEquals("property1", prop1.getName()); assertEquals("property1", prop2.getName()); assertEquals("property1", prop2.getMember().getName()); assertEquals("property1", prop2.get
@Test public void testWithValueDeserializer() { MethodProperty prop1 = new MethodProperty(new BeanPropertyDefinition(), JavaType.STRING, TypeDeserializer.NULL_TYPE_DESERIALIZER, null, new AnnotatedMethod("property1")); MethodProperty prop2 = prop1.withValueDeserializer(new JsonDeserializer<String>() { @Override public String deserialize(JsonParser jp, DeserializationContext ctxt, Object value) throws IOException, JsonProcessingException { throw new AssertionError(); } }); assertEquals("property1", prop1.getName()); assertEquals("property1", prop2.getName()); assertEquals("property1", prop2.getMember().getName()); assertEquals("property1", prop2.get
@Test public void testGetMember() { AnnotatedMember member = methodProperty1.getMember(); assertThat(member, notNullValue()); assertThat(member.getMember(), equalTo(methodProperty1)); }
@Test public void testDeserializeAndSet() throws IOException { SimpleType type = new SimpleType(); type.setName("name"); SimpleProperty simpleProperty = new SimpleProperty(type, "name"); simpleProperty.withValueDeserializer(new JsonDeserializer<String>() { @Override public String deserialize(JsonParser jp, DeserializationContext ctxt, Object instance) throws IOException, JsonProcessingException { return "value"; } }); MethodProperty src = simpleProperty.withName("name").withValueDeserializer(new JsonDeserializer<String>() { @Override public String deserialize(JsonParser jp, DeserializationContext ctxt, Object instance) throws IOException, JsonProcessingException { return "value"; } }); src.deserializeAndSet(jp,
@Test public void testDeserializeAndSet() throws IOException { SimpleType type = new SimpleType(); type.setName("name"); SimpleProperty simpleProperty = new SimpleProperty(type, "name"); simpleProperty.withValueDeserializer(new JsonDeserializer<String>() { @Override public String deserialize(JsonParser jp, DeserializationContext ctxt, Object instance) throws IOException, JsonProcessingException { return "test"; } }); SimpleType instance = new SimpleType(); instance.setName("name"); instance.setSimpleProperty(simpleProperty); instance.deserializeAndSet(jp, null, instance); assertEquals("test", instance.name); assertEquals("test", instance.simpleProperty); }
@Test public void testSet() throws IOException { MethodProperty src = PropertyUtils.createMethodProperty(getClass().getDeclaredMethod("set", Object.class), "value"); TestBean testBean = new TestBean(); src.set(testBean, "test"); assertEquals("test", testBean.getValue()); src.set(testBean, "test"); assertEquals("test", testBean.getValue()); src.set(testBean, "test"); assertEquals("test", testBean.getValue()); src.setAndReturn(testBean, "test"); assertEquals("test", testBean.getValue()); src.setAndReturn(testBean, "test"); assertEquals("test", testBean.
@Test public void testSet() throws IOException { MethodProperty src = PropertyUtils.createMethodProperty(getClass().getDeclaredMethod("set"), String.class, String.class); src.set("test"); assertEquals("test", src.get("test")); src.set("test2"); assertEquals("test2", src.get("test2")); src.set("test3"); assertEquals("test3", src.get("test3")); src.set("test4"); assertEquals("test4", src.get("test4")); src.set("test5"); assertEquals("test5", src.get("test5")); }
@Test public void testSet() throws IOException { BeanPropertyDefinition propDef = mock(BeanPropertyDefinition.class); when(propDef.getName()).thenReturn("name"); when(propDef.getType()).thenReturn(String.class); when(propDef.isOptional()).thenReturn(true); MethodProperty src = new MethodProperty(propDef, SimpleType.class, null, null, new AnnotatedMethod("set", SimpleType.class)); src.withValueDeserializer(new JsonDeserializer<String>() { @Override public String deserialize(JsonParser jp, DeserializationContext ctxt, Object object) throws IOException, JsonProcessingException { return "test"; } }); src.setAndReturn
@Test public void testWriteAsField() throws IOException, JsonGenerationException { ObjectIdWriter w = mock(ObjectIdWriter.class); SerializedString name = new SerializedString("myField"); when(w.propertyName()).thenReturn(name); when(jgen.writeFieldName(name)).thenReturn(true); WritableObjectId testObject = new WritableObjectId(new SimpleObjectIdGenerator()); testObject.writeAsField(jgen, null, w); verify(jgen).writeFieldName(name); verify(jgen).writeFieldName(name); verify(serializer).serialize(eq(testObject), eq(jgen), eq(null)); }
@Test public void testWriteAsField() throws IOException, JsonGenerationException { ObjectIdWriter w = mock(ObjectIdWriter.class); SimplePojo pojo = new SimplePojo(); when(jgen.writeFieldName(any(SerializedString.class))).thenAnswer(new Answer<Object>() { @Override public Object answer(InvocationOnMock invocation) throws Throwable { SerializedString name = (SerializedString) invocation.getArguments()[0]; return name; } }); WritableObjectId id = new WritableObjectId(new SimplePojoIdGenerator()); when(jgen.writeFieldName(any(SerializedString.class))).thenAnswer(new Answer<Object>() { @Override public Object answer(InvocationOnMock
@Test public void testGetDeclaringClass() { Class<?> superclass = class1.getDeclaringClass(); assertEquals(Class1.class, superclass); }
@Test public void testGetDeclaringClass() { Class<?> superclass = new AnnotatedField(FooPojo.class.getDeclaredField("foo"), null).getDeclaringClass(); assertEquals(FooPojo.class, superclass); }
@Test public void testGetFullName() { ClassWithAnnotatedFields tested = new ClassWithAnnotatedFields(); tested.setName("foo"); String name = tested.getFullName(); System.out.println(name); assertTrue(name.startsWith(ClassWithAnnotatedFields.class.getName())); assertTrue(name.endsWith("#foo")); }
@Test public void testGetFullName() { ClassWithAnnotatedFields tested = new ClassWithAnnotatedFields(); tested.setName("foobar"); assertEquals("ClassWithAnnotatedFields#foobar", tested.getFullName()); }
@Test public void testToString() { String[][] lines = new String[][] { {"foo", "bar"}, {"foo", "bar"}, {"foo", "bar"}, {"foo", "bar"}, {"foo", "bar"}, {"foo", "bar"}, {"foo", "bar"}, {"foo", "bar"}, {"foo", "bar"}, {"foo", "bar"}, {"foo", "bar"}, {"foo", "bar"}, {"foo", "bar"}, {"foo", "bar"}, {"foo", "bar"}, {"foo", "bar"}, {"foo", "bar"}, {"foo", "bar"}, {"foo
@Test public void testToString() throws Exception { ClassPool cp = ClassPool.getDefault(); Field f1 = cp.getDeclaredField("f1"); Field f2 = cp.getDeclaredField("f2"); Field f3 = cp.getDeclaredField("f3"); Field f4 = cp.getDeclaredField("f4"); Field f5 = cp.getDeclaredField("f5"); Field f6 = cp.getDeclaredField("f6"); System.out.println(f1.toString()); System.out.println(f2.toString()); System.out.println(f3.toString()); System.out.println(f4.toString()); }
@Test public void nestedObjectTest() throws IOException, JsonGenerationException { SimpleBean simpleBean = new SimpleBean(); SimpleBean simpleBean2 = new SimpleBean(); SimpleBean simpleBean3 = new SimpleBean(); SimpleBean simpleBean4 = new SimpleBean(); simpleBean.setIntegerField(1); simpleBean2.setIntegerField(2); simpleBean3.setIntegerField(3); simpleBean4.setIntegerField(4); SimpleBean simpleBean5 = new SimpleBean(); simpleBean5.setIntegerField(5); simpleBean4.setIntegerField(6); simpleBean5.setSimpleBean(simpleBean2); SimpleBean simpleBean6 = new SimpleBean(); simpleBean6
@Test public void testAsExternalTypeSerializer() { SimpleTypeIdResolver res = new SimpleTypeIdResolver(); BeanProperty prop = new SimpleProperty("propName"); AsExternalTypeSerializer extSerializer = new AsExternalTypeSerializer(res, prop, "propName"); Assert.assertEquals(extSerializer.getTypeInclusion(), TypeId.BOOLEAN); Assert.assertEquals(extSerializer.getPropertyName(), "propName"); extSerializer = new AsExternalTypeSerializer(res, prop, "propName"); Assert.assertEquals(extSerializer.getTypeInclusion(), TypeId.BOOLEAN); Assert.assertEquals(extSerializer.getPropertyName(), "propName"); extSerializer = new AsExternalTypeSerializer(res, prop
@Test public void testAsExternalTypeSerializer() { SimpleTypeIdResolver res = new SimpleTypeIdResolver(); BeanProperty prop = new SimpleProperty("propName"); AsExternalTypeSerializer serializer = new AsExternalTypeSerializer(res, prop, "propName"); serializer.writeTypePrefixForScalar(Arrays.asList("a", "b"), jgen, "propName"); Assert.assertEquals(mapper.writeValueAsString(Arrays.asList("a", "b")), mapper.writeValueAsString(Arrays.asList("a", "b"))); serializer.writeTypePrefixForScalar(Arrays.asList("a", "b"), jgen, "propName"); serializer.writeType
@Test public void testAsExternalTypeSerializer() { TypeIdResolver res = new DefaultTypeIdResolver(); BeanProperty prop = new SimpleBeanProperty("prop1", "value1"); AsExternalTypeSerializer serializer = new AsExternalTypeSerializer(res, prop, "prop1"); Assert.assertEquals(serializer.getTypeInclusion(), TypeId.DEFAULT); Assert.assertEquals(serializer.getPropertyName(), "prop1"); serializer = new AsExternalTypeSerializer(res, prop, "prop2"); Assert.assertEquals(serializer.getTypeInclusion(), TypeId.DEFAULT); Assert.assertEquals(serializer.getPropertyName(), "prop2"); serializer = new AsExternalTypeSerializer(res, prop, "
@Test public void testWriteTypePrefixForObject() throws IOException { AsExternalTypeSerializer serializer = new AsExternalTypeSerializer(null, new BeanProperty("prop1"), "prop1"); ByteArrayOutputStream out = new ByteArrayOutputStream(); serializer.writeTypePrefixForObject(Arrays.asList("a", "b", "c"), new JsonGenerator(out)); String result = out.toString(); Assert.assertEquals("{\\"prop1\\":[\\"a\\",\\"b\\",\\"c\\"],\\"prop2\\":[\\"a\\",\\"b\\",\\"c\\"],\\"prop3\\":[\\"a\\",\\"b\\",\\"c\\"]}", result); }
@Test public void writeTypePrefixForObject() throws IOException { when(jgen.getExactBytes(anyString())).thenReturn("{\\"foo\\":\\"bar\\"}".getBytes()); AsExternalTypeSerializer serializer = new AsExternalTypeSerializer(typeIdResolver, property, "foo"); serializer._writeObjectPrefix(Arrays.asList("bar", "baz"), jgen); Assert.assertEquals("{\\"foo\\":[\\"bar\\",\\"baz\\"],\\"bar\\":[\\"baz\\"]}", new String(outputStream.toString())); }
@Test public void testWriteTypeSuffixForObject() throws IOException { when(jsonGenerator.nextToken()).thenReturn("1"); when(jsonGenerator.asText()).thenReturn("str"); AsExternalTypeSerializer serializer = new AsExternalTypeSerializer(typeIdResolver, prop, "prop"); serializer.writeTypeSuffixForObject(Arrays.asList("a", "b"), jsonGenerator); verify(jsonGenerator).writeFieldName("prop"); verify(jsonGenerator).writeFieldName("str"); verify(jsonGenerator).writeFieldName("int"); verify(jsonGenerator).writeFieldName("long"); verify(jsonGenerator).writeFieldName("float"); verify(jsonGenerator).writeFieldName("double"); verify(json
@Test public void testWriteObjectSuffix() throws IOException { when(jgen.getExactBytes(anyString())).thenReturn(new byte[] { (byte) 1, (byte) 2, (byte) 3 }); when(idRes.getNextId()).thenReturn("1"); when(property1.getName()).thenReturn("prop1"); when(property2.getName()).thenReturn("prop2"); when(property3.getName()).thenReturn("prop3"); when(property4.getName()).thenReturn("prop4"); when(property5.getName()).thenReturn("prop5"); when(property6.getName()).thenReturn("prop6"); when(
@Test public void testWriteCustomTypePrefixForObject() throws IOException { AsExternalTypeSerializer serializer = new AsExternalTypeSerializer(null, new BeanProperty("prop1"), "prop1"); ByteArrayOutputStream out = new ByteArrayOutputStream(); serializer.writeCustomTypePrefixForObject(Arrays.asList("a", "b", "c"), new JsonGenerator(out), "test"); String result = out.toString(); Assert.assertEquals("{\\"prop1\\":[\\"a\\",\\"b\\",\\"c\\"],\\"prop2\\":[\\"a\\",\\"b\\",\\"c\\"],\\"prop3\\":[\\"a\\",\\"b\\",\\"c\\"]}",
@Test public void testWriteObjectPrefix() throws IOException { when(jgen.getExactBytes(anyString())).thenReturn(new byte[] {1,2,3,4}); when(jgen.getPrefix()).thenReturn("{\\"a\\":[1,2,3,4]}"); AsExternalTypeSerializer serializer = new AsExternalTypeSerializer(typeIdResolver, property, "a"); serializer._writeObjectPrefix(Arrays.asList("1", "2", "3"), jgen); Assert.assertEquals("{\\"a\\":[1,2,3,4]}", new String(outputStream.toString())); }
@Test public void testWriteCustomTypeSuffixForObject() throws IOException { when(jgen.nextToken()).thenReturn("1"); new AsExternalTypeSerializer(null, null, "prop1").writeCustomTypeSuffixForObject(Arrays.asList("a", "b"), jgen, "prop1"); verify(jgen).nextToken(); verify(jgen).writeFieldName("prop1"); verify(jgen).writeFieldName("prop2"); verify(jgen).writeFieldName("prop3"); verify(jgen).writeFieldName("val1"); verify(jgen).writeFieldName("val2"); verify(jgen).writeFieldName("val3"); }
@Test public void testWriteObjectSuffix() throws IOException { when(jgen.getExactBytes(anyString())).thenReturn(new byte[] { (byte) 1, (byte) 2, (byte) 3 }); when(jgen.getPropertyName()).thenReturn("prop1"); when(property1.getName()).thenReturn("prop2"); when(property2.getName()).thenReturn("prop3"); when(property3.getName()).thenReturn("prop4"); List<String> list = Arrays.asList("a", "b", "c"); when(property1.getValues()).thenReturn(list); when(property2.getValues()).thenReturn
@Test public void _writeObjectPrefix() throws IOException { ByteArrayOutputStream baos = new ByteArrayOutputStream(); JsonGenerator jgen = new JsonFactory().createGenerator(baos); new A().writeObjectPrefix("a", jgen); new A().writeObjectPrefix("b", jgen); new A().writeObjectPrefix("c", jgen); new A().writeObjectPrefix("d", jgen); new A().writeObjectPrefix("e", jgen); new A().writeObjectPrefix("f", jgen); new A().writeObjectPrefix("g", jgen); new A().writeObjectPrefix("h", jgen); new A().writeObjectPrefix("i", jgen); new A().writeObjectPrefix("
@Test public void testWriteObjectPrefix() throws IOException { AsExternalTypeSerializer serializer = new AsExternalTypeSerializer(new DefaultTypeIdResolver(), new DefaultBeanProperty("prop1"), "prop1"); ByteArrayOutputStream baos = new ByteArrayOutputStream(); serializer.writeObjectPrefix(Arrays.asList("a", "b", "c"), baos); String result = baos.toString(); Assert.assertEquals("{\\"prop1\\":[\\"a\\",\\"b\\",\\"c\\"],\\"prop2\\":[\\"a\\",\\"b\\",\\"c\\"],\\"prop3\\":[\\"a\\",\\"b\\",\\"c\\"],\\"prop4\\":[\\"a\\",\\"
@Test public void _writeObjectSuffix() throws IOException { when(jsonGenerator.hasNext()).thenReturn(true, false); final String EXPECTED_RESULT = "[{\\"prop\\":\\"prop1\\",\\"type\\":\\"string\\",\\"prefix\\":\\"\\",\\"prefix2\\":\\"\\",\\"prefix3\\":\\"\\",\\"prefix4\\":\\"\\",\\"prefix5\\":\\"\\",\\"prefix6\\":\\"\\",\\"prefix7\\":\\"\\",\\"prefix8\\":\\"\\",\\"prefix9\\":\\"\\",\\"prefix10\\":\\"\\",\\"prefix11\\":\\"\\",\\"prefix12\\":\\"\\
@Test public void testWriteObjectSuffix() throws IOException { AsExternalTypeSerializer serializer = new AsExternalTypeSerializer(typeIdRes, prop1, "prop1"); ByteArrayOutputStream baos = new ByteArrayOutputStream(); serializer.writeObjectSuffix(Arrays.asList("a", "b"), baos); String result = baos.toString(); Assert.assertEquals("{\\"prop1\\":[\\"a\\",\\"b\\"],\\"prop2\\":[\\"a\\",\\"b\\"],\\"prop3\\":[\\"a\\",\\"b\\"],\\"prop4\\":[\\"a\\",\\"b\\"],\\"prop5\\":[\\"a\\",\\"b\\"]}", result); }
@Test public void testWriteTypePrefixForObject() throws IOException { when(jsonHelper.readAsString(isA(String.class), eq("{\\"type\\":\\"string\\",\\"prefix\\":[\\"1\\",\\"2\\"]}"))).thenReturn("{\\"prefix\\":[\\"1\\",\\"2\\"]}"); when(jsonHelper.readAsString(isA(String.class), eq("{\\"type\\":\\"string\\",\\"prefix\\":[\\"1\\",\\"2\\"]}"))).thenReturn("{\\"prefix\\":[\\"1\\",\\"2\\"]}"); AsExternalTypeSerializer serializer = new AsExternalTypeSerializer(
@Test public void testExternalTypeHandler() throws IOException, JsonProcessingException { SettableBeanProperty p1 = mock(SettableBeanProperty.class); when(p1.getPropertyName()).thenReturn("p1"); SettableBeanProperty p2 = mock(SettableBeanProperty.class); when(p2.getPropertyName()).thenReturn("p2"); SettableBeanProperty p3 = mock(SettableBeanProperty.class); when(p3.getPropertyName()).thenReturn("p3"); SettableBeanProperty p4 = mock(SettableBeanProperty.class); when(p4.getPropertyName()).thenReturn("p4"); SettableBeanProperty p5 = mock(
@Test public void testExternalTypeHandler() throws IOException, JsonProcessingException { SettableBeanProperty p0 = mock(SettableBeanProperty.class); when(p0.getPropertyName()).thenReturn("p0"); SettableBeanProperty p1 = mock(SettableBeanProperty.class); when(p1.getPropertyName()).thenReturn("p1"); SettableBeanProperty p2 = mock(SettableBeanProperty.class); when(p2.getPropertyName()).thenReturn("p2"); SettableBeanProperty p3 = mock(SettableBeanProperty.class); when(p3.getPropertyName()).thenReturn("p3"); SettableBeanProperty p4 = mock(
@Test public void testComplete() throws IOException, JsonProcessingException { SettableBeanProperty p0 = mock(SettableBeanProperty.class); when(p0.getPropertyName()).thenReturn("p0"); SettableBeanProperty p1 = mock(SettableBeanProperty.class); when(p1.getPropertyName()).thenReturn("p1"); SettableBeanProperty p2 = mock(SettableBeanProperty.class); when(p2.getPropertyName()).thenReturn("p2"); SettableBeanProperty p3 = mock(SettableBeanProperty.class); when(p3.getPropertyName()).thenReturn("p3"); SettableBeanProperty p4 = mock(Settable
@Test public void testExternalTypeHandler() throws IOException, JsonProcessingException { SettableBeanProperty p0 = mock(SettableBeanProperty.class); when(p0.getPropertyName()).thenReturn("p0"); SettableBeanProperty p1 = mock(SettableBeanProperty.class); when(p1.getPropertyName()).thenReturn("p1"); SettableBeanProperty p2 = mock(SettableBeanProperty.class); when(p2.getPropertyName()).thenReturn("p2"); SettableBeanProperty p3 = mock(SettableBeanProperty.class); when(p3.getPropertyName()).thenReturn("p3"); SettableBeanProperty p4 = mock(
@Test public void testExternalTypeHandler() throws IOException, JsonProcessingException { SettableBeanProperty p1 = mock(SettableBeanProperty.class); SettableBeanProperty p2 = mock(SettableBeanProperty.class); SettableBeanProperty p3 = mock(SettableBeanProperty.class); when(p1.hasType()).thenReturn(true); when(p2.hasType()).thenReturn(true); when(p3.hasType()).thenReturn(true); SettableBeanProperty p4 = mock(SettableBeanProperty.class); when(p4.hasType()).thenReturn(true); when(p4.hasType()).thenReturn(true
@Test public void testExternalTypeHandler() throws IOException, JsonProcessingException { ExternalTypeHandler h = new ExternalTypeHandler() { @Override protected boolean handleTypePropertyValue(JsonParser jp, DeserializationContext ctxt, String propName, Object bean) throws IOException, JsonProcessingException { return true; } @Override protected String[] _properties() { return new String[0]; } @Override protected String[] _nameToPropertyIndex() { return new String[0]; } @Override protected String[] _typeIds() { return new String[0]; } @Override protected TokenBuffer[] _tokens() { return new TokenBuffer[0]; } @Override public boolean handleTypePropertyValue(JsonParser jp, DeserializationContext ctxt,
@Test public void testExternalTypeHandler() throws IOException, JsonProcessingException { SettableBeanProperty p1 = mock(SettableBeanProperty.class); when(p1.getPropertyName()).thenReturn("p1"); SettableBeanProperty p2 = mock(SettableBeanProperty.class); when(p2.getPropertyName()).thenReturn("p2"); SettableBeanProperty p3 = mock(SettableBeanProperty.class); when(p3.getPropertyName()).thenReturn("p3"); SettableBeanProperty p4 = mock(SettableBeanProperty.class); when(p4.getPropertyName()).thenReturn("p4"); SettableBeanProperty p5 = mock(
@Test public void testExternalTypeHandler() throws IOException, JsonProcessingException { SettableBeanProperty prop1 = mockProperty("prop1", "string"); SettableBeanProperty prop2 = mockProperty("prop2", "string"); SettableBeanProperty prop3 = mockProperty("prop3", "string"); SettableBeanProperty prop4 = mockProperty("prop4", "string"); SettableBeanProperty prop5 = mockProperty("prop5", "string"); SettableBeanProperty prop6 = mockProperty("prop6", "string"); SettableBeanProperty prop7 = mockProperty("prop7", "string"); SettableBeanProperty prop8 = mockProperty("prop8", "string"); SettableBeanProperty prop
@Test public void testExternalTypeHandler() throws IOException, JsonProcessingException { SettableBeanProperty p0 = mock(SettableBeanProperty.class); when(p0.getPropertyName()).thenReturn("p0"); SettableBeanProperty p1 = mock(SettableBeanProperty.class); when(p1.getPropertyName()).thenReturn("p1"); SettableBeanProperty p2 = mock(SettableBeanProperty.class); when(p2.getPropertyName()).thenReturn("p2"); SettableBeanProperty p3 = mock(SettableBeanProperty.class); when(p3.getPropertyName()).thenReturn("p3"); SettableBeanProperty p4 = mock(
@Test public void testComplete() throws IOException, JsonProcessingException { SettableBeanProperty p1 = mockProperty("p1", "string"); SettableBeanProperty p2 = mockProperty("p2", "string"); SettableBeanProperty p3 = mockProperty("p3", "string"); SettableBeanProperty p4 = mockProperty("p4", "string"); SettableBeanProperty p5 = mockProperty("p5", "string"); SettableBeanProperty p6 = mockProperty("p6", "string"); SettableBeanProperty p7 = mockProperty("p7", "string"); SettableBeanProperty p8 = mockProperty("p8", "string"); SettableBeanProperty p9 =
@Test public void testComplete() throws IOException, JsonProcessingException { SettableBeanProperty p0 = mock(SettableBeanProperty.class); when(p0.getPropertyName()).thenReturn("p0"); SettableBeanProperty p1 = mock(SettableBeanProperty.class); when(p1.getPropertyName()).thenReturn("p1"); SettableBeanProperty p2 = mock(SettableBeanProperty.class); when(p2.getPropertyName()).thenReturn("p2"); SettableBeanProperty p3 = mock(SettableBeanProperty.class); when(p3.getPropertyName()).thenReturn("p3"); SettableBeanProperty p4 = mock(Settable
@Test public void test_start() throws IOException { ExternalTypeHandler h = new ExternalTypeHandler(new ExtTypedProperty[] {}, new HashMap<String, Integer>(), new String[] {}, new TokenBuffer[] {}); ExternalTypeHandler h1 = h.start(); assertTrue(h1.handleTypePropertyValue(jp, jp, null, null)); assertTrue(h1.handleTypePropertyValue(jp, jp, null, null)); assertTrue(h1.handleTypePropertyValue(jp, jp, null, null)); assertTrue(h1.handleTypePropertyValue(jp, jp, null, null)); assertTrue(h1.handleTypePropertyValue(jp, jp, null, null)); assertTrue(
@Test public void testStart() throws IOException, JsonProcessingException { ExternalTypeHandler h = new ExternalTypeHandler(new ExtTypedProperty[] {}, new HashMap<String, Integer>(), new String[] {}, new TokenBuffer[] {}); assertTrue(h.start().handleTypePropertyValue(jp, jp, null, null)); assertTrue(h.start().handleTypePropertyValue(jp, jp, null, null)); assertTrue(h.start().handleTypePropertyValue(jp, jp, null, null)); assertTrue(h.start().handleTypePropertyValue(jp, jp, null, null)); assertTrue(h.start().handleTypePropertyValue(jp, jp, null, null)); assertTrue(h.start
@Test public void testHandleTypePropertyValue() throws IOException, JsonProcessingException { SettableBeanProperty p0 = mock(SettableBeanProperty.class); when(p0.getText()).thenReturn("p0"); SettableBeanProperty p1 = mock(SettableBeanProperty.class); when(p1.getText()).thenReturn("p1"); SettableBeanProperty p2 = mock(SettableBeanProperty.class); when(p2.getText()).thenReturn("p2"); SettableBeanProperty p3 = mock(SettableBeanProperty.class); when(p3.getText()).thenReturn("p3"); SettableBeanProperty p4 = mock(
@Test public void testHandleTypePropertyValue() throws IOException, JsonProcessingException { SettableBeanProperty p0 = mock(SettableBeanProperty.class); when(p0.getText()).thenReturn("p0"); when(p0.hasTypePropertyName("p0")).thenReturn(true); SettableBeanProperty p1 = mock(SettableBeanProperty.class); when(p1.getText()).thenReturn("p1"); when(p1.hasTypePropertyName("p1")).thenReturn(true); SettableBeanProperty p2 = mock(SettableBeanProperty.class); when(p2.getText()).thenReturn("p2"); when(p2
@Test public void testHandleTypePropertyValue() throws IOException, JsonProcessingException { SettableBeanProperty p0 = mock(SettableBeanProperty.class); when(p0.getText()).thenReturn("p0"); when(p0.hasTypePropertyName("p0")).thenReturn(true); SettableBeanProperty p1 = mock(SettableBeanProperty.class); when(p1.getText()).thenReturn("p1"); when(p1.hasTypePropertyName("p1")).thenReturn(true); SettableBeanProperty p2 = mock(SettableBeanProperty.class); when(p2.getText()).thenReturn("p2"); when(p2
@Test public void testHandleTypePropertyValue() throws IOException, JsonProcessingException { SettableBeanProperty p0 = mock(SettableBeanProperty.class); when(p0.getText()).thenReturn("p0"); when(p0.hasTypePropertyName("p0")).thenReturn(true); SettableBeanProperty p1 = mock(SettableBeanProperty.class); when(p1.getText()).thenReturn("p1"); when(p1.hasTypePropertyName("p1")).thenReturn(true); SettableBeanProperty p2 = mock(SettableBeanProperty.class); when(p2.getText()).thenReturn("p2"); when(p2
@Test public void handlePropertyValue() throws IOException, JsonProcessingException { Map<String, Integer> nameToPropertyIndex = new HashMap<String, Integer>(); nameToPropertyIndex.put("test1", 1); nameToPropertyIndex.put("test2", 2); ExternalTypeHandler tHandler = new ExternalTypeHandler(new ExtTypedProperty[] { property("test1.test2.test3"), property("test2.test3.test4") }, nameToPropertyIndex, new String[] { "test1", "test2", "test3" }, new TokenBuffer[] { new TokenBuffer("test1"), new TokenBuffer("test2"), new TokenBuffer("test3"),
@Test public void testHandlePropertyValue() throws IOException, JsonProcessingException { Map<String, Integer> nameToPropertyIndex = new HashMap<String, Integer>(); nameToPropertyIndex.put("test1", 1); nameToPropertyIndex.put("test2", 2); ExternalTypeHandler tr = new ExternalTypeHandler(new ExtTypedProperty[] { property("test1.test2.test3"), property("test2.test3.test4") }, nameToPropertyIndex, new String[] { "test1", "test2", "test3" }, new TokenBuffer[] { new TokenBuffer("test1"), new TokenBuffer("test2"), new TokenBuffer("test3"),
@Test public void testHandlePropertyValue() throws IOException, JsonProcessingException { Map<String, Integer> nameToPropertyIndex = new HashMap<String, Integer>(); nameToPropertyIndex.put("test1", 1); nameToPropertyIndex.put("test2", 2); ExternalTypeHandler tHandler = new ExternalTypeHandler(new ExtTypedProperty[] { property("test1.test2.test3"), property("test2.test3.test4") }, nameToPropertyIndex, new String[] { "test1", "test2", "test3" }, new TokenBuffer[] { new TokenBuffer("test1"), new TokenBuffer("test2"), new TokenBuffer("test3"
@Test public void handlePropertyValue() throws IOException, JsonProcessingException { Map<String, Integer> nameToPropertyIndex = new HashMap<String, Integer>(); nameToPropertyIndex.put("test1", 1); nameToPropertyIndex.put("test2", 2); ExternalTypeHandler tHandler = new ExternalTypeHandler(new ExtTypedProperty[] { property("test1.test2.test3"), property("test2.test3.test4") }, nameToPropertyIndex, new String[] { "test1", "test2", "test3" }, new TokenBuffer[] { new TokenBuffer("test1"), new TokenBuffer("test2"), new TokenBuffer("test3"),
@Test public void testHandlePropertyValue() throws IOException, JsonProcessingException { SettableBeanProperty prop = mock(SettableBeanProperty.class); when(prop.hasTypePropertyName("a")).thenReturn(true); when(prop.hasTypePropertyName("b")).thenReturn(true); when(prop.hasTypePropertyName("c")).thenReturn(true); when(prop.hasTypePropertyName("d")).thenReturn(true); when(prop.hasTypePropertyName("e")).thenReturn(true); when(prop.hasTypePropertyName("f")).thenReturn(true); when(prop.hasTypePropertyName("g")).thenReturn(true); when(prop.hasTypePropertyName
@Test public void testHandlePropertyValue() throws IOException, JsonProcessingException { Map<String, Integer> nameToPropertyIndex = new HashMap<String, Integer>(); nameToPropertyIndex.put("test1", 1); nameToPropertyIndex.put("test2", 2); ExternalTypeHandler trp = new ExternalTypeHandler(new ExtTypedProperty[] { property("test1.test2.test3"), property("test2.test3.test4") }, nameToPropertyIndex, new String[] { "test1", "test2", "test3" }, new TokenBuffer[] { new TokenBuffer("test1"), new TokenBuffer("test2"), new TokenBuffer("test3"
@Test public void testHandlePropertyValue() throws IOException, JsonProcessingException { SettableBeanProperty prop = mock(SettableBeanProperty.class); when(prop.hasTypePropertyName("test")).thenReturn(true); when(prop.hasTypePropertyName("test1")).thenReturn(true); when(prop.hasTypePropertyName("test2")).thenReturn(true); when(prop.hasTypePropertyName("test3")).thenReturn(true); when(prop.hasTypePropertyName("test4")).thenReturn(true); when(prop.hasTypePropertyName("test5")).thenReturn(true); when(prop.hasTypePropertyName("test6")).thenReturn(true); when
@Test public void testHandlePropertyValue() throws IOException, JsonProcessingException { SettableBeanProperty prop = mock(SettableBeanProperty.class); when(prop.hasTypePropertyName("a")).thenReturn(true); when(prop.hasTypePropertyName("b")).thenReturn(true); when(prop.hasTypePropertyName("c")).thenReturn(true); when(prop.hasTypePropertyName("d")).thenReturn(true); when(prop.hasTypePropertyName("e")).thenReturn(true); when(prop.hasTypePropertyName("f")).thenReturn(true); when(prop.hasTypePropertyName("g")).thenReturn(true); when(prop.hasTypePropertyName
@Test public void testHandlePropertyValue() throws IOException, JsonProcessingException { Map<String, Integer> nameToPropertyIndex = new HashMap<String, Integer>(); nameToPropertyIndex.put("test1", 1); nameToPropertyIndex.put("test2", 2); ExternalTypeHandler tHandler = new ExternalTypeHandler(null, nameToPropertyIndex, new String[]{"test1", "test2"}, new TokenBuffer[] {}); JsonParser jp = Mockito.mock(JsonParser.class); Mockito.when(jp.getText()).thenReturn("test1"); Mockito.when(jp.skipChildren()).thenReturn(true); Assert.assertTrue(tHandler
@Test public void testHandlePropertyValue() throws IOException, JsonProcessingException { Map<String, Integer> nameToPropertyIndex = new HashMap<String, Integer>(); nameToPropertyIndex.put("test1", 1); nameToPropertyIndex.put("test2", 2); ExternalTypeHandler trp = new ExternalTypeHandler(new ExtTypedProperty[] { property("test1.test2.test3"), property("test2.test3.test4") }, nameToPropertyIndex, new String[] { "test1", "test2", "test3" }, new TokenBuffer[] {}); trp.start(); Assert.assertTrue(trp.handleProperty(jp, null, "test
@Test public void handlePropertyValue() throws IOException, JsonProcessingException { Map<String, Integer> nameToPropertyIndex = new HashMap<String, Integer>(); nameToPropertyIndex.put("test1", 1); nameToPropertyIndex.put("test2", 2); ExternalTypeHandler tHandler = new ExternalTypeHandler(new ExtTypedProperty[] { property("test1.test2.test3"), property("test2.test3.test4") }, nameToPropertyIndex, new String[] { "test1", "test2", "test3" }, new TokenBuffer[] { new TokenBuffer("test1"), new TokenBuffer("test2"), new TokenBuffer("test3"),
@Test public void handlePropertyValue() throws IOException, JsonProcessingException { Map<String, Integer> nameToPropertyIndex = new HashMap<String, Integer>(); nameToPropertyIndex.put("test1", 1); nameToPropertyIndex.put("test2", 2); ExternalTypeHandler tHandler = new ExternalTypeHandler(new ExtTypedProperty[] { property("test1.test2.test3"), property("test2.test3.test4") }, nameToPropertyIndex, new String[] { "test1", "test2", "test3" }, new TokenBuffer[] { new TokenBuffer("@test1"), new TokenBuffer("@test2"), new TokenBuffer("@test
@Test public void handlePropertyValue() throws IOException, JsonProcessingException { Map<String, Integer> nameToPropertyIndex = new HashMap<String, Integer>(); nameToPropertyIndex.put("test1", 1); nameToPropertyIndex.put("test2", 2); ExternalTypeHandler tHandler = new ExternalTypeHandler(new ExtTypedProperty[] { property("test1.test2.test3"), property("test2.test3.test4") }, nameToPropertyIndex, new String[] { "test1", "test2", "test3" }, new TokenBuffer[] { new TokenBuffer("test1"), new TokenBuffer("test2"), new TokenBuffer("test3"),
@Test public void testHandlePropertyValue() throws IOException, JsonProcessingException { Map<String, Integer> nameToPropertyIndex = new HashMap<String, Integer>(); nameToPropertyIndex.put("test1", 1); nameToPropertyIndex.put("test2", 2); ExternalTypeHandler trp = new ExternalTypeHandler(new ExtTypedProperty[] { property("test1.test2.test3"), property("test2.test3.test4") }, nameToPropertyIndex, new String[] { "test1", "test2", "test3" }, new TokenBuffer[] { new TokenBuffer("test1"), new TokenBuffer("test2"), new TokenBuffer("test3"
@Test public void testHandlePropertyValue() throws IOException, JsonProcessingException { Map<String, Integer> nameToPropertyIndex = new HashMap<String, Integer>(); nameToPropertyIndex.put("test1", 1); nameToPropertyIndex.put("test2", 2); ExternalTypeHandler trp = new ExternalTypeHandler(new ExtTypedProperty[] { property("test1.test2.test3"), property("test2.test3.test4") }, nameToPropertyIndex, new String[] { "test1", "test2", "test3" }, new TokenBuffer[] {}); trp.start(); Assert.assertTrue(trp.handleProperty(jp, null, "test
@Test public void testHandlePropertyValue() throws IOException, JsonProcessingException { Map<String, Integer> nameToPropertyIndex = new HashMap<String, Integer>(); nameToPropertyIndex.put("test1", 1); nameToPropertyIndex.put("test2", 2); ExternalTypeHandler tHandler = new ExternalTypeHandler(new ExtTypedProperty[] { property("test1.test2.test3"), property("test2.test3.test4") }, nameToPropertyIndex, new String[] { "test1", "test2", "test3" }, new TokenBuffer[] { new TokenBuffer("test1"), new TokenBuffer("test2"), new TokenBuffer("test3"
@Test public void handlePropertyValue() throws IOException, JsonProcessingException { SettableBeanProperty prop = mock(SettableBeanProperty.class); when(prop.hasTypePropertyName("a")).thenReturn(true); when(prop.hasTypePropertyName("b")).thenReturn(true); when(prop.hasTypePropertyName("c")).thenReturn(true); when(prop.hasTypePropertyName("d")).thenReturn(true); when(prop.hasTypePropertyName("e")).thenReturn(true); when(prop.hasTypePropertyName("f")).thenReturn(true); when(prop.hasTypePropertyName("g")).thenReturn(true); when(prop.hasTypePropertyName("
@Test public void test_deserializeAndSet() throws IOException, JsonProcessingException { Map<String, Integer> nameToPropertyIndex = new HashMap<String, Integer>(); nameToPropertyIndex.put("test1", 1); nameToPropertyIndex.put("test2", 2); ExternalTypeHandler trp = new ExternalTypeHandler(new ExtTypedProperty[] { property("test1.test2.test3"), property("test2.test3.test4") }, nameToPropertyIndex, new String[] { "test1", "test2", "test3" }, new TokenBuffer[] { new TokenBuffer("test1"), new TokenBuffer("test2"), new TokenBuffer("test3
@Test public void handlePropertyValue() throws IOException, JsonProcessingException { Map<String, Integer> nameToPropertyIndex = new HashMap<String, Integer>(); nameToPropertyIndex.put("test1", 1); nameToPropertyIndex.put("test2", 2); ExternalTypeHandler tHandler = new ExternalTypeHandler(new ExtTypedProperty[] { property("test1.test2.test3"), property("test2.test3.test4") }, nameToPropertyIndex, new String[] { "test1", "test2", "test3" }, new TokenBuffer[] { new TokenBuffer("test1"), new TokenBuffer("test2"), new TokenBuffer("test3"),
@Test public void handlePropertyValue() throws IOException, JsonProcessingException { Map<String, Integer> nameToPropertyIndex = new HashMap<String, Integer>(); nameToPropertyIndex.put("test1", 1); nameToPropertyIndex.put("test2", 2); ExternalTypeHandler tHandler = new ExternalTypeHandler(new ExtTypedProperty[] { property("test1.test2.test3"), property("test2.test3.test4") }, nameToPropertyIndex, new String[] { "test1", "test2", "test3" }, new TokenBuffer[] { new TokenBuffer("test1"), new TokenBuffer("test2"), new TokenBuffer("test3"),
@Test public void testComplete() throws Exception { String json = "[\\n" + " {\\n" + " \\"type\\": \\"string\\",\\n" + " \\"properties\\": [\\n" + " {\\n" + " \\"name\\": \\"test\\",\\n" + " \\"type\\": \\"string\\"\\n" + " },\\n" + " {\\n" + " \\"name\\": \\"test2\\",\\n" + " \\"type\\": \\"string\\"\\n" + " },\\n" + " {\\n" + " \\"name\\": \\"test
@Test public void testComplete() throws Exception { Map<String, Integer> typeToPropertyIndex = new HashMap<String, Integer>(); typeToPropertyIndex.put("test1", 0); typeToPropertyIndex.put("test2", 1); Map<String, String> properties = new HashMap<String, String>(); properties.put("test1", "value1"); properties.put("test2", "value2"); SettableBean bean = new SettableBean(); ExternalTypeHandler h = new ExternalTypeHandler(properties, typeToPropertyIndex, new String[0], new TokenBuffer[] {new TokenBuffer("test1"), new TokenBuffer("test2"), new TokenBuffer("
@Test public void testComplete() throws Exception { Map<String, Integer> typeToPropertyIndex = new HashMap<String, Integer>(); typeToPropertyIndex.put("test1", 0); typeToPropertyIndex.put("test2", 1); typeToPropertyIndex.put("test3", 2); Map<String, String> properties = new HashMap<String, String>(); properties.put("test1", "value1"); properties.put("test2", "value2"); properties.put("test3", "value3"); Map<String, String> typeIds = new HashMap<String, String>(); typeIds.put("test1", "test2"); typeIds.put("
@Test public void testComplete() throws Exception { Map<String, Integer> typeIds = new HashMap<String, Integer>(); typeIds.put("test1", 1); typeIds.put("test2", 2); typeIds.put("test3", 3); Map<String, String> properties = new HashMap<String, String>(); properties.put("test1", "value1"); properties.put("test2", "value2"); properties.put("test3", "value3"); Map<String, String> typeIds2 = new HashMap<String, String>(); typeIds2.put("test1", "value1"); typeIds2.put("test2", "value
@Test public void testComplete() throws Exception { Map<String, Integer> typeIds = new HashMap<String, Integer>(); typeIds.put("test1", 0); typeIds.put("test2", 1); typeIds.put("test3", 2); Map<String, String> properties = new HashMap<String, String>(); properties.put("test1", "value1"); properties.put("test2", "value2"); properties.put("test3", "value3"); Map<String, String> typeIds2 = new HashMap<String, String>(); typeIds2.put("test1", "value1"); typeIds2.put("test2", "value
@Test public void testComplete() throws Exception { Map<String, Integer> typeIds = new HashMap<String, Integer>(); typeIds.put("test1", 0); typeIds.put("test2", 1); typeIds.put("test3", 2); Map<String, String> properties = new HashMap<String, String>(); properties.put("test1", "value1"); properties.put("test2", "value2"); properties.put("test3", "value3"); Map<String, String> typeIds2 = new HashMap<String, String>(); typeIds2.put("test1", "value1"); typeIds2.put("test2", "value
@Test public void testComplete() throws Exception { Map<String, Integer> typeIds = new HashMap<String, Integer>(); typeIds.put("test1", 0); typeIds.put("test2", 1); typeIds.put("test3", 2); Map<String, String> properties = new HashMap<String, String>(); properties.put("test1", "value1"); properties.put("test2", "value2"); properties.put("test3", "value3"); TypeDeserializer typeDeserializer = mock(TypeDeserializer.class); when(typeDeserializer.deserializeIfNatural(any(JsonParser.class), any(DeserializationContext.class), anyString())).then
@Test public void testComplete() throws Exception { Map<String, Integer> typeIds = new HashMap<String, Integer>(); typeIds.put("test1", 0); typeIds.put("test2", 1); typeIds.put("test3", 2); Map<String, String> properties = new HashMap<String, String>(); properties.put("test1", "value1"); properties.put("test2", "value2"); properties.put("test3", "value3"); Map<String, String> typeIds2 = new HashMap<String, String>(); typeIds2.put("test1", "value1"); typeIds2.put("test2", "value
@Test(expectedExceptions = NullPointerException.class) public void testNullProperty() throws IOException, JsonProcessingException { JsonParser jp = mock(JsonParser.class); DeserializationContext ctxt = mock(DeserializationContext.class); PropertyValueBuffer buffer = mock(PropertyValueBuffer.class); PropertyBasedCreator creator = mock(PropertyBasedCreator.class); when(creator.build(jp, buffer)).thenReturn(null); new MyBean().complete(jp, ctxt, buffer, creator); }
@Test(expectedExceptions = JsonProcessingException.class) public void noType() throws JsonProcessingException, IOException { JsonParser jp = Mockito.mock(JsonParser.class); DeserializationContext ctxt = Mockito.mock(DeserializationContext.class); PropertyValueBuffer buffer = Mockito.mock(PropertyValueBuffer.class); PropertyBasedCreator creator = Mockito.mock(PropertyBasedCreator.class); Mockito.when(creator.build(jp, buffer)).thenReturn(null); Mockito.when(_properties[0].hasDefaultType()).thenReturn(false); Mockito.when(_properties[1].hasDefaultType()).thenReturn(false); Mockito.when(_properties[
@Test(expectedExceptions = JsonProcessingException.class) public void noType() throws JsonProcessingException, IOException { JsonParser jp = Mockito.mock(JsonParser.class); DeserializationContext ctxt = Mockito.mock(DeserializationContext.class); PropertyValueBuffer buffer = Mockito.mock(PropertyValueBuffer.class); PropertyBasedCreator creator = Mockito.mock(PropertyBasedCreator.class); Mockito.when(creator.build(jp, buffer)).thenReturn(null); Mockito.when(properties[0].hasDefaultType()).thenReturn(false); Mockito.when(properties[1].hasDefaultType()).thenReturn(false); Mockito.when(properties[
@Test(expectedExceptions = JsonProcessingException.class) public void noType() throws JsonProcessingException, IOException { JsonParser jp = Mockito.mock(JsonParser.class); DeserializationContext ctxt = Mockito.mock(DeserializationContext.class); PropertyValueBuffer buffer = Mockito.mock(PropertyValueBuffer.class); PropertyBasedCreator creator = Mockito.mock(PropertyBasedCreator.class); Mockito.when(creator.build(jp, buffer)).thenReturn(null); Mockito.when(_properties[0].hasDefaultType()).thenReturn(false); Mockito.when(_properties[1].hasDefaultType()).thenReturn(false); Mockito.when(_properties[
@Test(expectedExceptions = JsonProcessingException.class) public void testNullType() throws IOException, JsonProcessingException { SimpleDeserializationContext context = new SimpleDeserializationContext(); SimpleDeserializationBuilder builder = new SimpleDeserializationBuilder(); SimpleDeserializationBuilder builder1 = new SimpleDeserializationBuilder(); SimpleDeserializationBuilder builder2 = new SimpleDeserializationBuilder(); SimpleDeserializationBuilder builder3 = new SimpleDeserializationBuilder(); builder1.setProperty(null); builder2.setProperty(null); builder3.setProperty(null); SimpleDeserializationBuilder builder4 = new SimpleDeserializationBuilder(); builder4.setProperty(null); builder4.setProperty(null); SimpleDeserializationBuilder builder5 = new Simple
@Test(expectedExceptions = JsonProcessingException.class) public void noType() throws JsonProcessingException, IOException { JsonParser jp = Mockito.mock(JsonParser.class); DeserializationContext ctxt = Mockito.mock(DeserializationContext.class); PropertyValueBuffer buffer = Mockito.mock(PropertyValueBuffer.class); PropertyBasedCreator creator = Mockito.mock(PropertyBasedCreator.class); Mockito.when(creator.build(jp, buffer)).thenReturn(null); Mockito.when(_properties[0].hasDefaultType()).thenReturn(false); Mockito.when(_properties[1].hasDefaultType()).thenReturn(false); Mockito.when(_properties[
@Test(expectedExceptions = JsonProcessingException.class) public void testNoProperty() throws JsonProcessingException, IOException { JsonParser jp = Mockito.mock(JsonParser.class); DeserializationContext ctxt = Mockito.mock(DeserializationContext.class); PropertyValueBuffer buffer = Mockito.mock(PropertyValueBuffer.class); PropertyBasedCreator creator = Mockito.mock(PropertyBasedCreator.class); Mockito.when(creator.build(jp, buffer)).thenReturn(null); Mockito.when(properties[0].hasDefaultType()).thenReturn(false); Mockito.when(properties[0].getProperty()).thenReturn(null); Mockito.when(properties[
@Test(expectedExceptions = NullPointerException.class, expectedExceptionsMessageRegExp = ".*null.*") public void testNullValue() throws IOException, JsonProcessingException { JsonParser jp = Mockito.mock(JsonParser.class); DeserializationContext ctxt = Mockito.mock(DeserializationContext.class); PropertyValueBuffer buffer = Mockito.mock(PropertyValueBuffer.class); PropertyBasedCreator creator = Mockito.mock(PropertyBasedCreator.class); Mockito.when(creator.build(jp, buffer)).thenReturn(null); ExternalTypeHandler.Builder builder = new ExternalTypeHandler.Builder(); builder.setProperties(new ExternalTypeHandler.Properties() { @Override public String getDefaultTypeId() {
@Test(expectedExceptions = JsonProcessingException.class) public void testNoProperty() throws JsonProcessingException, IOException { JsonParser jp = Mockito.mock(JsonParser.class); DeserializationContext ctxt = Mockito.mock(DeserializationContext.class); PropertyValueBuffer buffer = Mockito.mock(PropertyValueBuffer.class); PropertyBasedCreator creator = Mockito.mock(PropertyBasedCreator.class); Mockito.when(creator.build(jp, buffer)).thenReturn(null); Mockito.when(properties[0].hasDefaultType()).thenReturn(false); Mockito.when(properties[0].getProperty()).thenReturn(null); Mockito.when(properties[
@Test(expectedExceptions = JsonProcessingException.class) public void testException() throws IOException, JsonProcessingException { JsonParser jp = mock(JsonParser.class); DeserializationContext ctxt = mock(DeserializationContext.class); PropertyValueBuffer buffer = mock(PropertyValueBuffer.class); PropertyBasedCreator creator = mock(PropertyBasedCreator.class); when(creator.build(jp, buffer)).thenThrow(new NullPointerException()); new MyObject().complete(jp, ctxt, buffer, creator); }
@Test(expectedExceptions = JsonProcessingException.class) public void noType() throws JsonProcessingException, IOException { JsonParser jp = Mockito.mock(JsonParser.class); DeserializationContext ctxt = Mockito.mock(DeserializationContext.class); PropertyValueBuffer buffer = Mockito.mock(PropertyValueBuffer.class); PropertyBasedCreator creator = Mockito.mock(PropertyBasedCreator.class); Mockito.when(creator.build(jp, buffer)).thenReturn(null); Mockito.when(_properties[0].hasDefaultType()).thenReturn(false); Mockito.when(_properties[1].hasDefaultType()).thenReturn(false); Mockito.when(_properties[
@Test(expectedExceptions = JsonProcessingException.class) public void noType() throws JsonProcessingException, IOException { JsonParser jp = Mockito.mock(JsonParser.class); DeserializationContext ctxt = Mockito.mock(DeserializationContext.class); PropertyValueBuffer buffer = Mockito.mock(PropertyValueBuffer.class); PropertyBasedCreator creator = Mockito.mock(PropertyBasedCreator.class); Mockito.when(creator.build(jp, buffer)).thenReturn(null); Mockito.when(_properties[0].hasDefaultType()).thenReturn(false); Mockito.when(_properties[1].hasDefaultType()).thenReturn(false); Mockito.when(_properties[
@Test public void simple() throws IOException, JsonProcessingException { SimpleBean bean1 = new SimpleBean(); bean1.setIntegerProperty(1); SimpleBean bean2 = new SimpleBean(); bean2.setIntegerProperty(1); SimpleBean bean3 = new SimpleBean(); bean3.setIntegerProperty(1); SimpleBean bean4 = new SimpleBean(); bean4.setIntegerProperty(1); SimpleBean bean5 = new SimpleBean(); bean5.setIntegerProperty(1); SimpleBean bean6 = new SimpleBean(); bean6.setIntegerProperty(1); SimpleBean bean7 = new SimpleBean(); bean7.setIntegerProperty(1); SimpleBean bean8 = new SimpleBean(); bean
@Test(expectedExceptions = JsonProcessingException.class) public void noType() throws JsonProcessingException, IOException { JsonParser jp = Mockito.mock(JsonParser.class); DeserializationContext ctxt = Mockito.mock(DeserializationContext.class); PropertyValueBuffer buffer = Mockito.mock(PropertyValueBuffer.class); PropertyBasedCreator creator = Mockito.mock(PropertyBasedCreator.class); Mockito.when(creator.build(jp, buffer)).thenReturn(null); Mockito.when(_properties[0].hasDefaultType()).thenReturn(false); Mockito.when(_properties[1].hasDefaultType()).thenReturn(false); Mockito.when(_properties[
@Test(expectedExceptions = JsonProcessingException.class) public void noType() throws JsonProcessingException, IOException { JsonParser jp = Mockito.mock(JsonParser.class); DeserializationContext ctxt = Mockito.mock(DeserializationContext.class); PropertyValueBuffer buffer = Mockito.mock(PropertyValueBuffer.class); PropertyBasedCreator creator = Mockito.mock(PropertyBasedCreator.class); Mockito.when(creator.build(jp, buffer)).thenReturn(null); Mockito.when(_properties[0].hasDefaultType()).thenReturn(false); Mockito.when(_properties[1].hasDefaultType()).thenReturn(false); Mockito.when(_properties[
@Test(expectedExceptions = JsonProcessingException.class) public void noType() throws JsonProcessingException, IOException { JsonParser jp = Mockito.mock(JsonParser.class); DeserializationContext ctxt = Mockito.mock(DeserializationContext.class); PropertyValueBuffer buffer = Mockito.mock(PropertyValueBuffer.class); PropertyBasedCreator creator = Mockito.mock(PropertyBasedCreator.class); Mockito.when(creator.build(jp, buffer)).thenReturn(null); Mockito.when(_properties[0].hasDefaultType()).thenReturn(false); Mockito.when(_properties[1].hasDefaultType()).thenReturn(false); Mockito.when(_properties[
@Test(expectedExceptions = JsonProcessingException.class) public void noType() throws JsonProcessingException, IOException { JsonParser jp = Mockito.mock(JsonParser.class); DeserializationContext ctxt = Mockito.mock(DeserializationContext.class); PropertyValueBuffer buffer = Mockito.mock(PropertyValueBuffer.class); PropertyBasedCreator creator = Mockito.mock(PropertyBasedCreator.class); Mockito.when(creator.build(jp, buffer)).thenReturn(null); Mockito.when(_properties[0].hasDefaultType()).thenReturn(false); Mockito.when(_properties[1].hasDefaultType()).thenReturn(false); Mockito.when(_properties[
@Test public void simple() throws IOException, JsonProcessingException { SimpleBean bean1 = new SimpleBean(); bean1.setIntegerProperty(1); SimpleBean bean2 = new SimpleBean(); bean2.setIntegerProperty(1); SimpleBean bean3 = new SimpleBean(); bean3.setIntegerProperty(1); SimpleBean bean4 = new SimpleBean(); bean4.setIntegerProperty(1); SimpleBean bean5 = new SimpleBean(); bean5.setIntegerProperty(1); SimpleBean bean6 = new SimpleBean(); bean6.setIntegerProperty(1); SimpleBean bean7 = new SimpleBean(); bean7.setIntegerProperty(1); SimpleBean bean8 = new SimpleBean(); bean
@Test(expectedExceptions = NullPointerException.class) public void testNullValue() throws JsonProcessingException, IOException { JsonParser jp = Mockito.mock(JsonParser.class); MockDeserializationContext ctxt = Mockito.mock(DeserializationContext.class); PropertyValueBuffer buffer = Mockito.mock(PropertyValueBuffer.class); PropertyBasedCreator creator = Mockito.mock(PropertyBasedCreator.class); Mockito.when(creator.build(jp, buffer)).thenReturn(null); ExternalTypeHandlerImpl handler = new ExternalTypeHandlerImpl(); handler.complete(jp, ctxt, buffer, creator); }
@Test public void test_deserialize() throws IOException, JsonProcessingException { SettableBeanProperty p0 = mock(SettableBeanProperty.class); when(p0.getPropertyName()).thenReturn("p0"); SettableBeanProperty p1 = mock(SettableBeanProperty.class); when(p1.getPropertyName()).thenReturn("p1"); SettableBeanProperty p2 = mock(SettableBeanProperty.class); when(p2.getPropertyName()).thenReturn("p2"); SettableBeanProperty p3 = mock(SettableBeanProperty.class); when(p3.getPropertyName()).thenReturn("p3"); SettableBeanProperty p4 = mock(Set
@Test public void test_deserialize() throws IOException, JsonProcessingException { SettableBeanProperty p0 = mock(SettableBeanProperty.class); when(p0.getPropertyName()).thenReturn("p0"); SettableBeanProperty p1 = mock(SettableBeanProperty.class); when(p1.getPropertyName()).thenReturn("p1"); SettableBeanProperty p2 = mock(SettableBeanProperty.class); when(p2.getPropertyName()).thenReturn("p2"); SettableBeanProperty p3 = mock(SettableBeanProperty.class); when(p3.getPropertyName()).thenReturn("p3"); SettableBeanProperty p4 = mock(Set
@Test public void test_deserialize() throws IOException, JsonProcessingException { SettableBeanProperty p0 = mock(SettableBeanProperty.class); when(p0.getPropertyName()).thenReturn("p0"); SettableBeanProperty p1 = mock(SettableBeanProperty.class); when(p1.getPropertyName()).thenReturn("p1"); SettableBeanProperty p2 = mock(SettableBeanProperty.class); when(p2.getPropertyName()).thenReturn("p2"); SettableBeanProperty p3 = mock(SettableBeanProperty.class); when(p3.getPropertyName()).thenReturn("p3"); SettableBeanProperty p4 = mock(Set
@Test public void testMerge() throws IOException, JsonProcessingException { SettableBeanProperty p1 = mockProperty("p1"); SettableBeanProperty p2 = mockProperty("p2"); when(p1.getProperty()).thenReturn(p2); when(p2.getProperty()).thenReturn(p1); SettableBeanProperty p3 = mockProperty("p3"); SettableBeanProperty p4 = mockProperty("p4"); when(p4.getProperty()).thenReturn(p3); SettableBeanProperty p5 = mockProperty("p5"); SettableBeanProperty p6 = mockProperty("p6"); when(p6.getProperty()).thenReturn(
@Test public void testComplete() throws IOException, JsonProcessingException { SettableBeanProperty p0 = mock(SettableBeanProperty.class); when(p0.getPropertyName()).thenReturn("p0"); SettableBeanProperty p1 = mock(SettableBeanProperty.class); when(p1.getPropertyName()).thenReturn("p1"); SettableBeanProperty p2 = mock(SettableBeanProperty.class); when(p2.getPropertyName()).thenReturn("p2"); SettableBeanProperty p3 = mock(SettableBeanProperty.class); when(p3.getPropertyName()).thenReturn("p3"); SettableBeanProperty p4 = mock(Settable
@Test public void test_deserialize() throws IOException, JsonProcessingException { SettableBeanProperty p0 = mock(SettableBeanProperty.class); when(p0.getPropertyName()).thenReturn("p0"); SettableBeanProperty p1 = mock(SettableBeanProperty.class); when(p1.getPropertyName()).thenReturn("p1"); SettableBeanProperty p2 = mock(SettableBeanProperty.class); when(p2.getPropertyName()).thenReturn("p2"); SettableBeanProperty p3 = mock(SettableBeanProperty.class); when(p3.getPropertyName()).thenReturn("p3"); SettableBeanProperty p4 = mock(Set
@Test public void testComplete() throws IOException, JsonProcessingException { SettableBeanProperty p1 = mock(SettableBeanProperty.class); when(p1.getPropertyName()).thenReturn("p1"); SettableBeanProperty p2 = mock(SettableBeanProperty.class); when(p2.getPropertyName()).thenReturn("p2"); SettableBeanProperty p3 = mock(SettableBeanProperty.class); when(p3.getPropertyName()).thenReturn("p3"); SettableBeanProperty p4 = mock(SettableBeanProperty.class); when(p4.getPropertyName()).thenReturn("p4"); when(p4.getProperty()).thenReturn
@Test public void test_deserialize() throws IOException, JsonProcessingException { SettableBeanProperty p0 = mock(SettableBeanProperty.class); when(p0.getPropertyName()).thenReturn("p0"); SettableBeanProperty p1 = mock(SettableBeanProperty.class); when(p1.getPropertyName()).thenReturn("p1"); SettableBeanProperty p2 = mock(SettableBeanProperty.class); when(p2.getPropertyName()).thenReturn("p2"); SettableBeanProperty p3 = mock(SettableBeanProperty.class); when(p3.getPropertyName()).thenReturn("p3"); SettableBeanProperty p4 = mock(Set
@Test public void testComplete() throws IOException, JsonProcessingException { SettableBeanProperty p0 = mock(SettableBeanProperty.class); when(p0.getPropertyName()).thenReturn("p0"); SettableBeanProperty p1 = mock(SettableBeanProperty.class); when(p1.getPropertyName()).thenReturn("p1"); SettableBeanProperty p2 = mock(SettableBeanProperty.class); when(p2.getPropertyName()).thenReturn("p2"); SettableBeanProperty p3 = mock(SettableBeanProperty.class); when(p3.getPropertyName()).thenReturn("p3"); SettableBeanProperty p4 = mock(Settable
@Test public void test_deserialize() throws IOException, JsonProcessingException { SettableBeanProperty p0 = mock(SettableBeanProperty.class); when(p0.getPropertyName()).thenReturn("p0"); SettableBeanProperty p1 = mock(SettableBeanProperty.class); when(p1.getPropertyName()).thenReturn("p1"); SettableBeanProperty p2 = mock(SettableBeanProperty.class); when(p2.getPropertyName()).thenReturn("p2"); SettableBeanProperty p3 = mock(SettableBeanProperty.class); when(p3.getPropertyName()).thenReturn("p3"); SettableBeanProperty p4 = mock(Set
@Test public void test() throws IOException, JsonProcessingException { SettableBeanProperty p1 = mock(SettableBeanProperty.class); when(p1.getPropertyName()).thenReturn("p1"); SettableBeanProperty p2 = mock(SettableBeanProperty.class); when(p2.getPropertyName()).thenReturn("p2"); SettableBeanProperty p3 = mock(SettableBeanProperty.class); when(p3.getPropertyName()).thenReturn("p3"); SettableBeanProperty p4 = mock(SettableBeanProperty.class); when(p4.getPropertyName()).thenReturn("p4"); SettableBeanProperty p5 = mock(SettableBean
@Test public void test_deserializeAndSet() throws IOException, JsonProcessingException { SettableBeanProperty p0 = mock(SettableBeanProperty.class); when(p0.getPropertyName()).thenReturn("p0"); SettableBeanProperty p1 = mock(SettableBeanProperty.class); when(p1.getPropertyName()).thenReturn("p1"); SettableBeanProperty p2 = mock(SettableBeanProperty.class); when(p2.getPropertyName()).thenReturn("p2"); SettableBeanProperty p3 = mock(SettableBeanProperty.class); when(p3.getPropertyName()).thenReturn("p3"); SettableBeanProperty p4 = mock(
@Test public void test_deserializeAndSet() throws IOException, JsonProcessingException { SettableBeanProperty p0 = mock(SettableBeanProperty.class); when(p0.getPropertyName()).thenReturn("p0"); SettableBeanProperty p1 = mock(SettableBeanProperty.class); when(p1.getPropertyName()).thenReturn("p1"); SettableBeanProperty p2 = mock(SettableBeanProperty.class); when(p2.getPropertyName()).thenReturn("p2"); SettableBeanProperty p3 = mock(SettableBeanProperty.class); when(p3.getPropertyName()).thenReturn("p3"); SettableBeanProperty p4 = mock(
@Test public void test_deserializeAndSet() throws IOException, JsonProcessingException { SettableBeanProperty p0 = mock(SettableBeanProperty.class); when(p0.getPropertyName()).thenReturn("p0"); SettableBeanProperty p1 = mock(SettableBeanProperty.class); when(p1.getPropertyName()).thenReturn("p1"); SettableBeanProperty p2 = mock(SettableBeanProperty.class); when(p2.getPropertyName()).thenReturn("p2"); SettableBeanProperty p3 = mock(SettableBeanProperty.class); when(p3.getPropertyName()).thenReturn("p3"); SettableBeanProperty p4 = mock(
@Test public void testComplete() throws IOException, JsonProcessingException { SettableBeanProperty p1 = mock(SettableBeanProperty.class); when(p1.getPropertyName()).thenReturn("p1"); SettableBeanProperty p2 = mock(SettableBeanProperty.class); when(p2.getPropertyName()).thenReturn("p2"); SettableBeanProperty p3 = mock(SettableBeanProperty.class); when(p3.getPropertyName()).thenReturn("p3"); SettableBeanProperty p4 = mock(SettableBeanProperty.class); when(p4.getPropertyName()).thenReturn("p4"); when(p4.getProperty()).thenReturn
@Test public void testComplete() throws IOException, JsonProcessingException { SettableBeanProperty p0 = mock(SettableBeanProperty.class); when(p0.getPropertyName()).thenReturn("p0"); SettableBeanProperty p1 = mock(SettableBeanProperty.class); when(p1.getPropertyName()).thenReturn("p1"); SettableBeanProperty p2 = mock(SettableBeanProperty.class); when(p2.getPropertyName()).thenReturn("p2"); SettableBeanProperty p3 = mock(SettableBeanProperty.class); when(p3.getPropertyName()).thenReturn("p3"); SettableBeanProperty p4 = mock(Settable
@Test public void test_deserializeAndSet() throws IOException, JsonProcessingException { SettableBeanProperty prop1 = mock(SettableBeanProperty.class); when(prop1.getPropertyName()).thenReturn("prop1"); SettableBeanProperty prop2 = mock(SettableBeanProperty.class); when(prop2.getPropertyName()).thenReturn("prop2"); SettableBeanProperty prop3 = mock(SettableBeanProperty.class); when(prop3.getPropertyName()).thenReturn("prop3"); SettableBeanProperty prop4 = mock(SettableBeanProperty.class); when(prop4.getPropertyName()).thenReturn("prop4"); when(prop5.getPropertyName()).
@Test public void testComplete() throws IOException, JsonProcessingException { SettableBeanProperty p0 = mock(SettableBeanProperty.class); when(p0.getPropertyName()).thenReturn("p0"); SettableBeanProperty p1 = mock(SettableBeanProperty.class); when(p1.getPropertyName()).thenReturn("p1"); SettableBeanProperty p2 = mock(SettableBeanProperty.class); when(p2.getPropertyName()).thenReturn("p2"); SettableBeanProperty p3 = mock(SettableBeanProperty.class); when(p3.getPropertyName()).thenReturn("p3"); SettableBeanProperty p4 = mock(Settable
@Test public void test_deserializeAndSet() throws IOException, JsonProcessingException { SettableBeanProperty p0 = mock(SettableBeanProperty.class); when(p0.getPropertyName()).thenReturn("p0"); SettableBeanProperty p1 = mock(SettableBeanProperty.class); when(p1.getPropertyName()).thenReturn("p1"); SettableBeanProperty p2 = mock(SettableBeanProperty.class); when(p2.getPropertyName()).thenReturn("p2"); SettableBeanProperty p3 = mock(SettableBeanProperty.class); when(p3.getPropertyName()).thenReturn("p3"); SettableBeanProperty p4 = mock(
@Test public void testComplete() throws IOException, JsonProcessingException { SettableBeanProperty p0 = mock(SettableBeanProperty.class); when(p0.getPropertyName()).thenReturn("p0"); SettableBeanProperty p1 = mock(SettableBeanProperty.class); when(p1.getPropertyName()).thenReturn("p1"); SettableBeanProperty p2 = mock(SettableBeanProperty.class); when(p2.getPropertyName()).thenReturn("p2"); SettableBeanProperty p3 = mock(SettableBeanProperty.class); when(p3.getPropertyName()).thenReturn("p3"); SettableBeanProperty p4 = mock(Settable
@Test public void test_deserializeAndSet() throws IOException, JsonProcessingException { SettableBeanProperty prop1 = mock(SettableBeanProperty.class); when(prop1.getPropertyName()).thenReturn("prop1"); SettableBeanProperty prop2 = mock(SettableBeanProperty.class); when(prop2.getPropertyName()).thenReturn("prop2"); SettableBeanProperty prop3 = mock(SettableBeanProperty.class); when(prop3.getPropertyName()).thenReturn("prop3"); SettableBeanProperty prop4 = mock(SettableBeanProperty.class); when(prop4.getPropertyName()).thenReturn("prop4"); when(prop5.getPropertyName()).
@Test public void testComplete() throws IOException, JsonProcessingException { SettableBeanProperty p1 = mock(SettableBeanProperty.class); when(p1.getPropertyName()).thenReturn("p1"); SettableBeanProperty p2 = mock(SettableBeanProperty.class); when(p2.getPropertyName()).thenReturn("p2"); SettableBeanProperty p3 = mock(SettableBeanProperty.class); when(p3.getPropertyName()).thenReturn("p3"); SettableBeanProperty p4 = mock(SettableBeanProperty.class); when(p4.getPropertyName()).thenReturn("p4"); SettableBeanProperty p5 = mock(Settable
@Test public void testAddExternal() throws IOException, JsonProcessingException { SettableBeanProperty p1 = mock(SettableBeanProperty.class); when(p1.getName()).thenReturn("p1"); SettableBeanProperty p2 = mock(SettableBeanProperty.class); when(p2.getName()).thenReturn("p2"); SettableBeanProperty p3 = mock(SettableBeanProperty.class); when(p3.getName()).thenReturn("p3"); SettableBeanProperty p4 = mock(SettableBeanProperty.class); when(p4.getName()).thenReturn("p4"); SettableBeanProperty p5 = mock(SettableBeanProperty.
@Test public void testAddExternal() throws IOException, JsonProcessingException { SettableBeanProperty p1 = mock(SettableBeanProperty.class); when(p1.getName()).thenReturn("p1"); SettableBeanProperty p2 = mock(SettableBeanProperty.class); when(p2.getName()).thenReturn("p2"); SettableBeanProperty p3 = mock(SettableBeanProperty.class); when(p3.getName()).thenReturn("p3"); SettableBeanProperty p4 = mock(SettableBeanProperty.class); when(p4.getName()).thenReturn("p4"); SettableBeanProperty p5 = mock(SettableBeanProperty.
@Test public void testAddExternal() throws IOException, JsonProcessingException { SettableBeanProperty prop1 = mock(SettableBeanProperty.class); when(prop1.getName()).thenReturn("prop1"); SettableBeanProperty prop2 = mock(SettableBeanProperty.class); when(prop2.getName()).thenReturn("prop2"); SettableBeanProperty prop3 = mock(SettableBeanProperty.class); when(prop3.getName()).thenReturn("prop3"); SettableBeanProperty prop4 = mock(SettableBeanProperty.class); when(prop4.getName()).thenReturn("prop4"); SettableBeanProperty prop5 = mock(SettableBeanProperty.
@Test public void testAddExternal() throws IOException, JsonProcessingException { SettableBeanProperty p0 = mock(SettableBeanProperty.class); when(p0.getName()).thenReturn("p0"); SettableBeanProperty p1 = mock(SettableBeanProperty.class); when(p1.getName()).thenReturn("p1"); SettableBeanProperty p2 = mock(SettableBeanProperty.class); when(p2.getName()).thenReturn("p2"); SettableBeanProperty p3 = mock(SettableBeanProperty.class); when(p3.getName()).thenReturn("p3"); SettableBeanProperty p4 = mock(SettableBeanProperty.
@Test public void testAddExternal() throws IOException, JsonProcessingException { }
@Test public void testBuild() throws IOException, JsonProcessingException { SettableBeanProperty p1 = mock(SettableBeanProperty.class); when(p1.getPropertyName()).thenReturn("p1"); when(p1.getType()).thenReturn("type1"); SettableBeanProperty p2 = mock(SettableBeanProperty.class); when(p2.getPropertyName()).thenReturn("p2"); when(p2.getType()).thenReturn("type2"); SettableBeanProperty p3 = mock(SettableBeanProperty.class); when(p3.getPropertyName()).thenReturn("p3"); when(p3.getType()).thenReturn("
@Test public void test() throws IOException, JsonProcessingException { SettableBeanProperty p1 = mockProperty("p1", "string"); SettableBeanProperty p2 = mockProperty("p2", "string"); SettableBeanProperty p3 = mockProperty("p3", "string"); SettableBeanProperty p4 = mockProperty("p4", "string"); SettableBeanProperty p5 = mockProperty("p5", "string"); SettableBeanProperty p6 = mockProperty("p6", "string"); SettableBeanProperty p7 = mockProperty("p7", "string"); SettableBeanProperty p8 = mockProperty("p8", "string"); SettableBeanProperty p9 = mock
@Test public void testExtTypedProperty() throws IOException, JsonProcessingException { SettableBeanProperty p1 = mock(SettableBeanProperty.class); when(p1.getPropertyName()).thenReturn("p1"); when(p1.isDefault()).thenReturn(true); SettableBeanProperty p2 = mock(SettableBeanProperty.class); when(p2.getPropertyName()).thenReturn("p2"); when(p2.isDefault()).thenReturn(true); SettableBeanProperty p3 = mock(SettableBeanProperty.class); when(p3.getPropertyName()).thenReturn("p3"); when(p3.isDefault()).thenReturn(
@Test public void testExtTypedProperty() throws IOException, JsonProcessingException { SettableBeanProperty p1 = mock(SettableBeanProperty.class); when(p1.getPropertyName()).thenReturn("p1"); when(p1.isDefault()).thenReturn(true); SettableBeanProperty p2 = mock(SettableBeanProperty.class); when(p2.getPropertyName()).thenReturn("p2"); when(p2.isDefault()).thenReturn(true); SettableBeanProperty p3 = mock(SettableBeanProperty.class); when(p3.getPropertyName()).thenReturn("p3"); when(p3.isDefault()).thenReturn(
@Test public void testExtTypedProperty() throws IOException, JsonProcessingException { SettableBeanProperty p1 = mock(SettableBeanProperty.class); when(p1.getPropertyName()).thenReturn("p1"); when(p1.isDefault()).thenReturn(true); SettableBeanProperty p2 = mock(SettableBeanProperty.class); when(p2.getPropertyName()).thenReturn("p2"); when(p2.isDefault()).thenReturn(true); SettableBeanProperty p3 = mock(SettableBeanProperty.class); when(p3.getPropertyName()).thenReturn("p3"); when(p3.isDefault()).thenReturn(
@Test public void testExtTypedProperty() throws IOException, JsonProcessingException { SettableBeanProperty p1 = mock(SettableBeanProperty.class); when(p1.getPropertyName()).thenReturn("p1"); when(p1.isDefault()).thenReturn(true); SettableBeanProperty p2 = mock(SettableBeanProperty.class); when(p2.getPropertyName()).thenReturn("p2"); when(p2.isDefault()).thenReturn(true); SettableBeanProperty p3 = mock(SettableBeanProperty.class); when(p3.getPropertyName()).thenReturn("p3"); when(p3.isDefault()).thenReturn(
@Test public void testHasTypePropertyName() throws Exception { assertTrue(typeHandler.hasTypePropertyName("a")); assertTrue(typeHandler.hasTypePropertyName("b")); assertTrue(typeHandler.hasTypePropertyName("c")); assertTrue(typeHandler.hasTypePropertyName("d")); assertTrue(typeHandler.hasTypePropertyName("e")); assertTrue(typeHandler.hasTypePropertyName("f")); assertTrue(typeHandler.hasTypePropertyName("g")); assertTrue(typeHandler.hasTypePropertyName("h")); assertTrue(typeHandler.hasTypePropertyName("i")); assertTrue(typeHandler.hasTypePropertyName("j")); assertTrue(typeHandler.
@Test public void testHasTypePropertyName() throws Exception { assertTrue(typeHandler.hasTypePropertyName("foo")); assertTrue(typeHandler.hasTypePropertyName("bar")); assertFalse(typeHandler.hasTypePropertyName("baz")); }
@Test public void testGetProperty() throws IOException { SettableBeanProperty property = _typeHandler.getProperty(); Assert.assertEquals("id", property.getId()); Assert.assertEquals("name", property.getName()); Assert.assertEquals("type", property.getType()); Assert.assertEquals(2, property.getProperties().length); Assert.assertTrue(property.handleProperty(jp, jp, "name", bean)); Assert.assertTrue(property.handleProperty(jp, jp, "type", bean)); Assert.assertTrue(property.handleProperty(jp, jp, "name", bean)); Assert.assertTrue(property.handleProperty(jp, jp, "type", bean));
@Test public void testGetProperty() throws IOException, JsonProcessingException { SettableBeanProperty property = mock(SettableBeanProperty.class); when(property.getName()).thenReturn("name"); when(property.getType()).thenReturn("type"); when(property.isDefault()).thenReturn(true); when(property.handleProperty(any(JsonParser.class), any(JsonDeserializationContext.class), any(Object.class), anyInt(), anyString())).thenReturn(true); when(property.complete(any(JsonParser.class), any(JsonDeserializationContext.class), any(Object.class), anyInt(), anyString())).thenReturn(true);
@Test public void testLocale() { Locale locale = new Locale("en", "US"); assertEquals(locale.getLanguage(), locale.getLanguage()); assertEquals(locale.getCountry(), locale.getCountry()); assertEquals(locale.getVariant(), locale.getVariant()); assertEquals(locale.getVariantLocale(), locale.getVariantLocale()); }
@Test public void testTypeResolverBuilderInstance() throws Exception { TypeResolverBuilder<?> builder = config.typeResolverBuilderInstance(getAnnotated(), TypeResolverBuilder.class); assertNotNull(builder); assertTrue(builder instanceof TypeResolverBuilderImpl); builder = config.typeResolverBuilderInstance(getAnnotated(), TypeResolverBuilderImpl.class); assertNotNull(builder); assertTrue(builder instanceof TypeResolverBuilderImpl); builder = config.typeResolverBuilderInstance(getAnnotated(), TypeResolverBuilderImpl.class); assertNotNull(builder); assertTrue(builder instanceof TypeResolverBuilderImpl); builder = config.typeResolverBuilderInstance(getAnnotated(), TypeResolverBuilderImpl.class); assertNotNull(builder); assertTrue(builder instanceof TypeResolverBuilderImpl
@Test public void testTypeResolverBuilderInstance() { class MyTypeResolverBuilder extends TypeResolverBuilder<String> { @Override public TypeResolverBuilder<?> typeResolverBuilderInstance(Annotated annotated, Class<? extends TypeResolverBuilder<?>> builderClass) { return new MyTypeResolverBuilder(); } } MyTypeResolverBuilder myTypeResolverBuilder = new MyTypeResolverBuilder(); MapperConfig<MyType> config = new MapperConfig<MyType>() { @Override public Class<? extends TypeResolverBuilder<?>> getTypeFactory() { return MyTypeResolverBuilder.class; } }; config.setHandlerInstantiator(new HandlerInstantiator() { @Override public TypeResolverBuilder<MyType> getHandlerInstantiator() { return
@Test public void testTypeResolverBuilderInstance() { MyMapperConfig config = new MyMapperConfig(); config.setEnabled(true); config.setHandlerInstantiator(new HandlerInstantiator() { @Override public TypeResolverBuilder<?> typeResolverBuilderInstance(Annotated annotated, Class<? extends TypeResolverBuilder<?>> builderClass) { return null; } @Override public TypeResolverBuilder<?> typeResolverBuilderInstance(Annotated annotated, Class<? extends TypeResolverBuilder<?>> builderClass) { return new TypeResolverBuilderImpl(); } }); TypeResolverBuilder<?> builder = config.typeResolverBuilderInstance(config.getAnnotated(), TypeResolverBuilder.class); assertNotNull(builder); assertTrue(builder instanceof TypeResolverBuilderImpl
@Test public void testTypeResolverBuilderInstance() { class MyBuilder extends TypeResolverBuilder<MyType> { @Override public TypeResolverBuilder<?> typeResolverBuilderInstance(Annotated annotated, Class<? extends TypeResolverBuilder<?>> builderClass) { return null; } } MyBuilder myBuilder = new MyBuilder(); MapperConfig<MyType> config = new MapperConfig<MyType>(MyType.class) { @Override public Class<? extends TypeResolverBuilder<?>> getBuilderClass() { return MyType.class; } }; assertSame(myBuilder, config.typeResolverBuilderInstance(annotated, MyBuilder.class)); assertSame(myBuilder, config.typeResolverBuilderInstance(annotated,
@Test public void testNullProvider() throws JsonProcessingException { Object nullValue = new Object(); NullProvider provider = new NullProvider(String.class, nullValue); assertEquals(nullValue, provider.nullValue(null)); assertEquals(String.class, provider.getRawType()); assertEquals(nullValue, provider.nullValue(null)); }
@Test public void testNullProvider() { Object nullValue = new Object(); NullProvider provider = new NullProvider(String.class, nullValue); assertSame(nullValue, provider.nullValue(null)); assertSame(nullValue, provider.nullValue(null)); assertSame(nullValue, provider.nullValue(null)); assertSame(nullValue, provider.nullValue(null)); assertSame(nullValue, provider.nullValue(null)); assertSame(nullValue, provider.nullValue(null)); assertSame(nullValue, provider.nullValue(null)); assertSame(nullValue, provider.nullValue(null)); assertSame(nullValue, provider.nullValue(null));
@Test public void testNullProvider() throws JsonProcessingException { Object nullValue = new Object(); NullProvider provider = new NullProvider(String.class, nullValue); assertSame(nullValue, provider.nullValue(new DefaultDeserializationContext())); assertSame(nullValue, provider.nullValue(new DefaultDeserializationContext())); assertSame(nullValue, provider.nullValue(new DefaultDeserializationContext())); assertSame(nullValue, provider.nullValue(new DefaultDeserializationContext())); assertSame(nullValue, provider.nullValue(new DefaultDeserializationContext())); assertSame(nullValue, provider.nullValue(new DefaultDeserializationContext())); }
@Test public void testNullProvider() throws JsonProcessingException { Object nullValue = new Object(); NullProvider provider = new NullProvider(String.class, nullValue); assertSame(nullValue, provider.nullValue(null)); assertSame(nullValue, provider.nullValue(null)); }
@Test public void testStringValueNode() throws IOException { JsonNode node = JsonNodeFactory.instance.objectNode(); node.put("foo", JsonNodeFactory.instance.textNode("bar")); node.put("baz", JsonNodeFactory.instance.textNode("baz")); assertEquals("bar", node.get("foo").asText()); assertEquals("baz", node.get("baz").asText()); }
@Test public void findValuesTest() { List<JsonNode> foundSoFar = new ArrayList<JsonNode>(); foundSoFar.add(JsonNodeFactory.instance.textNode("foo")); foundSoFar.add(JsonNodeFactory.instance.textNode("bar")); foundSoFar.add(JsonNodeFactory.instance.textNode("baz")); foundSoFar.add(JsonNodeFactory.instance.textNode("qux")); List<JsonNode> result = new ArrayList<JsonNode>(); result.add(JsonNodeFactory.instance.textNode("foo")); result.add(JsonNodeFactory.instance.textNode("bar")); result.add(JsonNodeFactory.
@Test public void testFindValues() { List<JsonNode> foundSoFar = new ArrayList<JsonNode>(); foundSoFar.add(new TextNode("foo")); foundSoFar.add(new TextNode("bar")); foundSoFar.add(new TextNode("baz")); foundSoFar.add(new TextNode("qux")); List<JsonNode> foundSoFar2 = new ArrayList<JsonNode>(); foundSoFar2.add(new TextNode("foo")); foundSoFar2.add(new TextNode("bar")); foundSoFar2.add(new TextNode("baz")); foundSoFar2.add(new TextNode("qux")); List<JsonNode
@Test public void testFindParents() { List<JsonNode> foundSoFar = new ArrayList<JsonNode>(); foundSoFar.add(new ObjectNode("parent1")); foundSoFar.add(new ObjectNode("parent2")); foundSoFar.add(new ObjectNode("parent3")); foundSoFar.add(new ObjectNode("parent4")); foundSoFar.add(new ObjectNode("parent5")); foundSoFar.add(new ObjectNode("parent6")); foundSoFar.add(new ObjectNode("parent7")); foundSoFar.add(new ObjectNode("parent8")); foundSoFar.add(new ObjectNode("parent9")); foundSoFar.add(new Object
@Test public void testFindParents() { List<JsonNode> nodes = new ArrayList<JsonNode>(); nodes.add(new ObjectNode("foo")); nodes.add(new ObjectNode("bar")); nodes.add(new ObjectNode("baz")); List<JsonNode> foundSoFar = new ArrayList<JsonNode>(); foundSoFar.add(new ObjectNode("foo")); foundSoFar.add(new ObjectNode("bar")); foundSoFar.add(new ObjectNode("baz")); foundSoFar.add(new ObjectNode("foo")); foundSoFar.add(new ObjectNode("bar")); foundSoFar.add(new ObjectNode("baz")); List<
@Test(expected=IllegalStateException.class) public void testBuildTypeSerializer() { new StdTypeResolverBuilder().buildTypeSerializer(null, null, null); }
@Test(expected=IllegalStateException.class) public void testAsPrimitiveSerializer() { TypeIdResolver idResolver = new DefaultIdResolver(JsonTypeInfo.Id.OBJECT); TypeSerializer serializer = new StdTypeResolverBuilder().init(JsonTypeInfo.Id.OBJECT, idResolver).buildTypeSerializer(null, null, null); }
@Test public void testBuildTypeSerializer() { SimpleTypeInfo.Builder builder = new SimpleTypeInfo.Builder(); builder.idType(JsonTypeInfo.Id.NONE); builder.properties("foo"); TypeSerializer serializer = builder.buildTypeSerializer(null, null, null); Assert.assertNull(serializer); builder.properties("bar"); serializer = builder.buildTypeSerializer(null, null, null); Assert.assertNull(serializer); builder.properties("baz"); serializer = builder.buildTypeSerializer(null, null, null); Assert.assertNull(serializer); builder.properties("baz"); serializer = builder.buildTypeSerializer(null, null, null); Assert.assertNull(serializer); builder.
@Test(expected=IllegalStateException.class) public void testBuildTypeSerializer() { new StdTypeResolverBuilder().init(JsonTypeInfo.Id.NONE, new TypeIdResolver() { @Override protected TypeIdResolver idResolver(SerializationConfig config, JavaType baseType, Collection<NamedType> subtypes, boolean forSer, boolean forDeser) { return null; } @Override protected TypeIdResolver idResolver(SerializationConfig config, JavaType baseType, Collection<NamedType> subtypes, boolean forSer, boolean forDeser) { return null; } @Override protected TypeIdResolver idResolver(SerializationConfig config, JavaType baseType, Collection<NamedType> subtypes, boolean forSer, boolean forDeser)
@Test public void testBuildTypeDeserializer() { Set<NamedType> subtypes = new HashSet<NamedType>(); subtypes.add(new StdTypeInfo.Id("string")); subtypes.add(new StdTypeInfo.Id("boolean")); subtypes.add(new StdTypeInfo.Id("byte")); subtypes.add(new StdTypeInfo.Id("short")); subtypes.add(new StdTypeInfo.Id("int")); subtypes.add(new StdTypeInfo.Id("long")); subtypes.add(new StdTypeInfo.Id("float")); subtypes.add(new StdTypeInfo.Id("double")); subtypes.add(new StdTypeInfo.Id("
@Test public void testAsWrapperTypeDeserializer() { Set<NamedType> subtypes = new HashSet<NamedType>(); subtypes.add(new FooType()); TypeDeserializer deserializer = new StdTypeResolverBuilder().includeAs(JsonTypeInfo.Id.NONE).buildTypeDeserializer(null, FooType.class, subtypes); Assert.assertTrue(deserializer instanceof AsWrapperTypeDeserializer); }
@Test(expected=IllegalStateException.class) public void testClassNameIdResolver() { TypeIdResolver resolver = new MyIdResolver().idResolver(new MapperConfig.Builder().build(), MyType.class, null, false, false); }
@Test(expected=IllegalStateException.class) public void testClassNameIdResolver() { TypeIdResolver resolver = new SimpleClassNameIdResolver().idResolver(new MapperConfig<Object>() { @Override public TypeFactory getTypeFactory() { return new DefaultTypeFactory(); } @Override public TypeFactory getTypeFactory() { return new DefaultTypeFactory(); } }, new JavaType(String.class), null, false, false); Assert.assertNotNull(resolver); resolver.idResolver(new MapperConfig<Object>() { @Override public TypeFactory getTypeFactory() { return new DefaultTypeFactory(); } @Override public TypeFactory getTypeFactory() { return new DefaultTypeFactory(); } }, new JavaType(String.class),
@Test public void registerSubtypes() { NamedType t1 = new NamedType("t1"); NamedType t2 = new NamedType("t2"); NamedType t3 = new NamedType("t3"); new StdSubtypeResolver().registerSubtypes(t1, t2, t3); Collection<NamedType> types = new HashSet<NamedType>(); types.add(t1); types.add(t2); types.add(t3); new StdSubtypeResolver().registerSubtypes(t1, t2, t3); assertTrue(types.contains(t1)); assertTrue(types.contains(t2)); assertTrue(types.contains(t3));
@Test public void testRegisterSubtypes() { StdSubtypeResolver wt = new StdSubtypeResolver(); wt.registerSubtypes(DummyNamedType.class, DummyNamedType.class); wt.registerSubtypes(DummyNamedType.class, DummyNamedType.class); }
@Test public void registerSubtypes() { StdSubtypeResolver wt = new StdSubtypeResolver(); wt.registerSubtypes(TestType.class, TestType2.class); wt.registerSubtypes(TestType.class, TestType1.class, TestType2.class); assertTrue(wt.getRegisteredSubtypes().contains(TestType1.class)); assertTrue(wt.getRegisteredSubtypes().contains(TestType2.class)); assertTrue(wt.getRegisteredSubtypes().contains(TestType1.class)); assertTrue(wt.getRegisteredSubtypes().contains(TestType2.class)); }
@Test public void testRegisterSubtypes() { NamedType t1 = new NamedType("t1"); NamedType t2 = new NamedType("t2"); NamedType t3 = new NamedType("t3"); Set<NamedType> types = new HashSet<NamedType>(); types.add(t1); types.add(t2); types.add(t3); StdSubtypeResolver wt = new StdSubtypeResolver(); wt.registerSubtypes(t1, t2, t3); assertEquals(2, wt.getRegisteredSubtypes().size()); assertEquals(t1, wt.getRegisteredSubtypes().get(0)); assertEquals(t2, wt.get
@Test public void testRegisterSubtypes() { Set<NamedType> types = new HashSet<NamedType>(); NamedType t1 = new NamedType("t1"); types.add(t1); NamedType t2 = new NamedType("t2"); types.add(t2); NamedType t3 = new NamedType("t3"); types.add(t3); new StdSubtypeResolver().registerSubtypes(t1, t2, t3); assertTrue(types.contains(t1)); assertTrue(types.contains(t2)); assertTrue(types.contains(t3)); }
@Test public void registerSubtypes() { Set<NamedType> types = new HashSet<NamedType>(); NamedType t1 = new NamedType("t1"); NamedType t2 = new NamedType("t2"); NamedType t3 = new NamedType("t3"); types.add(t1); types.add(t2); types.add(t3); NamedType t4 = new NamedType("t4"); NamedType t5 = new NamedType("t5"); NamedType t6 = new NamedType("t6"); types.add(t6); classes.add(t1); classes.add(t2); classes.add(t3); classes.add(
@Test public void registerSubtypes() { NamedType t1 = new NamedType(Foo.class); NamedType t2 = new NamedType(Bar.class); NamedType t3 = new NamedType(Baz.class); t1.registerSubtypes(t2); t2.registerSubtypes(t3); Collection<NamedType> types = t1.getTypes(); assertEquals(3, types.size()); assertEquals(Foo.class, types.iterator().next().getType()); assertEquals(Bar.class, types.iterator().next().getType()); assertEquals(Baz.class, types.iterator().next().getType()); }
@Test public void registerSubtypes() { Set<NamedType> types = new HashSet<NamedType>(); NamedType t1 = new NamedType(TestBean.class); NamedType t2 = new NamedType(TestBean2.class); NamedType t3 = new NamedType(TestBean3.class); NamedType t4 = new NamedType(TestBean4.class); types.add(t1); types.add(t2); types.add(t3); types.add(t4); Class<?>[] classes = new Class<?>[] { TestBean.class, TestBean2.class, TestBean3.class, TestBean4.class }; MapperConfig
@Test public void registerSubtypes() { String[][] types = new String[][] { new String[] { "A", "B", "C" }, new String[] { "D", "E", "F" }, new String[] { "G", "H", "I", "J" }, new String[] { "G", "H", "I", "J" }, new String[] { "G", "H", "I", "J" }, new String[] { "G", "H", "I", "J" }, new String[] { "G", "H", "I", "J" }, new String[] { "G", "H", "I", "
@Test public void registerSubtypes() { Set<NamedType> types = new HashSet<NamedType>(); NamedType t1 = new NamedType("t1"); NamedType t2 = new NamedType("t2"); NamedType t3 = new NamedType("t3"); types.add(t1); types.add(t2); types.add(t3); new StdSubtypeResolver().registerSubtypes(types); assertEquals(3, types.size()); assertEquals(t1, types.get(0).getType()); assertEquals(t2, types.get(1).getType()); assertEquals(t3, types.get(2).getType()); }
@Test public void testCollectAndResolveSubtypes() throws Exception { File f = new File(getClass().getClassLoader().getResource("mapper-test.json").getFile()); try { f.delete(); } catch (IOException e) { e.printStackTrace(); } File f2 = new File(getClass().getClassLoader().getResource("mapper-test2.json").getFile()); File f3 = new File(getClass().getClassLoader().getResource("mapper-test3.json").getFile()); File f4 = new File(getClass().getClassLoader().getResource("mapper-test4.json").getFile()); File f5 = new File(getClass().getClassLoader().getResource("mapper
@Test public void testCollectAndResolveSubtypes() { Method m = Foo.class.getDeclaredMethod("getFoo"); Collection<NamedType> collected = new StdSubtypeResolver().collectAndResolveSubtypes(m, null, new AnnotationIntrospector(m, new HashMap<String, Object>()), JavaType.get(Foo.class)); assertTrue(collected.isEmpty()); collected = new StdSubtypeResolver().collectAndResolveSubtypes(m, null, new AnnotationIntrospector(m, new HashMap<String, Object>()), JavaType.get(Foo.class)); assertTrue(collected.isEmpty()); }
@Test public void testCollectAndResolveSubtypes() { System.out.println("collectAndResolveSubtypes"); Method m = Foo.class.getDeclaredMethod("foo"); AnnotationIntrospector config = new AnnotationIntrospector(m); Collection<NamedType> collected = new HashMap<NamedType, MediaType>(); Collection<NamedType> types = new HashMap<NamedType, MediaType>(); types.add(Foo.class); types.add(Foo.class); Collection<NamedType> types2 = new HashMap<NamedType, MediaType>(); types2.add(Foo.class); types2.add(Foo.class); Collection<NamedType> types3 = new HashMap
@Test public void testCollectAndResolveSubtypes() { System.out.println("collectAndResolveSubtypes"); Set<AnnotatedMember> fields = new HashSet<AnnotatedMember>(); fields.add(new AnnotatedFieldImpl(Employee.class)); fields.add(new AnnotatedFieldImpl(Employee.class)); fields.add(new AnnotatedFieldImpl(Employee.class)); fields.add(new AnnotatedFieldImpl(Employee.class)); fields.add(new AnnotatedFieldImpl(Employee.class)); fields.add(new AnnotatedFieldImpl(Employee.class)); fields.add(new AnnotatedFieldImpl(Employee.class)); fields.add(new AnnotatedFieldImpl(Employee.
@Test public void testCollectAndResolveSubtypes() { System.out.println("collectAndResolveSubtypes"); Map<String, Object> config = new HashMap<String, Object>(); Method m = Foo.class.getDeclaredMethod("getFoo"); config.put(m.getName(), m); Method m2 = Foo.class.getDeclaredMethod("getFoo2"); config.put(m2.getName(), m2); Method m3 = Foo.class.getDeclaredMethod("getFoo3"); config.put(m3.getName(), m3); Method m4 = Foo.class.getDeclaredMethod("getFoo4"); config.put(m4.getName
@Test public void testCollectAndResolveSubtypes() { System.out.println("collectAndResolveSubtypes"); Method m = Foo.class.getDeclaredMethod("getFoo"); Method m2 = Foo.class.getDeclaredMethod("getFoo2"); Method m3 = Foo.class.getDeclaredMethod("getFoo3"); Method m4 = Foo.class.getDeclaredMethod("getFoo4"); Method m5 = Foo.class.getDeclaredMethod("getFoo5"); Method m6 = Foo.class.getDeclaredMethod("getFoo6"); Method m7 = Foo.class.getDeclaredMethod("getFoo7"); Method m8 = Foo.class
@Test public void testCollectAndResolveSubtypes() throws Exception { Method m = Foo.class.getDeclaredMethod("getFoo"); Method m2 = Foo.class.getDeclaredMethod("getFoo2"); Method m3 = Foo.class.getDeclaredMethod("getFoo3"); Method m4 = Foo.class.getDeclaredMethod("getFoo4"); Method m5 = Foo.class.getDeclaredMethod("getFoo5"); Method m6 = Foo.class.getDeclaredMethod("getFoo6"); Method m7 = Foo.class.getDeclaredMethod("getFoo7"); Method m8 = Foo.class.getDeclaredMethod("getFoo8");
@Test public void testCollectAndResolve() throws Exception { Method m = Foo.class.getDeclaredMethod("getFoo"); Method m2 = Foo.class.getDeclaredMethod("getFoo2"); Method m3 = Foo.class.getDeclaredMethod("getFoo3"); Method m4 = Foo.class.getDeclaredMethod("getFoo4"); Method m5 = Foo.class.getDeclaredMethod("getFoo5"); Method m6 = Foo.class.getDeclaredMethod("getFoo6"); Method m7 = Foo.class.getDeclaredMethod("getFoo7"); Method m8 = Foo.class.getDeclaredMethod("getFoo8"); Method m
@Test public void testCollectAndResolveSubtypes() { System.out.println("collectAndResolveSubtypes"); Set<AnnotatedMember> memberSet = new HashSet<AnnotatedMember>(); Set<NamedType> types = new HashSet<NamedType>(); NamedType t1 = new NamedType(TestClass.class, null); NamedType t2 = new NamedType(TestClass2.class, null); NamedType t3 = new NamedType(TestClass3.class, null); NamedType t4 = new NamedType(TestClass4.class, null); NamedType t5 = new NamedType(TestClass5.class, null); NamedType t6 = new NamedType(TestClass
@Test public void testCollectAndResolveSubtypes() throws Exception { Method m = Foo.class.getDeclaredMethod("getFoo"); Method m2 = Foo.class.getDeclaredMethod("getFoo2"); Method m3 = Foo.class.getDeclaredMethod("getFoo3"); Method m4 = Foo.class.getDeclaredMethod("getFoo4"); Method m5 = Foo.class.getDeclaredMethod("getFoo5"); Method m6 = Foo.class.getDeclaredMethod("getFoo6"); Method m7 = Foo.class.getDeclaredMethod("getFoo7"); Method m8 = Foo.class.getDeclaredMethod("getFoo8");
@Test public void testCollectAndResolveSubtypes() { Method m = Foo.class.getDeclaredMethod("getFoo"); Method m2 = Foo.class.getDeclaredMethod("getFoo2"); Method m3 = Foo.class.getDeclaredMethod("getFoo3"); Method m4 = Foo.class.getDeclaredMethod("getFoo4"); Method m5 = Foo.class.getDeclaredMethod("getFoo5"); Method m6 = Foo.class.getDeclaredMethod("getFoo6"); Method m7 = Foo.class.getDeclaredMethod("getFoo7"); Method m8 = Foo.class.getDeclaredMethod("getFoo8"); Collection<
@Test public void testCollectAndResolveSubtypes() { System.out.println("collectAndResolveSubtypes"); Method m = Foo.class.getDeclaredMethod("getFoo"); Method m2 = Foo.class.getDeclaredMethod("getFoo2"); Method m3 = Foo.class.getDeclaredMethod("getFoo3"); Method m4 = Foo.class.getDeclaredMethod("getFoo4"); Method m5 = Foo.class.getDeclaredMethod("getFoo5"); Method m6 = Foo.class.getDeclaredMethod("getFoo6"); Method m7 = Foo.class.getDeclaredMethod("getFoo7"); Method m8 = Foo.class
@Test public void testCollectAndResolve() throws Exception { Method m = Foo.class.getDeclaredMethod("m"); Method m2 = Foo.class.getDeclaredMethod("m2"); Method m3 = Foo.class.getDeclaredMethod("m3"); Method m4 = Foo.class.getDeclaredMethod("m4"); Method m5 = Foo.class.getDeclaredMethod("m5"); Method m6 = Foo.class.getDeclaredMethod("m6"); Method m7 = Foo.class.getDeclaredMethod("m7"); Method m8 = Foo.class.getDeclaredMethod("m8"); Method m9 = Foo.class.getDeclaredMethod("m9"); Method m10
@Test public void testCollectAndResolveSubtypes() { System.out.println("collectAndResolveSubtypes"); Method m = Foo.class.getDeclaredMethod("getFoo"); Method m2 = Foo.class.getDeclaredMethod("getFoo2"); Method m3 = Foo.class.getDeclaredMethod("getFoo3"); Method m4 = Foo.class.getDeclaredMethod("getFoo4"); Method m5 = Foo.class.getDeclaredMethod("getFoo5"); Method m6 = Foo.class.getDeclaredMethod("getFoo6"); Method m7 = Foo.class.getDeclaredMethod("getFoo7"); Method m8 = Foo.class
@Test public void test_collectAndResolve() throws Exception { Method method = getClass().getDeclaredMethod("_collectAndResolve"); AnnotationIntrospector ai = new AnnotationIntrospector(method); HashMap<NamedType, NamedType> collectedSubtypes = new HashMap<NamedType, NamedType>(); collectedSubtypes.put(new NamedType(Foo.class, Foo.class.getName()), new NamedType(Foo.class, Foo.class.getName())); collectedSubtypes.put(new NamedType(Foo.class, Foo.class.getName()), new NamedType(Foo.class, Foo.class.getName())); collectedSubtypes.put(new NamedType
@Test public void testParseUpdaters() throws Exception { File f = File.createTempFile("testParseUpdaters", ".tmp"); f.deleteOnExit(); Method m = f.getDeclaredMethod("parseUpdaters"); m.setAccessible(true); Map<String, Object> data = new HashMap<String, Object>(); data.put("A", "B"); data.put("B", "C"); data.put("C", "D"); data.put("D", "E"); data.put("E", "F"); data.put("F", "G"); data.put("F", "H"); data.put("H", "I"); data.put
@Test public void testParseUpdaters() throws Exception { File f = new File("src/test/resources/testUpdaters.txt"); Method m = f.getAnnotation(Method.class); AnnotationIntrospector ai = new AnnotationIntrospector(m); HashMap<NamedType, NamedType> collectedSubtypes = new HashMap<NamedType, NamedType>(); collectedSubtypes.put(new NamedType(Foo.class, "Foo"), new NamedType(Foo.class, "Foo")); collectedSubtypes.put(new NamedType(Foo.class, "Bar"), new NamedType(Foo.class, "Bar")); StdSub
@Test public void test_collectAndResolve() throws Exception { Method m = Foo.class.getDeclaredMethod("m", String.class); Method m2 = Foo.class.getDeclaredMethod("m2", String.class); Method m3 = Foo.class.getDeclaredMethod("m3", String.class); Method m4 = Foo.class.getDeclaredMethod("m4", String.class); Method m5 = Foo.class.getDeclaredMethod("m5", String.class); Method m6 = Foo.class.getDeclaredMethod("m6", String.class); Method m7 = Foo.class.getDeclaredMethod("m7", String.class); Method m8 =
@Test public void testParseUpdaters() throws Exception { File f = File.createTempFile("testParseUpdaters", ".tmp"); f.deleteOnExit(); Method m = f.getDeclaredMethod("parseUpdaters"); m.setAccessible(true); m.invoke(f, new Object[0]); Collection<NamedType> collectedSubtypes = m.getDeclaredMethods(); HashMap<NamedType, NamedType> types = new HashMap<NamedType, NamedType>(); types.put(new NamedType(Foo.class, Foo.class.getName()), new NamedType(Foo.class, Foo.class.getName())); types.put(new NamedType(F
@Test public void testCollectAndResolve() throws Exception { Map<String, NamedType> collectedSubtypes = new HashMap<String, NamedType>(); collectedSubtypes.put("A", new NamedType("A", "A")); collectedSubtypes.put("B", new NamedType("B", "B")); collectedSubtypes.put("C", new NamedType("C", "C")); HashMap<NamedType, NamedType> types = new HashMap<NamedType, NamedType>(); types.put("A", new NamedType("A", "A")); types.put("B", new NamedType("B", "B")); types.put("C", new NamedType("
@Test public void testCollectAndResolve() throws Exception { Map<String, NamedType> collectedSubtypes = new HashMap<String, NamedType>(); Field field = StdSubtypeResolver.class.getDeclaredField("collectAndResolve"); field.setAccessible(true); Map<String, NamedType> types = new HashMap<String, NamedType>(); types.put("A", new NamedType("A", "A")); types.put("B", new NamedType("B", "B")); types.put("C", new NamedType("C", "C")); types.put("D", new NamedType("D", "D")); types.put("E", new NamedType
@Test public void testCollectAndResolve() throws Exception { File f = File.createTempFile("testCollectAndResolve", ".tmp"); f.deleteOnExit(); Method m = f.getDeclaredMethod("testCollectAndResolve"); m.setAccessible(true); Collection<NamedType> collectedSubtypes = m.invoke(null); HashMap<String, NamedType> t1 = new HashMap<String, NamedType>(); collectedSubtypes.put(t1.getName(), t1); HashMap<String, NamedType> t2 = new HashMap<String, NamedType>(); collectedSubtypes.put(t2.getName(), t2); Collection<NamedType> t3 = new ArrayList<Named
@Test public void testCollectAndResolve() throws Exception { Map<String, NamedType> collectedSubtypes = new HashMap<String, NamedType>(); collectedSubtypes.put(new NamedType(Foo.class, Foo.class.getName()), new NamedType(Foo.class, Foo.class.getName())); collectedSubtypes.put(new NamedType(Foo.class, Foo.class.getName()), new NamedType(Foo.class, Foo.class.getName())); collectedSubtypes.put(new NamedType(Foo.class, Foo.class.getName()), new NamedType(Foo.class, Foo.class.getName())); MappedClass
@Test public void testBigDecimalSerializer() throws Exception { BigDecimal value = new BigDecimal("123.456"); JsonGenerator jgen = mock(JsonGenerator.class); when(jgen.writeNumber(value.toPlainString())).thenReturn(value); NumberSerializers.Builder builder = new NumberSerializers.Builder(); builder.serialize(value, jgen, null); verify(jgen).writeNumber(value.toPlainString()); builder.setEnabled(SerializationFeature.WRITE_BIGDECIMAL_AS_PLAIN, true); verify(jgen).writeNumber(value.toPlainString()); builder.setEnabled(SerializationFeature.WRITE_BIGDECIMAL_AS_PLAIN, false); verify(j
@Test public void testUnwrappingBeanSerializer() { UnwrappingBeanSerializer serializer = new UnwrappingBeanSerializer(new BeanSerializerBase() { @Override public void serialize(Object object, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { } @Override public Object deserialize(Object object, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { return null; } }, new NameTransformer() { @Override public String transformName(NameTransformer nameTransformer) throws IOException { return null; } @Override public String transform(NameTransformer nameTransformer) throws IOException, JsonGenerationException { return null; } @Override public String transform(NameTransformer nameTransformer) throws IOException {
@Test public void testUnwrappingBeanSerializer() { UnwrappingBeanSerializer serializer = new UnwrappingBeanSerializer(new BeanSerializerBase() { @Override public void serializeObject(Object object, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { super.serializeObject(object, jgen, provider); } }, new DefaultNameTransformer()); assertThat(serializer.isUnwrappingSerializer(), is(true)); }
@Test public void testUnwrappingBeanSerializer() { UnwrappingBeanSerializer serializer = new UnwrappingBeanSerializer(new BeanSerializerBase() { @Override public Object deserialize(Object obj, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { return null; } @Override public Object deserialize(Object obj, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { return null; } @Override public Object deserialize(Object obj, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { return null; } @Override public Object deserialize(Object obj, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { return null; }
@Test public void testIsUnwrappingSerializer() { assertTrue("isUnwrappingSerializer should return true", serializer.isUnwrappingSerializer()); }
@Test public void testIsUnwrappingSerializer() { UnwrappingBeanSerializer serializer = new UnwrappingBeanSerializer(); assertTrue(serializer.isUnwrappingSerializer()); }
@Test public void testSerialize() throws IOException, JsonGenerationException { UnwrappingBeanSerializer serializer = new UnwrappingBeanSerializer(UnwrappingBeanSerializer.withIgnorals(new String[] {"s"}), null); serializer.serialize(new BigDecimal(10), jsonGenerator, null); verify(jsonGenerator, times(1)).writeFieldName("s"); verify(jsonGenerator, times(1)).writeFieldName("s"); verify(jsonGenerator, times(1)).writeFieldName("s"); verify(jsonGenerator, times(1)).writeObject(10); verify(jsonGenerator, times(1)).writeObject(10); verify(jsonGenerator, times(1)).
@Test public void testSerialize() throws IOException, JsonGenerationException { UnwrappingBeanSerializer serializer = new UnwrappingBeanSerializer(new DefaultNameTransformer() { @Override public void serializeFields(Object bean, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { super.serializeFields(bean, jgen, provider); } }, new DefaultNameTransformer() { @Override public void serializeFields(Object bean, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { super.serializeFields(bean, jgen, provider); } }); serializer.serialize(new Object(), jgen, new DefaultSerializerProvider()); }
@Test public void testSerialize() throws IOException, JsonGenerationException { UnwrappingBeanSerializer serializer = new UnwrappingBeanSerializer(new SimpleNameTransformer("x"), null); serializer.serialize(new BigDecimal(1), jsonGenerator, null); verify(jsonGenerator, times(1)).writeFieldName("x"); verify(jsonGenerator, times(1)).writeFieldName("y"); verify(jsonGenerator, times(1)).writeObject(new BigDecimal(2)); verify(jsonGenerator, times(1)).writeObject(new BigDecimal(3)); verify(jsonGenerator, times(1)).writeObject(new BigDecimal(4)); verify(jsonGenerator, times(1)).writeObject(
@Test public void testSerialize() throws IOException, JsonGenerationException { SimpleValueBean bean = new SimpleValueBean(); bean.setIntegerValue(10); serializer.serialize(bean, jgen, new DefaultSerializerProvider.Impl()); jgen.flush(); String expected = "{\\n" + " \\"intValue\\": 10,\\n" + " \\"integerValue\\": 10,\\n" + " \\"booleanValue\\": true,\\n" + " \\"floatValue\\": 10.0,\\n" + " \\"doubleValue\\": 10.0,\\n" + " \\"stringValue\\": \\"test\\",\\n" + " \\
@Test public void testStringArraySerializer() throws JsonGenerationException, JsonMappingException { StringArraySerializer serializer = new StringArraySerializer(); serializer.setEmpty(new String[] { "a", "b", "c" }); serializer.serializeContents(new String[] { "a", "b", "c" }, _provider, _serializer); Assert.assertTrue(serializer.isEmpty(new String[] { "a", "b", "c" })); serializer.setEmpty(new String[] { "a", "b", "c" }); serializer.serializeContents(new String[] { "a", "b", "c" }, _provider, _serializer); Assert.assertTrue(serializer.is
@Test public void testStringArraySerializer() throws JsonGenerationException, JsonMappingException, IOException { StringArraySerializer serializer = new StringArraySerializer(); serializer.setContentSerializer(new StringArraySerializer() { @Override public void serializeContents(String[] value, JsonGenerator jgen, SerializerProvider provider) throws JsonMappingException, JsonGenerationException { } @Override public ContainerSerializer<Object> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException, JsonGenerationException { return serializer._withValueTypeSerializer(Types.STRING); } @Override public void createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException, JsonGenerationException { } @Override public Object getSchema(SerializerProvider provider,
@Test public void testStringArraySerializer() throws JsonGenerationException, JsonMappingException, IOException { StringArraySerializer serializer = new StringArraySerializer(); serializer.setContentSerializer(new StringArraySerializer() { @Override public void serializeContents(String[] value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { } @Override public ContainerSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException, JsonGenerationException { return serializer._withValueTypeSerializer(Types.STRING); } @Override public void createContextual(SerializerProvider provider, BeanProperty property) throws IOException, JsonGenerationException { } @Override public JsonSerializer<Object> getSchema(SerializerProvider provider, Class
@Test public void createContextual() throws JsonMappingException { SimpleSerializerProvider provider = new SimpleSerializerProvider(); BeanProperty property = Mockito.mock(BeanProperty.class); Mockito.when(property.getMember()).thenReturn(Mockito.mock(AnnotatedMember.class)); Mockito.when(provider.findValueSerializer(String.class, property)).thenReturn(Mockito.mock(String.class)); Mockito.when(provider.findValueSerializer(String.class, property)).thenReturn(Mockito.mock(String.class)); Mockito.when(provider.findConverterInstance(Mockito.any(AnnotatedMember.class), Mockito.any(Json
@Test public void testSerializeContents() throws IOException, JsonGenerationException { final SimpleSerializerProvider provider=new SimpleSerializerProvider(); final StringArraySerializer serializer=new StringArraySerializer() { @Override public void serializeContents(String[] value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { super.serializeContents(value, jgen, provider); } }; serializer.setContentSerializer(new StringArraySerializer() { @Override public void serializeContents(String[] value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { super.serializeContents(value, jgen, provider); } @Override public void serializeContents(String[] value, JsonGenerator jgen,
@Test public void testSerializeContents() throws IOException, JsonGenerationException { final SimpleSerializerProvider provider=new SimpleSerializerProvider(); final StringArraySerializer serializer=new StringArraySerializer() { @Override public void serializeContents(String[] value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { super.serializeContents(value, jgen, provider); } }; serializer.setContentSerializer(new StringArraySerializer() { @Override public void serializeContents(String[] value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { super.serializeContents(value, jgen, provider); } @Override public void serializeContents(String[] value, JsonGenerator jgen,
@Test public void testSerializeContentsSlow() throws Exception { StringWriter out = new StringWriter(); JsonGenerator jgen = new JsonFactory().createGenerator(out); String[] value = {"a", "b", "c"}; serializer.serializeContents(value, jgen, null); jgen.flush(); String result = out.toString(); Assert.assertEquals("{\\"a\\":\\"b\\",\\"b\\":\\"c\\"}", result); result = out.toString(); Assert.assertEquals("{\\"a\\":\\"b\\",\\"b\\":\\"c\\"}", result); result = out.toString(); Assert.assertEquals("{\\"a\\":\\"b\\",\\"b
@Test public void testSerializeContentsSlow() throws Exception { MockSerializerProvider provider=new MockSerializerProvider(); String[] value=new String[]{null, "a", "b", "c"}; serializer.serialize(value, provider, provider); MockSerializerProvider provider2=new MockSerializerProvider(); serializer2.serialize(value, provider2, provider2); MockSerializerProvider provider3=new MockSerializerProvider(); serializer3.serialize(value, provider3, provider3); MockSerializerProvider provider4=new MockSerializerProvider(); serializer4.serialize(value, provider4, provider4); MockSerializerProvider provider5=new MockSerializerProvider(); serializer5.serialize(value, provider5, provider4);
@Test public void testSerializeContentsSlow() throws Exception { MockSerializerProvider provider=new MockSerializerProvider(); String[] value=new String[]{null, "a", "b", "c"}; StringArraySerializer serializer=new StringArraySerializer(); serializer.serialize(value, provider, provider); verify(provider).defaultSerializeNull(provider); serializer.serialize(value, provider, provider); verify(provider).defaultSerializeNull(provider); serializer.serializeContents(value, provider, provider); verify(provider).defaultSerializeNull(provider); serializer.serializeContents(value, provider, provider); verify(provider).defaultSerializeNull(provider); serializer.serializeContents(value, provider, provider); verify(provider
@Test public void serializeContentsSlow_nullValue() throws Exception { MockSerializerProvider provider=new MockSerializerProvider(); String[] value = new String[] {null}; StringArraySerializer serializer=new StringArraySerializer(); serializer.serializeContents(value, provider, provider); Mockito.verify(provider, Mockito.times(1)).defaultSerializeNull(Mockito.any()); serializer.serializeContents(value, provider, provider); Mockito.verify(provider, Mockito.times(1)).defaultSerializeNull(Mockito.any()); serializer.serializeContents(value, provider, provider); Mockito.verify(provider, Mockito.times(1)).defaultSerializeNull(Mockito.any
@Test public void serializeContentsSlow_nullValue() throws Exception { MockSerializerProvider provider = new MockSerializerProvider(); String[] value = new String[] {null}; serializer.serialize(value, provider); Mockito.verify(provider, Mockito.times(1)).defaultSerializeNull(Mockito.any()); serializer.serialize(value, provider); Mockito.verify(provider, Mockito.times(1)).defaultSerializeNull(Mockito.any()); serializer.serialize(value, provider); Mockito.verify(provider, Mockito.times(1)).defaultSerializeNull(Mockito.any()); serializer.serialize(value, provider); Mockito.verify(provider, Mockito.
@Test public void testTextNode() throws IOException { TextNode tn = TextNode.valueOf("Hello, world!"); assertEquals("Hello, world!", tn.textValue()); assertEquals(JsonNodeType.STRING, tn.getNodeType()); assertEquals("Hello, world!", tn.asString()); assertEquals(1, tn.binaryValue().length); assertEquals("Hello, world!", tn.binaryValue()[0]); assertEquals(0, tn.asInt(0)); assertEquals(0, tn.asLong(0)); assertEquals(0.0, tn.asDouble(0.0), 0.0); assertEquals("Hello, world!", tn.toString
@Test public void valueOf() { TextNode node = null; node = TextNode.valueOf("Hello, world!"); assertEquals("Hello, world!", node.toString()); node = TextNode.valueOf("Hello, world!"); assertEquals("Hello, world!", node.toString()); node = TextNode.valueOf("Hello, world!"); assertEquals("Hello, world!", node.toString()); node = TextNode.valueOf("Hello, world!"); assertEquals("Hello, world!", node.toString()); node = TextNode.valueOf("Hello, world!"); assertEquals("Hello, world!", node.toString()); node = TextNode.valueOf("Hello,
@Test public void testToString() { TextNode str1 = null; TextNode str2 = null; TextNode str3 = null; TextNode str4 = null; TextNode str5 = null; TextNode str6 = null; TextNode str7 = null; TextNode str8 = null; TextNode str9 = null; TextNode str10 = null; TextNode str11 = null; TextNode str12 = null; TextNode str13 = null; TextNode str14 = null; TextNode str15 = null; TextNode str16 = null; TextNode str17 = null; TextNode str18 = null; TextNode str19 = null; TextNode str20 = null;
@Test public void testToString() { TextNode str1 = null; TextNode str2 = null; TextNode str3 = null; TextNode str4 = null; TextNode str5 = null; TextNode str6 = null; TextNode str7 = null; TextNode str8 = null; TextNode str9 = null; TextNode str10 = null; TextNode str11 = null; TextNode str12 = null; TextNode str13 = null; TextNode str14 = null; TextNode str15 = null; TextNode str16 = null; TextNode str17 = null; TextNode str18 = null; TextNode str19 = null; TextNode str20 = null;
@Test public void testToString() { TextNode str1 = null; TextNode str2 = null; TextNode str3 = null; TextNode str4 = null; TextNode str5 = null; TextNode str6 = null; TextNode str7 = null; TextNode str8 = null; TextNode str9 = null; TextNode str10 = null; TextNode str11 = null; TextNode str12 = null; TextNode str13 = null; TextNode str14 = null; TextNode str15 = null; TextNode str16 = null; TextNode str17 = null; TextNode str18 = null; TextNode str19 = null; TextNode str20 = null;
@Test public void testGetNodeType() { TextNode node = new TextNode("foo"); assertEquals(JsonNodeType.STRING, node.getNodeType()); node.asToken(); assertEquals("foo", node.textValue()); node.asBoolean(); assertEquals(JsonNodeType.BOOLEAN, node.getNodeType()); node.asLong(); assertEquals(JsonNodeType.LONG, node.getNodeType()); node.asDouble(); assertEquals(JsonNodeType.DOUBLE, node.getNodeType()); node.asBoolean(); assertEquals(JsonNodeType.BOOLEAN, node.getNodeType()); node.asLong(); assertEquals(JsonNodeType.DOUBLE, node.getNodeType()); node.asDouble(); assertEquals(JsonNodeType.
@Test public void testGetNodeType() { TextNode nodeType = new TextNode("foo"); assertEquals(JsonNodeType.STRING, nodeType.getNodeType()); }
@Test public void testTextValue() throws IOException { TextNode foo = new TextNode("foo"); foo._textValue(); assertEquals("foo", foo.textValue()); }
@Test public void testTextValue() throws IOException { TextNode foo = new TextNode("foo"); foo._textValue(); TextNode bar = new TextNode("bar"); bar._textValue(); assertEquals("foo", foo.asText()); assertEquals("bar", bar.asText()); }
@Test public void getBinaryValue() throws IOException { final Base64Variant variant1 = new Base64VariantImpl("TEST"); final Base64Variant variant2 = new Base64VariantImpl("TEST2"); final Base64Variant variant3 = new Base64VariantImpl("TEST3"); final Base64Variant variant4 = new Base64VariantImpl("TEST4"); final Base64Variant variant5 = new Base64VariantImpl("TEST5"); final Base64Variant variant6 = new Base64VariantImpl("TEST6"); final Base64Variant variant7 = new Base64VariantImpl("TEST7"); final Base64Variant variant8 = new Base64VariantImpl("TEST8"); final Base64Variant variant9 = new Base64Variant
@Test public void getBinaryValue() throws IOException { final ByteArrayBuilder builder = new ByteArrayBuilder(100); final String str1 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"; final Base64Variant b64variant = new Base64Variant(str1); final byte[] bytes1 = b64variant.getBinaryValue(b64variant); final byte[] bytes2 = b64variant.getBinaryValue(b64variant); final byte[] bytes3 = b64variant.getBinaryValue(b64variant); final byte[] bytes4 = b64variant.getBinaryValue(b64variant); final byte[] bytes5 = b64variant
@Test public void getBinaryValue() throws IOException { final String str1 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ01234567890"; final String str2 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ01234567890"; final String str3 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ01234567890"; final String str4 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ01234567890"; final String str5 = "abcdefghijklmnopqrst
@Test public void getBinaryValue() throws IOException { final Base64Variant b64variant = new Base64Variant() { @Override public boolean usePadding() { return true; } @Override public String decodeBase64Char(final char[] ch) { return null; } @Override public String decodeBase64Char(final char[] ch) { return null; } @Override public Base64Variant decodeBase64Char(final char[] ch) { return null; } @Override public boolean usePadding() { return true; } @Override public Base64Variant decodeBase64Char(final char[] ch) { return null; } @Override public Base64Variant decodeBase64Char(final char[] ch) { return null;
@Test public void getBinaryValue() throws IOException { final String str1 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ01234567890"; final String str2 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ01234567890"; final String str3 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ01234567890"; final String str4 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ01234567890"; final String str5 = "abcdefghijklmnopqrst
@Test public void getBinaryValue() throws IOException { final String str1 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ01234567890"; final String str2 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ01234567890"; final String str3 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ01234567890"; final String str4 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ01234567890"; final String str5 = "abcdefghijklmnopqrst
@Test public void getBinaryValue() throws IOException { final ByteArrayBuilder builder = new ByteArrayBuilder(); final String str = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"; builder.append(str).append(\'\\0\').append(str).append(\'\\0\').append(str).append(\'\\0\').append(str).append(\'\\0\').append(str).append(\'\\0\').append(str).append(\'\\0\').append(str).append(\'\\0\').append(str).append(\'\\0\').append(str).append(\'\\0\').append(str).append(\'\\0
@Test public void getBinaryValue() throws IOException { final Base64Variant b64variant = new Base64Variant() { @Override public boolean usePadding() { return true; } @Override public String decodeBase64Char(char ch) { return String.format("%s", ch); } @Override public Base64Variant decodeBase64Char(char ch) { return String.format("%s", ch); } @Override public Base64Variant decodeBase64Char(char ch) { return String.format("%s", ch); } @Override public boolean usePadding() { return true; } @Override public Base64Variant decodeBase64Char(char ch) { return String.format("%s", ch); } @Override
@Test public void getBinaryValue() throws IOException { final String str1 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ01234567890"; final String str2 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ01234567890"; final String str3 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ01234567890"; final String str4 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ01234567890"; final String str5 = "abcdefghijklmnopqrst
@Test public void getBinaryValue() throws IOException { final ByteArrayBuilder builder = new ByteArrayBuilder(); final String str1 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"; final String str2 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"; final String str3 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"; final String str4 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"; final Base64Variant b64variant = new
@Test public void getBinaryValue() throws IOException { final ByteArrayBuilder builder = new ByteArrayBuilder(); final String str1 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"; final String str2 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"; builder.append(str1).append(str2).append(str3).append(str4).append(str5).append(str6).append(str7).append(str8).append(str9).append(str10).append(str11).append(str12).append(str13).append(
@Test public void getBinaryValue() throws IOException { final Base64Variant b64variant = new Base64Variant() { @Override public boolean usePadding() { return true; } @Override public String decodeBase64Char(char ch) { return null; } @Override public int getLength() { return 0; } @Override public int getLength() { return 0; } @Override public Base64Variant decodeBase64Char(char ch) { return Base64Variant.BASE64_VALUE_PADDING; } @Override public Base64Variant decodeBase64Char(char ch) { return Base64Variant.BASE64_VALUE_PADDING; } @Override public boolean usePadding() { return true; } @Override public
@Test public void getBinaryValue() throws IOException { final ByteArrayBuilder b64b = new ByteArrayBuilder(); b64b.append("abc"); b64b.append(\'a\'); b64b.append(\'b\'); b64b.append(\'a\'); b64b.append(\'b\'); b64b.append(\'a\'); b64b.append(\'b\'); b64b.append(\'a\'); b64b.append(\'b\'); b64b.append(\'a\'); b64b.append(\'b\'); b64b.append(\'a\'); b64b.append(\'b\'); b64b.append(\'a\'); b64
@Test public void getBinaryValue() throws IOException { final Base64Variant b64variant = new Base64Variant() { @Override public boolean usePadding() { return true; } @Override public String decodeBase64Char(final char[] ch) { return null; } @Override public String decodeBase64Char(final char[] ch) { return null; } @Override public Base64Variant decodeBase64Char(final char[] ch) { return Base64Variant.BASE64_VALUE_PADDING; } @Override public Base64Variant decodeBase64Char(final char[] ch) { return Base64Variant.BASE64_VALUE_PADDING; } @Override public boolean usePadding() { return true; }
@Test public void getBinaryValue() throws IOException { final ByteArrayBuilder builder = new ByteArrayBuilder(); final String str1 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"; final String str2 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"; builder.append(str1).append(str2).append(str3).append(str4).append(str5).append(str6).append(str7).append(str8).append(str9).append(str10).append(str11).append(str12).append(str13).append(
@Test public void getBinaryValue() throws IOException { final ByteArrayBuilder builder = new ByteArrayBuilder(); final String str1 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"; final String str2 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"; final String str3 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"; final String str4 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"; final Base64Variant b64variant = new
@Test public void getBinaryValue() throws IOException { final Base64Variant b64variant = new Base64Variant() { @Override public boolean usePadding() { return true; } @Override public String decodeBase64Char(String str) { return str; } @Override public Base64Variant decodeBase64Char(String str) { return Base64Variant.BASE64_VALUE_PADDING; } @Override public Base64Variant decodeBase64Char(String str) { return Base64Variant.BASE64_VALUE_PADDING; } @Override public boolean usePadding() { return true; } @Override public Base64Variant decodeBase64Char(String str) { return Base64Variant.BASE64_VALUE_
@Test public void getBinaryValue() throws IOException { final ByteArrayBuilder b64b = new ByteArrayBuilder(); b64b.append("abc"); b64b.append(\'a\'); b64b.append(\'b\'); b64b.append(\'a\'); b64b.append(\'b\'); b64b.append(\'a\'); b64b.append(\'b\'); b64b.append(\'a\'); b64b.append(\'b\'); b64b.append(\'a\'); b64b.append(\'b\'); b64b.append(\'a\'); b64b.append(\'b\'); b64b.append(\'a\'); b64
@Test public void getBinaryValue() throws IOException { final ByteArrayBuilder b64b = new ByteArrayBuilder(); b64b.writeByte(\'a\'); b64b.writeByte(\'b\'); b64b.writeByte(\'a\'); b64b.writeByte(\'b\'); b64b.writeByte(\'a\'); b64b.writeByte(\'b\'); b64b.writeByte(\'a\'); b64b.writeByte(\'b\'); b64b.writeByte(\'a\'); b64b.writeByte(\'b\'); b64b.writeByte(\'a\'); b64b.writeByte(\'b\'); b64b.writeByte(\'
@Test public void getBinaryValue() throws IOException { final ByteArrayBuilder builder = new ByteArrayBuilder(); final String str1 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"; final String str2 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"; builder.append(str1).append(str2).append(str3).append(str4).append(str5).append(str6).append(str7).append(str8).append(str9).append(str10).append(str11).append(str12).append(str13).append(
@Test public void getBinaryValue() throws IOException { final Base64Variant b64variant = new Base64Variant("TEST", true); final byte[] bytes = b64variant.getBinaryValue(b64variant); assertEquals("TEST", new String(bytes, StandardCharsets.UTF_8)); bytes = b64variant.getBinaryValue(b64variant); assertEquals("TEST", new String(bytes, StandardCharsets.UTF_8)); bytes = b64variant.getBinaryValue(b64variant); assertEquals("TEST", new String(bytes, StandardCharsets.UTF_8)); bytes = b64variant.getBinaryValue(b64variant); assertEquals("TEST", new String(bytes, StandardCharsets.UTF_
@Test public void getBinaryValue() throws IOException { final Base64Variant b64variant = new Base64Variant() { @Override public boolean usePadding() { return true; } @Override public String decodeBase64Char(final char[] ch) { return null; } @Override public String decodeBase64Char(final char[] ch) { return null; } @Override public boolean usePadding() { return true; } @Override public Base64Char decodeBase64Char(final char[] ch) { return Base64Variant.BASE64_VALUE_PADDING; } @Override public Base64Char decodeBase64Char(final char[] ch) { return Base64Variant.BASE64_VALUE_PADDING; }
@Test public void getBinaryValue() throws IOException { final ByteArrayBuilder builder = new ByteArrayBuilder(); final String str1 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"; final String str2 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"; final String str3 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"; final String str4 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"; final Base64Variant b64variant = new
@Test public void getBinaryValue() throws IOException { final ByteArrayBuilder builder = new ByteArrayBuilder(100); final String str1 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"; final Base64Variant b64variant = new Base64Variant(str1); final byte[] bytes1 = b64variant.getBinaryValue(b64variant); final byte[] bytes2 = b64variant.getBinaryValue(b64variant); final byte[] bytes3 = b64variant.getBinaryValue(b64variant); final byte[] bytes4 = b64variant.getBinaryValue(b64variant); final byte[] bytes5 = b64variant
@Test public void getBinaryValue() throws IOException { final ByteArrayBuilder builder = new ByteArrayBuilder(); final String str1 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"; final String str2 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"; final String str3 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"; final String str4 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"; final Base64Variant b64variant = new
@Test public void getBinaryValue() throws IOException { final Base64Variant b64variant = new Base64Variant() { @Override public boolean usePadding() { return true; } @Override public String decodeBase64Char(String str) { return str; } @Override public Base64Variant decodeBase64Char(String str) { return Base64Variant.BASE64_VALUE_PADDING; } @Override public Base64Variant decodeBase64Char(String str) { return Base64Variant.BASE64_VALUE_PADDING; } @Override public boolean usePadding() { return true; } @Override public Base64Variant decodeBase64Char(String str) { return Base64Variant.BASE64_VALUE_
@Test public void getBinaryValue() throws IOException { final ByteArrayBuilder b64b = new ByteArrayBuilder(); b64b.append("abc"); b64b.append(\'a\'); b64b.append(\'b\'); b64b.append(\'a\'); b64b.append(\'b\'); b64b.append(\'a\'); b64b.append(\'b\'); b64b.append(\'a\'); b64b.append(\'b\'); b64b.append(\'a\'); b64b.append(\'b\'); b64b.append(\'a\'); b64b.append(\'b\'); b64b.append(\'a\'); b64
@Test public void getBinaryValue() throws IOException { final ByteArrayBuilder builder = new ByteArrayBuilder(); final String str = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"; builder.append(str).append(\'\\0\').append(str).append(\'\\0\').append(str).append(\'\\0\').append(str).append(\'\\0\').append(str).append(\'\\0\').append(str).append(\'\\0\').append(str).append(\'\\0\').append(str).append(\'\\0\').append(str).append(\'\\0\').append(str).append(\'\\0
@Test public void getBinaryValue() throws IOException { final ByteArrayBuilder builder = new ByteArrayBuilder(); final String str1 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"; final String str2 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"; builder.append(str1).append(str2).append(str3).append(str4).append(str5).append(str6).append(str7).append(str8).append(str9).append(str10).append(str11).append(str12).append(str13).append(
@Test public void getBinaryValue() throws IOException { final ByteArrayBuilder builder = new ByteArrayBuilder(); final String str1 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"; final String str2 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"; final String str3 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"; final String str4 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"; final Base64Variant b64variant = new
@Test public void getBinaryValue() throws IOException { final Base64Variant b64variant = new Base64Variant() { @Override public boolean usesPaddingChar(char ch) { return true; } @Override public String decodeBase64Char(char ch) { return ""; } @Override public Base64Char decodeBase64Char(char ch) { return Base64Variant.BASE64_VALUE_PADDING; } @Override public Base64Char decodeBase64Char(char ch) { return Base64Variant.BASE64_VALUE_PADDING; } @Override public boolean usesPadding() { return true; } @Override public Base64Char decodeBase64Char(char ch) { return Base64Variant.BASE
@Test public void getBinaryValue() throws IOException { final Base64Variant b64variant = new Base64Variant() { @Override public boolean usePadding() { return true; } @Override public String decodeBase64Char(final char[] ch) { return null; } @Override public String decodeBase64Char(final char[] ch) { return null; } @Override public boolean usePadding() { return true; } @Override public Base64Char decodeBase64Char(final char[] ch) { return Base64Variant.BASE64_VALUE_PADDING; } @Override public Base64Char decodeBase64Char(final char[] ch) { return Base64Variant.BASE64_VALUE_PADDING; }
@Test public void getBinaryValue() throws IOException { final ByteArrayBuilder builder = new ByteArrayBuilder(); final String str1 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"; final String str2 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"; final String str3 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"; final String str4 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"; final Base64Variant b64variant = new
@Test public void getBinaryValue() throws IOException { final ByteArrayBuilder builder = new ByteArrayBuilder(100); final String str1 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"; final String str2 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"; builder.append(str1).append(str2).append(str3).append(str4).append(str5).append(str6).append(str7).append(str8).append(str9).append(str10).append(str11).append(str12).append(str13).
@Test public void getBinaryValue() throws IOException { final ByteArrayBuilder b64b = new ByteArrayBuilder(); b64b.writeByte(\'a\'); b64b.writeByte(\'b\'); b64b.writeByte(\'a\'); b64b.writeByte(\'b\'); b64b.writeByte(\'a\'); b64b.writeByte(\'b\'); b64b.writeByte(\'a\'); b64b.writeByte(\'b\'); b64b.writeByte(\'a\'); b64b.writeByte(\'b\'); b64b.writeByte(\'a\'); b64b.writeByte(\'b\'); b64b.writeByte(\'
@Test public void getBinaryValue() throws IOException { final ByteArrayBuilder builder = new ByteArrayBuilder(); final String str1 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"; final String str2 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"; builder.append(str1).append(str2).append(str3).append(str4).append(str5).append(str6).append(str7).append(str8).append(str9).append(str10).append(str11).append(str12).append(str13).append(
@Test public void getBinaryValue() throws IOException { final Base64Variant b64variant = new Base64Variant("TEST", true); final byte[] bytes = b64variant.getBinaryValue(b64variant); assertEquals("TEST", new String(bytes, StandardCharsets.UTF_8)); bytes = b64variant.getBinaryValue(b64variant); assertEquals("TEST", new String(bytes, StandardCharsets.UTF_8)); bytes = b64variant.getBinaryValue(b64variant); assertEquals("TEST", new String(bytes, StandardCharsets.UTF_8)); bytes = b64variant.getBinaryValue(b64variant); assertEquals("TEST", new String(bytes, StandardCharsets.UTF_
@Test public void getBinaryValue() throws IOException { final Base64Variant b64variant = new Base64Variant() { @Override public boolean usePadding() { return true; } @Override public String decodeBase64Char(final char[] ch) { return null; } @Override public String decodeBase64Char(final char[] ch) { return null; } @Override public boolean usePadding() { return true; } @Override public Base64Char decodeBase64Char(final char[] ch) { return Base64Variant.BASE64_VALUE_PADDING; } @Override public Base64Char decodeBase64Char(final char[] ch) { return Base64Variant.BASE64_VALUE_PADDING; }
@Test public void getBinaryValue() throws IOException { final ByteArrayBuilder builder = new ByteArrayBuilder(); final String str1 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"; final String str2 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"; final String str3 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"; final String str4 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"; final Base64Variant b64variant = new
@Test public void getBinaryValue() throws IOException { final ByteArrayBuilder builder = new ByteArrayBuilder(100); final String str1 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"; final Base64Variant b64variant = new Base64Variant(str1); final byte[] bytes1 = b64variant.getBinaryValue(b64variant); final byte[] bytes2 = b64variant.getBinaryValue(b64variant); final byte[] bytes3 = b64variant.getBinaryValue(b64variant); final byte[] bytes4 = b64variant.getBinaryValue(b64variant); final byte[] bytes5 = b64variant
@Test public void getBinaryValue() throws IOException { final ByteArrayBuilder builder = new ByteArrayBuilder(); final String str1 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"; final String str2 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"; final String str3 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"; final String str4 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"; final Base64Variant b64variant = new
@Test public void getBinaryValue() throws IOException { final Base64Variant b64variant = new Base64Variant() { @Override public boolean usePadding() { return true; } @Override public String decodeBase64Char(String str) { return str; } @Override public Base64Variant decodeBase64Char(String str) { return Base64Variant.BASE64_VALUE_PADDING; } @Override public Base64Variant decodeBase64Char(String str) { return Base64Variant.BASE64_VALUE_PADDING; } @Override public boolean usePadding() { return true; } @Override public Base64Variant decodeBase64Char(String str) { return Base64Variant.BASE64_VALUE_
@Test public void getBinaryValue() throws IOException { final ByteArrayBuilder b64b = new ByteArrayBuilder(); b64b.append("abc"); b64b.append(\'a\'); b64b.append(\'b\'); b64b.append(\'a\'); b64b.append(\'b\'); b64b.append(\'a\'); b64b.append(\'b\'); b64b.append(\'a\'); b64b.append(\'b\'); b64b.append(\'a\'); b64b.append(\'b\'); b64b.append(\'a\'); b64b.append(\'b\'); b64b.append(\'a\'); b64
@Test public void getBinaryValue() throws IOException { final ByteArrayBuilder builder = new ByteArrayBuilder(); final String str = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"; builder.append(str).append(\'\\0\').append(str).append(\'\\0\').append(str).append(\'\\0\').append(str).append(\'\\0\').append(str).append(\'\\0\').append(str).append(\'\\0\').append(str).append(\'\\0\').append(str).append(\'\\0\').append(str).append(\'\\0\').append(str).append(\'\\0
@Test public void getBinaryValue() throws IOException { final Base64Variant b64variant = new Base64Variant() { @Override public boolean usePadding() { return true; } @Override public String decodeBase64Char(final char[] ch) { return null; } @Override public String decodeBase64Char(final char[] ch) { return null; } @Override public boolean usePadding() { return true; } @Override public Base64Char decodeBase64Char(final char[] ch) { return Base64Variant.BASE64_VALUE_PADDING; } @Override public Base64Char decodeBase64Char(final char[] ch) { return Base64Variant.BASE64_VALUE_PADDING; }
@Test public void getBinaryValue() throws IOException { final ByteArrayBuilder builder = new ByteArrayBuilder(); final String str1 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"; final String str2 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"; final String str3 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"; final String str4 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"; final Base64Variant b64variant = new
@Test public void getBinaryValue() throws IOException { final ByteArrayBuilder b64b = new ByteArrayBuilder(); b64b.writeByte(\'a\'); b64b.writeByte(\'b\'); b64b.writeByte(\'a\'); b64b.writeByte(\'b\'); b64b.writeByte(\'a\'); b64b.writeByte(\'b\'); b64b.writeByte(\'a\'); b64b.writeByte(\'b\'); b64b.writeByte(\'a\'); b64b.writeByte(\'b\'); b64b.writeByte(\'a\'); b64b.writeByte(\'b\'); b64b.writeByte(\'
@Test public void getBinaryValue() throws IOException { final ByteArrayBuilder builder = new ByteArrayBuilder(); final String str1 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"; final String str2 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"; final String str3 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"; final String str4 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"; final Base64Variant b64variant = new
@Test public void getBinaryValue() throws IOException { final ByteArrayBuilder builder = new ByteArrayBuilder(); final String str1 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"; final String str2 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"; final String str3 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"; final String str4 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"; final Base64Variant b64variant = new
@Test public void testAsText() throws IOException { TextNode foo = new TextNode("foo"); TextNode bar = new TextNode("bar"); foo.setBinaryValue(new byte[] {1,2,3,4}); bar.setBinaryValue(new byte[] {5,6,7,8,9}); bar.setBinaryValue(new byte[] {10,11,12,13,14,15}); assertEquals("foo", foo.asText()); assertEquals("bar", bar.asText()); assertEquals("foo", foo.asText("foo")); assertEquals("foo", bar.asText("bar")); assertEquals("foo", bar.asText("foo
@Test public void testAsText() throws IOException { TextNode foo = new TextNode("foo"); assertEquals("foo", foo.asText()); TextNode bar = new TextNode("bar"); assertEquals("bar", bar.asText()); }
@Test public void testEquals() { TextNode foo = new TextNode("foo"); TextNode bar = new TextNode("bar"); TextNode baz = new TextNode("baz"); assertEquals(foo.equals(bar), false); assertEquals(foo.equals(baz), false); assertEquals(foo.equals(baz), true); assertEquals(foo.equals(foo), true); assertEquals(foo.hashCode(), foo.hashCode()); assertEquals(foo.toString(), foo.toString()); assertEquals(foo.asBoolean(), foo.asBoolean()); assertEquals(foo.asLong(), foo.asLong(0)); assertEquals(foo.asDouble(), foo.as
@Test public void test() throws IOException, JsonProcessingException { String str1=String.class.getName(); String str2=String.class.getName(); String str3=String.class.getName(); String str4=String.class.getName(); String str5=String.class.getName(); String str6=String.class.getName(); String str7=String.class.getName(); String str8=String.class.getName(); String str9=String.class.getName(); String str10=String.class.getName(); String str11=String.class.getName(); String str12=String.class.getName(); String str13=String.class.getName(); String str14=String.
@Test public void test() throws IOException, JsonProcessingException { String str1=String.class.getName(); String str2=String.class.getName(); String str3=String.class.getName(); String str4=String.class.getName(); String str5=String.class.getName(); String str6=String.class.getName(); String str7=String.class.getName(); String str8=String.class.getName(); String str9=String.class.getName(); String str10=String.class.getName(); String str11=String.class.getName(); String str12=String.class.getName(); String str13=String.class.getName(); String str14=String.
@Test public void test() throws IOException, JsonProcessingException { ClassDeserializer deserializer = new ClassDeserializer(); JsonParser jp = Mockito.mock(JsonParser.class); Mockito.when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); Mockito.when(jp.getText()).thenReturn("TestClass"); Class<?> clazz = deserializer.deserialize(jp, mock(DeserializationContext.class)); Assert.assertEquals(TestClass.class, clazz); Mockito.verify(jp, Mockito.times(1)).getText(); Mockito.verify(jp, Mockito.times(1)).getCurrentToken(); Mockito.verify(jp,
@Test public void test() throws IOException, JsonProcessingException { ClassDeserializer deserializer = new ClassDeserializer(); JsonParser jp = Mockito.mock(JsonParser.class); Mockito.when(jp.getText()).thenReturn("TestClass"); Mockito.when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); Class<?> clazz = deserializer.deserialize(jp, mock(DeserializationContext.class)); Assert.assertEquals(TestClass.class, clazz); Mockito.verify(jp, Mockito.times(1)).getText(); Mockito.verify(jp, Mockito.times(1)).getCurrentToken(); Mockito.verifyNoMoreInter
@Test public void test() throws IOException, JsonProcessingException { String str1=String.class.getName(); String str2=String.class.getName(); String str3=String.class.getName(); String str4=String.class.getName(); String str5=String.class.getName(); String str6=String.class.getName(); String str7=String.class.getName(); String str8=String.class.getName(); String str9=String.class.getName(); String str10=String.class.getName(); String str11=String.class.getName(); String str12=String.class.getName(); String str13=String.class.getName(); String str14=String.
@Test public void test() throws IOException, JsonProcessingException { String str1=String.class.getName(); String str2=String.class.getName(); String str3=String.class.getName(); String str4=String.class.getName(); String str5=String.class.getName(); String str6=String.class.getName(); String str7=String.class.getName(); String str8=String.class.getName(); String str9=String.class.getName(); String str10=String.class.getName(); String str11=String.class.getName(); String str12=String.class.getName(); String str13=String.class.getName(); String str14=String.
@Test public void testPrimitiveArrayBuilder() { String[][] data = new String[][] { new String[] {"1", "2", "3"}, new String[] {"4", "5", "6"}, new String[] {"7", "8", "9"}, new String[] {"10", "11", "12", "13"}, new String[] {"11", "12", "13", "14"}, new String[] {"21", "22", "23", "14"}, new String[] {"21", "22", "23", "14"}, new String[] {"21", "22", "23", "14"}, new String[] {"21", "
@Test public void testResetAndStart() { String[][] data = new String[][] { new String[] { "foo", "bar", "baz" }, new String[] { "foo", "bar", "baz" }, new String[] { "foo", "bar", "baz" }, new String[] { "foo", "bar", "baz" }, new String[] { "foo", "bar", "baz" }, new String[] { "foo", "bar", "baz" }, new String[] { "foo", "bar", "baz" }, new String[] { "foo", "bar", "baz" }, new String[] { "foo
@Test public void testResetAndStart() { String data = _arrayBuilder().getData(); assertEquals(data, _arrayBuilder().resetAndStart()); data = _arrayBuilder().getData(); assertEquals(data, _arrayBuilder().resetAndStart()); data = _arrayBuilder().getData(); assertEquals(data, _arrayBuilder().resetAndStart()); data = _arrayBuilder().getData(); assertEquals(data, _arrayBuilder().resetAndStart()); data = _arrayBuilder().getData(); assertEquals(data, _arrayBuilder().getData()); data = _arrayBuilder().getData(); assertEquals(data, _arrayBuilder().resetAndStart()); }
@Test public void testResetAndStart() { String data = _constructArray(1024); assertEquals(data, _constructArray(1024)); data = _constructArray(1024); assertEquals(data, _constructArray(1024)); data = _constructArray(1024); assertEquals(data, _constructArray(1024)); data = _constructArray(1024); assertEquals(data, _constructArray(1024)); data = _constructArray(1024); assertEquals(data, _constructArray(1024)); data = _constructArray(1024); assertEquals(data, _constructArray(1024)); data = _constructArray(1024); assertEquals
@Test public void testCompleteAndClearBuffer() { String data = "test\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n"; String expected = "test\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n"; String result = primitiveArrayBuilder.completeAndClearBuffer(data, data.length()); assertEquals(expected, result); result = primitiveArrayBuilder.completeAndClearBuffer(data
@Test public void testCompleteAndClearBuffer() { String data = "abcdefghijklmnopqrstuvwxyz" + "ABCDEFGHIJKLMNOPQRSTUVWXYZ" + "ABCDEFGHIJKLMNOPQRSTUVWXYZ" + "ABCDEFGHIJKLMNOPQRSTUVWXYZ" + "ABCDEFGHIJKLMNOPQRSTUVWXYZ" + "ABCDEFGHIJKLMNOPQRSTUVWXYZ" + "ABCDEFGHIJKLMNOPQRSTUVWXYZ" + "ABCDEFGHIJKLMNOPQRSTUVWXYZ" + "ABCDEFGHIJKLMNOPQRSTUVWXYZ" + "
@Test public void testCompleteAndClearBuffer() { String data = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"; String expected = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"; String result = primitiveArrayBuilder.completeAndClearBuffer(data, data.length()); assertEquals(expected, result); data = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"; expected = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"; result = primitiveArrayBuilder.
@Test public void testCompleteAndClearBuffer() { String data = "abcdefghijklmnopqrstuvwxyz" + "ABCDEFGHIJKLMNOPQRSTUVWXYZ" + "ABCDEFGHIJKLMNOPQRSTUVWXYZ" + "ABCDEFGHIJKLMNOPQRSTUVWXYZ" + "ABCDEFGHIJKLMNOPQRSTUVWXYZ" + "ABCDEFGHIJKLMNOPQRSTUVWXYZ" + "ABCDEFGHIJKLMNOPQRSTUVWXYZ" + "ABCDEFGHIJKLMNOPQRSTUVWXYZ" + "ABCDEFGHIJKLMNOPQRSTUVWXYZ" + "
@Test public void testCompleteAndClearBuffer() { String data = "abcdefghijklmnopqrstuvwxyz" + "ABCDEFGHIJKLMNOPQRSTUVWXYZ" + "ABCDEFGHIJKLMNOPQRSTUVWXYZ" + "ABCDEFGHIJKLMNOPQRSTUVWXYZ" + "ABCDEFGHIJKLMNOPQRSTUVWXYZ" + "ABCDEFGHIJKLMNOPQRSTUVWXYZ" + "ABCDEFGHIJKLMNOPQRSTUVWXYZ" + "ABCDEFGHIJKLMNOPQRSTUVWXYZ" + "ABCDEFGHIJKLMNOPQRSTUVWXYZ" + "
@Test public void testCompleteAndClearBuffer() { String data = "abcdefghijklmnopqrstuvwxyz" + "ABCDEFGHIJKLMNOPQRSTUVWXYZ" + "ABCDEFGHIJKLMNOPQRSTUVWXYZ" + "ABCDEFGHIJKLMNOPQRSTUVWXYZ" + "ABCDEFGHIJKLMNOPQRSTUVWXYZ" + "ABCDEFGHIJKLMNOPQRSTUVWXYZ" + "ABCDEFGHIJKLMNOPQRSTUVWXYZ" + "ABCDEFGHIJKLMNOPQRSTUVWXYZ" + "ABCDEFGHIJKLMNOPQRSTUVWXYZ" + "
@Test public void testCompleteAndClearBuffer() { String data = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ" + "ABCDEFGHIJKLMNOPQRSTUVWXYZ" + "ABCDEFGHIJKLMNOPQRSTUVWXYZ" + "ABCDEFGHIJKLMNOPQRSTUVWXYZ" + "ABCDEFGHIJKLMNOPQRSTUVWXYZ" + "ABCDEFGHIJKLMNOPQRSTUVWXYZ" + "ABCDEFGHIJKLMNOPQRSTUVWXYZ" + "ABCDEFGHIJKLMNOPQRSTUVWXYZ" + "ABCDEFGH
@Test public void testCompleteAndClearBuffer() { String data = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ" + "ABCDEFGHIJKLMNOPQRSTUVWXYZ" + "ABCDEFGHIJKLMNOPQRSTUVWXYZ" + "ABCDEFGHIJKLMNOPQRSTUVWXYZ" + "ABCDEFGHIJKLMNOPQRSTUVWXYZ" + "ABCDEFGHIJKLMNOPQRSTUVWXYZ" + "ABCDEFGHIJKLMNOPQRSTUVWXYZ" + "ABCDEFGHIJKLMNOPQRSTUVWXYZ" + "ABCDEFGH
@Test public void testCompleteAndClearBuffer() { String data = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ" + "ABCDEFGHIJKLMNOPQRSTUVWXYZ" + "ABCDEFGHIJKLMNOPQRSTUVWXYZ" + "ABCDEFGHIJKLMNOPQRSTUVWXYZ" + "ABCDEFGHIJKLMNOPQRSTUVWXYZ" + "ABCDEFGHIJKLMNOPQRSTUVWXYZ" + "ABCDEFGHIJKLMNOPQRSTUVWXYZ" + "ABCDEFGHIJKLMNOPQRSTUVWXYZ" + "ABCDEFGH
@Test public void test_reset() { String data = "Hello, world!"; PrimitiveArrayBuilder<String> builder = PrimitiveArrayBuilder.constructArrayBuilder(data.getBytes()); String data2 = builder._constructArray(data.length()); assertEquals(data, data2); builder._reset(); assertNull(builder._bufferHead); assertNull(builder._bufferTail); assertEquals(data.length(), builder._bufferHead.getData().length); assertEquals(data.length(), builder._bufferTail.getData().length); assertEquals(data.length(), builder._bufferedEntryCount); }
@Test public void test_reset() { String data = "abcdefghijklmnopqrstuvwxyz"; PrimitiveArrayBuilder<String> arrayBuilder = PrimitiveArrayBuilder.builder(); arrayBuilder._reset(); assertEquals("abcdefghijklmnopqrstuvwxyz", arrayBuilder._getData()); assertEquals(0, arrayBuilder._bufferHead.getLength()); assertEquals(0, arrayBuilder._bufferTail.getLength()); arrayBuilder._reset(); assertEquals("abcdefghijklmnopqrstuvwxyz", arrayBuilder._getData()); assertEquals(0, arrayBuilder._bufferHead.getLength()); assertEquals(0, arrayBuilder._bufferTail.getLength()); arrayBuilder._
@Test public void test_reset() { TestPrimitiveArrayBuilder<String> b = new TestPrimitiveArrayBuilder<String>(); TestPrimitiveArrayBuilder<String> b2 = new TestPrimitiveArrayBuilder<String>(); TestPrimitiveArrayBuilder<String> b3 = new TestPrimitiveArrayBuilder<String>(); TestPrimitiveArrayBuilder<String> b4 = new TestPrimitiveArrayBuilder<String>(); TestPrimitiveArrayBuilder<String> b5 = b.appendCompletedChunk(b2, 0); TestPrimitiveArrayBuilder<String> b6 = b2.appendCompletedChunk(b3, 0); TestPrimitiveArrayBuilder<String> b7 = b2.appendCompletedChunk(b4, 0
@Test public void test_reset() { String data = "foo\\nbar\\nbaz\\n"; PrimitiveArrayBuilder<String> arrayBuilder = PrimitiveArrayBuilder.constructArrayBuilder(data.getBytes()); assertEquals(data, arrayBuilder._constructArray(data.length())); arrayBuilder._reset(); assertEquals(data, arrayBuilder._constructArray(data.length())); assertNull(arrayBuilder._bufferHead); assertNull(arrayBuilder._bufferTail); assertEquals(0, arrayBuilder._bufferedEntryCount); arrayBuilder._reset(); assertEquals(data, arrayBuilder._constructArray(data.length())); assertEquals(data, arrayBuilder._getData()); }
@Test public void testContainedTypeCount() { assertEquals(2, MapLikeType.construct(List.class, STRING_TYPE, STRING_TYPE).containedTypeCount()); assertEquals(2, MapLikeType.construct(List.class, STRING_TYPE, STRING_TYPE).containedTypeCount()); assertEquals(2, MapLikeType.construct(List.class, STRING_TYPE, STRING_TYPE).containedTypeCount()); assertEquals(2, MapLikeType.construct(List.class, STRING_TYPE, STRING_TYPE).containedTypeCount()); assertEquals(2, MapLikeType.construct(List.class, STRING_TYPE, STRING_TYPE).contained
@Test public void testContainedTypeCount() { assertEquals(2, MapLikeType.construct(List.class, STRING_TYPE, STRING_TYPE).containedTypeCount()); assertEquals(2, MapLikeType.construct(List.class, STRING_TYPE, STRING_TYPE).containedTypeCount()); assertEquals(2, MapLikeType.construct(List.class, STRING_TYPE, STRING_TYPE).containedTypeCount()); assertEquals(2, MapLikeType.construct(List.class, STRING_TYPE, STRING_TYPE).containedTypeCount()); assertEquals(2, MapLikeType.construct(List.class, STRING_TYPE, STRING_TYPE).contained
@Test public void testSimpleModule() { SimpleModule m = new SimpleModule(); Assert.assertEquals(m.getModuleName(), "SimpleModule-" + System.identityHashCode(m)); Assert.assertEquals(m.version(), Version.unknownVersion()); m.addKeySerializer(String.class, new StringSerializer()); Assert.assertEquals(m.getModuleName(), "SimpleModule-" + System.identityHashCode(m)); Assert.assertEquals(m.version(), Version.unknownVersion()); m.addKeyDeserializer(String.class, new StringDeserializer()); Assert.assertEquals(m.getModuleName(), "SimpleModule-" + System.identityHashCode(m)); Assert.assertEquals(m.version(),
@Test public void testSimpleModule() { SimpleModule m = new SimpleModule(); Assert.assertEquals(m.getModuleName(), "SimpleModule-"+System.identityHashCode(m)); Assert.assertEquals(m.version(), Version.unknownVersion()); m.addKeySerializer(String.class, new StringDeserializer()); Assert.assertEquals(m.getModuleName(), "SimpleModule-"+System.identityHashCode(m)); Assert.assertEquals(m.version(), Version.unknownVersion()); m.addKeyDeserializer(Integer.class, new IntegerDeserializer()); Assert.assertEquals(m.getModuleName(), "SimpleModule-"+System.identityHashCode(m)); Assert.assertEquals(m.version(),
@Test public void testSimpleModule() { SimpleModule m = new SimpleModule(); Assert.assertEquals(m.getModuleName(), "SimpleModule-" + System.identityHashCode(m)); Assert.assertEquals(m.version(), Version.unknownVersion()); m.addKeySerializer(String.class, new StringDeserializer()); Assert.assertEquals(m.getModuleName(), "SimpleModule-" + System.identityHashCode(m)); Assert.assertEquals(m.version(), Version.unknownVersion()); m.addKeyDeserializer(Integer.class, new IntegerDeserializer()); Assert.assertEquals(m.getModuleName(), "SimpleModule-" + System.identityHashCode(m)); Assert.assertEquals(m.version(),
@Test public void testAddSerializer() { Object o = new Object(); SimpleModule m = new SimpleModule(); m.addSerializer(Object.class, new JsonSerializer<Object>() { @Override public void serialize(Object obj, Output out) throws IOException { out.writeObject(o); } }); m.addSerializer(Object.class, new JsonSerializer<Object>() { @Override public void serialize(Object obj, Output out) throws IOException { out.writeObject(o); } }); Assert.assertNotNull(m.getSerializers()); Assert.assertEquals(m.getSerializers().size(), 1); Assert.assertEquals(m.getSerializers().get(Object.class).
@Test public void testAddSerializer() { Object o = new Object(); SimpleModule m = new SimpleModule(); m.addSerializer(Object.class, new JsonSerializer<Object>() { @Override public void serialize(Object obj, Output out) throws IOException { out.writeObject(o); } }); m.addSerializer(Object.class, new JsonSerializer<Object>() { @Override public void serialize(Object obj, Output out) throws IOException { out.writeObject(o); } }); Assert.assertNotNull(m.getSerializers()); Assert.assertEquals(m.getSerializers().size(), 1); Assert.assertEquals(m.getSerializers().get(Object.class).
@Test public void testSimpleSerializers() { SimpleModule m = new SimpleModule(); m.addSerializer(String.class, new StringSerializer()); m.addSerializer(Integer.class, new IntegerSerializer()); m.addSerializer(String.class, new StringSerializer()); List<JsonSerializer<?>> serializers = m.getSerializers(); Assert.assertNotNull(serializers); Assert.assertEquals(serializers.size(), 2); Assert.assertEquals(serializers.get(0).getClass(), StringSerializer.class); Assert.assertEquals(serializers.get(1).getClass(), IntegerSerializer.class); Assert.assertEquals(serializers.get(2).getClass(), StringSerializer
@Test public void testAddSerializer() { SimpleModule m = new SimpleModule(); m.addSerializer(String.class, new JsonSerializer<String>() { @Override public String deserialize(JsonReader reader, Class<String> type) throws IOException { return "test"; } }); m.addSerializer(String.class, new JsonSerializer<String>() { @Override public String deserialize(JsonReader reader, Class<String> type) throws IOException { return "test2"; } }); m.addSerializer(String.class, new JsonSerializer<String>() { @Override public String deserialize(JsonReader reader, Class<String> type) throws IOException { return "test3"; } }); Assert.assert
@Test public void testAddSerializer() { Object o = new Object(); SimpleModule m = new SimpleModule("test", Version.DEFAULT_VERSION, new HashMap<Class<?>, JsonDeserializer<?>>(), new ArrayList<JsonSerializer<?>>()); m.addSerializer(Object.class, new JsonSerializer<Object>() { @Override public void serialize(Object obj, Output out) throws IOException { out.writeObject(o); } }); Assert.assertNotNull(m.getSerializers()); Assert.assertEquals(m.getSerializers().size(), 1); Assert.assertEquals(m.getSerializers().get(Object.class).getClass(), Object.class); }
@Test public void testCustomDeserializer() { SimpleModule m = new SimpleModule("test", Version.DEFAULT, new HashMap<Class<?>, JsonDeserializer<?>>(), new ArrayList<JsonSerializer<?>>()); m.addDeserializer(Integer.class, new JsonDeserializer<Integer>() { @Override public JsonDeserializer<Integer> deserialize(JsonReader reader, Class<Integer> type) { return new JsonDeserializer<Integer>() { @Override public Object deserialize(JsonReader reader, Class<Integer> type) { return Integer.class; } }); } }); m.addDeserializer(Integer.class, new JsonDeserializer<Integer>() { @Override public Integer deserialize(JsonReader reader, Class<Integer> type)
@Test public void testAddDeserializer() { SimpleModule m = new SimpleModule("test", Version.DEFAULT, null, null); m.addDeserializer(String.class, new JsonDeserializer<String>() { @Override public String deserialize(JsonNode node, JsonHandler handler) throws JsonProcessingException { return null; } }); m.addDeserializer(String.class, new JsonDeserializer<String>() { @Override public String deserialize(JsonNode node, JsonHandler handler) throws JsonProcessingException { return null; } }); m.addDeserializer(String.class, new JsonDeserializer<String>() { @Override public String deserialize(JsonNode node, JsonHandler handler) throws JsonProcessingException { return null; } }); m
@Test public void testAddDeserializer() { SimpleModule m = new SimpleModule("test", Version.DEFAULT, new HashMap<Class<?>, JsonDeserializer<?>>(), new ArrayList<JsonSerializer<?>>()); m.addDeserializer(String.class, new StringDeserializer()); m.addDeserializer(Integer.class, new IntegerDeserializer()); Assert.assertEquals(m.deserializers().size(), 2); Assert.assertEquals(m.deserializers().get(String.class).getClass(), StringDeserializer.class); Assert.assertEquals(m.deserializers().get(Integer.class).getClass(), IntegerDeserializer.class); Assert.assertEquals(m.deserializers().get(Integer.
@Test public void testAddDeserializer() { SimpleModule m = new SimpleModule(); m.addDeserializer(String.class, new JsonDeserializer<String>() { @Override public String deserialize(JsonReader reader, Object value, Class<String> type) { return "test"; } }); m.addDeserializer(String.class, new JsonDeserializer<String>() { @Override public String deserialize(JsonReader reader, Object value, Class<String> type) { return "test2"; } }); m.addDeserializer(String.class, new JsonDeserializer<String>() { @Override public String deserialize(JsonReader reader, Object value, Class<String> type) { return "test3"; } });
@Test public void testAddDeserializer() { SimpleModule m = new SimpleModule("test", Version.DEFAULT, null, null); m.addDeserializer(String.class, new JsonDeserializer<String>() { @Override public String deserialize(JsonReader reader, Object value, Class<String> type) { return null; } }); m.addDeserializer(String.class, new JsonDeserializer<String>() { @Override public String deserialize(JsonReader reader, Object value, Class<String> type) { return null; } }); m.addDeserializer(String.class, new JsonDeserializer<String>() { @Override public String deserialize(JsonReader reader, Object value, Class<String> type) {
@Test public void testRegisterSubtypes() { SimpleModule m = new SimpleModule("test"); m.registerSubtypes(String.class, Integer.class); m.registerSubtypes(String.class, Integer.class); Assert.assertEquals(m.getModuleName(), "test"); Assert.assertEquals(m.getVersion(), Version.DEFAULT_VERSION); Assert.assertEquals(m.getSerializers().size(), 2); Assert.assertTrue(m.getSerializers().containsKey(String.class)); Assert.assertTrue(m.getSerializers().containsKey(Integer.class)); Assert.assertTrue(m.getSerializers().containsKey(Integer.class)); Assert.
@Test public void testRegisterSubtypes() { SimpleModule m = new SimpleModule(); m.registerSubtypes(String.class, Integer.class); m.registerSubtypes(String.class, Integer.class); Assert.assertEquals(m.getSubtypes().size(), 2); Assert.assertEquals(m.getSubtypes().get(0).getClass(), String.class); Assert.assertEquals(m.getSubtypes().get(1).getClass(), Integer.class); Assert.assertEquals(m.getSubtypes().get(2).getClass(), Integer.class); }
@Test public void testRegisterSubtypes() { SimpleModule m = new SimpleModule(); m.registerSubtypes(TestBean.class, TestBean2.class); Assert.assertEquals(m.getSubtypes().size(), 2); Assert.assertEquals(m.getSubtypes().get(0).getClass(), TestBean2.class); Assert.assertEquals(m.getSubtypes().get(1).getClass(), TestBean2.class); m.registerSubtypes(TestBean.class, TestBean3.class); Assert.assertEquals(m.getSubtypes().size(), 3); Assert.assertEquals(m.getSubtypes().get(0).getClass(),
@Test public void testRegisterSubtypes() { SimpleModule m = new SimpleModule(); m.registerSubtypes(String.class, Integer.class); m.registerSubtypes(String.class, Integer.class); Assert.assertEquals(m.getByType(String.class), Integer.class); Assert.assertEquals(m.getByType(Integer.class), Integer.class); Assert.assertEquals(m.getByType(Integer.class), Integer.class); Assert.assertEquals(m.getByType(String.class), String.class); Assert.assertEquals(m.getByType(Integer.class), Integer.class); Assert.assertEquals(m.getByType(String.
@Test public void testRegisterSubtypes() { SimpleModule m = new SimpleModule(); m.registerSubtypes(String.class, Integer.class); m.registerSubtypes(String.class, Integer.class); Assert.assertEquals(m.getSubtypes().size(), 2); Assert.assertEquals(m.getSubtypes().get(0).getType(), String.class); Assert.assertEquals(m.getSubtypes().get(1).getType(), Integer.class); Assert.assertEquals(m.getSubtypes().get(2).getType(), Integer.class); Assert.assertEquals(m.getSubtypes().get(3).getType(), Integer.class
@Test public void testRegisterSubtypes() { Set<Class<?>> subtypes = new HashSet<Class<?>>(); subtypes.add(String.class); SimpleModule m = new SimpleModule("test", Version.DEFAULT, subtypes); m.registerSubtypes(String.class, String.class); Assert.assertEquals(m.getModuleName(), "test"); Assert.assertEquals(m.getVersion(), Version.DEFAULT.getVersion()); Assert.assertEquals(m.getSerializers().size(), 2); Assert.assertTrue(m.getSerializers().containsKey(String.class)); Assert.assertTrue(m.getSerializers().containsKey(String.class)); Assert.
@Test public void testSetupModule() { final SimpleModule module = new SimpleModule(); final SetupContext mockContext = mock(SetupContext.class); module.setupModule(mockContext); verify(mockContext, times(1)).addSerializers(any(Serializers.class)); verify(mockContext, times(1)).addDeserializers(any(Deserializers.class)); verify(mockContext, times(1)).addKeySerializers(any(KeySerializers.class)); verify(mockContext, times(1)).addKeyDeserializers(any(KeyDeserializers.class)); verify(mockContext, times(1)).addAbstractTypeResolver(any(AbstractTypeResolver.
@Test public void testSetupModule() { final SimpleModule module = new SimpleModule(); final SetupContext mockContext = mock(SetupContext.class); module.setupModule(mockContext); verify(mockContext, times(1)).addDeserializers(any(Deserializers.class)); verify(mockContext, times(1)).addDeserializers(any(Deserializers.class)); verify(mockContext, times(1)).addAbstractTypeResolver(any(AbstractTypeResolver.class)); verify(mockContext, times(1)).addKeySerializers(any(KeySerializers.class)); verify(mockContext, times(1)).addKeySerializers(any(KeySerializers.
@Test public void testSimpleModule() { final SimpleModule module = new SimpleModule(); final SetupContext context = mock(SetupContext.class); module.setupModule(context); verify(context, times(1)).registerSubtypes(any(Class[].class)); verify(context, times(1)).addSerializers(any(Class[].class)); verify(context, times(1)).addKeySerializers(any(Class[].class)); verify(context, times(1)).addKeyDeserializers(any(Class[].class)); verify(context, times(1)).addKeyDeserializers(any(Class[].class)); verify(context, times(1)
@Test public void test_narrow() { JavaType type = _narrow(String.class); assertEquals(String.class, type.getTypeClass()); assertArrayEquals(new String[] { "String", "Integer" }, type.getTypeNames()); assertArrayEquals(new String[] { "Integer" }, type.getTypeParams()); assertEquals(type, type._withTypeHandler(String.class)); assertEquals(type, type._withTypeHandler(Integer.class)); assertEquals(type, type._withTypeHandler(Integer.class)); assertEquals(type, type._narrow(String.class)); assertEquals(type, type._withTypeHandler(Integer.class));
@Test public void test_narrow() { JavaType type = _narrow(String.class); assertEquals(String.class, type.getTypeHandler().getRawType()); assertArrayEquals(new String[] {"String"}, type.getTypeNames()); assertArrayEquals(new String[] {"Integer"}, type.gettypeParameters()); assertEquals(type, type._withTypeHandler("String")); assertEquals(type, type._withTypeHandler("Integer")); assertEquals(type, type._narrow(String.class)); assertEquals(type, type._withTypeHandler("Integer")); assertEquals(type, type._narrow(String.class)); assertEquals(type, type
@Test public void testWithTypeHandler() throws Exception { JavaType type = new SimpleType(MyType.class) .withTypeHandler(null); assertEquals(2, type.typeNames().length); assertEquals(MyType.class, type.typeNames()[0]); assertEquals(String.class, type.typeNames()[1]); assertEquals(Integer.class, type.typeParams()[0]); assertEquals(String.class, type.typeParams()[1]); assertEquals(Integer.class, type.typeParams()[2]); }
@Test public void testWithTypeHandler() throws Exception { JavaType type = new SimpleType(MyType.class, new String[] {"a", "b"}, null, null, null, false) .withTypeHandler(new Object() { }); assertEquals(2, type.typeCount()); assertEquals("MyType", type.typeNames()[0]); assertEquals("a", type.typeNames()[1]); assertEquals("b", type.typeParams()[0]); assertEquals("int", type.typeParams()[1]); assertEquals("boolean", type.typeParams()[2]); assertEquals("byte", type.typeParams()[3]); assertEquals("char", type
@Test public void testBuildCanonicalName() { Assert.assertEquals(String.class.getName(), new SimpleType(String.class).buildCanonicalName()); Assert.assertEquals(Integer.class.getName(), new SimpleType(Integer.class).withTypeCount(0).buildCanonicalName()); Assert.assertEquals(Boolean.class.getName(), new SimpleType(Boolean.class).withTypeCount(0).buildCanonicalName()); Assert.assertEquals(Byte.class.getName(), new SimpleType(Byte.class).withTypeCount(0).buildCanonicalName()); Assert.assertEquals(Byte.class.getName(), new SimpleType(Byte.class).withTypeCount(0).buildCanonicalName
@Test public void testBuildCanonicalName() { assertEquals(String.class.getName(), new SimpleType(String.class).buildCanonicalName()); assertEquals("String", new SimpleType(String.class).withTypeHandler(null).buildCanonicalName()); assertEquals("java.lang.String", new SimpleType(String.class).withTypeHandler(null).buildCanonicalName()); assertEquals("java.util.List<java.lang.String>", new SimpleType(List.class).withTypeHandler(null).buildCanonicalName()); assertEquals("java.util.Map<java.lang.String,java.lang.String>", new SimpleType(Map.class).withTypeHandler
@Test public void testBuildCanonicalName() { Assert.assertEquals(String.class.getName(), new SimpleType(String.class).buildCanonicalName()); Assert.assertEquals(Integer.class.getName(), new SimpleType(Integer.class).withTypeCount(0).buildCanonicalName()); Assert.assertEquals(Boolean.class.getName(), new SimpleType(Boolean.class).withTypeCount(0).buildCanonicalName()); Assert.assertEquals(Byte.class.getName(), new SimpleType(Byte.class).withTypeCount(0).buildCanonicalName()); Assert.assertEquals(Byte.class.getName(), new SimpleType(Byte.class).withTypeCount(0).buildCanonicalName
@Test public void testBuildCanonicalName() { assertEquals(String.class.getName(), new SimpleType(String.class).buildCanonicalName()); assertEquals("String", new SimpleType(String.class).withTypeHandler(null).buildCanonicalName()); assertEquals("java.lang.String", new SimpleType(String.class).withTypeHandler(null).buildCanonicalName()); assertEquals("java.util.List<java.lang.String>", new SimpleType(List.class).withTypeHandler(null).buildCanonicalName()); assertEquals("java.util.Map<java.lang.String,java.lang.String>", new SimpleType(Map.class).withTypeHandler
@Test public void testBuildCanonicalName() { Assert.assertEquals(String.class.getName(), new SimpleType(String.class).buildCanonicalName()); Assert.assertEquals(Integer.class.getName(), new SimpleType(Integer.class).withTypeCount(0).buildCanonicalName()); Assert.assertEquals(Boolean.class.getName(), new SimpleType(Boolean.class).withTypeCount(0).buildCanonicalName()); Assert.assertEquals(Byte.class.getName(), new SimpleType(Byte.class).withTypeCount(0).buildCanonicalName()); Assert.assertEquals(Byte.class.getName(), new SimpleType(Byte.class).withTypeCount(0).buildCanonicalName
@Test public void testContainedTypeName() { assertEquals("String", new SimpleType(String.class).containedTypeName(0)); assertEquals("List", new SimpleType(List.class).containedTypeName(1)); assertEquals("Map", new SimpleType(Map.class).containedTypeName(2)); assertEquals("Map", new SimpleType(Map.class).containedTypeName(3)); assertEquals("Map", new SimpleType(Map.class).containedTypeName(4)); assertEquals("Map", new SimpleType(Map.class).containedTypeName(5)); assertEquals("Map", new SimpleType(Map.class).containedTypeName(6)); assertEquals("Map",
@Test public void testContainedTypeName() { Set<String> typeNames = new HashSet<String>(); typeNames.add("String"); typeNames.add("Integer"); typeNames.add("List"); typeNames.add("Map"); SimpleType type = new SimpleType(List.class, typeNames, null, null, null, false); Assert.assertEquals("List", type.containedTypeName(0)); Assert.assertEquals("Map", type.containedTypeName(1)); Assert.assertEquals("List", type.containedTypeName(2)); Assert.assertEquals("Map", type.containedTypeName(3)); Assert.assertEquals("Map", type.containedTypeName(4
@Test public void testContainedTypeName() { assertEquals("String", _type.containedTypeName(0)); assertEquals("Map", _type.containedTypeName(1)); assertEquals("Map", _type.containedTypeName(2)); assertEquals("Map", _type.containedTypeName(3)); assertEquals("Map", _type.containedTypeName(4)); assertEquals("Map", _type.containedTypeName(5)); assertEquals("Map", _type.containedTypeName(6)); assertEquals("Map", _type.containedTypeName(7)); assertEquals("Map", _type.containedTypeName(8)); assertEquals("Map", _type.containedTypeName(
@Test public void testToString() { String[][] types = new String[][] { new String[] {"a", "b"}, new String[] {"c", "d"}, new String[] {"e", "f"}, new String[] {"g", "h"}, new String[] {"i", "j"}, new String[] {"k", "l"} }; for (int i = 0; i < types.length; i++) { for (int j = 0; j < types[i].length; j++) { for (int k = 0; k < types[j].length; k++) { types[i][j] = types[i][j]; }
@Test public void testToString() throws Exception { String signature = _type.toString(); assertTrue(signature.contains("int")); assertTrue(signature.contains("long")); assertTrue(signature.contains("float")); assertTrue(signature.contains("double")); assertTrue(signature.contains("boolean")); assertTrue(signature.contains("byte")); assertTrue(signature.contains("char")); assertTrue(signature.contains("short")); assertTrue(signature.contains("int")); assertTrue(signature.contains("long")); assertTrue(signature.contains("float")); assertTrue(signature.contains("double")); assertTrue(signature.contains("char"));
@Test public void testToString() { assertEquals("[simple type, class java.lang.String]", new SimpleType(String.class).toString()); assertEquals("[simple type, class java.lang.String[][]", new SimpleType(String[][].class).toString()); assertEquals("[simple type, class java.lang.String[][]", new SimpleType(String[][].class).toString()); assertEquals("[simple type, class java.lang.String[][]", new SimpleType(String[][].class).toString()); assertEquals("[simple type, class java.lang.String[][]", new SimpleType(String[][].class).toString
@Test public void testToString() { assertEquals("[simple type, class java.lang.String[][]", new SimpleType(String.class).toString()); assertEquals("[simple type, class java.lang.String[][]", new SimpleType(String[][].class).toString()); assertEquals("[simple type, class java.lang.String[][]", new SimpleType(String[][].class).toString()); assertEquals("[simple type, class java.lang.String[][]", new SimpleType(String[][].class).toString()); assertEquals("[simple type, class java.lang.String[][]", new SimpleType(String[][].class
@Test public void testRawClass() { assertEquals(String.class, rawClass(String.class)); assertEquals(String.class, rawClass(String.class)); assertEquals(Integer.class, rawClass(Integer.class)); assertEquals(Long.class, rawClass(Long.class)); assertEquals(Float.class, rawClass(Float.class)); assertEquals(Long.class, rawClass(Long.class)); assertEquals(Float.class, rawClass(Float.class)); assertEquals(Double.class, rawClass(Double.class)); assertEquals(Double.class, rawClass(Double.class)); assertEquals(Double.class, rawClass(Double.class
@Test public void testRawClass() { assertEquals(String.class, TypeFactory.rawClass(String.class)); assertEquals(Map.class, TypeFactory.rawClass(Map.class)); assertEquals(Map.class, TypeFactory.rawClass(Map.class)); assertEquals(String[].class, TypeFactory.rawClass(String[].class)); assertEquals(String[][].class, TypeFactory.rawClass(String[][].class)); assertEquals(String[][].class, TypeFactory.rawClass(String[][].class)); assertEquals(String[][].class, TypeFactory.rawClass(String[][].class)); assertEquals(String[][
@Test public void testRawClass() { assertEquals(String.class, TypeFactory.rawClass(String.class)); assertEquals(String.class, TypeFactory.rawClass(String.class)); assertEquals(String[].class, TypeFactory.rawClass(String[].class)); assertEquals(String[][].class, TypeFactory.rawClass(String[][].class)); assertEquals(String[][].class, TypeFactory.rawClass(String[][].class)); assertEquals(String[][].class, TypeFactory.rawClass(String[][].class)); assertEquals(String[][].class, TypeFactory.rawClass(String[][].class)); assertEquals
@Test public void testMoreSpecificType() { assertEquals(STRING_TYPE, new TypeFactory().moreSpecificType(STRING_TYPE, STRING_TYPE)); assertEquals(STRING_TYPE, new TypeFactory().moreSpecificType(STRING_TYPE, STRING_TYPE)); assertEquals(STRING_TYPE, new TypeFactory().moreSpecificType(STRING_TYPE, STRING_TYPE)); assertEquals(STRING_TYPE, new TypeFactory().moreSpecificType(STRING_TYPE, STRING_TYPE)); assertEquals(STRING_TYPE, new TypeFactory().moreSpecificType(STRING_TYPE, STRING_TYPE)); assertEquals(STRING_TYPE, new TypeFactory().moreSpecificType(STRING_TYPE, STRING_TYPE));
@Test public void testMoreSpecificType() { assertEquals(STRING, TypeFactory.defaultInstance().moreSpecificType(STRING, STRING).getRawClass()); assertEquals(STRING, TypeFactory.defaultInstance().moreSpecificType(STRING, STRING).getRawClass()); assertEquals(STRING, TypeFactory.defaultInstance().moreSpecificType(STRING, STRING).getRawClass()); assertEquals(STRING, TypeFactory.defaultInstance().moreSpecificType(STRING, STRING).getRawClass()); assertEquals(STRING, TypeFactory.defaultInstance().moreSpecificType(STRING, STRING).getRawClass()); assertEquals(STRING, TypeFactory.defaultInstance().moreSpecificType(STRING, STRING).getRawClass());
@Test public void testMoreSpecificType() { JavaType type1 = TypeFactory.defaultInstance().constructType(List.class); JavaType type2 = TypeFactory.defaultInstance().constructType(List.class); assertEquals(type1, typeFactory.moreSpecificType(type1, type2)); type2 = TypeFactory.defaultInstance().constructType(List.class); assertEquals(type1, typeFactory.moreSpecificType(type1, type2)); type2 = TypeFactory.defaultInstance().constructType(List.class); assertEquals(type2, typeFactory.moreSpecificType(type1, type2)); type2 = TypeFactory.defaultInstance().constructType(List
@Test public void testMoreSpecificType() { JavaType type1 = TypeFactory.unknownType(); JavaType type2 = TypeFactory.unknownType(); assertEquals(type1, typeFactory.moreSpecificType(type1, type2)); type2 = TypeFactory.unknownType(); assertEquals(type1, typeFactory.moreSpecificType(type1, type2)); type2 = TypeFactory.unknownType(); assertEquals(type1, typeFactory.moreSpecificType(type1, type2)); type2 = TypeFactory.unknownType(); assertEquals(type1, typeFactory.moreSpecificType(type1, type2)); type2 = TypeFactory.unknownType(); assertEquals(type
@Test public void testMoreSpecificType() { JavaType type1 = TypeFactory.unknownType(); JavaType type2 = TypeFactory.unknownType(); assertEquals(type1, typeFactory.moreSpecificType(type1, type2)); type2 = TypeFactory.unknownType(); assertEquals(type1, typeFactory.moreSpecificType(type1, type2)); type2 = TypeFactory.unknownType(); assertEquals(type1, typeFactory.moreSpecificType(type1, type2)); type2 = TypeFactory.unknownType(); assertEquals(type1, typeFactory.moreSpecificType(type1, type2)); type2 = TypeFactory.unknownType(); assertEquals(type
@Test public void testMoreSpecificType() { JavaType type1 = TypeFactory.defaultInstance().constructType(List.class); JavaType type2 = TypeFactory.defaultInstance().constructType(List.class); assertEquals(type1, type2); type2 = TypeFactory.defaultInstance().constructType(List.class); assertEquals(type1, type2); type2 = TypeFactory.defaultInstance().constructType(List.class); assertEquals(type1, type2); type2 = TypeFactory.defaultInstance().constructType(List.class); assertEquals(type1, type2); type2 = TypeFactory.defaultInstance().constructType(List.class); assertEquals
@Test public void testMoreSpecificType() { JavaType type1 = TypeFactory.unknownType(); JavaType type2 = TypeFactory.unknownType(); assertEquals(type1, typeFactory.moreSpecificType(type1, type2)); type2 = TypeFactory.unknownType(); assertEquals(type1, typeFactory.moreSpecificType(type1, type2)); type2 = TypeFactory.unknownType(); assertEquals(type1, typeFactory.moreSpecificType(type1, type2)); type2 = TypeFactory.unknownType(); assertEquals(type1, typeFactory.moreSpecificType(type1, type2)); type2 = TypeFactory.unknownType(); assertEquals(type
@Test public void testMoreSpecificType() { assertEquals(STRING, TypeFactory.defaultInstance().moreSpecificType(STRING, STRING).getRawClass()); assertEquals(STRING, TypeFactory.defaultInstance().moreSpecificType(STRING, STRING).getRawClass()); assertEquals(STRING, TypeFactory.defaultInstance().moreSpecificType(STRING, STRING).getRawClass()); assertEquals(STRING, TypeFactory.defaultInstance().moreSpecificType(STRING, STRING).getRawClass()); assertEquals(STRING, TypeFactory.defaultInstance().moreSpecificType(STRING, STRING).getRawClass()); assertEquals(STRING, TypeFactory.defaultInstance().moreSpecificType(STRING, STRING).getRawClass());
@Test public void testMoreSpecificType() { assertEquals(STRING_TYPE, new TypeFactory().moreSpecificType(STRING_TYPE, STRING_TYPE)); assertEquals(STRING_TYPE, new TypeFactory().moreSpecificType(STRING_TYPE, STRING_TYPE)); assertEquals(STRING_TYPE, new TypeFactory().moreSpecificType(STRING_TYPE, STRING_TYPE)); assertEquals(STRING_TYPE, new TypeFactory().moreSpecificType(STRING_TYPE, STRING_TYPE)); assertEquals(STRING_TYPE, new TypeFactory().moreSpecificType(STRING_TYPE, STRING_TYPE)); assertEquals(STRING_TYPE, new TypeFactory().moreSpecificType(STRING_TYPE, STRING_TYPE));
@Test public void constructSimpleType() { SimpleType simpleType = new SimpleType(); SimpleType stringType = new SimpleType(); TypeBindings typeBindings = new TypeBindings(); typeBindings.put("string", stringType); SimpleType stringType2 = new SimpleType(); TypeBindings typeBindings2 = new TypeBindings(); typeBindings2.put("string", stringType2); SimpleType stringType3 = new SimpleType(); TypeBindings typeBindings3 = new TypeBindings(); typeBindings3.put("string", stringType3); SimpleType stringType4 = new SimpleType(); TypeBindings typeBindings4 = new TypeBindings(); typeBindings4.put("string", stringType4); SimpleType stringType5 =
@Test public void convertSimpleType() { SimpleType type = new SimpleType() { }; TypeBindings bindings = new TypeBindings(); bindings.put("foo", "bar"); Type type2 = new SimpleType() { }; TypeBindings bindings2 = new TypeBindings(); types.add(type); types.add(type2); SimpleType map = new SimpleType() { }; types.add(map); SimpleType map2 = new SimpleType() { }; types.add(map2); SimpleType mapExpected = new SimpleType() { }; types.add(mapExpected); SimpleType mapExpected2 = new SimpleType() { }; types.add(mapExpected2); SimpleType
@Test public void convertSimpleType() { SimpleType type = new SimpleType() { @Override public Class<?> getRawType() { return Map.class; } @Override public JavaType[] getActualTypeArguments() { return new Class<?>[] {String.class}; } @Override public JavaType[] constructTypeParameters(Class<?> clazz, TypeBindings bindings) { return new JavaType[0]; } @Override public SimpleType constructSimpleType(Class<?> clazz, TypeBindings bindings) { return new SimpleType[0]; } @Override public Class<?> getRawType() { return Map.class; } @Override public JavaType[] constructTypeParameters(Class<?> clazz, TypeBindings bindings) { return new Class
@Test public void constructSimpleType() { SimpleType type = new SimpleType(); TypeBindings bindings = new TypeBindings(); types.add(type); MapType ss = new MapType() { private static final long serialVersionUID = 1L; @Override public Class<?> getRawType() { return type.getActualTypeArguments()[0]; } @Override public JavaType constructType(ParameterizedType type, TypeBindings context) { return type; } @Override public JavaType constructSimpleType(Class<?> type, TypeBindings context) { return new SimpleType(); } @Override public Class<?> getRawType() { return Map.class; } @Override public JavaType constructType(Class<?> type, TypeBindings context) { return new
@Test(expected = JsonProcessingException.class) public void badJson() throws IOException, JsonProcessingException { JsonParser jp = mock(JsonParser.class); when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); Object val = new Object(); when(jp.nextToken()).thenReturn(JsonToken.VALUE_NULL); when(jp.isCurrentToken()).thenReturn(true); val.deserializeTypedFromObject(jp, null); }
@Test(expected = JsonProcessingException.class) public void badJson() throws IOException, JsonProcessingException { String str = "{\\n" + " \\"a\\": {\\n" + " \\"b\\": {\\n" + " \\"c\\": {\\n" + " \\"d\\": {\\n" + " \\"e\\": \\"f\\"\\n" + " }\\n" + " }\\n" + " }\\n" + " }\\n" + "}"; JsonFactory f = new JsonFactory(); JsonParser jp = f.createParser(str); new MyTypedImpl().deserializeTypedFromObject(jp, null); }
@Test(expected = JsonProcessingException.class) public void badJson() throws IOException, JsonProcessingException { String str = "{\\n" + " \\"a\\": {\\n" + " \\"b\\": {\\n" + " \\"c\\": {\\n" + " \\"d\\": {\\n" + " \\"e\\": \\"f\\"\\n" + " }\\n" + " }\\n" + " }\\n" + " }\\n" + "}"; JsonFactory f = new JsonFactory(); JsonParser jp = f.createParser(str); new MyTypedImpl().deserializeTypedFromObject(jp, null); }
@Test(expected = JsonProcessingException.class) public void testInvalidType() throws IOException, JsonProcessingException { String id = "MyType"; when(jp.getText()).thenReturn(id); new MyTypeDeserializer()._deserializeTypedForId(jp, null, null); }
@Test(expected = NullPointerException.class) public void testDeserializeTypedForId() throws IOException, JsonProcessingException { SimpleDeserializationContext ctxt = new SimpleDeserializationContext(); JsonFactory f = new JsonFactory(); JsonParser jp = f.createParser("\\"aaa\\""); jp.nextToken(); SimpleDeserializationContext ctxt2 = f.createDeserializationContext(); TokenBuffer tb = new TokenBuffer(); tb.nextToken(); f.deserializeTypedForId(jp, ctxt2, tb); }
@Test(expected = NullPointerException.class) public void testDeserializeTypedForId() throws IOException, JsonProcessingException { JsonFactory f = new JsonFactory(); JsonParser jp = f.createParser("\\"aaa\\""); jp.nextToken(); Map<String, Object> map = new HashMap<String, Object>(); map.put("aaa", "aaa"); map.put("bbb", "bbb"); map.put("ccc", "ccc"); new MockUp<JsonParser>() { @Mock JsonParser parse(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { throw new NullPointerException(); } }; new MockUp<JsonParser>() { @Mock JsonParser
@Test public void testTypedForId() throws IOException, JsonProcessingException { String typeId = "testType"; String fieldName = "testField"; String fieldName1 = "testField1"; String fieldName2 = "testField2"; String fieldName3 = "testField3"; List<String> fields = Arrays.asList(fieldName, fieldName1, fieldName2, fieldName3); Mockito.when(jp.getText()).thenReturn(typeId); Mockito.when(jp.nextToken()).thenAnswer(new Answer<JsonToken>() { @Override public JsonToken answer(InvocationOnMock invocation) throws Throwable { Object val = invocation.getArguments()[0]; assertEquals(typeId
@Test(expected=JsonProcessingException.class) public void testReadTypedUsingDefaultImpl() throws IOException, JsonProcessingException { String str = "{\\n" + " \\"a\\" : {\\n" + " \\"b\\" : {\\n" + " \\"c\\" : {\\n" + " \\"d\\" : \\"e\\"\\n" + " }\\n" + " }\\n" + " },\\n" + " \\"d\\" : {\\n" + " \\"d\\" : {\\n" + " \\"e\\" : \\"f\\"\\n" + " }\\n" + " }\\n" + "}";
@Test(expected=JsonProcessingException.class) public void testReadTypedUsingDefaultImpl() throws IOException, JsonProcessingException { String str = "{\\n" + " \\"a\\" : {\\n" + " \\"b\\" : {\\n" + " \\"c\\" : {\\n" + " \\"d\\" : \\"e\\"\\n" + " }\\n" + " }\\n" + " },\\n" + " \\"d\\" : {\\n" + " \\"d\\" : {\\n" + " \\"e\\" : \\"f\\"\\n" + " }\\n" + " }\\n" + "}";
@Test public void testDefaultDeserializer() throws IOException, JsonProcessingException { SimpleTypeRegistry typeRegistry = new SimpleTypeRegistry(); TypeDeserializer<String> stringDeserializer = typeRegistry.getTypeDeserializer(String.class); SimpleTypeRegistry typeRegistry2 = typeRegistry.getTypeDeserializer(String.class); SimpleTypeRegistry typeRegistry3 = typeRegistry.getTypeDeserializer(String.class); SimpleTypeRegistry typeRegistry4 = typeRegistry.getTypeDeserializer(String.class); SimpleTypeRegistry typeRegistry5 = typeRegistry.getTypeDeserializer(String.class); SimpleTypeRegistry typeRegistry6 = typeRegistry.getTypeDeserializer(String.class); SimpleTypeRegistry typeRegistry7 = typeRegistry.getTypeDeserializer(
@Test(expected=JsonProcessingException.class) public void testReadTypedUsingDefaultImpl() throws IOException, JsonProcessingException { String str = "{\\n" + " \\"a\\" : {\\n" + " \\"b\\" : {\\n" + " \\"c\\" : {\\n" + " \\"d\\" : {\\n" + " \\"e\\" : {\\n" + " \\"f\\" : \\"g\\"\\n" + " }\\n" + " }\\n" + " }\\n" + " }\\n" + " }\\n" + "}"; JsonFactory f = new JsonFactory(); JsonParser jp = f.
@Test public void subtypeResolver() { SubtypeResolver subtypeResolver = new SubtypeResolver() { @Override public boolean supports(Class<?> cls) { return true; } @Override public Class<?> getRawType() { return Object.class; } @Override public boolean supports(Class<?> cls) { return true; } @Override public Class<?> getRawType() { return Object.class; } @Override public boolean supports(Class<?> cls) { return true; } @Override public boolean supports(Class<?> cls) { return true; } @Override public Class<?> getRawType() { return Object.class; } @Override public boolean supports(Class<?> cls) { return true; } @Override public
@Test public void subtypeResolver() { SubtypeResolver subtypeResolver = new SubtypeResolver() { @Override public Class<?> getRawType() { return List.class; } @Override public Class<?> getRawType() { return List.class; } @Override public boolean supports(Class<?> clazz) { return false; } @Override public boolean supports(Class<?> clazz) { return false; } @Override public Class<?> getRawType() { return List.class; } @Override public boolean supports(Class<?> clazz) { return false; } @Override public boolean supports(Class<?> clazz) { return false; } @Override public boolean supports(Class<?> clazz) { return false; } @Override public
@Test public void testClose() { String[][] lines = new String[][] { new String[] {"a", "b", "c"}, new String[] {"d", "e", "f"}, new String[] {"g", "h", "i", "j", "k"}, new String[] {"h", "i", "j", "k"}, new String[] {"h", "i", "j", "k"}, new String[] {"h", "i", "j", "k"}, new String[] {"h", "i", "j", "k"}, new String[] {"h", "i", "j", "k"}, new String[]
@Test public void testClose() { try { _buf.close(); } catch (IOException e) { e.printStackTrace(); fail(e.getMessage()); } try { _buf.close(); } catch (IOException e) { e.printStackTrace(); fail(e.getMessage()); } try { _buf.close(); } catch (IOException e) { e.printStackTrace(); fail(e.getMessage()); } try { _buf.close(); } catch (IOException e) { e.printStackTrace(); fail(e.getMessage()); } }
@Test public void testString() { String test = "test"; TokenBuffer t = new TokenBuffer(); t.writeString(test); assertEquals(test, t.toString()); t.writeString(null); assertEquals(test, t.toString()); t.writeString(test, 0, 0); assertEquals(test, t.toString()); t.writeString(test, 1, 1); assertEquals(test, t.toString()); t.writeString(test, 2, 2); assertEquals(test, t.toString()); t.writeString(test, 3, 3); assertEquals(test, t.toString()); t.writeString(test, 4, 4); assertEquals(
@Test public void testString() { { TokenBuffer tf = new TokenBuffer(); tf.writeString("foo"); assertEquals("foo", tf.toString()); } { TokenBuffer tf = new TokenBuffer(); tf.writeString(null); assertEquals("", tf.toString()); } { TokenBuffer tf = new TokenBuffer(); tf.writeString("bar"); assertEquals("bar", tf.toString()); } { TokenBuffer tf = new TokenBuffer(); tf.writeString("baz"); assertEquals("baz", tf.toString()); } }
@Test public void testEmptyString() { String str = ""; TokenBuffer tf = new TokenBuffer(); tf.append(JsonToken.VALUE_STRING, str); assertEquals("{}", tf.toString()); }
@Test public void testNumber() { String[] numbers = {"1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21", "22", "23", "24", "25", "26", "26", "26", "26", "26", "26", "26", "26", "26", "26", "26", "26", "26", "26", "26", "26", "26", "26", "26", "26", "
@Test public void testNumber() { String _10 = "{\\"a\\":1,\\"b\\":2,\\"c\\":3}"; String _11 = "{\\"a\\":1,\\"b\\":2,\\"c\\":3}"; String _12 = "{\\"a\\":1,\\"b\\":2,\\"c\\":3}"; String _13 = "{\\"a\\":1,\\"b\\":2,\\"c\\":3}"; String _21 = "{\\"a\\":1,\\"b\\":2,\\"c\\":3}"; String _22 = "{\\"a\\":1,\\"b\\":2,\\"c\\
@Test public void testDoubleWrite() throws IOException { Double d = 1.0; TokenBuffer t = new TokenBuffer(); t.writeNumber(d); assertEquals("1.0", String.valueOf(d)); }
@Test public void testNumber() { String _1 = "{\\"a\\":1.0,\\"b\\":2.0,\\"c\\":3.0}"; String _2 = "{\\"a\\":1.0,\\"b\\":2.0,\\"c\\":3.0}"; String _3 = "{\\"a\\":1.0,\\"b\\":2.0,\\"c\\":3.0}"; String _4 = "{\\"a\\":1.0,\\"b\\":2.0,\\"c\\":3.0}"; String _5 = "{\\"a\\":1.0,\\"b\\":2.0
@Test public void testCodec() { ObjectCodec codec = new ObjectCodec() { private static final long serialVersionUID = 1L; @Override public ObjectCodec getCodec() { return new ObjectCodec() { private final long serialVersionUID = 1L; @Override public ObjectCodec getCodec() { return new ObjectCodec() { private final long serialVersionUID = 1L; @Override public ObjectCodec getCodec() { return new ObjectCodec() { private final long serialVersionUID = 1L; @Override public String toString() { return "a"; } @Override public String toString() { return "b"; } @Override public int getLength() { return 0; } @Override public int getLength() { return 0; } @Override public int getLength() {
@Test public void test() { ObjectCodec codec = new ObjectCodec() { @Override public void serialize(JsonWriter out) throws IOException, JsonGenerationException, JsonGenerationException { out.writeObject("foo"); } @Override public void writeObject(JsonWriter out) throws IOException, JsonGenerationException, JsonGenerationException { out.writeObject("bar"); } @Override public void writeObject(JsonWriter out) throws IOException, JsonGenerationException, JsonGenerationException { out.writeObject("baz"); } @Override public void writeObject(JsonWriter out) throws IOException, JsonGenerationException, JsonGenerationException { out.writeObject("qux"); } @Override public void writeObject(JsonWriter out)
@Test public void testGetCurrentName() { String[] tokens = new String[1]; tokens[0] = "a"; tokens[0] = "b"; tokens[1] = "c"; assertEquals("a", tokens[0]); assertEquals("b", tokens[1]); assertEquals("c", tokens[2]); tokens = new String[1]; tokens[0] = "d"; tokens[0] = "e"; tokens[1] = "f"; assertEquals("a", tokens[0]); assertEquals("b", tokens[1]); assertEquals("c", tokens[2]); tokens = new String[1]; tokens[0] = "g"; tokens[1] =
@Test public void testGetCurrentName() { assertEquals("a", _parser.getCurrentName()); assertEquals("b", _parser.getCurrentName()); assertEquals("c", _parser.getCurrentName()); assertEquals("d", _parser.getCurrentName()); }
@Test public void testOverrideCurrentName() { String name = "test"; _tokenizer.setCurrentName(name); assertEquals(name, _tokenizer.getCurrentName()); _tokenizer.overrideCurrentName(name); assertEquals(name, _tokenizer.getCurrentName()); }
@Test public void test() { JsonReadContext ctxt = new JsonReadContext(); ctxt.setCurrentName("a"); ctxt.setCurrentName("b"); assertEquals("{\\"a\\":\\"b\\"}", "{\\"a\\":\\"b\\"}"); assertEquals("{\\"a\\":\\"b\\"}", "{\\"a\\":\\"b\\"}"); assertEquals("{\\"a\\":\\"b\\"}", "{\\"a\\":\\"b\\"}"); assertEquals("{\\"a\\":\\"b\\"}", "{\\"a\\":\\"b\\"}"); assertEquals("{\\"a\\":\\"b\\"}", "{\\"a\\":\\"b\\"}",
@Test public void testJsonGeneration() { for (int i = 0; i < 10; i++) { TokenBuffer t = new TokenBuffer(); t.firstToken(); t.writeString("foo"); t.writeString("bar"); t.writeString("baz"); t.flush(); } assertEquals("{\\"foo\\":\\"foo\\",\\"bar\\":\\"bar\\",\\"baz\\":\\"baz\\"}", json()); }
@Test public void testParsingContext() { JsonReadContext ctxt = new JsonReadContext(); ctxt.setCurrentName("a"); ctxt.setCurrentName("b"); ctxt.setCurrentName("c"); assertEquals("{\\"a\\":\\"b\\",\\"b\\":\\"c\\"}", String.format("{\\"a\\":\\"b\\",\\"b\\":\\"c\\"}", ctxt)); assertEquals("{\\"a\\":\\"b\\",\\"c\\":\\"c\\"}", String.format("{\\"a\\":\\"b\\",\\"c\\":\\"c\\"}", ctxt)); assertEquals("{\\"a\\":\\"b\\",\\"b\\
@Test public void testGetText() { TokenBuffer t = new TokenBuffer(); t.nextToken(); assertEquals("", t.getText()); t.nextToken(); assertEquals("a", t.getText()); t.nextToken(); assertEquals("b", t.getText()); t.nextToken(); assertEquals("c", t.getText()); t.nextToken(); assertEquals("d", t.getText()); t.nextToken(); assertEquals("e", t.getText()); t.nextToken(); assertEquals("f", t.getText()); t.nextToken(); assertEquals("g", t.getText()); t.nextToken(); assertEquals("h", t.
@Test public void testGetText() { TokenBuffer t = new TokenBuffer(); t.nextToken(); assertEquals("", t.getText()); t.nextToken(); assertEquals("a", t.getText()); t.nextToken(); assertEquals("b", t.getText()); t.nextToken(); assertEquals("c", t.getText()); t.nextToken(); assertEquals("d", t.getText()); t.nextToken(); assertEquals("e", t.getText()); t.nextToken(); assertEquals("f", t.getText()); t.nextToken(); assertEquals("g", t.getText()); t.nextToken(); assertEquals("h", t.
@Test public void testGetText() { TokenBuffer tokenBuffer = new TokenBuffer(); tokenBuffer.nextToken(); assertEquals("", tokenBuffer.getText()); tokenBuffer.nextToken(); assertNull(tokenBuffer.getText()); tokenBuffer.nextToken(); assertEquals("test", tokenBuffer.getText()); tokenBuffer.nextToken(); assertEquals("test", tokenBuffer.getText()); tokenBuffer.nextToken(); assertEquals("test", tokenBuffer.getText()); tokenBuffer.nextToken(); assertEquals("test", tokenBuffer.getText()); tokenBuffer.nextToken(); assertEquals("test", tokenBuffer.getText()); tokenBuffer.nextToken(); assertEquals("test", tokenBuffer.
@Test public void testGetText() { TokenBuffer t = new TokenBuffer(); t.nextToken(); assertEquals("", t.getText()); t.nextToken(); assertEquals("a", t.getText()); t.nextToken(); assertEquals("b", t.getText()); t.nextToken(); assertEquals("c", t.getText()); t.nextToken(); assertEquals("d", t.getText()); t.nextToken(); assertEquals("e", t.getText()); t.nextToken(); assertEquals("f", t.getText()); t.nextToken(); assertEquals("g", t.getText()); t.nextToken(); assertEquals("h", t.
@Test public void testGetText() { TokenBuffer t = new TokenBuffer(); t.nextToken(); assertEquals("", t.getText()); t.nextToken(); assertEquals("a", t.getText()); t.nextToken(); assertEquals("b", t.getText()); t.nextToken(); assertEquals("c", t.getText()); t.nextToken(); assertEquals("d", t.getText()); t.nextToken(); assertEquals("e", t.getText()); t.nextToken(); assertEquals("f", t.getText()); t.nextToken(); assertEquals("g", t.getText()); t.nextToken(); assertEquals("h", t.
@Test public void testGetText() { TokenBuffer t = new TokenBuffer() { @Override public JsonToken firstToken() { return JsonToken.VALUE_STRING; } @Override public String getText() { return "test"; } }; assertEquals("test", t.getText()); t = new TokenBuffer() { @Override public JsonToken firstToken() { return JsonToken.VALUE_STRING; } @Override public String getText() { return null; } }; assertEquals("test", t.getText()); t = new TokenBuffer() { @Override public JsonToken firstToken() { return JsonToken.VALUE_NUMBER_INT; } @Override public String getText() { return "test"; } }; assertEquals("test",
@Test public void testDoubleValue() { assertEquals(0.0, new TokenBuffer().getDoubleValue(), 0.0); assertEquals(1.0, new TokenBuffer().getDoubleValue(1.0), 0.0); assertEquals(2.0, new TokenBuffer().getDoubleValue(2.0), 0.0); assertEquals(3.0, new TokenBuffer().getDoubleValue(3.0), 0.0); assertEquals(4.0, new TokenBuffer().getDoubleValue(4.0), 0.0); assertEquals(5.0, new TokenBuffer().getDoubleValue(5.0), 0.0); }
@Test public void test() { assertEquals(0.0, new TokenBuffer().getDoubleValue(), 0.0); assertEquals(1.0, new TokenBuffer().getDoubleValue(1.0), 0.0); assertEquals(2.0, new TokenBuffer().getDoubleValue(2.0), 0.0); assertEquals(3.0, new TokenBuffer().getDoubleValue(3.0), 0.0); assertEquals(4.0, new TokenBuffer().getDoubleValue(4.0), 0.0); assertEquals(5.0, new TokenBuffer().getDoubleValue(5.0), 0.0); assertEquals(6.0,
@Test public void testNarrowBy() { JavaType type = _type.narrowBy(List.class); Assert.assertEquals("List", type.getRawClass()); Assert.assertEquals(List.class, type.getRawType()); Assert.assertEquals(Integer.class, type.getTypeHandler()); Assert.assertEquals(List.class, type.getTypeHandler()); Assert.assertEquals(List.class, type.getTypeHandler()); }
@Test public void testIsAbstract() throws Exception { }
@Test public void testIsAbstract() throws Exception { Assert.assertTrue(JavaType.isAbstract(List.class)); Assert.assertTrue(JavaType.isAbstract(List.class)); Assert.assertTrue(JavaType.isAbstract(List.class)); Assert.assertTrue(JavaType.isAbstract(List.class)); Assert.assertTrue(JavaType.isAbstract(List.class)); Assert.assertTrue(JavaType.isAbstract(List.class)); Assert.assertTrue(JavaType.isAbstract(List.class)); Assert.assertFalse(JavaType.isAbstract(List.class)); Assert.assertFalse(JavaType.isAbstract(List.class)); Assert.assertFalse(JavaType.isAbstract(List
@Test public void testIsConcrete() { Assert.assertTrue(JavaType.isConcrete(String.class)); Assert.assertTrue(JavaType.isConcrete(Integer.class)); Assert.assertTrue(JavaType.isConcrete(List.class)); Assert.assertTrue(JavaType.isConcrete(List.class)); Assert.assertTrue(JavaType.isConcrete(List.class)); Assert.assertTrue(JavaType.isConcrete(List.class)); Assert.assertTrue(JavaType.isConcrete(List.class)); Assert.assertTrue(JavaType.isConcrete(List.class)); Assert.assertTrue(JavaType.isConcrete(List.class)); Assert.assertTrue(JavaType.isConcrete(List.class
@Test public void testIsConcrete() { Assert.assertTrue(JavaType.isConcrete(String.class)); Assert.assertTrue(JavaType.isConcrete(Integer.class)); Assert.assertTrue(JavaType.isConcrete(List.class)); Assert.assertTrue(JavaType.isConcrete(List.class)); Assert.assertTrue(JavaType.isConcrete(List.class)); Assert.assertTrue(JavaType.isConcrete(List.class)); Assert.assertFalse(JavaType.isConcrete(List.class)); Assert.assertFalse(JavaType.isConcrete(List.class)); Assert.assertFalse(JavaType.isConcrete(List.class)); Assert.assertFalse(JavaType.isConcrete(List.class
@Test public void testIsThrowable() throws Exception { }
@Test public void testIsThrowable() { Assert.assertTrue(Throwable._class.isAssignableFrom(Throwable.class)); Assert.assertTrue(Throwable._class.isAssignableFrom(ThrowableImpl.class)); Assert.assertTrue(Throwable._class.isAssignableFrom(ThrowableImpl2.class)); Assert.assertTrue(Throwable._class.isAssignableFrom(ThrowableImpl3.class)); Assert.assertTrue(Throwable._class.isAssignableFrom(ThrowableImpl4.class)); Assert.assertTrue(Throwable._class.isAssignableFrom(ThrowableImpl5.class)); Assert.assertTrue(Throwable._class.isAssignableFrom(ThrowableImpl6.class)); Assert.assertTrue(Throwable._class.
@Test public void testNullValue() throws IOException, JsonProcessingException { final Object value = null; new POJONode(value).serialize(jg, null); verify(jg).writeNull(); verifyNoMoreInteractions(jg); }
@Test public void testNullValueSerialize() throws IOException, JsonProcessingException { final NullValue value = new NullValue(); final POJONode val = new POJONode(value); val.serialize(jg, null); verify(jg).writeNull(); verifyNoMoreInteractions(jg); val.value = null; val.serialize(jg, null); verify(jg).writeNull(); verifyNoMoreInteractions(jg); val.value = null; val.serialize(jg, null); verify(jg).writeNull(); verifyNoMoreInteractions(jg); val.value = null; val.serialize(jg, null); verify(jg
@Test public void testNullValueSerialize() throws IOException, JsonProcessingException { final Object value = null; new POJONode(value).serialize(jg, null); verify(jg).writeNull(); verifyNoMoreInteractions(jg); }
@Test public void testDateSerializer() { DateSerializer serializer = new DateSerializer().withFormat(true, new SimpleDateFormat("yyyy-MM-dd")); assertNotNull(serializer); assertTrue(serializer instanceof DateSerializer); assertEquals(true, ((DateSerializer) serializer).useTimestamp); serializer = new DateSerializer().withFormat(false, new SimpleDateFormat("yyyy-MM-dd")); assertNotNull(serializer); assertTrue(serializer instanceof DateSerializer); assertEquals(false, ((DateSerializer) serializer).useTimestamp); serializer = new DateSerializer().withFormat(true, new SimpleDateFormat("yyyy-MM-dd")); assertNotNull(serializer); assertTrue(serializer instanceof DateSerializer); assertEquals(false, ((DateSerializer) serializer
@Test public void withFormat() throws Exception { DateSerializer serializer = new DateSerializer(); assertTrue(serializer.withFormat(true, new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'")).getSerializer() instanceof DateSerializer); assertTrue(serializer.withFormat(false, new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'")).getSerializer() instanceof DateSerializer); assertTrue(serializer.withFormat(false, new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'")).getSerializer() instanceof DateSerializer); }
@Test public void testDateSerializer() throws Exception { DateSerializer serializer = new DateSerializer(); assertTrue(serializer.withFormat(true, new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'")).useTimestamp); assertTrue(serializer.withFormat(true, new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'")).useTimestamp); assertTrue(serializer.withFormat(false, new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'")).useTimestamp); assertTrue(serializer.withFormat(false, new SimpleDateFormat("yyyy-MM-dd
@Test public void testDateSerializer() throws Exception { DateSerializer serializer = new DateSerializer(); assertTrue(serializer.withFormat(false, new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'")) instanceof DateSerializer); assertTrue(serializer.withFormat(true, new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'")) instanceof DateSerializer); assertTrue(serializer.withFormat(true, new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'")) instanceof DateSerializer); assertTrue(serializer.withFormat(false, new SimpleDateFormat("yyyy-
@Test public void test_timestamp() { DateSerializer serializer = new DateSerializer(); assertEquals(0L, serializer._timestamp(null)); assertEquals(0L, serializer._timestamp(new Date(0L))); assertEquals(1L, serializer._timestamp(new Date(1L))); assertEquals(2L, serializer._timestamp(new Date(2L))); assertEquals(3L, serializer._timestamp(new Date(3L))); assertEquals(4L, serializer._timestamp(new Date(4L))); assertEquals(5L, serializer._timestamp(new Date(5L))); assertEquals(6L, serializer._timestamp(new Date(6L)));
@Test public void test_timestamp() { DateSerializer serializer = new DateSerializer(); assertEquals(0L, serializer._timestamp(null)); assertEquals(0L, serializer._timestamp(new Date(0L))); assertEquals(0L, serializer._timestamp(new Date(1L))); assertEquals(1L, serializer._timestamp(new Date(2L))); assertEquals(2L, serializer._timestamp(new Date(3L))); assertEquals(3L, serializer._timestamp(new Date(4L))); assertEquals(3L, serializer._timestamp(new Date(5L))); assertEquals(5L, serializer._timestamp(new Date(6L)));
@Test public void testSerialize() throws IOException, JsonGenerationException { final DateSerializer serializer = new DateSerializer(); final JsonGenerator generator = mock(JsonGenerator.class); final Date value = new Date(); serializer.serialize(value, generator, new DefaultSerializerProvider()); verify(generator).writeNumber(value); verifyNoMoreInteractions(generator); }
@Test public void testSerialize() throws Exception { final Date value = new Date(); final DateSerializer serializer = new DateSerializer(); final JsonGenerator jgen = mock(JsonGenerator.class); serializer.serialize(value, jgen, null); verify(jgen).writeNumber(value); serializer.withFormat(true, new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'")); serializer.serialize(value, jgen, null); verify(jgen).writeNumber(value); serializer.withFormat(false, new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'")); serializer.serialize(value
@Test public void testSerializeDateValue() throws IOException, JsonGenerationException { final Date value = new Date(); final DateSerializer serializer = new DateSerializer(); final JsonGenerator jgen = mock(JsonGenerator.class); serializer.serialize(value, jgen, new DefaultSerializerProvider()); verify(jgen).writeString(value); verifyNoMoreInteractions(jgen); }
@Test public void getInputType() { TypeFactory typeFactory = new TypeFactory() { @Override protected Class<? extends Converter> findTypeParameters(Class<? extends Converter> typeClass, Class<? extends Converter> typeClass) { if (typeClass == Converter.class) { return null; } else if (typeClass == String.class) { return null; } else if (typeClass == Integer.class) { return null; } else if (typeClass == Double.class) { return null; } else if (typeClass == Byte.class) { return null; } else if (typeClass == Character.class) { return null; } else if (typeClass == Character.class) { return
@Test public void testGetInputType() { Assert.assertEquals(String.class, new MyConverter().getInputType(new TypeFactory()).getRawClass()); Assert.assertEquals(Integer.class, new MyConverter().getInputType(new TypeFactory()).getRawClass()); Assert.assertEquals(Double.class, new MyConverter().getInputType(new TypeFactory()).getRawClass()); Assert.assertEquals(Float.class, new MyConverter().getInputType(new TypeFactory()).getRawClass()); Assert.assertEquals(Double.class, new MyConverter().getInputType(new TypeFactory()).getRawClass()); }
@Test public void testGetInputType() { Assert.assertEquals(String.class, new MyConverter().getInputType(new TypeFactory()).getRawClass()); Assert.assertEquals(Integer.class, new MyConverter().getInputType(new TypeFactory()).getRawClass()); Assert.assertEquals(Double.class, new MyConverter().getInputType(new TypeFactory()).getRawClass()); Assert.assertEquals(Float.class, new MyConverter().getInputType(new TypeFactory()).getRawClass()); Assert.assertEquals(Double.class, new MyConverter().getInputType(new TypeFactory()).getRawClass()); }
@Test public void testGetInputType() { Assert.assertEquals(String.class, new MyConverter().getInputType(new TypeFactory()).getRawClass()); Assert.assertEquals(Integer.class, new MyConverter().getInputType(new TypeFactory()).getRawClass()); Assert.assertEquals(Double.class, new MyConverter().getInputType(new TypeFactory()).getRawClass()); Assert.assertEquals(Float.class, new MyConverter().getInputType(new TypeFactory()).getRawClass()); Assert.assertEquals(Double.class, new MyConverter().getInputType(new TypeFactory()).getRawClass()); }
@Test public void testBaseJsonNode() throws IOException { ObjectMapper mapper = new ObjectMapper(); JsonNode root = mapper.readTree("{\\"field1\\":\\"value1\\",\\"field2\\":\\"value2\\"}"); assertEquals("{\\"field1\\":\\"value1\\",\\"field2\\":\\"value2\\"}", root.toString()); root = mapper.readTree("{\\"field1\\":\\"value1\\",\\"field2\\":\\"value2\\"}"); assertEquals("{\\"field1\\":\\"value1\\",\\"field2\\":\\"value2\\"}", root.toString()); root = mapper.readTree("{\\"field1\\":
@Test public void findPath() { BaseJsonNode node = JsonNodeFactory.instance.objectNode(); node.put("test", JsonNodeFactory.instance.textNode("test")); node.put("test2", JsonNodeFactory.instance.textNode("test2")); node.put("test3", JsonNodeFactory.instance.textNode("test3")); JsonNode path = node.findPath("test"); Assert.assertNotNull(path); Assert.assertEquals("test", path.get("test").asText()); Assert.assertEquals("test2", path.get("test2").asText()); Assert.assertEquals("test3", path.get("test3").asText()); }
@Test public void findPath() { JsonNode node = JsonNodeFactory.instance.objectNode(); node.put("test", JsonNodeFactory.instance.numberNode(1)); node.put("test2", JsonNodeFactory.instance.numberNode(2)); node.put("test3", JsonNodeFactory.instance.numberNode(3)); node.put("test4", JsonNodeFactory.instance.numberNode(4)); node.put("test5", JsonNodeFactory.instance.numberNode(5)); node.put("test6", JsonNodeFactory.instance.numberNode(6)); node.put("test7", JsonNodeFactory.instance.numberNode(7)); node.put("test8", JsonNodeFactory.instance
@Test public void testFindPath() { BaseJsonNode node = JsonNodeFactory.instance.objectNode(); node.set("test", JsonNodeFactory.instance.textNode("test")); node.set("test2", JsonNodeFactory.instance.textNode("test2")); node.set("test3", JsonNodeFactory.instance.textNode("test3")); JsonNode path = node.findPath("test"); Assert.assertNotNull(path); Assert.assertEquals("test", path.get("test").asText()); Assert.assertEquals("test2", path.get("test2").asText()); Assert.assertEquals("test3", path.get("test3").asText()); }
@Test public void testFindPath_MissingNode() { BaseJsonNode node = new BaseJsonNode() { @Override public JsonNode findPath(String fieldName) { return null; } @Override public JsonNode findValue(String fieldName) { return null; } }; Assertions.assertEquals(MissingNode.getInstance(), node.findPath(null)); Assertions.assertEquals(MissingNode.getInstance(), node.findPath("")); Assertions.assertEquals(MissingNode.getInstance(), node.findPath("foo")); Assertions.assertEquals(MissingNode.getInstance(), node.findPath("bar")); Assertions.assertEquals(MissingNode.getInstance(), node.find
@Test public void testObjectAndNonFinal() { SimpleJavaType t = new SimpleJavaType("java.lang.Object", Object.class); assertTrue(t.useForType(t)); t = new SimpleJavaType("java.lang.String", String.class); assertTrue(t.useForType(t)); t = new SimpleJavaType("java.lang.Integer", Integer.class); assertTrue(t.useForType(t)); t = new SimpleJavaType("java.lang.Long", Long.class); assertTrue(t.useForType(t)); t = new SimpleJavaType("java.lang.Float", Float.class); assertTrue(t.useForType(t)); t = new SimpleJavaType
@Test public void testVersion() { Version v = new DefaultTypeResolverBuilder(DefaultTyping.DEFAULT).version(); Assert.assertEquals(Version.VERSION_4_5_6, v.getMapperVersion()); Assert.assertEquals(Version.VERSION_4_5_6, v.getOwner().version()); Assert.assertEquals(Version.VERSION_4_5_6, v.getOwner().version()); Assert.assertEquals(Version.VERSION_4_5_6, v.getOwner().version()); Assert.assertEquals(Version.VERSION_4_5_6, v.getOwner().version()); Assert.assertEquals(Version.VERSION_4_5_6
@Test public void testVersion() { Version v = new DefaultTypeResolverBuilder(DefaultTyping.DEFAULT).version(); System.out.println(v); }
@Test(expected = IllegalArgumentException.class) public void testNullModule() { new NullModule() { @Override public String getModuleName() { return null; } @Override public Version getVersion() { return null; } @Override public void setupModule(Module.SetupContext ctx) { ctx.setupModule(null); } }.registerModule(new NullModule() { @Override public String getModuleName() { return null; } @Override public Version getVersion() { return null; } @Override public void setupModule(Module.SetupContext ctx) { ctx.setupModule(new Module.SetupContext() { @Override public void setupModule(Module.SetupContext ctx) { ctx.setupModule(new Module.Setup
@Test(expected = IllegalArgumentException.class) public void testNullModuleName() { final Module module = new Module() { @Override public String getModuleName() { return null; } @Override public void setupModule(Module.SetupContext ctx) { ctx.setupModule(null); } }; new MockUp<Module>() { @Mock Module setupModule(Module.SetupContext ctx) { return module; } }; new MockUp<String>() { @Mock String getModuleName() { return null; } }; new MockUp<Integer>() { @Mock Integer getVersion() { return null; } }; new MockUp<Integer>() { @Mock Integer getVersion() { return null; } };
@Test public void registerModule() { final Module module = mock(Module.class); final Version version = new Version(); when(module.version()).thenReturn(version); final Module.SetupContext setupContext = mock(Module.SetupContext.class); when(module.setupModule(any(Module.SetupContext.class))).thenAnswer(new Answer<Module.SetupContext>() { @Override public Module.SetupContext answer(InvocationOnMock invocation) throws Throwable { final Module.SetupContext context = (Module.SetupContext) invocation.getArguments()[0]; context.setupModule(new Module.SetupContext() { @Override public Version getMapperVersion() { return version; } }); return
@Test public void testRegisterModule() { final Module module = mock(Module.class); final Version version = mock(Version.class); when(module.version()).thenReturn(version); final Module.SetupContext setupContext = mock(Module.SetupContext.class); when(module.setupModule(any(Module.SetupContext.class))).thenReturn(setupContext); final ObjectMapper mapper = mock(ObjectMapper.class); when(module.version()).thenReturn(version); when(module.setupModule(any(Module.SetupContext.class))).thenReturn(mapper); when(mapper.isEnabled(any(JsonParser.Feature.class))).thenReturn(true);
@Test public void testRegisterModule() { final Module module = mock(Module.class); final Version version = new Version(); when(module.version()).thenReturn(version); final Module.SetupContext setupContext = mock(Module.SetupContext.class); when(module.setupModule(any(Module.SetupContext.class))).thenAnswer(new Answer<Module.SetupContext>() { @Override public Module.SetupContext answer(InvocationOnMock invocation) throws Throwable { final Module.SetupContext context = (Module.SetupContext) invocation.getArguments()[0]; context.setupModule(new Module.SetupContext() { @Override public Version getMapperVersion() { return version; } });
@Test public void registerModule() { final Module module = mock(Module.class); final Version version = new Version(); when(module.version()).thenReturn(version); final Module.SetupContext setupContext = mock(Module.SetupContext.class); when(module.setupModule(any(Module.SetupContext.class))).thenReturn(setupContext); final ObjectMapper mapper = new Mapper().registerModule(module); assertEquals(version, mapper.getVersion()); verify(module, times(1)).setupModule(any(Module.SetupContext.class)); verify(setupContext, times(1)).setupModule(any(Module.SetupContext.class)); }
@Test public void testModule() { final Module module = mock(Module.class); final Version version = new Version(); when(module.version()).thenReturn(version); final Module.SetupContext context = mock(Module.SetupContext.class); when(module.getModuleName()).thenReturn("test"); when(module.version()).thenReturn(version); final Module moduleMock = mock(Module.class); when(moduleMock.setupModule(any(Module.SetupContext.class))).thenReturn(context); final Module moduleMock = mock(Module.class); when(moduleMock.getModuleName()).thenReturn("test"); when(moduleMock.version()).thenReturn(
@Test public void registerModule() { final Module module = mock(Module.class); final Version version = new Version(); when(module.version()).thenReturn(version); final Module.SetupContext setupContext = mock(Module.SetupContext.class); when(module.setupModule(any(Module.SetupContext.class))).thenAnswer(new Answer<Module.SetupContext>() { @Override public Module.SetupContext answer(InvocationOnMock invocation) throws Throwable { final Module.SetupContext context = (Module.SetupContext) invocation.getArguments()[0]; context.setupModule(new Module.SetupContext() { @Override public Version getMapperVersion() { return version; } }); return
@Test public void registerModule() { final Module module = mock(Module.class); when(module.getModuleName()).thenReturn("test"); final Version version = new Version(); when(module.version()).thenReturn(version); final Module.SetupContext setupContext = mock(Module.SetupContext.class); when(module.setupModule(any(Module.SetupContext.class))).thenReturn(setupContext); final ObjectMapper mapper = mock(ObjectMapper.class); when(module.version()).thenReturn(version); when(module.setupModule(any(Module.SetupContext.class))).thenReturn(mapper); final SerializationFeature feature = mock(JsonParser.Feature.class
@Test(expected = IllegalArgumentException.class) public void testRegisterModule() { final Module module = mock(Module.class); final Version version = new Version(); when(module.version()).thenReturn(version); final Module.SetupContext setupContext = mock(Module.SetupContext.class); when(module.setupModule(any(Module.SetupContext.class))).thenAnswer(new Answer<Module.SetupContext>() { @Override public Module.SetupContext answer(InvocationOnMock invocation) throws Throwable { final Module.SetupContext context = (Module.SetupContext) invocation.getArguments()[0]; context.setupModule(new Module.SetupContext() { @Override public Version getMapperVersion
@Test public void registerModule() { @SuppressWarnings("unchecked") Module module = mock(Module.class); when(module.getModuleName()).thenReturn("test"); Version version = mock(Version.class); when(module.version()).thenReturn(version); DeserializationContext._deserializationContext = mock(DeserializationContext.class); when(module.setupModule(any(Module.SetupContext.class))).thenReturn(mock(Module.SetupContext.class)); ObjectMapper mapper = mock(ObjectMapper.class); when(mapper.registerModule(any(Module.class))).thenAnswer(new Answer<Object>() { @Override public Object answer(InvocationOnMock invocation
@Test public void registerModule() { @SuppressWarnings("unchecked") Module module = mock(Module.class); when(module.getModuleName()).thenReturn("test"); Version version = mock(Version.class); when(module.version()).thenReturn(version); @SuppressWarnings("unchecked") Module.SetupContext mfSetupContext = mock(Module.SetupContext.class); when(module.setupModule(any(Module.SetupContext.class))).thenReturn(mfSetupContext); ObjectMapper mapper = mock(ObjectMapper.class); when(module.version()).thenReturn(version); when(module.setupModule(any(Module.SetupContext.class))).thenReturn(mapper);
@Test(expected = IllegalArgumentException.class) public void testRegisterModule() { final Module module = mock(Module.class); final Version version = new Version(); when(module.version()).thenReturn(version); final Module.SetupContext setupContext = mock(Module.SetupContext.class); when(module.setupModule(any(Module.SetupContext.class))).thenAnswer(new Answer<Module.SetupContext>() { @Override public Module.SetupContext answer(InvocationOnMock invocation) throws Throwable { final Module.SetupContext context = (Module.SetupContext) invocation.getArguments()[0]; context.setupModule(new Module.SetupContext() { @Override public Version getMapperVersion
@Test public void registerModule() { final Module module = mock(Module.class); when(module.getModuleName()).thenReturn("test"); final Version version = mock(Version.class); when(module.version()).thenReturn(version); final Module.SetupContext ctx = mock(Module.SetupContext.class); when(module.setupModule(any(Module.SetupContext.class))).thenReturn(ctx); final DeserializationContext._Factory df = mock(DeserializationContext._Factory.class); when(ctx.withAbstractTypeResolver(any(TypeResolver.class))).thenReturn(df); final ObjectMapper mapper = mock(ObjectMapper.class); when(mapper.register
@Test public void registerModule() { @SuppressWarnings("unchecked") Module module = mock(Module.class); when(module.getModuleName()).thenReturn("test"); Version version = mock(Version.class); when(module.version()).thenReturn(version); @SuppressWarnings("unchecked") Module.SetupContext mfSetupContext = mock(Module.SetupContext.class); when(module.setupModule(any(Module.SetupContext.class))).thenReturn(mfSetupContext); ObjectMapper mapper = mock(ObjectMapper.class); when(module.version()).thenReturn(version); when(module.setupModule(any(Module.SetupContext.class))).thenReturn(mapper);
@Test(expected = IllegalArgumentException.class) public void testRegisterModule() { final Module module = mock(Module.class); final Version version = new Version(); when(module.version()).thenReturn(version); final Module.SetupContext setupContext = mock(Module.SetupContext.class); when(module.setupModule(any(Module.SetupContext.class))).thenAnswer(new Answer<Module.SetupContext>() { @Override public Module.SetupContext answer(InvocationOnMock invocation) throws Throwable { final Module.SetupContext context = (Module.SetupContext) invocation.getArguments()[0]; context.setupModule(new Module.SetupContext() { @Override public Version getMapperVersion
@Test public void registerModule() { @SuppressWarnings("unchecked") Module module = mock(Module.class); when(module.getModuleName()).thenReturn("test"); Version version = mock(Version.class); when(module.version()).thenReturn(version); @SuppressWarnings("unchecked") Module.SetupContext setupContext = mock(Module.SetupContext.class); when(module.setupModule(any(Module.SetupContext.class))).thenReturn(setupContext); ObjectMapper mapper = mock(ObjectMapper.class); when(mapper.registerModule(any(Module.SetupContext.class))).thenReturn(mapper); ObjectMapper builtObjectMapper = mock(ObjectMapper.class); when(
@Test public void registerModule() { final Module module = mock(Module.class); final Version version = new Version(); when(module.version()).thenReturn(version); final Module.SetupContext setupContext = mock(Module.SetupContext.class); when(module.setupModule(any(Module.SetupContext.class))).thenAnswer(new Answer<Module.SetupContext>() { @Override public Module.SetupContext answer(InvocationOnMock invocation) throws Throwable { final Module.SetupContext context = (Module.SetupContext) invocation.getArguments()[0]; context.setupModule(new Module.SetupContext() { @Override public Version getMapperVersion() { return version; } }); return
@Test public void testDefaultSerializerProvider() throws Exception { DefaultSerializerProvider p = new DefaultSerializerProvider(); ObjectMapper om = new ObjectMapper(); om.setSerializerProvider(p); om.configure(SerializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, true); om.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false); om.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false); om.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false); om.setSerializerProvider(p); om.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, true); om.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES
@Test public void testDefaultSerializerProvider() throws Exception { DefaultSerializerProvider p = new DefaultSerializerProvider(); assertSame(p, _mapper.getSerializerProvider()); _mapper.setSerializerProvider(p); assertSame(p, _mapper.getSerializerProvider()); }
@Test public void testDefaultSerializerProvider() throws Exception { DefaultSerializerProvider p = new DefaultSerializerProvider(); ObjectMapper om = new ObjectMapper(); om.setSerializerProvider(p); assertSame(p, om.getSerializerProvider()); }
@Test public void testGetSerializerProvider() { SerializerProvider pp = _builder.getSerializerProvider(); assertTrue(pp.getClass().getName(), pp.getClass().getName().equals("java.lang.String")); assertTrue(pp.getClass().getName(), pp.getClass().getName().equals("java.lang.Integer")); assertTrue(pp.getClass().getName(), pp.getClass().getName().equals("java.lang.Long")); assertTrue(pp.getClass().getName(), pp.getClass().getName().equals("java.lang.Float")); assertTrue(pp.getClass().getName(), pp.getClass().getName().equals("java.lang.
@Test public void testGetSerializerProvider() { SerializerProvider pp = _builder.getSerializerProvider(); assertNotNull(pp); }
@Test public void testGetSubtypeResolver() { SubtypeResolver resolver = _builder.getSubtypeResolver(); Set<String> names = new HashSet<String>(); for (NamedType type : _builder.getSubtypes()) { names.add(type.getName()); } Assert.assertEquals(names, new HashSet<String>(Arrays.asList("a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k"))); }
@Test public void testGetSubtypeResolver() { DefaultTyping t = new DefaultTyping(); DefaultTypeResolverBuilder rb = new DefaultTypeResolverBuilder(t); SubtypeResolver cr = rb.getSubtypeResolver(); assertTrue(cr.getSubtypes().contains(SimpleType.class)); assertTrue(cr.getSubtypes().contains(SimpleType2.class)); assertTrue(cr.getSubtypes().contains(SimpleType3.class)); assertTrue(cr.getSubtypes().contains(SimpleType4.class)); assertTrue(cr.getSubtypes().contains(SimpleType5.class)); assertTrue(cr.getSubtypes().contains(SimpleType6.class));
@Test public void testRegisterSubtypes() { Class<?>[] classes = new Class<?>[2]; classes[0] = String.class; classes[1] = Integer.class; Class<?>[] subtypes = new Class<?>[2]; subtypes[0] = String.class; subtypes[1] = Integer.class; try { mapper.registerSubtypes(classes, subtypes); } catch (Exception e) { e.printStackTrace(); Assert.fail(e.getMessage()); } try { mapper.registerSubtypes(classes, subtypes); } catch (Exception e) { e.printStackTrace(); Assert.fail(e.getMessage()); } }
@Test public void testSubtypeResolver() { DefaultTyping t = new DefaultTyping(); t.registerSubtypes(TestSubtype1.class, TestSubtype2.class); t.registerSubtypes(TestSubtype3.class, TestSubtype4.class); t.registerSubtypes(TestSubtype5.class); t.registerSubtypes(TestSubtype6.class, TestSubtype7.class); t.registerSubtypes(TestSubtype8.class, TestSubtype9.class); t.registerSubtypes(TestSubtype10.class, TestSubtype11.class, TestSubtype12.class); t.registerSubtypes(TestSub
@Test public void testRegisterSubtypes() { NamedType[] subtypes = new NamedType[3]; subtypes[0] = new NamedType("String"); subtypes[1] = new NamedType("Integer"); subtypes[2] = new NamedType("List"); subtypes[3] = new NamedType("Map"); subtypes[4] = new NamedType("Map"); subtypes[5] = new NamedType("List"); subtypes[6] = new NamedType("Map"); subtypes[7] = new NamedType("List"); subtypes[8] = new NamedType("Map"); subtypes[9] = new NamedType("Map"); subtypes[10] =
@Test public void testSubtypeResolver() { DefaultTyping t = new DefaultTyping(); t.registerSubtypes(TestType1.class, TestType2.class); t.registerSubtypes(TestType1.class, TestType3.class); t.registerSubtypes(TestType2.class, TestType3.class); t.registerSubtypes(TestType1.class, TestType2.class); t.registerSubtypes(TestType2.class, TestType3.class); t.registerSubtypes(TestType1.class, TestType2.class); t.registerSubtypes(TestType2.class, TestType3.class); }
@Test public void testEnum() { JavaType javaType = _constructType(MyEnum.class); assertEquals(MyEnum.class, javaType.getRawType()); assertEquals(MyEnum.class, javaType.getTypeFactory().constructType(MyEnum.class).getRawType()); assertEquals(MyEnum.class, javaType.getTypeFactory().constructType(MyEnum.class).getRawType()); assertEquals(MyEnum.class, javaType.getTypeFactory().constructType(MyEnum.class).getRawType()); assertEquals(MyEnum.class, javaType.getTypeFactory().constructType(MyEnum.class).getRawType()); assertEquals(MyEnum.class, javaType
@Test public void testPrimitives() { Assert.assertEquals("int", _typeFactory.constructType(int.class).getTypeName()); Assert.assertEquals("long", _typeFactory.constructType(long.class).getTypeName()); Assert.assertEquals("float", _typeFactory.constructType(float.class).getTypeName()); Assert.assertEquals("double", _typeFactory.constructType(double.class).getTypeName()); Assert.assertEquals("short", _typeFactory.constructType(short.class).getTypeName()); Assert.assertEquals("long", _typeFactory.constructType(long.class).getTypeName()); Assert.assertEquals("float", _typeFactory.constructType
@Test public void testConfigure() { ObjectMapper om = new ObjectMapper(); om.configure(JsonGenerator.Feature.VALUE_NUMBER, true); om.configure(JsonGenerator.Feature.VALUE_STRING, true); om.configure(JsonGenerator.Feature.VALUE_NUMBER_NUMBER, true); om.configure(JsonGenerator.Feature.VALUE_NUMBER_NUMBER, true); om.configure(JsonGenerator.Feature.VALUE_NUMBER_NUMBER_NUMBER, true); om.configure(JsonGenerator.Feature.VALUE_NUMBER_NUMBER_NUMBER, true); om.configure(JsonGenerator.Feature.VALUE_NUMBER_NUMBER_NUMBER_NUMBER, true); om.configure(JsonGenerator.Feature.VALUE_
@Test public void test() throws IOException { ObjectMapper jf = new ObjectMapper(); jf.configure(JsonGenerator.Feature.READ_ONLY, true); jf.configure(JsonGenerator.Feature.WRITE_ONLY, true); jf.configure(JsonGenerator.Feature.READ_ONLY, true); jf.configure(JsonParser.Feature.READ_ONLY, true); jf.configure(JsonFactory.Feature.WRITE_ONLY, true); jf.configure(JsonFactory.Feature.WRITE_ONLY, true); jf.configure(JsonFactory.Feature.READ_ONLY, true); jf.configure(JsonFactory.Feature.WRITE_ONLY, true); jf.configure
@Test public void testConfigure() { ObjectMapper om = new ObjectMapper(); om.configure(JsonGenerator.Feature.READ_ONLY, true); om.configure(JsonGenerator.Feature.WRITE_ONLY, true); om.configure(JsonGenerator.Feature.WRITE_ONLY, true); om.configure(JsonParser.Feature.READ_ONLY, true); om.configure(JsonGenerator.Feature.WRITE_ONLY, true); om.configure(JsonGenerator.Feature.READ_ONLY, true); om.configure(JsonGenerator.Feature.WRITE_ONLY, true); om.configure(JsonGenerator.Feature.READ_ONLY, true); om.configure(JsonGenerator.Feature.WRITE_ONLY, true
@Test public void testDisable() throws IOException { ObjectMapper om = new ObjectMapper(); ObjectMapper mapper = om.disable(SerializationFeature.SERIALIZE); String s = om.writeValueAsString(new BigDecimal(1.0)); assertEquals("1.0", s); om.disable(SerializationFeature.SERIALIZE); s = om.writeValueAsString(new BigDecimal(2.0)); assertEquals("2.0", s); om.disable(SerializationFeature.SERIALIZE); s = om.writeValueAsString(new BigDecimal(3.0)); assertEquals("3.0", s); om.disable(SerializationFeature.SERIALIZE); s = om.writeValueAsString(new BigDecimal(4
@Test public void testDisable() { _serialization.disable(SerializationFeature.SERIALIZE); assertTrue(_serialization.isEnabled(SerializationFeature.SERIALIZE)); assertTrue(_serialization.isEnabled(JsonFactory.Feature.SERIALIZE)); assertTrue(_serialization.isEnabled(JsonParser.Feature.SERIALIZE)); assertTrue(_serialization.isEnabled(JsonGenerator.Feature.SERIALIZE)); assertFalse(_serialization.isEnabled(SerializationFeature.SERIALIZE)); assertFalse(_serialization.isEnabled(JsonParser.Feature.SERIALIZE)); assertFalse(_serialization.isEnabled(JsonGenerator.Feature.SERIALIZE)); assertFalse(_serialization
@Test public void testDisable() { ObjectMapper om = new ObjectMapper(); om.disable(SerializationFeature.JSON_SERIALIZATION); assertTrue(om.isEnabled(SerializationFeature.JSON_SERIALIZATION)); om.disable(SerializationFeature.JSON_SERIALIZATION); assertFalse(om.isEnabled(SerializationFeature.JSON_SERIALIZATION)); }
@Test public void testWriteValue() throws IOException, JsonGenerationException, JsonMappingException { final Closeable value = mock(Closeable.class); final JsonGenerator jgen = mock(JsonGenerator.class); final SerializationConfig config = mock(SerializationConfig.class); when(config.isEnabled(SerializationFeature.INDENT_OUTPUT)).thenReturn(true); when(config.isEnabled(SerializationFeature.CLOSE_CLOSEABLE)).thenReturn(false); when(config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)).thenReturn(true); when(jgen.useDefaultPrettyPrinter()).thenReturn(true); when(jgen.writeValue(eq(
@Test public void testReadValue() throws IOException, JsonParseException, JsonMappingException { Map<String, Object> m = new HashMap<String, Object>(); m.put("a", "A"); m.put("b", "B"); m.put("c", "C"); m.put("d", "D"); m.put("e", "E"); m.put("f", "F"); m.put("g", "G"); m.put("h", "H"); assertEquals("A", m.get("a")); assertEquals("B", m.get("b")); assertEquals("C", m.get("c")); assertEquals("D", m
@Test public void testReadValue() throws IOException, JsonParseException, JsonMappingException { Map<String, Object> m = new LinkedHashMap<String, Object>(); m.put("a", "b"); m.put("c", "d"); m.put("d", "e"); m.put("e", "f"); m.put("f", "g"); m.put("g", "h"); m.put("h", "i"); m.put("i", "j"); m.put("j", "k"); m.put("k", "l"); m.put("l", "m"); m.put("l", "o"); m.put("o",
@Test public void testReadValue() throws IOException, JsonParseException, JsonMappingException { String data = "{\\n" + " \\"a\\" : \\"b\\",\\n" + " \\"b\\" : \\"c\\",\\n" + " \\"c\\" : \\"d\\",\\n" + " \\"d\\" : \\"e\\",\\n" + " \\"e\\" : \\"f\\",\\n" + " \\"f\\" : \\"g\\",\\n" + " \\"g\\" : \\"h\\",\\n" + " \\"h\\" : \\"i\\",\\n" + " \\
@Test public void testReadValue() throws JsonParseException, JsonMappingException, IOException { Map<String, Object> map = new HashMap<String, Object>(); map.put("a", 1); map.put("b", 2); map.put("c", 3); byte[] bytes = _jsonFactory.createParser(new ByteArrayInputStream(bytes), 0, bytes.length, JavaType.INT).toString().getBytes(); assertEquals(1, (int) _readMapAndClose(bytes, 0, bytes.length, JavaType.INT).a); assertEquals(2, (int) _readMapAndClose(bytes, 0, bytes.length, JavaType.INT).b);
@Test(expected = JsonMappingException.class) public void testWriteValueAsString() throws JsonProcessingException { JsonFactory f = new JsonFactory(); JsonGenerator gen = f.createGenerator(null); gen.nextValue(); try { f.writeValueAsString(new Object()); } catch (JsonMappingException e) { Assert.assertTrue(e.getCause() instanceof JsonMappingException); throw e; } }
@Test public void testWriter() { ObjectWriter w = m.writer(); w.writeValue(1); w.writeValue(2); w.writeValue(3); w.writeValue(4); w.writeValue(5); w.writeValue(6); w.writeValue(7); w.writeValue(8); w.writeValue(9); w.writeValue(10); w.writeValue(11); w.writeValue(12); w.writeValue(13); w.writeValue(14); w.writeValue(15); w.writeValue(16); w.writeValue(17); w.writeValue(18); w.writeValue(18
@Test public void testObjectWriter() { ObjectWriter w = new DefaultTypeResolverBuilder(DefaultTyping.DEFAULT).buildTypeSerializer(SerializationConfig.DEFAULT, DefaultTyping.DEFAULT).writer(); w.addValueInstantiators(new ValueInstantiators()); w.addValueSerializerModifier(new ValueSerializerModifier() { @Override public void configure(DeserializationConfig config) { } @Override public void configure(DeserializationConfig config) { } @Override public void configure(DeserializationConfig config) { } }); w.addValueInstantiators(new ValueInstantiators()); w.addValueSerializerModifier(new ValueSerializerModifier() { @Override public void configure(DeserializationConfig config) {
@Test public void testWriterWithType() { ObjectWriter w = _type.writerWithType(String.class); w.writeValue("test"); w.writeValue("test2"); w.writeValue("test3"); w.writeValue("test4"); w.writeValue("test5"); w.writeValue("test6"); ObjectWriter w2 = _type.writerWithType(String.class); w2.writeValue("test7"); w2.writeValue("test8"); ObjectWriter w3 = _type.writerWithType(String.class); w3.writeValue("test9"); w3.writeValue("test10"); w3.writeValue("test11
@Test public void testObjectWriterWithType() { ObjectWriter writer = _builder.writerWithType(String.class); assertTrue(writer.writerWithType(String.class) instanceof ObjectWriter); }
@Test public void testReader() { String[][] lines = new String[][] { new String[] { "A", "B", "C" }, new String[] { "D", "E", "F" }, new String[] { "G", "H", "I" }, new String[] { "H", "I", "J" }, new String[] { "G", "H", "I", "J" }, new String[] { "G", "H", "I", "J" }, new String[] { "G", "H", "I", "J" }, new String[] { "G", "H", "I", "J" }, new String[] {
@Test public void testReader() { FormatSchema schema; try { schema = new FormatSchema(); schema._verifySchemaType(schema); } catch (Exception e) { e.printStackTrace(); Assert.fail(e.getMessage()); } try { schema = new FormatSchema(); schema._verifySchemaType(schema); } catch (Exception e) { e.printStackTrace(); Assert.fail(e.getMessage()); } try { schema = new FormatSchema(); schema._verifySchemaType(schema); } catch (Exception e) { e.printStackTrace(); Assert.fail(e.getMessage()); } try { schema = new FormatSchema(); schema._verifySchemaType(schema); } catch (Exception e) { e.
@Test public void testReader() { String[][] lines = new String[][] { new String[] { "A", "B", "C" }, new String[] { "D", "E", "F" }, new String[] { "G", "H", "I" }, new String[] { "H", "I", "J" }, new String[] { "G", "H", "I", "J" }, new String[] { "G", "H", "I", "J" }, new String[] { "G", "H", "I", "J" }, new String[] { "G", "H", "I", "J" }, new String[] {
@Test public void testDate() { Date d = new Date(); SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); sdf.setTimeZone(TimeZone.getTimeZone("UTC")); Date d2 = new Date(d.getTimeInMillis()); Date d3 = new Date(d2.getTimeInMillis()); assertEquals(d, new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'").parse(d2.toString())); assertEquals(d2, new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'").parse(d
@Test public void testDate() { Date d = new Date(); SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); sdf.setTimeZone(TimeZone.getTimeZone("UTC")); Date d1 = sdf.parse(d); Date d2 = sdf.parse(d1.getTime()); Date d3 = sdf.parse(d2.getTime()); Date d4 = sdf.parse(d3.getTime()); assertEquals(d1.getTime(), d2.getTime()); assertEquals(d1.getTime(), d3.getTime()); assertEquals(d2.getTime(), d4.get
@Test public void testDate() { Date d = new Date(); SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); Date d1 = format.parse(d); Date d2 = format.parse(d1); Date d3 = format.parse(d2); Date d4 = format.parse(d3); Date d5 = format.parse(d4); Date d6 = format.parse(d5); Date d7 = format.parse(d6); Date d8 = format.parse(d8); Date d9 = format.parse(d9); Date d10 = format.parse(d10
@Test public void testDate() { Date d = new Date(); SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); sdf.setTimeZone(TimeZone.getTimeZone("UTC")); Date d1 = sdf.parse("2001-01-01T00:00:00.000Z"); Date d2 = sdf.parse("2002-01-01T00:00:00.000Z"); Date d3 = sdf.parse("2003-01-01T00:00:00.000Z"); Date d4 = sdf.parse("2004-01-01T00:00:00.000Z
@Test public void testDate() { Date d = new Date(); SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); sdf.applyPattern("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); Date d1 = sdf.parse("2001-01-01T00:00:00.000Z"); Date d2 = sdf.parse("2002-01-01T00:00:00.000Z"); Date d3 = sdf.parse("2003-01-01T00:00:00.000Z"); Date d4 = sdf.parse("2004-
@Test public void testConfigAndWriteValue() throws IOException, JsonGenerationException, JsonMappingException { final SimpleSerializationConfig cfg = new SimpleSerializationConfig(); cfg.setEnabled(SerializationFeature.INDENT_OUTPUT, true); cfg.setEnabled(SerializationFeature.CLOSE_CLOSEABLE, true); final SimpleSerializationProvider sp = new SimpleSerializationProvider(); final SimpleSerializerProvider sp2 = new SimpleSerializerProvider(); final SimpleSerializerProvider sp3 = new SimpleSerializerProvider(); final JsonGenerator jgen = mock(JsonGenerator.class); final Closeable value = mock(Closeable.class); final Closeable closeable = mock(Closeable.class); doReturn(cfg).when(sp).getSerializationConfig(); doReturn
@Test public void testConfigAndWriteValue() throws IOException, JsonGenerationException, JsonMappingException { final SimpleSerializationConfig cfg = new SimpleSerializationConfig(); cfg.setEnabled(SerializationFeature.INDENT_OUTPUT, true); final JsonGenerator jgen = mock(JsonGenerator.class); final Closeable value = mock(Closeable.class); final Closeable closeable = mock(Closeable.class); when(jgen.close()).thenReturn(closeable); when(cfg.isEnabled(SerializationFeature.CLOSE_CLOSEABLE)).thenReturn(cfg.isEnabled(SerializationFeature.INDENT_OUTPUT)); when(cfg.serializeValue(eq(jgen), eq(value))).thenReturn
@Test(expected = IllegalArgumentException.class) public void testBadSchema() { FormatSchema sf = null; try { sf._verifySchemaType(sf); } catch (IllegalArgumentException e) { Assert.assertTrue(true); Assert.assertEquals("Can not use FormatSchema of type " + sf.getClass().getName() + " for format " + sf.getClass().getName(), e.getMessage()); throw e; } catch (Exception e) { Assert.assertTrue(true); Assert.assertEquals("Can not use FormatSchema of type " + sf.getClass().getName() + " for format " + sf.getClass().getName(), e.getMessage()); throw e; } }
@Test public void test_verifySchemaType() { _verifySchemaType(null); _verifySchemaType(new FormatSchema()); _verifySchemaType(new FormatSchema() { @Override public boolean canUseSchema(FormatSchema schema) { return true; } @Override public String formatName() { return "testFormat"; } @Override public boolean useSchema(FormatSchema schema) { return false; } @Override public boolean useSchema(FormatSchema schema) { return true; } @Override public boolean useSchema(FormatSchema schema) { return false; } @Override public boolean useSchema(FormatSchema schema) { return false; } @Override public String formatName() { return "testFormat"; } @Override
@Test(expected = IllegalArgumentException.class) public void testInvalidSchema() { _jsonFactory.setCanUseSchema(true); _jsonFactory.setSchema(null); _jsonFactory._verifySchemaType(new FormatSchema()); }
@Test public void testCanInstantiate() { { SettableBeanProperty a = new SettableBeanProperty().setName("a"); SettableBeanProperty b = new SettableBeanProperty().setName("b"); SettableBeanProperty c = new SettableBeanProperty().setName("c"); SettableBeanProperty d = new SettableBeanProperty().setName("d"); SettableBeanProperty e = new SettableBeanProperty().setName("e"); SettableBeanProperty f = new SettableBeanProperty().setName("f"); SettableBeanProperty g = new SettableBeanProperty().setName("g"); SettableBeanProperty h = new SettableBeanProperty().setName("h"); Settable
@Test public void testCanInstantiate() { { SettableBeanProperty a = new SettableBeanProperty().setName("a"); SettableBeanProperty b = new SettableBeanProperty().setName("b"); SettableBeanProperty c = new SettableBeanProperty().setName("c"); SettableBeanProperty d = new SettableBeanProperty().setName("d"); SettableBeanProperty e = new SettableBeanProperty().setName("e"); SettableBeanProperty f = new SettableBeanProperty().setName("f"); SettableBeanProperty g = new SettableBeanProperty().setName("g"); SettableBeanProperty h = new SettableBeanProperty().setName("h"); Settable
@Test public void testGetTrue() { assertEquals(BooleanNode.TRUE, BooleanNode.getTrue()); }
@Test public void testValueOf() { BooleanNode n1=BooleanNode.valueOf(true); BooleanNode n2=BooleanNode.valueOf(false); BooleanNode n3=BooleanNode.valueOf(true); assertEquals(n1.booleanValue(), n2.booleanValue()); assertEquals(n1.booleanValue(), n3.booleanValue()); assertEquals(n1.asBoolean(), n2.asBoolean()); assertEquals(n1.asInt(), n3.asInt()); assertEquals(n1.asLong(), n3.asLong()); assertEquals(n1.asDouble(), n3.asDouble()); }
@Test public void testGetNodeType() { assertEquals(JsonNodeType.BOOLEAN, new BooleanNode(true).getNodeType()); assertEquals(JsonNodeType.BOOLEAN, new BooleanNode(false).getNodeType()); }
@Test public void testGetNodeType() { assertEquals(JsonNodeType.BOOLEAN, new BooleanNode(true).getNodeType()); assertEquals(JsonNodeType.BOOLEAN, new BooleanNode(false).getNodeType()); }
@Test public void testBooleanValue() { BooleanNode node = BooleanNode.TRUE; assertEquals(node._valueOf(true), true); assertEquals(node._valueOf(false), false); }
@Test public void testBooleanValue() { BooleanNode node = BooleanNode.TRUE; node.setValue(true); assertTrue(node.booleanValue()); node.setValue(false); assertFalse(node.booleanValue()); }
@Test public void testAsText() { BooleanNode node = BooleanNode.TRUE; assertEquals("true", node.asText()); node.setValue(false); assertEquals("false", node.asText()); node.setValue(true); assertEquals("true", node.asText()); node.setValue(true); assertEquals("true", node.asText()); node.setValue(false); assertEquals("false", node.asText()); node.setValue(true); assertEquals("true", node.asText()); node.setValue(false); assertEquals("false", node.asText()); node.setValue(true); assertEquals("true", node.asText()); node
@Test public void testAsText() { BooleanNode node = BooleanNode.TRUE; node.setValue(true); assertEquals("true", node.asText()); node.setValue(false); assertEquals("false", node.asText()); node.setValue(false); assertEquals("false", node.asText()); node.setValue(true); assertEquals("true", node.asText()); node.setValue(true); assertEquals("true", node.asText()); node.setValue(false); assertEquals("false", node.asText()); node.setValue(false); assertEquals("false", node.asText()); }
@Test public void testEquals() { BooleanNode a = BooleanNode.valueOf(true); BooleanNode b = BooleanNode.valueOf(false); BooleanNode c = BooleanNode.valueOf(true); BooleanNode d = BooleanNode.valueOf(false); BooleanNode e = BooleanNode.valueOf(true); BooleanNode f = BooleanNode.valueOf(false); assertTrue(a.equals(a)); assertTrue(a.equals(b)); assertTrue(a.equals(c)); assertFalse(a.equals(d)); assertFalse(b.equals(e)); assertFalse(c.equals(f)); assertFalse(d.equals(e)); assertFalse(e.
@Test public void testEquals() { BooleanNode a = BooleanNode.valueOf(true); BooleanNode b = BooleanNode.valueOf(false); BooleanNode c = BooleanNode.valueOf(true); BooleanNode d = BooleanNode.valueOf(false); BooleanNode e = BooleanNode.valueOf(true); BooleanNode f = BooleanNode.valueOf(false); assertEquals(a, b); assertEquals(b, c); assertEquals(a.hashCode(), b.hashCode()); assertEquals(b.hashCode(), c.hashCode()); assertEquals(a.hashCode(), d.hashCode()); assertEquals(b.hashCode(), e.hashCode()); assertEquals
@Test public void testNameTransformer() { final List<String> transformed = new ArrayList<String>(); NameTransformer t1 = new NameTransformer() { @Override public String transform(String transformedString) { transformed.add(transformedString); return transformedString; } }; NameTransformer t2 = new NameTransformer() { @Override public String transform(String transformedString) { return transformedString; } }; transformed.add("one"); transformed.add("two"); transformed.add("three"); transformed.add("four"); transformed.add("five"); transformed.add("six"); transformed.add("seven"); transformed.add("eight"); transformed.add("nine"); transformed.
@Test public void testSimpleTransformer() { final Charset charset = Charset.forName("UTF-8"); final Charset charset1 = Charset.forName("UTF-16"); final Charset charset2 = Charset.forName("UTF-16"); final Charset charset3 = Charset.forName("UTF-16"); final Charset charset4 = Charset.forName("UTF-16"); final Charset charset5 = Charset.forName("UTF-16"); final Charset charset6 = Charset.forName("UTF-16"); final Charset charset7 = Charset.forName("UTF-16"); final Charset charset8 = Charset.forName("UTF-16"); final Charset charset9 = Charset.forName("UTF-16");
@Test public void testSimpleTransformer() { final Charset charset = Charset.forName("UTF-8"); final Charset charset1 = Charset.forName("UTF-16"); final Charset charset2 = Charset.forName("UTF-16"); final Charset charset3 = Charset.forName("UTF-16"); final Charset charset4 = Charset.forName("UTF-16"); final Charset charset5 = Charset.forName("UTF-16"); final Charset charset6 = Charset.forName("UTF-16"); final Charset charset7 = Charset.forName("UTF-16"); final Charset charset8 = Charset.forName("UTF-16"); final Charset charset9 = Charset.forName("UTF-16");
@Test public void simpleTransformer() { final Charset charset = Charset.forName("UTF-8"); final Charset charset1 = Charset.forName("UTF-16"); final Charset charset2 = Charset.forName("UTF-16"); final Charset charset3 = Charset.forName("UTF-16"); final Charset charset4 = Charset.forName("UTF-16"); final Charset charset5 = Charset.forName("UTF-16"); final Charset charset6 = Charset.forName("UTF-16"); final Charset charset7 = Charset.forName("UTF-16"); final Charset charset8 = Charset.forName("UTF-16"); final Charset charset9 = Charset.forName("UTF-16"); final
@Test public void testSimpleTransformer() { final Charset charset = Charset.forName("UTF-8"); final Charset charset1 = Charset.forName("UTF-16"); final Charset charset2 = Charset.forName("UTF-16"); final Charset charset3 = Charset.forName("UTF-16"); final Charset charset4 = Charset.forName("UTF-16"); final Charset charset5 = Charset.forName("UTF-16"); final Charset charset6 = Charset.forName("UTF-16"); final Charset charset7 = Charset.forName("UTF-16"); final Charset charset8 = Charset.forName("UTF-16"); final Charset charset9 = Charset.forName("UTF-16");
@Test public void testAsExternalTypeDeserializer() { AsExternalTypeDeserializer at = new AsExternalTypeDeserializer(String.class, new TypeIdResolver(new DefaultIdResolver(new DefaultIdResolver(new DefaultIdResolver(new DefaultIdResolver(new DefaultIdResolver(new DefaultIdRegistry(new DefaultIdRegistry(new DefaultIdRegistry(new DefaultIdRegistry(new DefaultIdRegistry(new DefaultIdRegistry(new DefaultIdRegistry(new DefaultIdRegistry(new DefaultIdRegistry(new DefaultIdRegistry(new DefaultIdRegistry(new DefaultIdRegistry(new DefaultIdRegistry(new DefaultIdRegistry(new DefaultIdRegistry(new DefaultIdRegistry(new DefaultIdRegistry(new DefaultIdRegistry(new
@Test public void testAsExternalTypeDeserializer() { String[][] lines = new String[][] { new String[] { "java.lang.String", "java.lang.Integer", "java.lang.Long" }, new String[] { "java.lang.String", "java.lang.Long", "java.lang.Long" }, new String[] { "java.lang.String", "java.lang.Integer", "java.lang.Long" }, new String[] { "java.lang.String", "java.lang.Integer", "java.lang.Long" }, new String[] { "java.lang.String", "java.lang.Integer", "java.
@Test public void testAsExternalTypeDeserializer() { System.out.println("AsExternalTypeDeserializer"); AsExternalTypeDeserializer csd = new AsExternalTypeDeserializer(new JavaType("java.lang.String"), new BeanProperty("name", String.class)); System.out.println("AsExternalTypeDeserializer: " + csd.getTypeInclusion()); System.out.println("AsExternalTypeDeserializer: " + csd.forProperty(new BeanProperty("name", String.class))); System.out.println("AsExternalTypeDeserializer: " + csd.forProperty(new BeanProperty("name", String.class))); System.out.println("AsExternalTypeDeserializer:
@Test public void testAsExternalTypeDeserializer() { String[][] data = new String[][] { new String[] { "a", "b" }, new String[] { "c" }, new String[] { "d" }, new String[] { "e" }, new String[] { "f" }, new String[] { "g" }, new String[] { "h" }, new String[] { "i" }, new String[] { "j" }, new String[] { "k" }, new String[] { "l" }, new String[] { "i" }, new String[] { "j" }, new String[] { "k" }, new String[] { "l" }, new String
@Test public void simple() throws Exception { String[][] lines = new String[][] { new String[] {"a", "b", "c"}, new String[] {"a", "b", "c"}, new String[] {"a", "b", "c"}, new String[] {"a", "b", "c"}, new String[] {"a", "b", "c"}, new String[] {"a", "b", "c"}, new String[] {"a", "b", "c"}, new String[] {"a", "b", "c"}, new String[] {"a", "b", "c"}, new String[] {"a", "b", "
@Test public void test() throws Exception { String[][] data = new String[][] { new String[] {"a", "b", "c"}, new String[] {"a", "b", "c"}, new String[] {"a", "b", "c"}, new String[] {"a", "b", "c"}, new String[] {"a", "b", "c"}, new String[] {"a", "b", "c"}, new String[] {"a", "b", "c"}, new String[] {"a", "b", "c"}, new String[] {"a", "b", "c"}, new String[] {"a", "b", "
@Test public void test() throws Exception { AsExternalTypeDeserializer src = new AsExternalTypeDeserializer(MyType.class, new TypeIdResolver(MyType.class), "name", true, MyType.class); assertEquals(MyType.class, src.getTypeClass()); assertEquals("name", src.forProperty(new BeanProperty("name", MyType.class)).getClass().getName()); assertEquals(MyType.class, src.forProperty(new BeanProperty("name", MyType.class)).getClass().getName()); assertEquals(MyType.class, src.forProperty(new BeanProperty("name", MyType.class)).getClass().getName()); }
@Test public void asExternalProperty() { AsExternalTypeDeserializer es = new AsExternalTypeDeserializer(new JavaType(MyType.class), new TypeIdResolver(MyType.class), "foo", true, MyType.class); assertEquals(As.EXTERNAL_PROPERTY, es.getTypeInclusion()); }
@Test public void testGetTypeInclusion() throws Exception { assertEquals(As.EXTERNAL_PROPERTY, new AsExternalTypeDeserializer(MyType.class, new TypeIdResolver(MyType.class), "foo", true, MyType.class).getTypeInclusion()); assertEquals(As.EXTERNAL_PROPERTY, new AsExternalTypeDeserializer(MyType.class, new TypeIdResolver(MyType.class), "bar", true, MyType.class).getTypeInclusion()); assertEquals(As.EXTERNAL_PROPERTY, new AsExternalTypeDeserializer(MyType.class, new TypeIdResolver(MyType.class), "baz", true, MyType.class).get
@Test public void testParseBooleanPrimitive() throws Exception { JsonParser jp = mock(JsonParser.class); when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NULL); assertTrue(new SimpleDeserializer()._parseBooleanPrimitive(jp, null)); when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_TRUE); assertTrue(new SimpleDeserializer()._parseBooleanPrimitive(jp, null)); when(jp.getText()).thenReturn("true"); assertTrue(new SimpleDeserializer()._parseBooleanPrimitive(jp, null)); when(jp.getText()).thenReturn("false"); assertFalse(new SimpleDeserializer()._parseBooleanPrimitive(jp
@Test public void testParseBooleanPrimitive() throws Exception { JsonParser jp = mock(JsonParser.class); when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NULL); assertFalse(new MyDeserializer()._parseBooleanPrimitive(jp, null)); when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); assertTrue(new MyDeserializer()._parseBooleanPrimitive(jp, null)); when(jp.getText()).thenReturn("true"); assertTrue(new MyDeserializer()._parseBooleanPrimitive(jp, null)); when(jp.getText()).thenReturn("false"); assertFalse(new MyDeserializer()._parseBooleanPrimitive(jp
@Test public void _parseShort() throws IOException, JsonProcessingException { String str = "123"; when(jsonParser.getCurrentToken()).thenReturn(JsonToken.VALUE_INT.getToken()); assertEquals(123, _deserializer._parseShort(jsonParser, jsonDeserializationContext)); when(jsonParser.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING.getToken()); assertEquals(123, _deserializer._parseShort(jsonParser, jsonDeserializationContext)); when(jsonParser.getText()).thenReturn(str); assertEquals(123, _deserializer.getShortValue(jsonParser, jsonDeserializationContext)); when(jsonParser.
@Test public void parseNull() throws IOException, JsonProcessingException { String str = "null"; when(jsonParser.getCurrentToken()).thenReturn(JsonToken.VALUE_NULL); Short l = _parseShort(str); assertEquals(null, l); verify(jsonParser, times(1)).getCurrentToken(); when(jsonParser.getText()).thenReturn(str); l = _parseShort(str); assertEquals(null, l); verify(jsonParser, times(1)).getCurrentToken(); when(jsonParser.getText()).thenReturn(str); l = _parseShort(jsonParser, times(1)); assertEquals(null, l); }
@Test public void testFloat() throws IOException, JsonProcessingException { final Float value = Float.MIN_VALUE; final Short expected = value; when(jsonParser.getCurrentToken()).thenReturn(JsonToken.VALUE_FLOAT); when(jsonParser.getFloatValue()).thenReturn(value); Short actual = _parseShort(jsonParser, jsonContext); assertEquals(expected, actual); verify(jsonParser).getCurrentToken(); when(jsonParser.getFloatValue()).thenReturn(value); actual = _parseShort(jsonParser, jsonContext); assertEquals(expected, actual); }
@Test(expected = JsonProcessingException.class) public void testNull() throws IOException, JsonProcessingException { String str = "null"; when(jsonParser.getCurrentToken()).thenReturn(JsonToken.VALUE_NULL); when(jsonParser.getText()).thenReturn(str); _deserializer.setValue(str); _deserializer._parseShort(jsonParser, jsonContext); }
@Test public void testShorts() throws IOException, JsonProcessingException { assertEquals((short) 0, _parseShortPrimitive("\\"0\\"")); assertEquals((short) 1, _parseShortPrimitive("\\"1\\"")); assertEquals((short) 2, _parseShortPrimitive("\\"2\\"")); assertEquals((short) 3, _parseShortPrimitive("\\"3\\"")); assertEquals((short) 4, _parseShortPrimitive("\\"4\\"")); assertEquals((short) 5, _parseShortPrimitive("\\"5\\"")); assertEquals((short) 6, _parseShortPrimitive("\\"6\\"")); assertEquals((short) 7, _parseShortPrimitive("\\"7\\
@Test public void testParseLong() throws IOException, JsonProcessingException { Long value = 123L; when(jsonParser.getCurrentToken()).thenReturn(JsonToken.VALUE_INT); when(jsonParser.getText()).thenReturn("123"); assertEquals(value, _parseLong(jsonParser, jsonContext)); verify(jsonParser).getCurrentToken(); when(jsonParser.getText()).thenReturn("123"); assertEquals(value, _parseLong(jsonParser, jsonContext)); when(jsonParser.getCurrentToken()).thenReturn(JsonToken.VALUE_FLOAT); assertEquals(value, _parseLong(jsonParser, jsonContext)); when(jsonParser.get
@Test(expected = JsonProcessingException.class) public void testNullValue() throws IOException, JsonProcessingException { String str = null; when(jsonParser.getCurrentToken()).thenReturn(JsonToken.VALUE_NULL); long value = _parseLong(jsonParser, jsonContext); Assert.assertEquals(value, 0); when(jsonParser.getText()).thenReturn(str); value = _parseLong(jsonParser, jsonContext); Assert.assertEquals(value, 0); when(jsonParser.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); value = _parseLong(jsonParser, jsonContext); Assert.assertEquals(value, 0); }
@Test public void testParseLongPrimitive() throws IOException, JsonProcessingException { String str = "123"; when(jsonParser.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); long val = 123l; when(jsonParser.getLongValue()).thenReturn(val); assertEquals(val, new StdDeserializer(String.class)._parseLongPrimitive(jsonParser, jsonContext)); verify(jsonParser).getCurrentToken(); verify(jsonParser).getText(); assertEquals(val, new StdDeserializer(String.class)._parseLongPrimitive(jsonParser, jsonContext)); }
@Test public void testString() throws IOException, JsonProcessingException { String str = "123"; when(jsonParser.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); assertEquals(str, new StdDeserializer(String.class)._parseLongPrimitive(jsonParser, null)); when(jsonParser.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); assertEquals(123L, new StdDeserializer(String.class)._parseLongPrimitive(jsonParser, null)); when(jsonParser.getText()).thenReturn(str); assertEquals(str, new StdDeserializer(String.class)._parseLongPrimitive(jsonParser, null)); }
@Test public void testParseLongPrimitive() throws IOException, JsonProcessingException { Long value = 123L; when(jsonParser.getCurrentToken()).thenReturn(JsonToken.VALUE_INT); when(jsonParser.getLongValue()).thenReturn(value); assertEquals(value, _deserializer._parseLongPrimitive(jsonParser, jsonContext)); when(jsonParser.getCurrentToken()).thenReturn(JsonToken.VALUE_FLOAT); assertEquals(value, _deserializer._parseLongPrimitive(jsonParser, jsonContext)); when(jsonParser.getText()).thenReturn("123"); try { _deserializer._parseLongPrimitive(jsonParser, jsonContext); fail
@Test public void testParseLongPrimitive() throws IOException, JsonProcessingException { when(jsonParser.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); long value = 123L; when(jsonParser.getLongValue()).thenReturn(value); assertEquals(value, _parseLongPrimitive(jsonParser, jsonContext)); verify(jsonParser).getCurrentToken(); verify(jsonParser).getLongValue(); when(jsonParser.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); value = 0L; when(jsonParser.getLongValue()).thenReturn(value); assertEquals(value, _parseLongPrimitive(jsonParser, jsonContext));
@Test public void testParseFloat() throws JsonProcessingException, IOException { JsonParser jp = mock(JsonParser.class); DeserializationContext ctxt = mock(DeserializationContext.class); when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); when(jp.getText()).thenReturn("12345"); assertEquals(12345f, new MyDeserializer()._parseFloat(jp, ctxt), 0.1f); when(jp.getText()).thenReturn("12345"); assertEquals(12345f, new MyDeserializer()._parseFloat(jp, ctxt), 0.1f); when(jp.getCurrentToken()).thenReturn(
@Test public void testParseFloat() throws JsonProcessingException, IOException { JsonParser jp = mock(JsonParser.class); DeserializationContext ctxt = mock(DeserializationContext.class); when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); when(jp.getText()).thenReturn("12345"); assertEquals(12345f, new MyDeserializer()._parseFloat(jp, ctxt), 0.1f); when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); when(jp.getText()).thenReturn("12345"); assertEquals(12345f, new MyDeserializer()._parseFloat(jp,
@Test public void testParseFloat() throws JsonProcessingException, IOException { JsonParser jp = mock(JsonParser.class); DeserializationContext ctxt = mock(DeserializationContext.class); when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); when(jp.getText()).thenReturn("123"); assertEquals(123f, new MyDeserializer()._parseFloat(jp, ctxt), 0.1f); when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); assertEquals("123", new MyDeserializer()._parseFloat(jp, ctxt), 0.1f); when(jp.getText()).thenReturn("
@Test public void testParseFloat() throws JsonProcessingException, IOException { JsonParser jp = mock(JsonParser.class); DeserializationContext ctxt = mock(DeserializationContext.class); when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); when(jp.getText()).thenReturn("12345"); assertEquals(12345f, new MyDeserializer()._parseFloat(jp, ctxt)); when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); when(jp.getText()).thenReturn("12345"); assertEquals(12345f, new MyDeserializer()._parseFloat(jp, ctxt)); when(jp
@Test public void testParseDoublePrimitive() throws JsonProcessingException, IOException { JsonParser jp = mock(JsonParser.class); when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NULL); DeserializationContext ctxt = mock(DeserializationContext.class); when(jp.getText()).thenReturn("null"); TestDeserializer deserializer = new TestDeserializer(); double value = deserializer._parseDoublePrimitive(jp, ctxt); assertEquals(0.0, value, 0.0); value = deserializer._parseDoublePrimitive(jp, ctxt); assertEquals(0.0, value, 0.0); value = deserializer._parseDoublePrimitive(jp, ctxt); assertEquals
@Test public void testParseDoublePrimitive() throws JsonProcessingException, IOException { JsonParser jp = mock(JsonParser.class); DeserializationContext ctxt = mock(DeserializationContext.class); when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); when(jp.getText()).thenReturn("1"); double val = new MyDeserializer()._parseDoublePrimitive(jp, ctxt); assertEquals(1.0, val, 0.0); when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); val = new MyDeserializer()._parseDoublePrimitive(jp, ctxt); assertEquals(1.0, val, 0.
@Test public void handleUnknownProperty() throws IOException, JsonProcessingException { final StdDeserializer deserializer = new StdDeserializer(String.class); final JsonParser jp = jp("\\"string\\""); final DeserializationContext ctxt = Mockito.mock(DeserializationContext.class); Mockito.when(jp.nextToken()).thenReturn((JsonToken) null); Mockito.when(jsonParser.nextToken()).thenReturn((JsonToken) null); Mockito.when(jsonParser.readString("\\"string\\"")).thenReturn("string"); Mockito.when(jsonParser.nextToken()).thenReturn((JsonToken) null); Mockito.when(jsonContext.handleUnknown
@Test public void testEnum() throws IOException, JsonProcessingException { final EnumTestEnum testEnum = new EnumTestEnum(TestEnum.class); final DeserializationContext ctxt = mock(DeserializationContext.class); when(jp.skipChildren()).thenReturn(true); final EnumTestEnum testEnum2 = new EnumTestEnum(TestEnum.class); when(jp.nextToken()).thenReturn((JsonToken) null); when(jsonParser.nextToken()).thenReturn((JsonToken) null); when(jsonParser.nextToken()).thenReturn((JsonToken) null); when(jsonParser.nextToken()).thenReturn((JsonToken) null); when(testEnum2
@Test public void testIterableSerializer() { Set<String> values = new HashSet<String>(); values.add("a"); values.add("b"); values.add("c"); TypeSerializer vts = new JsonSerializer<String>() { @Override public void withValueTypeSerializer(TypeSerializer elemType) { } @Override public void withResolved(BeanProperty property, TypeSerializer vts, JsonGenerator jgen) throws IOException, JsonGenerationException { } @Override public JsonSerializer<?> withResolved(BeanProperty property, TypeSerializer vts, JsonGenerator jgen) throws IOException, JsonGenerationException { return vts.withValueTypeSerializer(vts).withResolved(property, vts, vgen
@Test public void testIterableSerializer() { Set<String> values = new HashSet<String>(); values.add("a"); values.add("b"); values.add("c"); TypeSerializer vts = new JsonSerializer<Set<String>>() { @Override public void withValueTypeSerializer(TypeSerializer vts) { } @Override public void withResolved(BeanProperty property, TypeSerializer vts, JsonGenerator jgen) throws IOException, JsonGenerationException { } @Override public JsonSerializer<?> withResolved(BeanProperty property, TypeSerializer vts, JsonGenerator jgen) throws IOException, JsonGenerationException { return vts.withValueTypeSerializer(vts).withResolved(property, vts,
@Test public void testIterableSerializer() { Set<String> values = new HashSet<String>(); values.add("test1"); values.add("test2"); values.add("test3"); values.add("test4"); TypeSerializer vts = new JsonSerializer<Set>(Set.class) { @Override public Set<String> withValueTypeSerializer(TypeSerializer valueSerializer) { return values; } @Override public void withResolved(BeanProperty property, TypeSerializer vts, JsonGenerator jgen) throws IOException, JsonGenerationException { return null; } @Override public void serializeContents(Collection<?> collection, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { return
@Test public void testIterableSerializer() throws Exception { Set<String> values = new HashSet<String>(); values.add("one"); values.add("two"); values.add("three"); values.add("four"); TypeSerializer vts = new TypeSerializer(VarcharType.INSTANCE); BeanProperty property = Mockito.mock(BeanProperty.class); Mockito.when(property.getName()).thenReturn("id"); Mockito.when(property.getType()).thenReturn(String.class); Mockito.when(property.isStaticTyping()).thenReturn(true); Mockito.when(property.getSerializer()).thenReturn(vts); IterableSerializer
@Test public void withResolved() { Set<String> values = new HashSet<String>(); values.add("a"); values.add("b"); values.add("c"); TypeSerializer vts = new JsonSerializer<String>() { @Override public void serialize(JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { super.serialize(jgen, provider); } @Override public void serialize(JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { super.serialize(jgen, provider); } }; BeanProperty property = Mockito.mock(BeanProperty.class); Mockito.when(property.getType()).thenReturn(String.class
@Test public void testIterableSerializer() { BeanProperty property = mock(BeanProperty.class); TypeSerializer vts = new JsonSerializer<Object>() { @Override public void serialize(Object obj, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { super.serialize(obj, jgen, provider); } @Override public void withResolved(BeanProperty property, TypeSerializer vts, JsonSerializer<?> vts2) { super.withResolved(property, vts2, vts2); } @Override public void withResolved(BeanProperty property, TypeSerializer vts2, JsonSerializer<?> vts2) { super.withResolved(property, vts2,
@Test public void AnyGetterWriter() throws Exception { AnyGetterWriter getter = new AnyGetterWriter(this.property, this.accessor, this.serializer); assertEquals(this.property, getter.getProperty()); assertEquals(this.accessor, getter.getAccessor()); assertEquals(this.serializer, getter.getSerializer()); JsonGenerator jgen = mock(JsonGenerator.class); JsonSerializerProvider provider = mock(JsonSerializerProvider.class); getter.getAndSerialize(this.bean, jgen, provider); verify(jgen, times(1)).writeObject(this.bean); verify(jgen, times(1)).writeObject(this.bean); verify(provider
@Test public void AnyGetterWriter() throws Exception { MockBean bean = new MockBean(); BeanProperty property = new AnnotatedMember(MockBean.class.getDeclaredField("objectField")); MockMapSerializer serializer = new MockMapSerializer(); AnyGetterWriter getter = new AnyGetterWriter(property, accessor, serializer); assertEquals(accessor, getter.getAccessor()); assertEquals(property, getter.getProperty()); assertEquals(serializer, getter.getSerializer()); getter.resolve(serializerProvider); assertEquals(accessor, getter.getAccessor()); assertEquals(property, getter.getProperty()); assertEquals(serializer, getter.getSerializer()); }
@Test public void AnyGetterWriter() throws Exception { MockBean bean = new MockBean(); AnyGetterWriter getter = new AnyGetterWriter(new AnnotatedMember(MockBean.class.getDeclaredField("stringField")), new AnnotatedMember(MockBean.class.getDeclaredField("stringField")), new MapSerializer()); JsonGenerator jgen = mock(JsonGenerator.class); getter.getAndSerialize(bean, jgen, new DefaultSerializerProvider()); verify(jgen).close(); }
@Test public void AnyGetterWriter() throws Exception { MockBean bean = new MockBean(); AnyGetterWriter getter = new AnyGetterWriter(new AnnotatedMember(MockBean.class.getDeclaredField("objectField")), new AnnotatedMember(MockBean.class.getDeclaredField("objectField")), new MapSerializer()); JsonGenerator jgen = mock(JsonGenerator.class); getter.getAndSerialize(bean, jgen, new DefaultSerializerProvider()); verify(jgen).writeObject(bean); }
@Test public void getterWriter() throws Exception { AnyGetterWriter getterWriter = new AnyGetterWriter(nameProperty, accessor, new MapSerializer()); SimpleBean bean = new SimpleBean(); getterWriter.getAndSerialize(bean, jgen, provider); Mockito.verify(jgen, Mockito.times(1)).writeFieldName("name"); Mockito.verify(jgen, Mockito.times(1)).writeObject(bean); }
@Test public void getterWriter() throws Exception { Object value = new Object(); AnnotatedMember accessor = mock(AnnotatedMember.class); when(accessor.getValue(eq(value))).thenReturn(value); MapSerializer serializer = mock(MapSerializer.class); AnyGetterWriter getterWriter = new AnyGetterWriter( _property, accessor, serializer); JsonGenerator jgen = mock(JsonGenerator.class); getterWriter.getAndSerialize(value, jgen, mock(SerializerProvider.class)); verify(serializer).serializeFields(eq(value), eq(jgen), eq(mock(SerializerProvider.class))); }
@Test public void getter() throws Exception { Object value = new Object(); AnnotatedMember accessor = mock(AnnotatedMember.class); when(accessor.getValue(eq(value))).thenReturn(value); MapSerializer serializer = mock(MapSerializer.class); AnyGetterWriter getterWriter = new AnyGetterWriter( _property, accessor, serializer ); JsonGenerator jgen = mock(JsonGenerator.class); SerializerProvider provider = mock(SerializerProvider.class); getterWriter.getAndSerialize(value, jgen, provider); verify(serializer).serializeFields(eq(value), eq(jgen), eq(provider)); }
@Test public void getter() throws Exception { Object value = new Object(); AnnotatedMember accessor = mock(AnnotatedMember.class); when(accessor.getValue(eq(value))).thenReturn(value); MapSerializer serializer = mock(MapSerializer.class); AnyGetterWriter getterWriter = new AnyGetterWriter(FOO_PROPERTY, accessor, serializer); JsonGenerator jgen = mock(JsonGenerator.class); getterWriter.getAndSerialize(value, jgen, mock(SerializerProvider.class)); verify(serializer).serializeFields(eq(value), eq(jgen), eq(mock(SerializerProvider.class))); }
@Test public void getterWriter() throws Exception { Object value = new Object(); AnnotatedMember accessor = mock(AnnotatedMember.class); when(accessor.getValue(value)).thenReturn(value); AnyGetterWriter getterWriter = new AnyGetterWriter( _property, accessor, _serializer); getterWriter.getAndSerialize(value, jgen, _provider); Mockito.verify(_serializer).serializeFields(value, jgen, _provider); }
@Test public void resolve() throws Exception { MapSerializer serializer = mock(MapSerializer.class); Mockito.when(serializer.createContextual(provider, _property)).thenReturn(serializer); AnyGetterWriter writer = new AnyGetterWriter( _property, _accessor, serializer); writer.resolve(provider); verify(serializer).createContextual(provider, _property); verifyNoMoreInteractions(serializer); }
@Test public void resolve() throws Exception { MockBean bean = new MockBean(); AnyGetterWriter getterWriter = new AnyGetterWriter(new AnnotatedMember("name"), new AnnotatedMember("age"), new MapSerializer()); JsonGenerator jgen = mock(JsonGenerator.class); getterWriter.getAndSerialize(bean, jgen, mock(SerializerProvider.class)); verify(jgen).writeFieldName("name"); verify(jgen).writeObject(bean); verifyNoMoreInteractions(jgen); }
@Test public void testNumericNode() { NumericNode node = new NumericNode() { @Override public Type getType() { return null; } @Override public int intValue() { return 0; } @Override public long longValue() { return 0; } @Override public double doubleValue() { return 0; } @Override public BigDecimal decimalValue() { return null; } @Override public BigInteger bigIntegerValue() { return BigInteger.valueOf(Long.MAX_VALUE); } @Override public BigInteger bigIntegerValue() { return BigInteger.valueOf(Long.MIN_VALUE); } @Override public BigDecimal decimalValue() { return BigDecimal.valueOf(Long.MAX_VALUE); } @Override public String asText() { return
@Test public void testWith() { Class<?>[] types = new Class<?>[] { SimpleType.class, SimpleType2.class, SimpleType3.class, SimpleType4.class, SimpleType5.class, SimpleType6.class, SimpleType7.class, SimpleType8.class, SimpleType9.class, SimpleType10.class, SimpleType11.class, SimpleType12.class, SimpleType13.class, SimpleType14.class, SimpleType15.class, SimpleType16.class, SimpleType17.class, SimpleType18.class, SimpleType19.class, SimpleType20.class, SimpleType21.class, SimpleType22
@Test public void testWith() { Class<?>[] classes = new Class<?>[] { SimpleType.class, SimpleType2.class, SimpleType1.class, SimpleType2.class, SimpleType3.class, SimpleType4.class, SimpleType5.class, SimpleType6.class, SimpleType7.class, SimpleType8.class, SimpleType9.class, SimpleType10.class, SimpleType11.class, SimpleType12.class, SimpleType13.class, SimpleType21.class, SimpleType22.class, SimpleType22.class, SimpleType23.class, SimpleType24.class, SimpleType22.class, SimpleType22
@Test(expected = IllegalArgumentException.class) public void testInvalidPropertyNamingStrategy() { new SerializationConfig( new TypeResolverBuilder<Object>() { @Override public Class<?> resolve(String s) { return Object.class; } @Override public Class<?> getRawType() { return Object.class; } @Override public Class<?> getRawType() { return Object.class; } @Override public Class<?>[] getInheritedClasses() { return new Class<?>[0]; } @Override public Class<?>[] getInheritedClasses2() { return new Class<?>[0]; } @Override public Class<?>[] getInheritedClasses3() { return new Class<?>[0]; } @Override public Class
@Test public void testWith() { final SerializationConfig cfg = new SerializationConfig( new TypeResolverBuilder<Object>(Object.class) .with(PropertyNamingStrategy.LOWER_CASE_WITH_UNDERSCORES) .with(PropertyNamingStrategy.UPPER_CASE_WITH_UNDERSCORES)); final SerializationConfig newConfig = cfg.with(PropertyNamingStrategy.LOWER_CASE_WITH_UNDERSCORES); assertSerialization(newConfig, newConfig); final SerializationConfig newConfig2 = newConfig.with(PropertyNamingStrategy.LOWER_CASE_WITH_UNDERSCORES) .with(PropertyNamingStrategy.UPPER_CASE_WITH_UNDERSCORES); assertSerialization(newConfig2, newConfig
@Test public void testWith() { final SerializationConfig cfg = new SerializationConfig().with(TimeZone.getTimeZone("UTC")); assertEquals(1, cfg.getMapperFeatures().size()); assertEquals(0, cfg.getSerdeFeatures().size()); final SerializationConfig cfg2 = cfg.with(SubtypeResolver.getDefault()); assertEquals(1, cfg2.getMapperFeatures().size()); assertEquals(0, cfg2.getSerdeFeatures().size()); final SerializationConfig cfg3 = cfg.with(SubtypeResolver.getDefault()); assertEquals(1, cfg3.getMapperFeatures().size()); assertEquals(0, cfg3.getSerdeFeatures().size()); }
@Test public void testWith() { List<Path> paths = new ArrayList<>(); paths.addAll(Arrays.asList(PATH_A, PATH_B, PATH_C)); paths.addAll(Arrays.asList(PATH_D, PATH_E, PATH_F)); SerializationConfig cfg = new SerializationConfig( new BaseSettings().with(Paths.get(PATH_A)), SubtypeResolver.getDefault(), Collections.<ClassKey, Class<?>>emptyMap()); assertSerialization(cfg, new SerializationConfig(cfg, SubtypeResolver.getDefault(), Collections.<ClassKey, Class<?>>emptyMap())); cfg = new SerializationConfig(new BaseSettings().with(Paths.get
@Test public void testToString() { final SerializationConfig cfg = new SerializationConfig.Builder().build(); assertEquals( "[SerializationConfig: flags=0x0" + Integer.toHexString(Integer.MIN_VALUE) + "]", cfg.toString() ); assertEquals( "[SerializationConfig: flags=0x0" + Integer.MAX_VALUE + "]", cfg.toString() ); assertEquals( "[SerializationConfig: flags=0x0" + Integer.MIN_VALUE + "]", cfg.toString() ); assertEquals( "[SerializationConfig: flags=0x0" + Integer.MAX_VALUE + "]", cfg.toString() ); assertEquals( "[SerializationConfig: flags=0x0"
@Test public void testToString() { assertEquals( "[SerializationConfig: flags=0x0" + Integer.toHexString(1), "[SerializationConfig: flags=0x0" + Integer.toHexString(2), "[SerializationConfig: flags=0x0" + Integer.toHexString(3), "[SerializationConfig: flags=0x0" + Integer.toHexString(4), "[SerializationConfig: flags=0x0" + Integer.toHexString(5), "[SerializationConfig: flags=0x0" + Integer.toHexString(6), "[SerializationConfig: flags=0x0" + Integer.toHexString(7), "[SerializationConfig: flags=0x0" +
@Test public void testURLDeserializer() { URLDeserializer deserializer = new URLDeserializer(); assertNull(deserializer.deserialize("http: deserializer = new URLDeserializer(); assertSame(URLDeserializer.instance, deserializer.deserialize("http: deserializer = new URLDeserializer(); assertSame(URLDeserializer.instance, deserializer.deserialize("http: deserializer = new URLDeserializer(); assertSame(URLDeserializer.instance, deserializer.deserialize("http: deserializer = new URLDeserializer(); assertSame(URLDeserializer.instance, deserializer.deserialize("http: deserializer = new URLDeserializer(); assertSame(URLDeserializer.instance, deserializer.deserialize("http: deserializer = new URLDeserializer(); assertSame(URLDeserializer.instance, deserializer.deserialize("http: deserializer
@Test public void testUrlDeserializer() { final URL url = new URL("http: final URLDeserializer<?> deserializer = (URLDeserializer<?>) find(URL.class, URL.class.getName()); assertNull(deserializer); deserializer = (URLDeserializer<?>) find(URL.class, URL.class.getName()); assertTrue(deserializer instanceof URLDeserializer); deserializer = (URLDeserializer<?>) find(URL.class, URL.class.getName()); assertTrue(deserializer instanceof URLDeserializer); deserializer = (URLDeserializer<?>) find(URL.class, Pattern.class.getName()); assertTrue(deserializer instanceof PatternDeserializer); deserializer = (URLDeserializer<?>) find(URL.class, Pattern.class
@Test public void testClassDeserializer() { JsonDeserializer<?> deserializer = JsonDeserializer.find(Class.class, "TestClass"); assertNull(deserializer); deserializer = JsonDeserializer.find(Class.class, "TestClass"); assertTrue(deserializer instanceof ClassDeserializer); deserializer = JsonDeserializer.find(Class.class, "TestClass2"); assertTrue(deserializer instanceof ClassDeserializer); deserializer = JsonDeserializer.find(Class.class, "TestClass3"); assertTrue(deserializer instanceof ClassDeserializer); deserializer = JsonDeserializer.find(Class.class, "TestClass4"); assertTrue(deserializer instanceof ClassDeserializer); deserializer = JsonDeserializer.find(Class.class, "TestClass5
@Test public void testURLDeserializer() throws IOException, URISyntaxException { URLDeserializer deserializer = new URLDeserializer(); URL url1 = new URL("http: URL url2 = new URL("http: URL url3 = new URL("http: URL url4 = new URL("http: assertTrue(deserializer.deserialize(url1, null).equals(url1)); assertTrue(deserializer.deserialize(url2, null).equals(url2)); assertTrue(deserializer.deserialize(url3, null).equals(url3)); assertTrue(deserializer.deserialize(url4, null).equals(url4)); }
@Test public void testURLDeserializer() throws IOException, URISyntaxException { final URL url = new URL("http: assertEquals(url, deserializer._deserialize(url.toString(), null)); assertEquals(url, deserializer._deserialize("http: assertEquals(url, deserializer._deserialize("http: assertEquals(url, deserializer._deserialize("http: assertEquals(url, deserializer._deserialize("http: assertEquals(url, deserializer._deserialize("http: assertEquals(url, deserializer._deserialize("http: assertEquals(url, deserializer._deserialize("http: assertEquals(url, deserializer._deserialize("http: assertEquals(url, deserializer._deserialize("http: assertEquals
@Test public void testURLDeserializer() throws IOException, URISyntaxException { final URL url = new URL("http: assertEquals(url, deserializer._deserialize(url.toString(), null)); assertEquals(url, deserializer._deserialize("http: assertEquals(url, deserializer._deserialize("http: assertEquals(url, deserializer._deserialize("http: assertEquals(url, deserializer._deserialize("http: assertEquals(url, deserializer._deserialize("http: assertEquals(url, deserializer._deserialize("http: assertEquals(url, deserializer._deserialize("http: assertEquals(url, deserializer._deserialize("http: assertEquals(url, deserializer._deserialize("http: assertEquals
@Test public void testCharsetDeserializer() throws IOException, URISyntaxException { CharsetDeserializer deserializer = CharsetDeserializer.find(Charset.class, "UTF-8"); assertEquals(Charset.forName("UTF-8"), deserializer._deserialize(new URL("http: assertEquals(Charset.forName("UTF-8"), deserializer._deserialize(new URL("http: assertEquals(Charset.forName("UTF-8"), deserializer._deserialize(new URL("http: assertEquals(Charset.forName("UTF-8"), deserializer._deserialize(new URL("http: assertEquals(Charset.forName("UTF-8"), deserializer._deserialize(new URL("http: assertEquals
@Test public void testPatternDeserialization() throws IOException, URISyntaxException { Pattern pattern = Pattern.compile("[0-9]+"); assertEquals(pattern, deserializer._deserialize("[0-9]+", null)); assertEquals(pattern, deserializer._deserialize("[0-9]+", null)); assertEquals(Pattern.compile("[0-9]+"), deserializer._deserialize("[0-9]+", null)); assertEquals(Pattern.compile("[0-9]+"), deserializer._deserialize("[0-9]+", null)); assertEquals(Pattern.compile("[0-9]+"), deserializer._deserialize("[0-9]+", null)); assertEquals(Pattern
@Test public void testCharsetDeserializer() throws Exception { Charset charset = Charset.forName("UTF-8"); assertEquals(charset, _deserializer._deserialize("UTF-8", null)); assertEquals(charset, _deserializer._deserialize("UTF-16", null)); assertEquals(charset, _deserializer._deserialize("UTF-16", null)); assertEquals(charset, _deserializer._deserialize("UTF-16", null)); assertEquals(charset, _deserializer._deserialize("UTF-16", null)); assertEquals(charset, _deserializer._deserialize("UTF-16", null)); assertEquals(charset, _deserializer._deserialize("UTF-16", null
@Test public void testCreateContextual() throws JsonMappingException { SerializerProvider provider = new SerializerProvider() { @Override public Class<? extends Annotation> annotationType() { return SerializerProvider.class; } @Override public Config getConfig() { return new MockConfig(); } @Override public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { return new MockSerializer(); } @Override public JsonSerializer<?> withFormat(boolean useTimestamp, boolean customFormat) { return new MockJsonSerializer(); } @Override public JsonSerializer<?> withFormat(boolean useTimestamp, boolean customFormat) throws JsonMappingException { return new MockJsonSerializer(); } @Override public JsonSerializer<?> with
@Test(expected = JsonMappingException.class) public void testCreateContextual() throws JsonMappingException { final SimpleSerializerProvider provider = new SimpleSerializerProvider(); provider.getConfig().setDateFormat(new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'")); provider.getConfig().setDateFormat(new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'")); serializer.withFormat(true, new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'")); serializer.createContextual(provider, null); }
@Test public void testCreateContextual() throws JsonMappingException { SimpleSerializerProvider prov = new SimpleSerializerProvider(); prov.setConfig(new TestConfig()); JsonSerializer<?> f1 = new DateTimeSerializerImpl(SimpleDateFormat.class, false, new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'")).createContextual(prov, null); JsonSerializer<?> f2 = new DateTimeSerializerImpl(SimpleDateFormat.class, false, new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'")).createContextual(prov, null); JsonSerializer<?> f3 = new DateTimeSerializerImpl(Simple
@Test public void testCreateContextual() throws JsonMappingException { SimpleSerializerProvider provider = new SimpleSerializerProvider(); SimpleSerializer testSerializer = new SimpleSerializer(SimpleType.class, false, new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'")); testSerializer.withFormat(true, new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'")); testSerializer.withFormat(true, new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'")); testSerializer.withFormat(true, new SimpleDateFormat("yyyy-MM-dd\'T\'HH
@Test(expected = JsonMappingException.class) public void testCreateContextual() throws JsonMappingException { final SimpleSerializerProvider provider = new SimpleSerializerProvider(); provider.getConfig().setDateFormat(new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'")); provider.getConfig().setDateFormat(new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'")); serializer.withFormat(true, new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'")); serializer.createContextual(provider, null); }
@Test(expected = JsonMappingException.class) public void testCreateContextual() throws JsonMappingException { SerializerProvider provider = new MockSerializerProvider(); DateTimeSerializer testee = new DateTimeSerializerImpl(DateTime.class, false, new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'")); testee.withFormat(true, new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'")); testee.withFormat(true, new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'")); testee.createContextual(provider, null); }
@Test public void testCreateContextual() throws JsonMappingException { SerializerProvider provider = mock(SerializerProvider.class); BeanProperty property = mock(BeanProperty.class); when(provider.getAnnotationIntrospector()).thenReturn(mock(SerializerIntrospector.class)); when(provider.getConfig()).thenReturn(mock(SerializerConfig.class)); when(property.getMember()).thenReturn(null); JsonSerializer<?> serializer = new DateTimeSerializerImpl(DateTimeSerializer.class, false, null).createContextual(provider, property); assertTrue(serializer instanceof DateTimeSerializerImpl); when(provider.getAnnotationIntrospector()).thenReturn(mock(SerializerProvider.class));
@Test public void testCreateContextual() throws JsonMappingException { SimpleSerializerProvider provider = new SimpleSerializerProvider(); BeanProperty property = mock(BeanProperty.class); when(property.getMember()).thenReturn(mock(Object.class)); when(property.getAnnotationIntrospector()).thenReturn(mock(AnnotationIntrospector.class)); when(provider.getConfig()).thenReturn(mock(SerializerConfig.class)); when(provider.getAnnotationIntrospector()).thenReturn(mock(AnnotationIntrospector.class)); when(provider.getLocale()).thenReturn(Locale.US); JsonSerializer<?> serializer = new DateTimeSerializerImpl(DateTime.class, false,
@Test public void testCreateContextual() throws JsonMappingException { SimpleSerializerProvider provider = new SimpleSerializerProvider(); BeanProperty property = mock(BeanProperty.class); when(property.getMember()).thenReturn(mock(Object.class)); when(provider.getAnnotationIntrospector()).thenReturn(mock(SerializerProvider.class)); when(provider.getConfig()).thenReturn(mock(SerializerConfig.class)); DateTimeSerializer testee = new DateTimeSerializerImpl(DateTime.class, false, new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'")); JsonSerializer<?> serializer = testee.createContextual(provider, property);
@Test public void testCreateContextual() throws JsonMappingException { SimpleSerializerProvider provider = new SimpleSerializerProvider(); BeanProperty property = mock(BeanProperty.class); when(property.getMember()).thenReturn(mock(Object.class)); when(provider.getAnnotationIntrospector()).thenReturn(mock(AnnotationIntrospector.class)); when(provider.getLocale()).thenReturn(Locale.US); JsonSerializer<?> serializer = new DateTimeSerializerImpl(DateTime.class, false, new SimpleDateFormat("yyyy-MM-dd")).createContextual(provider, property); serializer.acceptJsonFormatVisitor(null); serializer.acceptJsonFormatVisitor(null); serializer.acceptJsonFormat
@Test public void testCreateContextual() throws JsonMappingException { SimpleSerializerProvider provider = new SimpleSerializerProvider(); BeanProperty property = mock(BeanProperty.class); when(property.getMember()).thenAnswer(new Answer<Object>() { @Override public Object answer(InvocationOnMock invocation) throws Throwable { AnnotationIntrospector introspector = (AnnotationIntrospector) invocation.getArguments()[0]; introspector.findFormat((Annotated) invocation.getArguments()[1]); return null; } }); SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); df.setTimeZone(TimeZone.getTimeZone("UTC
@Test public void testCreateContextual() throws JsonMappingException { SerializerProvider provider = new SerializerProvider() { @Override public Class<? extends Annotation> annotationType() { return DateTimeSerializer.class; } @Override public Config getConfig() { return new MockConfig(); } @Override public boolean useTimestamp() { return true; } @Override public boolean useISO8601Format() { return true; } @Override public DateTimeSerializerBase<DateTime> withFormat(boolean useTimestamp, DateTimeFormatter df) { return new DateTimeSerializerBase<DateTime>() { @Override public DateTime withFormat(boolean useTimestamp, DateTimeFormatter df) { return new DateTimeSerializerBase<DateTime>() { @Override public boolean useTimestamp(DateTime value) {
@Test public void testCreateContextual() throws JsonMappingException { SerializerProvider provider = new SerializerProvider() { @Override public Class<? extends Annotation> annotationType() { return SerializerProvider.class; } @Override public Config getConfig() { return new MockConfig(); } @Override public boolean useTimestamp() { return true; } @Override public boolean useISO8601Format() { return true; } @Override public JsonSerializer<?> withContextual(boolean useTimestamp, JsonSerializer<?> serializer, BeanProperty property) throws JsonMappingException { return true; } @Override public JsonSerializer<?> withContextual(boolean useTimestamp, JsonSerializer<?> serializer, BeanProperty property) throws JsonMappingException { return null; }
@Test public void testCreateContextual() throws JsonMappingException { final SimpleSerializerProvider provider = new SimpleSerializerProvider(); final JsonSerializer<?> serializer = new DateTimeSerializerImpl(SimpleTestData.class, false, new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'")).withFormat(true, new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'")); serializer.acceptJsonFormatVisitor(new JsonSerializerImpl(SimpleTestData.class)); serializer.acceptJsonFormatVisitor(new JsonSerializerImpl(SimpleTestData.class)); serializer.acceptJsonFormatVisitor(new JsonSerializerImpl(SimpleTest
@Test public void testCreateContextual() throws JsonMappingException { SimpleSerializerProvider provider = new SimpleSerializerProvider(); SimpleSerializer testSerializer = new SimpleSerializer(Simple.class, false, new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'")); testSerializer.acceptJsonFormatVisitor(JsonSerializer.class); testSerializer.acceptJsonFormatVisitor(JsonSerializer.class); testSerializer.acceptJsonFormatVisitor(JsonSerializer.class); testSerializer.acceptJsonFormatVisitor(JsonSerializer.class); testSerializer.acceptJsonFormatVisitor(JsonSerializer.class); testSerializer.acceptJsonFormatVisitor(JsonSerializer.class); testSerializer.acceptJsonFormatVisitor
@Test public void testGetAnnotation() { BeanPropertyDefinition def = mock(BeanPropertyDefinition.class); Annotations Annotations = mock(Annotations.class); when(def.getAnnotations()).thenReturn(annotations); FieldProperty prop = new FieldProperty(def, mock(JavaType.class), mock(TypeDeserializer.class), mock(Annotations.class), mock(AnnotatedField.class)); Annotation annotation = prop.getAnnotation(SimpleAnnotation.class); assertEquals(SimpleAnnotation.class, annotation.getClass()); }
@Test public void testGetAnnotation() { BeanPropertyDefinition def = mock(BeanPropertyDefinition.class); Annotations Annotations = mock(Annotations.class); when(def.getAnnotations()).thenReturn(annotations); FieldProperty prop = new FieldProperty(def, mock(JavaType.class), mock(TypeDeserializer.class), mock(Annotations.class), mock(AnnotatedField.class)); A a = prop.getAnnotation(A.class); assertNotNull(a); }
@Test(expected=JsonMappingException.class) public void testUnwrappedProperty() throws JsonMappingException { final String json = "{\\n" + " \\"type\\": \\"object\\",\\n" + " \\"properties\\": [\\n" + " {\\n" + " \\"type\\": \\"object\\",\\n" + " \\"properties\\": [\\n" + " {\\n" + " \\"type\\": \\"object\\",\\n" + " \\"properties\\": [\\n" + " {\\n" + " \\"type\\": \\"object\\",\\n" + " \\"properties\\
@Test(expected=JsonMappingException.class) public void testUnwrappedPropertyHandler() throws JsonMappingException { final String json = "{\\n" + " \\"type\\": \\"object\\",\\n" + " \\"properties\\": [\\n" + " {\\n" + " \\"type\\": \\"object\\",\\n" + " \\"properties\\": [\\n" + " {\\n" + " \\"type\\": \\"object\\",\\n" + " \\"properties\\": [\\n" + " {\\n" + " \\"type\\": \\"object\\",\\n" + " \\"properties
@Test(expected = JsonMappingException.class) public void testUnwrappedProperty() throws JsonMappingException { final String json = "{\\n" + " \\"type\\": \\"object\\",\\n" + " \\"properties\\": [\\n" + " {\\n" + " \\"type\\": \\"object\\",\\n" + " \\"properties\\": [\\n" + " {\\n" + " \\"type\\": \\"object\\",\\n" + " \\"properties\\": [\\n" + " {\\n" + " \\"type\\": \\"string\\",\\n" + " \\"value\\
@Test public void test_resolveManagedReferenceProperty() { SimpleDeserializationContext ctxt = new SimpleDeserializationContext(); SettableBeanProperty b1 = new SimpleSettableBeanProperty(); b1.setManagedReferenceName("b1"); SettableBeanProperty b2 = new SimpleSettableBeanProperty(); b2.setManagedReferenceName("b2"); SettableBeanProperty b3 = new SimpleSettableBeanProperty(); b3.setManagedReferenceName("b3"); SettableBeanProperty b4 = new SimpleSettableBeanProperty(); b4.setManagedReferenceName("b4"); SettableBeanProperty b5 = new SimpleSettableBeanProperty(); b5.setManagedReferenceName("b5
@Test public void test_resolveManagedReferenceProperty() { SimpleDeserializer<String> d1 = new SimpleDeserializer<String>() { @Override public String decode(String str) { return str; } }; SimpleDeserializer<String> d2 = new SimpleDeserializer<String>() { @Override public String decode(String str) { return str; } }; SimpleDeserializer<String> d3 = new SimpleDeserializer<String>() { @Override public String decode(String str) { return str; } }; SimpleDeserializer<String> d4 = new SimpleDeserializer<String>() { @Override public String decode(String str) { return str; } }; SimpleDeserializer<String> d5 =
@Test public void test_resolveManagedReferenceProperty() { SimpleDeserializationContext ctxt = new SimpleDeserializationContext(); SettableBeanProperty b1 = new SimpleSettableBeanProperty(); b1.setManagedReferenceName("b1"); SettableBeanProperty b2 = new SimpleSettableBeanProperty(); b2.setManagedReferenceName("b2"); SettableBeanProperty b3 = new SimpleSettableBeanProperty(); b3.setManagedReferenceName("b3"); SettableBeanProperty b4 = new SimpleSettableBeanProperty(); b4.setManagedReferenceName("b4"); SettableBeanProperty b5 = new SimpleSettableBeanProperty(); b5.setManagedReferenceName("b5
@Test public void test_simpleDeserializer() { SimpleDeserializer simple = new SimpleDeserializer(); SimpleDeserializer simple2 = new SimpleDeserializer(); SimpleDeserializer simple3 = new SimpleDeserializer(); SimpleDeserializer simple4 = new SimpleDeserializer(); SimpleDeserializer simple5 = new SimpleDeserializer(); SimpleDeserializer simple6 = new SimpleDeserializer(); simple.setValueDeserializer(simple); simple2.setValueDeserializer(simple3); simple3.setValueDeserializer(simple4); simple4.setValueDeserializer(simple5); simple5.setValueDeserializer(simple6); SimpleDeserializer simple7 = new SimpleDeserializer(); simple7.setValueDeserializer(simple); simple7.setValueDeserializer(simple4); simple7.setValueDeserializer(simple5
@Test public void test_resolveManagedReferenceProperty() { SimpleDeserializationContext ctxt = new SimpleDeserializationContext(); SettableBeanProperty b1 = new SimpleSettableBeanProperty(); b1.setManagedReferenceName("b1"); SettableBeanProperty b2 = new SimpleSettableBeanProperty(); b2.setManagedReferenceName("b2"); SettableBeanProperty b3 = new SimpleSettableBeanProperty(); b3.setManagedReferenceName("b3"); SettableBeanProperty b4 = new SimpleSettableBeanProperty(); b4.setManagedReferenceName("b4"); SettableBeanProperty b5 = new SimpleSettableBeanProperty(); b5.setManagedReferenceName("b5
@Test public void test_resolveInnerClassValuedProperty() { SimpleDeserializationContext ctxt = new SimpleDeserializationContext(); BeanDeserializerBuilder builder = new BeanDeserializerBuilder(); BeanDescription desc = new BeanDescription(); Map<String, SettableBeanProperty> properties = new HashMap<String, SettableBeanProperty>(); properties.put("id", new BeanPropertyMap()); properties.put("firstName", new BeanPropertyMap()); properties.put("lastName", new BeanPropertyMap()); SettableBeanProperty property = new SettableBeanProperty(SimpleBean.class, "id", "firstName", properties); SimpleBean bean = new SimpleBean(); bean.setFirstName("firstName"); bean.setLastName
@Test public void test_resolveInnerClassValuedProperty() { SimpleDeserializationContext ctxt = new SimpleDeserializationContext(); BeanDeserializerBuilder builder = new BeanDeserializerBuilder(); BeanDescription desc = new BeanDescription(); Map<String, SettableBeanProperty> properties = new HashMap<String, SettableBeanProperty>(); properties.put("id", new BeanPropertyMap()); properties.put("firstName", new BeanPropertyMap()); properties.put("lastName", new BeanPropertyMap()); SimpleBeanType beanType = new SimpleBeanType(); beanType.setRawClass(String.class); SettableBeanProperty property = new SimpleBeanProperty(beanType, "firstName", "lastName"); SettableBeanProperty
@Test public void test_resolveInnerClassValuedProperty() { SimpleBeanType beanType = new SimpleBeanType(); BeanDeserializerBuilder builder = new BeanDeserializerBuilder(); BeanDescription description = new BeanDescription(); description.setBeanType(beanType); Map<String, SettableBeanProperty> properties = new HashMap<String, SettableBeanProperty>(); properties.put("field1", new BeanPropertyMap()); properties.put("field2", new BeanPropertyMap()); properties.put("field3", new BeanPropertyMap()); properties.put("field4", new BeanPropertyMap()); SimpleDeserializationContext ctxt = new SimpleDeserializationContext(); ctxt.setConfig(new SimpleDeserializationConfig()); SettableBeanProperty
@Test public void test_resolveInnerClassValuedProperty() { BeanDeserializerBuilder builder = new BeanDeserializerBuilder(); BeanDescription desc = new BeanDescription(); BeanPropertyMap properties = new BeanPropertyMap(); properties.addProperty("id", Integer.class); properties.addProperty("name", String.class); properties.addProperty("age", Integer.class); SettableBeanProperty property = new SettableBeanProperty(BeanType.INTEGER, "id", "name"); SettableBeanProperty result = new BeanDeserializerBase(builder, desc, properties, new HashMap<String, SettableBeanProperty>(), true, false).resolveInnerClassValuedProperty(new DeserializationContext(), property); Assert.assertEquals(
@Test public void test_resolveInnerClassValuedProperty() { DeserializerBuilder builder = new DeserializerBuilder(); BeanDescription desc = new BeanDescription(); PropertyMap propertyMap = new PropertyMap(); propertyMap.addProperty("id", String.class); propertyMap.addProperty("name", String.class); SettableBeanProperty property = new SettableBeanProperty(desc, propertyMap); SimpleDeserializationContext ctxt = new SimpleDeserializationContext(); ctxt.getConfig().setCanOverrideAccessModifiers(true); BeanDeserializerBase beanDeserializer = new BeanDeserializerBase(builder, desc, propertyMap, new HashMap<String, SettableBeanProperty>(), true, true); SettableBeanProperty result = beanDeserializer.
@Test public void test_resolveInnerClassValuedProperty() { BeanDeserializerBuilder builder = new BeanDeserializerBuilder(); BeanDescription desc = new BeanDescription(); Map<String, SettableBeanProperty> properties = new HashMap<String, SettableBeanProperty>(); properties.put("id", new BeanPropertyMap()); properties.put("firstName", new BeanPropertyMap()); properties.put("lastName", new BeanPropertyMap()); SimpleDeserializationContext ctxt = new SimpleDeserializationContext(); ctxt.setConfig(new SimpleDeserializationConfig()); SettableBeanProperty property = new SimpleBeanProperty(SimpleBean.class, "id", "firstName"); SettableBeanProperty result = _resolver.resolveInnerClassValuedProperty
@Test public void test_resolveInnerClassValuedProperty() { SimpleDeserializationContext ctxt = new SimpleDeserializationContext(); BeanDeserializerBuilder builder = new BeanDeserializerBuilder(); BeanDescription desc = new BeanDescription(); Map<String, SettableBeanProperty> properties = new HashMap<String, SettableBeanProperty>(); properties.put("id", new BeanPropertyMap()); properties.put("firstName", new BeanPropertyMap()); properties.put("lastName", new BeanPropertyMap()); properties.put("id", new BeanPropertyMap()); SimpleBeanType type = new SimpleBeanType(); type.setRawClass(Integer.class); SettableBeanProperty property = new SimpleBeanProperty(type, "id", "
@Test public void test_resolveInnerClassValuedProperty() { DeserializerBuilder builder = new DeserializerBuilder(); BeanDescription desc = new BeanDescription(); Map<String, SettableBeanProperty> properties = new HashMap<String, SettableBeanProperty>(); properties.put("id", new BeanPropertyMap()); properties.put("name", new BeanPropertyMap()); SimpleDeserializationContext ctxt = new SimpleDeserializationContext(); ctxt.setConfig(new SimpleDeserializationConfig()); SettableBeanProperty property = new SimpleSettableBeanProperty(); property.setValueDeserializer(new JsonDeserializerBase() { @Override public JsonDeserializer<Object> getValueDeserializer() { return new JsonDeserializer<Object>() { @Override public boolean
@Test public void testInnerClassProperty() { SimpleBeanType beanType = new SimpleBeanType(); BeanDeserializerBuilder builder = new BeanDeserializerBuilder(); builder.setBeanType(beanType); Map<String, SettableBeanProperty> properties = new LinkedHashMap<String, SettableBeanProperty>(); properties.put("id", new BeanPropertyMap()); properties.put("name", new BeanPropertyMap()); properties.put("age", new BeanPropertyMap()); SimpleDeserializationContext ctxt = new SimpleDeserializationContext(); ctxt.setConfig(new SimpleDeserializationConfig()); SettableBeanProperty property = new SimpleBeanProperty("id", String.class, properties); SettableBeanProperty result = _resolveInnerClassValued
@Test public void testKnownPropertyNames() throws JsonMappingException { SettableBeanProperty property1 = new SettableBeanProperty(); property1.setName("a"); SettableBeanProperty property2 = new SettableBeanProperty(); property2.setName("b"); SettableBeanProperty property3 = new SettableBeanProperty(); property3.setName("c"); SettableBeanProperty property4 = new SettableBeanProperty(); property4.setName("d"); SettableBeanProperty property5 = new SettableBeanProperty(); property5.setName("e"); SettableBeanProperty property6 = new SettableBeanProperty(); property6.setName("f"); SettableBeanProperty property7 = new Set
@Test public void testPropertyBasedDeserializer() throws JsonMappingException, IOException { String json = "{\\n" + " \\"type\\": \\"string\\",\\n" + " \\"properties\\": [\\n" + " {\\n" + " \\"name\\": \\"string\\",\\n" + " \\"type\\": \\"string\\"\\n" + " },\\n" + " {\\n" + " \\"name\\": \\"string\\",\\n" + " \\"type\\": \\"string\\"\\n" + " },\\n" + " {\\n" + " \\"name\\": \\"string\\
@Test(expected = JsonProcessingException.class) public void testMalformedJson() throws JsonProcessingException, IOException { JsonParser jp = Mockito.mock(JsonParser.class); DeserializationContext ctxt = Mockito.mock(DeserializationContext.class); Mockito.when(jp.getNumberType()).thenReturn(JsonNumberType.INT); Mockito.when(jp.getIntValue()).thenReturn(123L); new BeanDeserializerBase(null, null, null, null).deserializeFromNumber(jp, ctxt); }
@Test public void construct() { ViewMatcher m = ViewMatcher.construct(new Class<?>[]{TestView.class}); Assert.assertNotNull(m); Assert.assertTrue(m instanceof Multi); Assert.assertTrue(m.isVisibleForView(TestView.class)); m = ViewMatcher.construct(new Class<?>[]{TestView.class}); Assert.assertNotNull(m); Assert.assertTrue(m instanceof Multi); Assert.assertTrue(m.isVisibleForView(TestView.class)); m = ViewMatcher.construct(new Class<?>[]{TestView.class}); Assert.assertNotNull(m); Assert.assertTrue(m instanceof Multi); Assert.assertTrue(m
@Test public void construct() { ViewMatcher matcher = ViewMatcher.construct(new Class<?>[]{A.class, B.class}); Assert.assertTrue(matcher.isVisibleForView(A.class)); Assert.assertTrue(matcher.isVisibleForView(B.class)); matcher = ViewMatcher.construct(new Class<?>[]{A.class, B.class}); Assert.assertTrue(matcher.isVisibleForView(A.class)); Assert.assertTrue(matcher.isVisibleForView(B.class)); matcher = ViewMatcher.construct(new Class<?>[]{A.class, B.class}); Assert.assertTrue(matcher.isVisibleForView(A.class
@Test public void construct() { ViewMatcher matcher = ViewMatcher.construct(new Class<?>[]{A.class, B.class}); Assert.assertTrue(matcher.isVisibleForView(A.class)); Assert.assertTrue(matcher.isVisibleForView(B.class)); matcher = ViewMatcher.construct(new Class<?>[]{A.class, B.class}); Assert.assertTrue(matcher.isVisibleForView(A.class)); Assert.assertTrue(matcher.isVisibleForView(B.class)); matcher = ViewMatcher.construct(new Class<?>[]{A.class, B.class}); Assert.assertTrue(matcher.isVisibleForView(A.class
@Test public void construct() { ViewMatcher matcher = construct(new Class<?>[]{TestView.class}); Assert.assertTrue(matcher.isVisibleForView(TestView.class)); Assert.assertTrue(matcher.isVisibleForView(TestView2.class)); Assert.assertTrue(matcher.isVisibleForView(TestView3.class)); Assert.assertTrue(matcher.isVisibleForView(TestView4.class)); Assert.assertTrue(matcher.isVisibleForView(TestView5.class)); Assert.assertTrue(matcher.isVisibleForView(TestView6.class)); Assert.assertTrue(matcher.isVisibleForView(TestView7.class));
@Test public void construct() { ViewMatcher matcher = ViewMatcher.construct(new Class<?>[]{A.class, B.class}); Assert.assertTrue(matcher.isVisibleForView(A.class)); Assert.assertTrue(matcher.isVisibleForView(B.class)); matcher = ViewMatcher.construct(new Class<?>[]{A.class, B.class}); Assert.assertTrue(matcher.isVisibleForView(A.class)); Assert.assertTrue(matcher.isVisibleForView(B.class)); matcher = ViewMatcher.construct(new Class<?>[]{A.class, B.class}); Assert.assertTrue(matcher.isVisibleForView(A.class
@Test public void construct() { ViewMatcher matcher = ViewMatcher.construct(new Class<?>[]{A.class, B.class}); Assert.assertTrue(matcher.isVisibleForView(A.class)); Assert.assertTrue(matcher.isVisibleForView(B.class)); matcher = ViewMatcher.construct(new Class<?>[]{A.class, B.class}); Assert.assertTrue(matcher.isVisibleForView(A.class)); Assert.assertTrue(matcher.isVisibleForView(B.class)); matcher = ViewMatcher.construct(new Class<?>[]{A.class, B.class}); Assert.assertTrue(matcher.isVisibleForView(A.class
@Test public void construct() { ViewMatcher matcher = ViewMatcher.construct(new Class<?>[]{TestView.class}); Assert.assertTrue(matcher.isVisibleForView(TestView.class)); Assert.assertTrue(matcher.isVisibleForView(TestView2.class)); Assert.assertTrue(matcher.isVisibleForView(TestView3.class)); Assert.assertTrue(matcher.isVisibleForView(TestView4.class)); Assert.assertTrue(matcher.isVisibleForView(TestView5.class)); Assert.assertTrue(matcher.isVisibleForView(TestView6.class)); Assert.assertTrue(matcher.isVisibleForView(TestView7
@Test public void testIsVisibleForView() { Assert.assertTrue(new Single(new Class<?>[]{String.class}).isVisibleForView(null)); Assert.assertFalse(new Multi(new Class<?>[]{String.class, String.class}).isVisibleForView(null)); Assert.assertFalse(new Multi(new Class<?>[]{String.class, String.class}).isVisibleForView(null)); Assert.assertFalse(new Multi(new Class<?>[]{String.class, String.class}).isVisibleForView(null)); Assert.assertFalse(new Multi(new Class<?>[]{String.class, String.class}).isVisibleFor
@Test public void isVisibleForView() { Assert.assertFalse(new Single(new Class<?>[0]) { @Override public boolean isVisibleForView(Class<?> activeView) { return false; } }.isVisibleForView(TestView.class)); Assert.assertFalse(new Multi(new Class<?>[0]) { @Override public boolean isVisibleForView(Class<?> activeView) { return false; } }.isVisibleForView(TestView.class)); Assert.assertFalse(new Multi(new Class<?>[0]) { @Override public boolean isVisibleForView(Class<?> activeView) { return false; } }.isVisibleForView(TestView.class)); }
@Test public void testSingle() { ViewMatcher matcher = construct(new Class<?>[]{String.class, String.class}); Assert.assertTrue(matcher.isVisibleForView(String.class)); Assert.assertTrue(matcher.isVisibleForView(String.class)); Assert.assertFalse(matcher.isVisibleForView(String.class)); matcher = construct(new Class<?>[]{String.class, String.class}); Assert.assertTrue(matcher.isVisibleForView(String.class)); Assert.assertFalse(matcher.isVisibleForView(String.class)); matcher = construct(new Class<?>[]{String.class, String.class}); Assert.assertTrue(matcher.
@Test public void testIsVisibleForView() { Assert.assertTrue(new Multi(new Class<?>[0]).isVisibleForView(ActiveView.class)); Assert.assertTrue(new Multi(new Class<?>[0]).isVisibleForView(ActiveView.class)); Assert.assertTrue(new Multi(new Class<?>[0]).isVisibleForView(ActiveView.class)); Assert.assertFalse(new Multi(new Class<?>[0]).isVisibleForView(ActiveView.class)); Assert.assertFalse(new Multi(new Class<?>[0]).isVisibleForView(ActiveView.class)); Assert.assertFalse(new Multi(new Class<?>[
@Test public void testVisibleForView() { Assert.assertTrue(new Single(ViewMatcherTest.class).isVisibleForView(ViewMatcherTest.class)); Assert.assertTrue(new Multi(ViewMatcherTest.class).isVisibleForView(ViewMatcherTest.class)); Assert.assertTrue(new Single(ViewMatcherTest.class).isVisibleForView(ViewMatcherTest.class)); Assert.assertFalse(new Multi(ViewMatcherTest.class).isVisibleForView(ViewMatcherTest.class)); Assert.assertFalse(new Multi(ViewMatcherTest.class).isVisibleForView(ViewMatcherTest.class)); Assert.assertFalse(new Multi(ViewMatcherTest.class
@Test public void testJsonDeserializer() throws IOException, JsonMappingException, JsonProcessingException { ObjectMapper mapper = new ObjectMapper(); JsonNodeFactory nodeFactory = new JsonNodeFactory(mapper); JsonNode node = nodeFactory.createObjectNode(); node.put("field1", "value1"); node.put("field2", "value2"); node.put("field3", "value3"); node.put("field4", "value4"); JsonNode expectedNode = nodeFactory.createObjectNode(); expectedNode.put("field1", "value1"); expectedNode.put("field2", "value2"); expectedNode.put("field3", "value3"); expectedNode.put("field4", "value4");
@Test public void test() throws Exception { String json = "{\\n" + " \\"type\\": \\"object\\",\\n" + " \\"properties\\": [\\n" + " {\\n" + " \\"name\\": \\"test\\",\\n" + " \\"type\\": \\"string\\"\\n" + " },\\n" + " {\\n" + " \\"name\\": \\"test2\\",\\n" + " \\"type\\": \\"boolean\\"\\n" + " },\\n" + " {\\n" + " \\"name\\": \\"test3\\",\\n" +
@Test public void test() throws Exception { String json = "{\\n" + " \\"children\\": [\\n" + " {\\n" + " \\"id\\": 1,\\n" + " \\"name\\": \\"test\\",\\n" + " \\"children\\": [\\n" + " {\\n" + " \\"id\\": 2,\\n" + " \\"name\\": \\"test\\",\\n" + " \\"children\\": [\\n" + " {\\n" + " \\"id\\": 3,\\n" + " \\"name\\": \\"test\\",\\n"
@Test public void test() throws Exception { String json = "{\\n" + " \\"field1\\": \\"value1\\",\\n" + " \\"field2\\": \\"value2\\",\\n" + " \\"field3\\": [\\n" + " {\\n" + " \\"field1\\": \\"value1\\",\\n" + " \\"field2\\": \\"value2\\",\\n" + " \\"field3\\": [\\n" + " {\\n" + " \\"field1\\": \\"value1\\",\\n" + " \\"field2\\": \\"value
@Test public void test() throws Exception { String json = "{\\n" + " \\"children\\": [\\n" + " {\\n" + " \\"id\\": 1,\\n" + " \\"name\\": \\"test\\",\\n" + " \\"children\\": [\\n" + " {\\n" + " \\"id\\": 2,\\n" + " \\"name\\": \\"test\\",\\n" + " \\"children\\": [\\n" + " {\\n" + " \\"id\\": 3,\\n" + " \\"name\\": \\"test\\",\\n"
@Test public void test() throws Exception { String json = "{\\n" + " \\"children\\": [\\n" + " {\\n" + " \\"id\\": 1,\\n" + " \\"name\\": \\"test\\",\\n" + " \\"children\\": [\\n" + " {\\n" + " \\"id\\": 2,\\n" + " \\"name\\": \\"test\\",\\n" + " \\"children\\": [\\n" + " {\\n" + " \\"id\\": 3,\\n" + " \\"name\\": \\"test\\",\\n"
@Test public void test() throws IOException, JsonMappingException, JsonProcessingException { ObjectMapper mapper = new ObjectMapper(); JsonParser jp = mock(JsonParser.class); when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); ObjectNode node = mock(ObjectNode.class); when(node.isArray()).thenReturn(true); when(node.get("field1").asText()).thenReturn("value1"); when(node.get("field2").asText()).thenReturn("value2"); when(node.get("field3").asText()).thenReturn("value3"); when(node.get("field4").asText()).thenReturn
@Test public void test() throws IOException, JsonMappingException, JsonProcessingException { ObjectMapper mapper = new ObjectMapper(); JsonParser jp = mock(JsonParser.class); when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); ObjectNode node = mock(ObjectNode.class); when(node.get("field1").asText()).thenReturn("value1"); when(node.get("field2").asText()).thenReturn("value2"); when(jp.nextToken()).thenReturn(JsonToken.START_ARRAY); when(jp.read("value1")).thenReturn(node); when(jp.nextToken()).thenReturn(JsonToken.
@Test public void test() throws IOException, JsonMappingException, JsonProcessingException { ObjectMapper mapper = new ObjectMapper(); JsonParser jp = mapper.createParser("\\"test\\""); jp.nextToken(); JsonNode resultNode = mapper.readTree("\\"test\\""); assertEquals("test", resultNode.get("test").asText()); jp.nextToken(); resultNode = mapper.readTree("\\"test\\""); assertEquals("test", resultNode.get("test").asText()); jp.nextToken(); resultNode = mapper.readTree("\\"test\\""); assertEquals("test", resultNode.get("test").asText()); jp.nextToken(); resultNode = mapper.readTree
@Test public void test() throws IOException, JsonMappingException, JsonProcessingException { ObjectMapper mapper = new ObjectMapper(); JsonNodeFactory nodeFactory = new JsonNodeFactoryImpl(); JsonNode node1 = mapper.readTree("\\"test\\""); JsonNode node2 = mapper.readTree("\\"test1\\""); JsonNode node3 = mapper.readTree("\\"test2\\""); JsonNode node4 = mapper.readTree("\\"test3\\""); JsonNode node5 = mapper.readTree("\\"test4\\""); JsonNode node6 = mapper.readTree("\\"test5\\""); JsonNode node7 = mapper.readTree("\\"test6\\""); JsonNode node8 = mapper.readTree("\\"test7
@Test public void test() throws IOException, JsonMappingException, JsonProcessingException { ObjectMapper mapper = new ObjectMapper(); JsonParser jp = mock(JsonParser.class); when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); ObjectNode node = mock(ObjectNode.class); when(node.get("field1").asText()).thenReturn("value1"); when(node.get("field2").asText()).thenReturn("value2"); when(node.get("field3").asText()).thenReturn("value3"); when(node.get("field4").asText()).thenReturn("value4"); when(node.get("field5").
@Test public void test() throws IOException, JsonMappingException, JsonProcessingException { ObjectMapper mapper = new ObjectMapper(); JsonParser jp = mock(JsonParser.class); when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); ObjectNode node = mock(ObjectNode.class); when(node.get("field1").asText()).thenReturn("value1"); when(node.get("field2").asText()).thenReturn("value2"); when(node.get("field3").asText()).thenReturn("value3"); when(node.get("field4").asText()).thenReturn("value4"); when(node.get("field5").
@Test public void test() throws IOException, JsonMappingException, JsonProcessingException { ObjectMapper mapper = new ObjectMapper(); JsonParser jp = mock(JsonParser.class); when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); ObjectNode node = mock(ObjectNode.class); when(node.get("field1").asText()).thenReturn("value1"); when(node.get("field2").asText()).thenReturn("value2"); when(node.get("field3").asText()).thenReturn("value3"); when(node.get("field4").asText()).thenReturn("value4"); when(node.get("field5").
@Test public void test() throws IOException, JsonMappingException, JsonProcessingException { ObjectMapper mapper = new ObjectMapper(); JsonParser jp = mock(JsonParser.class); when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); ObjectNode node = mock(ObjectNode.class); when(node.get("field1").asText()).thenReturn("value1"); when(node.get("field2").asText()).thenReturn("value2"); when(jp.readObject("value1")).thenReturn(node); when(jp.readObject("value2")).thenReturn(node); when(node.get("field3").asText()).thenReturn
@Test public void testObjectDeserializer() throws Exception { String json = "{\\n" + " \\"type\\": \\"object\\",\\n" + " \\"properties\\": {\\n" + " \\"prop1\\": \\"value1\\",\\n" + " \\"prop2\\": \\"value2\\",\\n" + " \\"prop3\\": \\"value3\\"\\n" + " },\\n" + " \\"properties\\": {\\n" + " \\"prop1\\": \\"value1\\",\\n" + " \\"prop2\\": \\"value2\\",\\n" + " \\
@Test public void testGetInstance() throws Exception { ObjectDeserializer d1 = ObjectDeserializer.getInstance(); Assert.assertNotNull(d1); ObjectDeserializer d2 = ObjectDeserializer.getInstance(); Assert.assertSame(d1, d2); }
@Test public void test() throws IOException, JsonMappingException, JsonProcessingException { ObjectMapper mapper = new ObjectMapper(); JsonParser jp = mock(JsonParser.class); when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); ObjectNode node = mock(ObjectNode.class); when(node.get("test").asText()).thenReturn("test"); when(node.get("test2").asText()).thenReturn("test2"); when(node.get("test3").asText()).thenReturn("test3"); when(node.get("test4").asText()
@Test public void test() throws IOException, JsonMappingException, JsonProcessingException { ObjectMapper mapper = new ObjectMapper(); JsonNodeFactory nodeFactory = new JsonNodeFactory(mapper); JsonNode jsonNode = mapper.readTree("\\"test\\""); JsonParser jp = jp.nextToken(); jp.nextToken(); ObjectNode deserializedNode = mock(ObjectNode.class); when(jsonNode.get("test").asText()).thenReturn("test"); when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); when(jsonNode.get("test").asText()).thenReturn("test1"); when(jsonNode.get("test").asText()).thenReturn("test2"); when
@Test public void test() throws IOException, JsonMappingException, JsonProcessingException { ObjectMapper mapper = new ObjectMapper(); JsonParser jp = mock(JsonParser.class); when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); when(jp.nextToken()).thenReturn(JsonToken.VALUE_STRING); ObjectNode node = mock(ObjectNode.class); when(node.get("test").asText()).thenReturn("test"); when(node.get("test1").asText()).thenReturn("test1"); when(node.get("test2").asText()).thenReturn("test2"); when(node.get("test3").asText()
@Test public void test() throws IOException, JsonMappingException, JsonProcessingException { ObjectMapper mapper = new ObjectMapper(); JsonNodeFactory nodeFactory = mapper.createObjectNodeFactory(); JsonNode node = nodeFactory.createObjectNode(); node.put("test", "test"); node.put("test2", "test2"); node.put("test3", "test3"); JsonNode expected = nodeFactory.createObjectNode(); expected.put("test", "test"); expected.put("test2", "test2"); expected.put("test3", "test3"); String json = mapper.writeValueAsString(node); String expected2 = mapper.writeValueAsString(expected); String json2 = mapper.writeValueAsString
@Test public void testBaseNodeDeserializer() throws Exception { ObjectMapper mapper = new ObjectMapper(); JsonNode node = mapper.readTree("\\"test\\""); BaseNodeDeserializer deserializer = new BaseNodeDeserializer().getDeserializer(Node.class); Assert.assertEquals(node.get("test").asText(), "test"); node = mapper.readTree("\\"test\\""); deserializer = new BaseNodeDeserializer().getDeserializer(Node.class); Assert.assertEquals(node.get("test").asText(), "test"); node = mapper.readTree("\\"test\\""); Assert.assertEquals(node.get("test").asText(), "test"); deserializer = new BaseNodeDeserializer().getDeserializer(Node
@Test public void testBaseNodeDeserializer() throws IOException, JsonMappingException { ObjectMapper mapper = new ObjectMapper(); JsonNode node = mapper.readTree("\\"test\\""); ObjectNode deserializedNode = new ObjectNode(mapper.writeValueAsString(node)); Assert.assertNotNull(deserializedNode); Assert.assertEquals(node.get("test").asText(), deserializedNode.get("test").asText()); JsonNode node2 = mapper.readTree("\\"test\\""); ObjectNode deserializedNode2 = new ObjectNode(mapper.writeValueAsString(node2)); Assert.assertNotNull(deserializedNode2); Assert.assertEquals(node2.get("test").asText(), deserializedNode2
@Test public void deserializeObject() throws Exception { String json = "{ \\"data\\": { \\"type\\": \\"object\\" } }"; String json2 = "{ \\"data\\": { \\"type\\": \\"object\\" } }"; String json3 = "{ \\"data\\": { \\"type\\": \\"object\\" } }"; String json4 = "{ \\"data\\": { \\"type\\": \\"object\\" } }"; String json5 = "{ \\"data\\": { \\"type\\": \\"object\\" } }"; String json6 = "{ \\"data\\": { \\"type\\": \\"object\\" } }"; String
@Test public void test() throws IOException, JsonProcessingException { String json = "{\\n" + " \\"a\\": [\\n" + " {\\n" + " \\"b\\": [\\n" + " \\"c\\",\\n" + " \\"d\\",\\n" + " \\"e\\",\\n" + " \\"f\\",\\n" + " \\"g\\",\\n" + " \\"h\\",\\n" + " \\"i\\",\\n" + " \\"j\\",\\n" + " \\"k\\",\\n" + " \\"l\\",\\n" +
@Test public void testObject() throws IOException, JsonProcessingException { String json = "{ \\"test\\" : { \\"test1\\" : \\"test2\\" } }"; JsonNodeFactory nodeFactory = new JsonNodeFactory(); JsonNode node = nodeFactory.objectNode(); node.put("test1", "test2"); JsonNode test1 = nodeFactory.objectNode(); test1.put("test2", "test3"); JsonNode test2 = nodeFactory.objectNode(); test2.put("test1", "test4"); JsonNode test3 = nodeFactory.objectNode(); test3.put("test2", "test5"); JsonNode test4 = nodeFactory.objectNode(); test4.put("test
@Test public void testObject() throws Exception { String json = "{ \\"test\\": { \\"test2\\": \\"test3\\" } }"; String json2 = "{ \\"test\\": { \\"test2\\": \\"test3\\" } }"; String json3 = "{ \\"test\\": { \\"test2\\": \\"test3\\" } }"; String json4 = "{ \\"test\\": { \\"test2\\": \\"test4\\" } }"; String json5 = "{ \\"test\\": { \\"test\\": \\"test5\\" } }"; String json6 = "{ \\"test\\": { \\"test2
@Test(expected = JsonMappingException.class) public void test() throws Exception { String json = "{\\n" + " \\"a\\": {\\n" + " \\"b\\": [\\n" + " \\"c\\",\\n" + " \\"d\\",\\n" + " \\"e\\",\\n" + " \\"f\\",\\n" + " \\"g\\",\\n" + " \\"h\\",\\n" + " \\"i\\",\\n" + " \\"j\\",\\n" + " \\"k\\",\\n" + " \\"l\\",\\n" +
@Test public void test() throws IOException, JsonProcessingException { String jsonSample = "{\\n" + " \\"a\\": [\\n" + " {\\n" + " \\"b\\": [\\n" + " \\"c\\",\\n" + " \\"d\\",\\n" + " \\"e\\",\\n" + " \\"f\\",\\n" + " \\"g\\",\\n" + " \\"h\\",\\n" + " \\"i\\",\\n" + " \\"j\\",\\n" + " \\"k\\",\\n" + " \\"l\\",\\n"
@Test public void test() throws IOException, JsonProcessingException { String jsonSample = "{\\n" + " \\"a\\": [\\n" + " {\\n" + " \\"b\\": [\\n" + " \\"c\\",\\n" + " \\"d\\",\\n" + " \\"e\\",\\n" + " \\"f\\",\\n" + " \\"g\\",\\n" + " \\"h\\",\\n" + " \\"i\\",\\n" + " \\"j\\",\\n" + " \\"k\\",\\n" + " \\"l\\",\\n"
@Test(expected = JsonMappingException.class) public void deserializeObject() throws Exception { String json = "{\\n" + " \\"a\\": [\\n" + " {\\n" + " \\"b\\": [\\n" + " \\"c\\",\\n" + " \\"d\\",\\n" + " \\"e\\",\\n" + " \\"f\\",\\n" + " \\"g\\",\\n" + " \\"h\\",\\n" + " \\"i\\",\\n" + " \\"j\\",\\n" + " \\"k\\",\\n" + " \\"
@Test public void test() throws IOException, JsonProcessingException { String json = "{\\n" + " \\"a\\": [\\n" + " {\\n" + " \\"b\\": [\\n" + " \\"c\\",\\n" + " \\"d\\",\\n" + " \\"e\\",\\n" + " \\"f\\",\\n" + " \\"g\\",\\n" + " \\"h\\",\\n" + " \\"i\\",\\n" + " \\"j\\",\\n" + " \\"k\\",\\n" + " \\"l\\",\\n" +
@Test public void testDeserializeObject() throws Exception { String jsonSample = "{\\n" + " \\"a\\": [\\n" + " {\\n" + " \\"b\\": [\\n" + " \\"c\\",\\n" + " \\"d\\",\\n" + " \\"e\\",\\n" + " \\"f\\",\\n" + " \\"g\\",\\n" + " \\"h\\",\\n" + " \\"i\\",\\n" + " \\"j\\",\\n" + " \\"k\\",\\n" + " \\"l\\",\\n" +
@Test public void test() throws IOException, JsonProcessingException { String jsonSample = "{\\n" + " \\"a\\": [\\n" + " {\\n" + " \\"b\\": [\\n" + " \\"c\\",\\n" + " \\"d\\",\\n" + " \\"e\\",\\n" + " \\"f\\",\\n" + " \\"g\\",\\n" + " \\"h\\",\\n" + " \\"i\\",\\n" + " \\"j\\",\\n" + " \\"k\\",\\n" + " \\"l\\",\\n"
@Test(expected = JsonMappingException.class) public void test() throws Exception { String jsonStr = "{\\n" + " \\"a\\": [\\n" + " {\\n" + " \\"b\\": [\\n" + " \\"c\\",\\n" + " \\"d\\",\\n" + " \\"e\\",\\n" + " \\"f\\",\\n" + " \\"g\\",\\n" + " \\"h\\",\\n" + " \\"i\\",\\n" + " \\"j\\",\\n" + " \\"k\\",\\n" + " \\"
@Test(expected = JsonMappingException.class) public void test() throws Exception { String jsonStr = "[\\n" + " {\\n" + " \\"type\\": \\"string\\"\\n" + " },\\n" + " {\\n" + " \\"type\\": \\"string\\"\\n" + " },\\n" + " {\\n" + " \\"type\\": \\"string\\"\\n" + " },\\n" + " {\\n" + " \\"type\\": \\"string\\"\\n" + " },\\n" + " {\\n" + " \\"type\\": \\"string\\"\\
@Test public void deserializeObject() throws Exception { String jsonA = "[\\n" + " {\\n" + " \\"type\\": \\"string\\"\\n" + " },\\n" + " {\\n" + " \\"type\\": \\"string\\"\\n" + " },\\n" + " {\\n" + " \\"type\\": \\"string\\"\\n" + " },\\n" + " {\\n" + " \\"type\\": \\"string\\"\\n" + " },\\n" + " {\\n" + " \\"type\\": \\"string\\"\\n" + " },\\n"
@Test(expected = JsonMappingException.class) public void test() throws Exception { String jsonStr = "{\\n" + " \\"a\\": [\\n" + " {\\n" + " \\"b\\": [\\n" + " \\"c\\",\\n" + " \\"d\\",\\n" + " \\"e\\",\\n" + " \\"f\\",\\n" + " \\"g\\",\\n" + " \\"h\\",\\n" + " \\"i\\",\\n" + " \\"j\\",\\n" + " \\"k\\",\\n" + " \\"
@Test(expected = JsonMappingException.class) public void test() throws Exception { String jsonStr = "{\\n" + " \\"a\\": [\\n" + " {\\n" + " \\"b\\": [\\n" + " \\"c\\",\\n" + " \\"d\\",\\n" + " \\"e\\",\\n" + " \\"f\\",\\n" + " \\"g\\",\\n" + " \\"h\\",\\n" + " \\"i\\",\\n" + " \\"j\\",\\n" + " \\"k\\",\\n" + " \\"
@Test public void deserializeObject() throws Exception { String jsonSample = "{ \\"data\\": { \\"type\\": \\"string\\" } }"; String jsonSample2 = "{ \\"data\\": { \\"type\\": \\"string\\" } }"; String jsonSample3 = "{ \\"data\\": { \\"type\\": \\"string\\" } }"; String jsonSample4 = "{ \\"data\\": { \\"type\\": \\"string\\" } }"; String jsonSample5 = "{ \\"data\\": { \\"type\\": \\"string\\" } }"; String jsonSample6 = "{ \\"data\\": { \\"type\\": \\"
@Test(expected = JsonMappingException.class) public void test() throws Exception { String jsonStr = "{\\n" + " \\"a\\": [\\n" + " {\\n" + " \\"b\\": [\\n" + " \\"c\\",\\n" + " \\"d\\",\\n" + " \\"e\\",\\n" + " \\"f\\",\\n" + " \\"g\\",\\n" + " \\"h\\",\\n" + " \\"i\\",\\n" + " \\"j\\",\\n" + " \\"k\\",\\n" + " \\"
@Test(expected = JsonMappingException.class) public void test() throws Exception { String json = "{\\n" + " \\"a\\" : {\\n" + " \\"b\\" : {\\n" + " \\"c\\" : {\\n" + " \\"d\\" : \\"e\\"\\n" + " }\\n" + " }\\n" + " }\\n" + "}"; ObjectMapper mapper = new ObjectMapper(); JsonParser jp = new JsonParser(json); JsonNodeFactory nodeFactory = new JsonNodeFactory(); JsonNode node = nodeFactory.objectNode(); node.put("a", "a"); node.put("b", "b"); node.put
@Test public void test() throws IOException, JsonProcessingException { String jsonSample = "{\\n" + " \\"a\\": [\\n" + " {\\n" + " \\"b\\": [\\n" + " \\"c\\",\\n" + " \\"d\\",\\n" + " \\"e\\",\\n" + " \\"f\\",\\n" + " \\"g\\",\\n" + " \\"h\\",\\n" + " \\"i\\",\\n" + " \\"j\\",\\n" + " \\"k\\",\\n" + " \\"l\\",\\n"
@Test public void test() throws IOException, JsonProcessingException { String json = "{\\n" + " \\"a\\": [\\n" + " {\\n" + " \\"b\\": [\\n" + " \\"c\\",\\n" + " \\"d\\",\\n" + " \\"e\\",\\n" + " \\"f\\",\\n" + " \\"g\\",\\n" + " \\"h\\",\\n" + " \\"i\\",\\n" + " \\"j\\",\\n" + " \\"k\\",\\n" + " \\"l\\",\\n" +
@Test public void test() throws IOException, JsonProcessingException { String json = "{ \\"data\\": { \\"type\\": \\"string\\" } }"; String json2 = "{ \\"data\\": { \\"type\\": \\"string\\" } }"; String json3 = "{ \\"data\\": { \\"type\\": \\"string\\" } }"; String json4 = "{ \\"data\\": { \\"type\\": \\"string\\" } }"; String json5 = "{ \\"data\\": { \\"type\\": \\"string\\" } }"; String json6 = "{ \\"data\\": { \\"type\\": \\"string\\" } }
@Test(expected = JsonMappingException.class) public void test() throws Exception { String json = "{\\n" + " \\"test\\": {\\n" + " \\"test2\\": {\\n" + " \\"test3\\": {\\n" + " \\"test4\\": {\\n" + " \\"test5\\": [\\n" + " \\"test6\\",\\n" + " \\"test7\\",\\n" + " \\"test8\\",\\n" + " \\"test9\\",\\n" + " \\"test10\\",\\n" + " \\"test11\\",\\
@Test(expected = JsonMappingException.class) public void testUnexpectedEndOfInput() throws Exception { Mockito.when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); Mockito.when(jp.readToken()).thenReturn(null); Mockito.when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); Mockito.when(nodeFactory.arrayNode()).thenReturn(node); Mockito.when(nodeFactory.textNode(Mockito.anyString())).thenThrow(new JsonMappingException("Unexpected end-of-input")); new TestDeserializer().deserializeArray(jp, null, nodeFactory); }
@Test(expected = JsonMappingException.class) public void testUnexpectedEndOfInput() throws Exception { Mockito.when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); Mockito.when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); Mockito.when(nodeFactory.arrayNode()).thenReturn(node); Mockito.when(node.get(0)).thenReturn(node); Mockito.when(jp.nextToken()).thenReturn(JsonToken.START_ARRAY); JsonNodeFactory nodeFactory = Mockito.mock(JsonNodeFactory.class); Mockito.when(nodeFactory.nodeFactory()).then
@Test(expected = JsonMappingException.class) public void testUnexpectedEndOfInput() throws Exception { Mockito.when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); Mockito.when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); Mockito.when(nodeFactory.arrayNode()).thenReturn(node); Mockito.when(nodeFactory.textNode(Mockito.anyString())).thenThrow(new JsonMappingException("Unexpected end-of-input")); JsonDeserializer.getInstance().deserialize(jp, null, nodeFactory); }
@Test(expected = JsonMappingException.class) public void testUnexpectedEndOfInput() throws Exception { Mockito.when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); Mockito.when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); Mockito.when(nodeFactory.arrayNode()).thenReturn(node); JsonNodeFactory nodeFactory = Mockito.mock(JsonNodeFactory.class); Mockito.when(nodeFactory.textNode(Mockito.anyString())).thenReturn(node); JsonDeserializer.getInstance().deserialize(jp, null, nodeFactory); }
@Test(expected = JsonMappingException.class) public void testUnexpectedEndOfInput() throws IOException, JsonProcessingException { when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); when(nodeFactory.arrayNode()).thenReturn(node); when(nodeFactory.textNode(node)).thenThrow(JsonMappingException.class); deserializer.deserialize(jp, ctxt); }
@Test(expected = JsonMappingException.class) public void testUnexpectedEndOfInput() throws Exception { Mockito.when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); Mockito.when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); Mockito.when(nodeFactory.arrayNode()).thenReturn(node); Mockito.when(nodeFactory.textNode(Mockito.anyString())).thenThrow(new JsonMappingException("Unexpected end-of-input")); JsonDeserializer.getInstance().deserialize(jp, null, nodeFactory); }
@Test(expected = JsonMappingException.class) public void testUnexpectedEndOfInput() throws Exception { Mockito.when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); Mockito.when(jp.getText()).thenReturn("foo"); Mockito.when(nodeFactory.arrayNode()).thenReturn(node); Mockito.when(nodeFactory.textNode("foo")).thenReturn(node); Mockito.when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); JsonNodeFactory nodeFactory = Mockito.mock(JsonNodeFactory.class); Mockito.when(nodeFactory.nodeNode()).thenReturn(node
@Test(expected = JsonMappingException.class) public void testUnexpectedEndOfInput() throws Exception { Mockito.when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); Mockito.when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); Mockito.when(nodeFactory.arrayNode()).thenReturn(nodeList); Mockito.when(nodeList.get(0)).thenReturn(node); Mockito.when(jp.nextToken()).thenReturn(JsonToken.START_ARRAY); JsonNodeFactory nodeFactory = Mockito.mock(JsonNodeFactory.class); Mockito.when(nodeFactory.textNode(
@Test(expected = JsonMappingException.class) public void testUnexpectedEndOfInput() throws Exception { Mockito.when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); Mockito.when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); Mockito.when(nodeFactory.arrayNode()).thenReturn(node); Mockito.when(nodeFactory.textNode(Mockito.anyString())).thenThrow(new JsonMappingException("Unexpected end-of-input")); JsonDeserializer.getInstance().deserialize(jp, null, nodeFactory); }
@Test(expected = JsonMappingException.class) public void testUnexpectedEndOfInput() throws Exception { JsonNodeFactory mockNodeFactory = Mockito.mock(JsonNodeFactory.class); Mockito.when(mockNodeFactory.arrayNode()).thenReturn(null); Mockito.when(mockNodeFactory.nextToken()).thenReturn(JsonToken.START_OBJECT); Mockito.when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); Mockito.when(jp.getText()).thenThrow(new JsonMappingException("Unexpected end-of-input")); JsonDeserializer.getInstance().deserialize(jp, mock(DeserializationContext.class)); }
@Test(expected = JsonMappingException.class) public void testUnexpectedEndOfInput() throws IOException, JsonProcessingException { ArrayNode node = mock(ArrayNode.class); when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); when(nodeFactory.arrayNode()).thenReturn(node); JsonDeserializer.getInstance().deserialize(jp, null, nodeFactory); }
@Test public void deserializeAny() throws IOException { when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); when(jp.getText()).thenReturn("test"); when(jp.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)).thenReturn(true); when(jp.getIntValue()).thenReturn(42L); when(jp.getLongValue()).thenReturn(42L); when(jp.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)).thenReturn(true); when(nodeFactory.textNode("test")).thenReturn(nodeFactory.textNode("
@Test public void deserializeAny() throws IOException { final JsonParser jp = mock(JsonParser.class); final DeserializationContext ctxt = mock(DeserializationContext.class); when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); when(jp.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)).thenReturn(true); final JsonNodeFactory nodeFactory = mock(JsonNodeFactory.class); when(nodeFactory.nullNode()).thenReturn(null); when(jp.nextToken()).thenReturn(JsonToken.VALUE_STRING); when(jp.getText()).thenReturn("test"); when(jp.get
@Test(expected = JsonProcessingException.class) public void testException() throws JsonProcessingException, IOException { final JsonParser jp = mock(JsonParser.class); final DeserializationContext ctxt = mock(DeserializationContext.class); final JsonNodeFactory nodeFactory = mock(JsonNodeFactory.class); when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); when(jp.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)).thenReturn(false); when(jp.getText()).thenThrow(JsonProcessingException.class); new MyClass().deserializeAny(jp, ctxt, nodeFactory); }
@Test public void deserializeAny() throws IOException { final JsonParser jp = mock(JsonParser.class); final DeserializationContext ctxt = mock(DeserializationContext.class); final JsonNodeFactory nodeFactory = mock(JsonNodeFactory.class); when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); when(jp.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)).thenReturn(true); when(jp.getText()).thenReturn("test"); when(jp.getNumberType()).thenReturn(JsonParser.NumberType.INT); when(jp.isEnabled(DeserializationFeature.USE_BIG_INTEGER_
@Test(expected = JsonProcessingException.class) public void testParseNull() throws JsonProcessingException, IOException { final JsonParser jp = mock(JsonParser.class); final DeserializationContext ctxt = mock(DeserializationContext.class); final JsonNodeFactory nodeFactory = mock(JsonNodeFactory.class); when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); when(jp.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)).thenReturn(true); when(jp.getText()).thenReturn(null); when(jp.getEmbeddedObject()).thenReturn(null); new MyClass().deserializeAny(jp, ctxt,
@Test(expected = JsonProcessingException.class) public void testParseNull() throws JsonProcessingException, IOException { final JsonNodeFactory nodeFactory = new JsonNodeFactoryImpl(); final JsonNodeFactory nodeFactory = new JsonNodeFactoryImpl(nodeFactory); final JsonParser jp = jpFactory.createParser("null"); jp.nextToken(); Mockito.when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); Mockito.when(jp.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)).thenReturn(false); new MyClass().deserializeAny(jp, null, nodeFactory); }
@Test(expected = JsonProcessingException.class) public void testException() throws JsonProcessingException, IOException { final JsonParser jp = mock(JsonParser.class); final DeserializationContext ctxt = mock(DeserializationContext.class); final JsonNodeFactory nodeFactory = mock(JsonNodeFactory.class); when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); when(jp.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)).thenReturn(false); when(jp.getText()).thenThrow(JsonProcessingException.class); new MyClass().deserializeAny(jp, ctxt, nodeFactory); }
@Test(expected = JsonProcessingException.class) public void testParseNull() throws JsonProcessingException, IOException { final JsonParser jp = mock(JsonParser.class); final DeserializationContext ctxt = mock(DeserializationContext.class); final JsonNodeFactory nodeFactory = mock(JsonNodeFactory.class); when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); when(jp.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)).thenReturn(true); when(jp.getIntValue()).thenReturn(42); when(jp.getEmbeddedObject()).thenReturn(null); when(nodeFactory.nullNode()).then
@Test public void deserializeAny() throws IOException { final JsonNodeFactory nodeFactory = new JsonNodeFactoryImpl(); final JsonNodeFactory nodeFactory = new JsonNodeFactoryImpl(nodeFactory); final JsonParser jp = jpFactory.createParser("123"); jp.nextToken(); jp.nextToken(); final JsonNode value = nodeFactory.numberNode(123L); assertEquals(value, nodeFactory.numberNode(123L)); jp.nextToken(); assertEquals(value, nodeFactory.numberNode(123L)); jp.nextToken(); assertEquals(value, nodeFactory.numberNode(123L)); jp.nextToken(); assertEquals(value, nodeFactory.numberNode(123L)); jp.nextToken(); assert
@Test public void testSimpleDeserialization() throws Exception { String json = "{\\n" + " \\"type\\": \\"string\\",\\n" + " \\"fields\\": [\\n" + " {\\n" + " \\"id\\": \\"int\\",\\n" + " \\"name\\": \\"string\\",\\n" + " \\"type\\": \\"string\\",\\n" + " \\"fields\\": [\\n" + " {\\n" + " \\"id\\": \\"long\\",\\n" + " \\"name\\": \\"string\\",\\n" + " \\"type
@Test public void testMapDeserialization() throws Exception { Map<String, Object> map = new HashMap<String, Object>(); map.put("byte", Byte.class.getName()); map.put("short", Short.class.getName()); map.put("int", Integer.class.getName()); map.put("long", Long.class.getName()); map.put("float", Float.class.getName()); map.put("double", Double.class.getName()); map.put("string", String.class.getName()); BeanDescription desc = new BeanDescription("map", map); DeserializationContext ctxt = new DeserializationContext(new ByteArrayInputStream("{\\n" + " \\"byte
@Test public void buildBeanDeserializer() throws JsonMappingException { SimpleDeserializationContext ctxt = new SimpleDeserializationContext(); ctxt.setConfig(new DeserializationConfig()); SimpleBeanBean beanBean = new SimpleBeanBean(); beanBean.setBean1("aaa"); beanBean.setBean2("bbb"); beanBean.setBean3("ccc"); SimpleBeanBean beanBean2 = new SimpleBeanBean(); beanBean2.setBean1("ccc"); beanBean2.setBean2("ddd"); beanBean2.setBean3("eee"); SimpleBeanBean beanBean3 = new SimpleBeanBean(); beanBean3.setBean1("bbb"); beanBean3.
@Test public void simple() throws JsonMappingException { SimpleBean bean = new SimpleBean(); bean.setId("foo"); BeanDescription desc = new BeanDescription(bean, SimpleBean.class); BeanDeserializerBuilder builder = new BeanDeserializerBuilder(); SimpleBean bean2 = new SimpleBean(); bean2.setId("bar"); BeanDeserializerBuilder builder2 = new BeanDeserializerBuilder(); builder2.addBeanProps(bean, desc, builder2); SimpleBean bean3 = new SimpleBean(); bean3.setId("baz"); BeanDeserializerBuilder builder3 = new BeanDeserializerBuilder(); builder3.addBeanProps(bean, desc, builder3); SimpleBean bean4 = new SimpleBean(); bean4.
@Test public void simple() throws JsonMappingException { SimpleBean bean = new SimpleBean(); bean.setStringField("aaa"); bean.setIntField(1); bean.setIntField(2); SimpleBean bean2 = new SimpleBean(); bean2.setStringField("bbb"); bean2.setIntField(3); bean2.setIntField(4); SimpleBean bean3 = new SimpleBean(); bean3.setStringField("ccc"); bean3.setIntField(5); bean3.setIntField(6); SimpleBean bean4 = new SimpleBean(); bean4.setStringField("ddd"); bean4.setIntField(7); bean4.
@Test public void addBeanProps() throws JsonMappingException { SimpleBean bean = new SimpleBean(); bean.setValue("foo"); BeanDeserializerBuilder builder = new BeanDeserializerBuilder(); SimpleBeanBean bean2 = new SimpleBeanBean(); bean2.setValue("bar"); BeanBeanBean bean3 = new SimpleBeanBean(); bean3.setValue("baz"); BeanDeserializerBuilder builder1 = new BeanDeserializerBuilder(); builder1.addBeanBean(bean); builder1.addBeanBean(bean2); builder1.addBeanBean(bean3); SimpleBeanBean bean4 = new SimpleBeanBean(); bean4.setValue("baz"); BeanDeserializerBuilder builder2 = new BeanDeserializerBuilder();
@Test public void testFilterBeanProps() throws Exception { BeanDeserializerBuilder builder = new BeanDeserializerBuilder(); List<BeanPropertyDefinition> propDefsIn = new ArrayList<BeanPropertyDefinition>(); Set<String> ignore = new HashSet<String>(); propDefsIn.add(new BeanPropertyDefinition("string", String.class)); propDefsIn.add(new BeanPropertyDefinition("int", Integer.class)); propDefsIn.add(new BeanPropertyDefinition("long", Long.class)); propDefsIn.add(new BeanPropertyDefinition("float", Float.class)); propDefsIn.add(new BeanPropertyDefinition("double", Double.class)); propDefsIn.add(new BeanPropertyDefinition("
@Test public void testFilterBeanProps() throws Exception { BeanDeserializerBuilder builder = new BeanDeserializerBuilder(); List<BeanPropertyDefinition> propDefsIn = new ArrayList<BeanPropertyDefinition>(); Set<String> ignore = new HashSet<String>(); propDefsIn.add("foo"); propDefsIn.add("bar"); propDefsIn.add("baz"); List<BeanPropertyDefinition> filtered = builder.filterBeanProps(null, null, builder, propDefsIn, ignore); Assert.assertEquals(4, filtered.size()); Assert.assertEquals("foo", filtered.get(0).getName()); Assert.assertEquals("bar", filtered.get(1).getName()); Assert.assertEquals
@Test public void testFilterBeanProps() throws Exception { BeanDeserializerBuilder builder = new BeanDeserializerBuilder(); List<BeanPropertyDefinition> propDefsIn = new ArrayList<BeanPropertyDefinition>(); Set<String> ignore = new HashSet<String>(); propDefsIn.add(new BeanPropertyDefinition("string", String.class)); propDefsIn.add(new BeanPropertyDefinition("int", Integer.class)); propDefsIn.add(new BeanPropertyDefinition("long", Long.class)); propDefsIn.add(new BeanPropertyDefinition("float", Float.class)); propDefsIn.add(new BeanPropertyDefinition("double", Double.class)); propDefsIn.add(new BeanPropertyDefinition("
@Test public void constructSettableProperty() throws JsonMappingException { SimpleBean bean = new SimpleBean(); BeanDescription beanDesc = new BeanDescription(SimpleBean.class, "test"); BeanPropertyDefinition propDef = new BeanPropertyDefinition(SimpleBean.class, "test", false); SimpleBeanProperty simpleBeanProperty = new SimpleBeanProperty().withType(SimpleBean.class); SimpleBeanProperty simpleBeanProperty2 = new SimpleBeanProperty().withType(SimpleBean.class); SimpleBeanProperty simpleBeanProperty3 = new SimpleBeanProperty().withType(SimpleBean.class); SimpleBeanProperty simpleBeanProperty4 = new SimpleBeanProperty().withType(SimpleBean.class); SimpleBeanProperty simpleBean
@Test public void testSimpleSetters() throws Exception { SettableBeanProperty p1 = new SimpleSetterlessProperty(); SettableBeanProperty p2 = new SimpleSetterlessProperty(); SettableBeanProperty p3 = new SimpleSetterlessProperty(); p1.setFieldValue(p2); p2.setFieldValue(p3); p3.setFieldValue(p1); SettableBeanProperty p4 = new SimpleSetterlessProperty(); p4.setFieldValue(p4); SettableBeanProperty p5 = new SimpleSetterlessProperty(); p5.setFieldValue(p5); SettableBeanProperty p6 = new SimpleSetterlessProperty(); p6.setFieldValue(p
@Test public void testCustomBeanDeserializer() throws Exception { BeanDescription description = Mockito.mock(BeanDescription.class); Mockito.when(description.getBeanType()).thenReturn(SimpleBean.class); Mockito.when(description.bindingsForBeanType()).thenReturn(SimpleBean.class); SimpleBean bean = new SimpleBean(); bean.setA(1); bean.setB(2); bean.setC(3); SimpleBean bean2 = new SimpleBean(); bean2.setA(4); bean2.setB(5); bean2.setC(6); SimpleBean bean3 = new SimpleBean(); bean3.setA(7); bean3
@Test public void testGetters() throws Exception { SimpleDeserializationContext ctxt = new SimpleDeserializationContext(); ctxt.setCanOverrideAccessModifiers(false); SimpleDeserializationContext ctxt2 = new SimpleDeserializationContext(); ctxt2.setCanOverrideAccessModifiers(true); SimpleDeserializationContext ctxt3 = new SimpleDeserializationContext(); ctxt3.setCanOverrideAccessModifiers(true); SimpleDeserializationContext ctxt4 = new SimpleDeserializationContext(); ctxt4.setCanOverrideAccessModifiers(true); SettableBeanPropertyAccessor accessor = new SettableBeanPropertyAccessor(); accessor.setAccessor(ctxt); accessor.setAccessor(ctxt2); accessor.setAccessor(ctxt3); accessor.setAccessor(ctxt
@Test public void testSimpleGetter() throws Exception { SimpleGetter simpleGetter = new SimpleGetter(); simpleGetter.setTypeHandler(new SimpleTypeHandler()); SimpleGetter simpleGetter2 = new SimpleGetter(); simpleGetter2.setTypeHandler(new SimpleTypeHandler()); SimpleGetter simpleGetter3 = new SimpleGetter(); simpleGetter3.setTypeHandler(new SimpleTypeHandler()); SimpleGetter simpleGetter4 = new SimpleGetter(); simpleGetter4.setTypeHandler(new SimpleTypeHandler()); SimpleGetter simpleGetter5 = new SimpleGetter(); simpleGetter5.setTypeHandler(new SimpleTypeHandler()); SimpleGetter simpleGetter6 = new SimpleGetter(); simpleGetter6.setTypeHandler(new SimpleTypeHandler()); Simple
@Test public void testSimpleDeserialization() throws Exception { SimpleDeserializationContext ctxt = new SimpleDeserializationContext(); ctxt.setCanOverrideAccessModifiers(false); SimpleDeserializationContext ctxt2 = new SimpleDeserializationContext(); ctxt2.setCanOverrideAccessModifiers(true); SimpleDeserializationContext ctxt3 = new SimpleDeserializationContext(); ctxt3.setCanOverrideAccessModifiers(true); SimpleDeserializationContext ctxt4 = new SimpleDeserializationContext(); ctxt4.setCanOverrideAccessModifiers(true); SimpleDeserializationContext ctxt5 = new SimpleDeserializationContext(); ctxt5.setCanOverrideAccessModifiers(true); SimpleDeserializationContext ctxt6 = new SimpleDeserializationContext(); ctxt6.setCan
@Test public void testCustomDeserializer() throws Exception { JsonDeserializerFactory factory = new JsonDeserializerFactory(); BeanDescription description = Mockito.mock(BeanDescription.class); Mockito.when(description.getTypeHandler()).thenReturn(SimpleTypeHandler.class); Mockito.when(description.bindingsForBeanType()).thenReturn(SimpleTypeHandler.class); Mockito.when(description.isNullable()).thenReturn(false); Mockito.when(description.getAccessor()).thenReturn(SimpleAccessor.class); Mockito.when(description.bindingsForBeanType()).thenReturn(SimpleTypeHandler.class); Mockito.when(description.getAnnotations()).thenReturn
@Test public void testSimpleDeserialization() throws Exception { SimpleDeserializationContext ctxt = new SimpleDeserializationContext(); ctxt.setCanOverrideAccessModifiers(true); SimpleDeserializationContext ctxt2 = new SimpleDeserializationContext(); ctxt2.setCanOverrideAccessModifiers(true); SimpleDeserializationContext ctxt3 = new SimpleDeserializationContext(); ctxt3.setCanOverrideAccessModifiers(true); SimpleDeserializationContext ctxt4 = new SimpleDeserializationContext(); ctxt4.setCanOverrideAccessModifiers(true); SettableBeanProperty property1 = new SettableBeanProperty(); property1.setField1("foo"); property1.setField2("bar"); SettableBeanProperty property2 = new SettableBean
@Test public void testSimpleSetters() throws Exception { SimpleBean bean = new SimpleBean(); bean.setIntegerField(123); bean.setBooleanField(true); bean.setByteField((byte) 456); bean.setShortField((short) 456); bean.setIntField(123); bean.setLongField(123L); bean.setFloatField(123.456f); bean.setDoubleField(123.456d); SettableBeanProperty prop = new SettableBeanProperty(SimpleBean.class, SimpleBean.class.getDeclaredField("stringField"), SimpleBean.class.getDeclaredField("integerField"), new SimpleBeanProperty(Simple
@Test public void testSimpleSetters() throws Exception { SettableBeanProperty prop = new SimpleSetters().constructSetterlessProperty(new SimpleDeserializationContext(new ObjectMapper()), new BeanDescriptionImpl(SimpleBean.class, SimpleBean.class), new BeanPropertyDefinitionImpl(SimpleBean.class, SimpleBean.class, SimpleBean.class, SimpleBean.class)); Assert.assertNotNull(prop.getValueDeserializer()); Assert.assertEquals(SimpleBean.class, prop.getValueDeserializer().getClass()); Assert.assertEquals(SimpleBean.class, prop.getValueDeserializer().getType(SimpleBean.class)); Assert.assertEquals(SimpleBean.class, prop.getValueDeserializer().getType(
@Test public void testConstructSetterlessProperty() throws Exception { SimpleDeserializationContext ctxt = new SimpleDeserializationContext(); ctxt.setCanOverrideAccessModifiers(false); SimpleDeserializationContext ctxt2 = new SimpleDeserializationContext(); ctxt2.setCanOverrideAccessModifiers(true); SimpleDeserializationContext ctxt3 = new SimpleDeserializationContext(); ctxt3.setCanOverrideAccessModifiers(true); SimpleDeserializationContext ctxt4 = new SimpleDeserializationContext(); ctxt4.setCanOverrideAccessModifiers(true); SettableBeanProperty field1 = new SettableBeanProperty(); field1.setField1("foo"); field1.setField2("bar"); SettableBeanProperty field2 = new Settable
@Test public void testConstructSetterlessProperty() throws Exception { SimpleDeserializationContext ctxt = new SimpleDeserializationContext(); ctxt.setCanOverrideAccessModifiers(false); SimpleDeserializationContext ctxt2 = new SimpleDeserializationContext(); ctxt2.setCanOverrideAccessModifiers(true); SimpleDeserializationContext ctxt3 = new SimpleDeserializationContext(); ctxt3.setCanOverrideAccessModifiers(true); SimpleDeserializationContext ctxt4 = new SimpleDeserializationContext(); ctxt4.setCanOverrideAccessModifiers(true); SettableBeanProperty property1 = new SimpleSettableBeanProperty(); SettableBeanProperty property2 = new SimpleSettableBeanProperty(); SettableBeanProperty property3 = new SimpleSettableBeanProperty
@Test public void testSimpleFilterProvider() { Map<String, BeanPropertyFilter> map = new LinkedHashMap<String, BeanPropertyFilter>(); SimpleFilterProvider provider = new SimpleFilterProvider(map); BeanPropertyFilter f1 = new BeanPropertyFilter("id1", "property1", "description1"); BeanPropertyFilter f2 = new BeanPropertyFilter("id2", "property2", "description2"); BeanPropertyFilter f3 = new BeanPropertyFilter("id3", "property3", "description3"); provider.addFilter("id1", f1); provider.addFilter("id2", f2); provider.addFilter("id3", f3); Map<String, BeanPropertyFilter
@Test public void testSimpleFilterProvider() { SimpleFilterProvider provider = new SimpleFilterProvider(); Map<String, BeanPropertyFilter> map = new HashMap<String, BeanPropertyFilter>(); SimplePropertyFilter f1 = new SimplePropertyFilter(); SimplePropertyFilter f2 = new SimplePropertyFilter(); map.put("a", f1); map.put("b", f2); SimplePropertyFilter f3 = new SimplePropertyFilter(); SimplePropertyFilter f4 = new SimplePropertyFilter(); map.put("c", f3); map.put("d", f4); provider.addFilter("a", f1); provider.addFilter("b", f2); provider.addFilter("c", f
@Test public void testSimpleFilterProvider() { Map<String,BeanPropertyFilter> map = new LinkedHashMap<String,BeanPropertyFilter>(); SimpleFilterProvider instance = new SimpleFilterProvider(map); BeanPropertyFilter f1 = new BeanPropertyFilter("id1", "property1", "description1"); BeanPropertyFilter f2 = new BeanPropertyFilter("id2", "property2", "description2"); BeanPropertyFilter f3 = new BeanPropertyFilter("id3", "property3", "description3"); instance.addFilter("id1", f1); instance.addFilter("id2", f2); instance.addFilter("id3", f3); instance.addFilter("id4
@Test public void testSimpleFilterProvider() { Map<String, BeanPropertyFilter> map = new LinkedHashMap<String, BeanPropertyFilter>(); SimpleFilterProvider instance = new SimpleFilterProvider(map); BeanPropertyFilter f1 = new BeanPropertyFilter("id1", "value1"); BeanPropertyFilter f2 = new BeanPropertyFilter("id2", "value2"); BeanPropertyFilter f3 = new BeanPropertyFilter("id3", "value3"); map.put("id1", f1); map.put("id2", f2); map.put("id3", f3); instance.addFilter("id1", f1); instance.addFilter("id2", f2);
@Test public void testAddFilter() { Map<String, BeanPropertyFilter> map = new LinkedHashMap<String, BeanPropertyFilter>(); SimpleFilterProvider p = new SimpleFilterProvider(map); p.addFilter("id", new BeanPropertyFilter() { @Override public void propertyAdded(String propName) { } @Override public void propertyRemoved(String propName) { } @Override public void propertyAdded(String propName) { } @Override public void propertyChanged(String propName) { } @Override public void propertyDeleted(String propName) { } @Override public void propertyAdded(String propName) { } @Override public void propertyChanged(String propName) { } @Override public void propertyDeleted(String propName)
@Test public void testAddFilter() { Map<String, BeanPropertyFilter> map = new LinkedHashMap<String, BeanPropertyFilter>(); SimpleFilterProvider p = new SimpleFilterProvider(map); BeanPropertyFilter f = new BeanPropertyFilter(); p.addFilter("id", f); assertEquals(1, map.size()); assertEquals(f, map.get("id")); p.addFilter("id", f); assertEquals(2, map.size()); assertEquals(f, map.get("id")); p.addFilter("id", f); assertEquals(2, map.size()); assertEquals(f, map.get("id")); }
@Test public void testAddFilter() { Map<String, BeanPropertyFilter> map = new LinkedHashMap<String, BeanPropertyFilter>(); SimpleFilterProvider p = new SimpleFilterProvider(map); p.addFilter("id", new BeanPropertyFilter() { @Override public void propertyAdded(String propName) { } @Override public void propertyRemoved(String propName) { } @Override public void propertyAdded(String propName) { } @Override public void propertyChanged(String propName) { } @Override public void propertyChanged(String propName) { } @Override public void propertyDeleted(String propName) { } @Override public void propertyAdded(String propName) { } @Override public void propertyChanged(String propName)
@Test public void findFilter() { SimpleFilterProvider provider = new SimpleFilterProvider(); BeanPropertyFilter filter = provider.addFilter("id", new BeanPropertyFilter() { @Override public boolean matches(Object value) { return "id".equals(value); } @Override public boolean matches(Object value) { return "id2".equals(value); } @Override public boolean matches(Object value) { return "id3".equals(value); } @Override public boolean matches(Object value) { return "id4".equals(value); } @Override public boolean matches(Object value) { return "id5".equals(value); } @Override public boolean matches(Object value) { return "id
@Test public void testFindFilter() { Map<String, BeanPropertyFilter> map = new LinkedHashMap<String, BeanPropertyFilter>(); SimpleFilterProvider provider = new SimpleFilterProvider(); provider.addFilter("a", new SimplePropertyFilter("b", "c")); provider.addFilter("b", new SimplePropertyFilter("d", "e")); provider.addFilter("c", new SimplePropertyFilter("f", "g")); BeanPropertyFilter f = provider.findFilter("a"); assertEquals("b", f.getId()); assertEquals("c", f.getName()); f = provider.findFilter("d"); assertEquals("e", f.getId()); assertEquals("g", f.
@Test public void testFindFilter() { SimpleFilterProvider provider = new SimpleFilterProvider(); BeanPropertyFilter f = provider.addFilter("a", new SimplePropertyFilter("b", "c")); assertEquals("b", f.getProperty("a")); assertEquals("c", f.getProperty("b")); BeanPropertyFilter found = provider.findFilter("a"); assertEquals("a", found.getProperty("a")); assertEquals("b", found.getProperty("b")); assertEquals("c", found.getProperty("c")); }
@Test public void testFindFilter() { SimpleFilterProvider provider = new SimpleFilterProvider(); BeanPropertyFilter f1 = provider.addFilter("id1", new BeanPropertyFilter() { @Override public boolean accept(String propName) { return propName.equals("prop1"); } @Override public boolean accept(String propName) { return propName.equals("prop2"); } @Override public boolean accept(String propName) { return propName.equals("prop3"); } @Override public boolean accept(String propName) { return propName.equals("prop4"); } @Override public boolean accept(String propName) { return propName.equals("prop5"); } }); BeanPropertyFilter f2 = provider.findFilter("id2
@Test public void testWithType() { System.out.println("testWithType"); System.out.println("testWithType: " + Std.class.getName()); System.out.println("testWithType: " + Std.class.getName()); System.out.println("testWithType: " + Std.class.getName()); System.out.println("testWithType: " + Std.class.getName()); System.out.println("testWithType: " + Std.class.getName()); System.out.println("testWithType: " + Std.class.getName()); System.out.println("testWithType: " + Std.class.getName()); System.out
@Test public void testWithType() throws Exception { System.out.println("testWithType"); System.out.println("testWithType: " + Std.class.getName()); System.out.println("testWithType: " + Std.class.getName()); System.out.println("testWithType: " + Std.class.getName()); System.out.println("testWithType: " + Std.class.getName()); System.out.println("testWithType: " + Std.class.getName()); System.out.println("testWithType: " + Std.class.getName()); System.out.println("testWithType: " + Std.class.getName()); System
@Test public void testSerializeWithType() throws IOException, JsonGenerationException { TypeSerializer typeSerializer = mock(TypeSerializer.class); when(typeSerializer.isTypePrefixForScalar(any(Object.class), any(JsonGenerator.class))).thenReturn(true); when(typeSerializer.isTypeSuffixForScalar(any(Object.class), any(JsonGenerator.class))).thenReturn(true); Object value = new Object(); new ToStringSerializer().serializeWithType(value, jgen, null, typeSerializer); verify(typeSerializer).writeTypePrefixForScalar(value, jgen); verify(typeSerializer).writeTypeSuffixForScalar(value, jgen); }
@Test public void testSerializeWithType() throws IOException, JsonGenerationException { MockTypeSerializer mockSerializer = new MockTypeSerializer(); JsonGenerator mockGenerator = mock(JsonGenerator.class); TypeSerializer mockTypeSerializer = mock(TypeSerializer.class); new ToStringSerializer().serializeWithType(new Object(), mockGenerator, null, mockTypeSerializer); verify(mockSerializer, times(1)).writeTypePrefixForScalar(new Object(), mockGenerator); verify(mockSerializer, times(1)).writeTypeSuffixForScalar(new Object(), mockGenerator); }
@Test public void testToStringSerializer() throws Exception { ToStringSerializer serializer = new ToStringSerializer(); JsonGenerator jgen = mock(JsonGenerator.class); serializer.serialize("a", jgen, null); verify(jgen).writeFieldName("a"); verify(jgen).writeFieldName("b"); verify(jgen).writeFieldName("c"); verify(jgen).writeNull(); verify(jgen).writeNull(); verify(serializer).serialize("a", jgen, null); verify(serializer).serializeWithType("a", jgen, null); verify(serializer).serialize("b", jgen, null); verify(serializer).serializeWithType("c", jgen, null); verify(serializer).
@Test public void testSerializeWithType() throws IOException, JsonGenerationException { MockTypeSerializer mockSerializer = new MockTypeSerializer(); JsonGenerator mockGenerator = mock(JsonGenerator.class); TypeSerializer mockTypeSerializer = mock(TypeSerializer.class); new ToStringSerializer().serializeWithType(new Object(), mockGenerator, null, mockTypeSerializer); verify(mockSerializer, times(1)).writeTypePrefixForScalar(new Object(), mockGenerator); verify(mockSerializer, times(1)).writeTypeSuffixForScalar(new Object(), mockGenerator); verify(mockTypeSerializer, times(1)).writeTypePrefixForScalar(new Object(), mockGenerator); verify(mockTypeSerializer, times(1
@Test public void withAlwaysAsId() { ObjectIdWriter writer1 = writer.withAlwaysAsId(true); ObjectIdWriter writer2 = writer.withAlwaysAsId(false); ObjectIdWriter writer3 = writer.withAlwaysAsId(true); assertSame(writer1, writer2); assertSame(writer2, writer3); }
@Test public void withAlwaysAsId() { ObjectIdWriter writer1 = writer.withAlwaysAsId(true); ObjectIdWriter writer2 = writer.withAlwaysAsId(false); ObjectIdWriter writer3 = writer.withAlwaysAsId(true); assertSame(writer1, writer2); assertSame(writer2, writer3); }
@Test public void withAlwaysAsId() { ObjectIdWriter writer1 = writer.withAlwaysAsId(true); ObjectIdWriter writer2 = writer.withAlwaysAsId(false); ObjectIdWriter writer3 = writer.withAlwaysAsId(true); assertSame(writer1, writer2); assertSame(writer2, writer3); }
@Test public void withAlwaysAsId() { ObjectIdWriter writer1 = writer.withAlwaysAsId(true); ObjectIdWriter writer2 = writer1.withAlwaysAsId(false); ObjectIdWriter writer3 = writer2.withAlwaysAsId(true); ObjectIdWriter writer4 = writer3.withAlwaysAsId(false); assertSame(writer1, writer2); assertSame(writer2, writer3); assertSame(writer3, writer4); }
@Test public void testMap() throws IOException, JsonProcessingException { SettableStringProperty prop1 = new SettableStringProperty("prop1", "value1"); SettableStringProperty prop2 = new SettableStringProperty("prop2", "value2"); SettableStringProperty prop3 = new SettableStringProperty("prop3", "value3"); SettableStringProperty prop4 = new SettableStringProperty("prop4", "value4"); SettableStringProperty prop5 = new SettableStringProperty("prop5", "value5"); SettableStringProperty prop6 = new SettableStringProperty("prop6", "value6"); SettableStringProperty prop7 = new SettableStringProperty("prop7
@Test public void testMap() throws IOException, JsonProcessingException { SettableStringProperty stringProperty = new SettableStringProperty("string", "string"); SettableStringProperty stringProperty2 = new SettableStringProperty("string", "string"); SettableStringProperty stringProperty3 = new SettableStringProperty("string", "string"); SettableStringProperty stringProperty4 = new SettableStringProperty("string", "string"); SettableStringProperty stringProperty5 = new SettableStringProperty("string", "string"); SettableStringProperty stringProperty6 = new SettableStringProperty("string", "string"); SettableStringProperty stringProperty7 = new SettableStringProperty("string", "string"); SettableString
@Test public void testMap() throws IOException, JsonProcessingException { SettableStringProperty prop1 = new SettableStringProperty("prop1", "value1"); SettableStringProperty prop2 = new SettableStringProperty("prop2", "value2"); SettableStringProperty prop3 = new SettableStringProperty("prop3", "value3"); SettableStringProperty prop4 = new SettableStringProperty("prop4", "value4"); SettableStringProperty prop5 = new SettableStringProperty("prop5", "value5"); SettableStringProperty prop6 = new SettableStringProperty("prop6", "value6"); SettableStringProperty prop7 = new SettableStringProperty("prop7
@Test public void testMap() throws IOException, JsonProcessingException { Map<String, Object> bean = new HashMap<String, Object>(); bean.put("a", "1"); bean.put("b", "2"); bean.put("c", "3"); Map<String, Object> newMap = new HashMap<String, Object>(); newMap.put("a", "1"); newMap.put("b", "2"); newMap.put("c", "3"); newMap.put("d", "4"); newMap.put("e", "5"); newMap.put("f", "6"); newMap.put("g", "7"); newMap.put("
@Test public void testMap() throws IOException, JsonProcessingException { Map<String, Object> bean1 = new HashMap<String, Object>(); bean1.put("a", "1"); bean1.put("b", "2"); bean1.put("c", "3"); Map<String, Object> bean2 = new HashMap<String, Object>(); bean2.put("a", "1"); bean2.put("b", "2"); bean2.put("c", "3"); Map<String, Object> bean3 = new HashMap<String, Object>(); bean3.put("a", "1"); bean3.put("b", "2"); bean3.put
@Test public void testBasicSerializerFactory() throws Exception { String json = "{\\n" + " \\"type\\" : \\"json\\",\\n" + " \\"serializers\\" : [\\n" + " {\\n" + " \\"class\\" : \\"uk.gov.gchq.koryphe.serializers.testing.TestSerializer\\",\\n" + " \\"serializers[0].class\\" : \\"uk.gov.gchq.koryphe.serializers.testing.TestSerializer\\",\\n" + " \\"serializers[1].class\\" : \\"uk.gov.
@Test public void testFindSerializerByAnnotation() throws Exception { SimpleSerializerProvider prov = new SimpleSerializerProvider(Types.class.getPackage().getName()); SimpleSerializer<String> serializer = new SimpleSerializer(Providers.class.getPackage().getName(), prov); serializer.setConfig(new DefaultSerializerConfig()); serializer.setProvider(prov); Set<String> serializers = new HashSet<String>(); serializers.add(serializer.getSerializerProvider(Types.class)); serializers.add(serializer.getSerializerProvider(Types.class)); serializers.add(serializer.getSerializerProvider(Types.class)); Class<?>[] classes = new Class<?>[2]; classes[0] = String.class; classes[
@Test public void testWithSerializerModifier() throws Exception { String json = "{\\n" + " \\"id\\" : \\"id\\",\\n" + " \\"serializers\\" : [\\n" + " {\\n" + " \\"class\\" : \\"uk.gov.gchq.koryphe.serializers.test.IntSerializer\\",\\n" + " \\"class\\" : \\"uk.gov.gchq.koryphe.serializers.test.StringSerializer\\",\\n" + " \\"serializers\\" : [\\n" + " {\\n" + " \\"class\\" : \\
@Test public void testWithSerializerModifier() throws Exception { String json = "{\\n" + " \\"serializers\\": [\\n" + " {\\n" + " \\"class\\": \\"uk.gov.gchq.koryphe.serializers.testing.TestSerializer\\",\\n" + " \\"serializers\\": [\\n" + " {\\n" + " \\"class\\": \\"uk.gov.gchq.koryphe.serializers.testing.TestSerializer\\",\\n" + " \\"serializers\\": [\\n" + " {\\n" + " \\
@Test public void testFindSerializerByAnnotations() throws Exception { SimpleSerializerProvider prov = new SimpleSerializerProvider(JavaType.getDefaultInstance(String.class)); SimpleSerializer sp = new SimpleSerializer(JavaType.getDefaultInstance(String.class), prov); SimpleSerializer sp2 = new SimpleSerializer(JavaType.getDefaultInstance(String.class), prov2); SimpleSerializer sp3 = new SimpleSerializer(JavaType.getDefaultInstance(String.class), prov3); SimpleSerializer sp4 = new SimpleSerializer(JavaType.getDefaultInstance(String.class), prov4); SimpleSerializer sp5 = new SimpleSerializer(JavaType.getDefaultInstance(String.class), prov5); SimpleSerializer sp6 = new Simple
@Test public void testFindSerializerByAnnotations() throws Exception { SimpleSerializerProvider prov = new SimpleSerializerProvider(); SimpleSerializer sp = new SimpleSerializer(SimpleSerializerProvider.class, prov); BeanDescription[] beanDescs = new BeanDescription[1]; beanDescs[0] = mock(BeanDescription.class); BeanDescription[] beanDescs1 = new BeanDescription[1]; beanDescs[0] = mock(BeanDescription.class); when(beanDescs[0].getRawClass()).thenReturn(SimpleJsonSerializable.class); when(beanDescs[0].findJsonValueMethod()).thenReturn(null); when(beanDescs[0].findJsonValueMethod()
@Test public void testFindSerializerByAnnotations() throws Exception { SimpleSerializerProvider prov = new SimpleSerializerProvider(); SimpleBean bean = new SimpleBean(); bean.setBeanClass(SimpleBean.class); BeanDescription[] beanDescs = new BeanDescription[] { bean }; SimpleSerializer s = ClassUtil.findSerializerByAnnotations(prov, bean.getJavaType(), beanDescs[0], true); assertTrue(s instanceof SimpleSerializer); s = ClassUtil.findSerializerByAnnotations(prov, bean.getJavaType(), beanDescs[1], true); assertTrue(s instanceof SimpleSerializer); s = ClassUtil.findSerializerByAnnotations(prov, bean.getJavaType(), beanDescs[2],
@Test public void testFindSerializerByAnnotations() throws Exception { SimpleSerializerProvider prov = new SimpleSerializerProvider(JavaType.getDefaultInstance(String.class)); SimpleSerializer sp = new SimpleSerializer(JavaType.getDefaultInstance(String.class), prov); SimpleSerializer sp1 = new SimpleSerializer(JavaType.getDefaultInstance(String.class), prov); SimpleSerializer sp2 = new SimpleSerializer(JavaType.getDefaultInstance(String.class), prov); SimpleSerializer sp3 = new SimpleSerializer(JavaType.getDefaultInstance(String.class), prov); SimpleSerializer sp4 = new SimpleSerializer(JavaType.getDefaultInstance(String.class), prov); SimpleSerializer sp5 = new SimpleSerializer(JavaType.
@Test public void testFindSerializerByAnnotations() throws Exception { SimpleSerializerProvider prov = new SimpleSerializerProvider(); SimpleBean bean = new SimpleBean(); bean.setBeanClass(SimpleBean.class); BeanDescription desc = new BeanDescription(bean, SimpleBean.class); SimpleSerializer s = new SimpleSerializer(prov, bean, desc); JsonSerializer<?> ser = new SimpleSerializer(prov, bean, desc); assertTrue(ser instanceof SimpleSerializer); ser = new SimpleSerializer(prov, bean, desc); assertTrue(ser instanceof SimpleSerializer); ser = new SimpleSerializer(prov, bean, desc); assertTrue(ser instanceof SimpleSerializer); ser = new SimpleSerializer(prov, bean, desc); assert
@Test public void testFindSerializerByPrimaryType() throws Exception { SimpleSerializerProvider prov = new SimpleSerializerProvider(); SimpleSerializer ts = new SimpleSerializer(); SimpleSerializer ts2 = new SimpleSerializer(); SimpleSerializer ts3 = new SimpleSerializer(); SimpleSerializer ts4 = new SimpleSerializer(); SimpleSerializer ts5 = new SimpleSerializer(); SimpleSerializer ts6 = new SimpleSerializer(); SimpleSerializer ts7 = new SimpleSerializer(); SimpleSerializer ts8 = new SimpleSerializer(); SimpleSerializer ts9 = new SimpleSerializer(); SimpleSerializer ts10 = new SimpleSerializer(); SimpleSerializer ts11 = new SimpleSerializer(); SimpleSerializer ts12 = new SimpleSerializer(); SimpleSerializer ts13 = new SimpleSerializer(); SimpleSerializer ts14 = new SimpleSerializer
@Test public void buildCollectionSerializer() throws Exception { final SerializationConfig config = new SerializationConfig(); final TypeSerializer elementTypeSerializer = new StringSerializer(); final TypeSerializer elementValueSerializer = new StringSerializer(); final JsonSerializer<?> schemaSerializer = new JsonSerializer<Schema>() { @Override public JsonSerializer<Schema> buildCollectionSerializer( SerializationConfig config, CollectionType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) { return schemaSerializer; } @Override public JsonSerializer<Schema> buildCollectionSerializer( SerializationConfig config, CollectionType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> element
@Test public void buildMapSerializer() throws Exception { SimpleSerializers simpleSerializers = new SimpleSerializers(); SimpleSerializer simpleSerializer = simpleSerializers.getSerializers().get(0); SimpleSerializer simpleSerializer2 = simpleSerializers.getSerializers().get(1); SimpleSerializer simpleSerializer3 = simpleSerializers.getSerializers().get(2); SimpleSerializer simpleSerializer4 = simpleSerializers.getSerializers().get(3); SimpleSerializer simpleSerializer5 = simpleSerializers.getSerializers().get(4); SimpleSerializer simpleSerializer6 = simpleSerializers.getSerializers().get(5); SimpleSerializer simpleSerializer7 = simpleSerializers.getSerializers().get(6);
@Test public void buildMapSerializer() throws Exception { SimpleSerializationConfig config = new SimpleSerializationConfig(); TypeSerializer elementTypeSerializer = new TypeSerializer(String.class); TypeSerializer elementValueSerializer = new TypeSerializer(Integer.class); TypeSerializer staticTypeSerializer = new TypeSerializer(String.class); SimpleSerializer staticSerializer = new SimpleSerializer(Integer.class); SimpleSerializer staticSerializer2 = new SimpleSerializer(Integer.class); SimpleSerializer staticSerializer3 = new SimpleSerializer(Integer.class); SimpleSerializer staticSerializer4 = new SimpleSerializer(Integer.class); SimpleSerializer staticSerializer5 = new SimpleSerializer(Integer.class); SimpleSerializer staticSerializer6 = new SimpleSerializer(Integer.class); SimpleSerializer static
@Test public void buildArraySerializer() throws Exception { SimpleSerializerProvider prov = new SimpleSerializerProvider(); SimpleSerializerProvider provider2 = new SimpleSerializerProvider(); SimpleSerializerProvider provider3 = new SimpleSerializerProvider(); SimpleSerializerProvider provider4 = new SimpleSerializerProvider(); SimpleSerializerProvider provider5 = new SimpleSerializerProvider(); SimpleSerializerProvider provider6 = new SimpleSerializerProvider(); SimpleSerializerProvider provider7 = new SimpleSerializerProvider(); SimpleSerializerProvider provider8 = new SimpleSerializerProvider(); SimpleSerializerProvider provider9 = new SimpleSerializerProvider(); SimpleSerializerProvider providerA = new SimpleSerializerProvider(); SimpleSerializerProvider providerB = new SimpleSerializerProvider(); SimpleSerializerProvider providerC = new SimpleSerializerProvider(); SimpleSerializerProvider providerD =
@Test public void testBuildArraySerializer() throws Exception { SimpleSerializerProvider prov = new SimpleSerializerProvider(); SimpleSerializerModifier modifier = new SimpleSerializerModifier(); SimpleSerializer<Object> type = new SimpleSerializer<Object>(Object.class) { @Override public JsonSerializer<Object> createSerializer(SerializationConfig config, ArrayType type, BeanDescription beanDesc, JsonSerializer<Object> nullSerializer) { return null; } @Override public JsonSerializer<Object> createTypeSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, JsonSerializer<Object> nullSerializer) { return null; } @Override public JsonSerializer<Object> createSerializer(SerializationConfig config, ArrayType type, BeanDescription beanDesc,
@Test public void testBuildIteratorSerializer() throws Exception { SimpleSerializerProvider prov = new SimpleSerializerProvider(Arrays.asList(String.class)); SimpleSerializer<String> serializer = new SimpleSerializer(prov, String.class); serializer.setProvider(prov); assertTrue(serializer.findSerializerByPRIMARYType(null, new JavaType(String.class), null, false).isNotNull()); serializer.setProvider(prov); assertTrue(serializer.findSerializerByPRIMARYType(null, new JavaType(String.class), null, false).isNotNull()); serializer.setProvider(prov); assertTrue(serializer.findSerializerByPRIMARYType(null, new JavaType(String.class), null,
@Test public void testSettableAnyProperty() throws Exception { SettableAnyProperty p1 = new SettableAnyProperty(this.property1, this.setter, this.type, this.valueDeser); p1.withValueDeserializer(this.valueDeserializer); SettableAnyProperty p2 = new SettableAnyProperty(this.property2, this.setter, this.type, this.valueDeser); p2.withValueDeserializer(this.valueDeserializer); SettableAnyProperty p3 = new SettableAnyProperty(this.property3, this.setter, this.type, this.valueDeser); p3.withValueDeserializer(this.valueDeserializer); p3.withValueDeserializer
@Test public void testAnyProperty() { BeanProperty p1 = new BeanProperty(); p1.setName("foo"); p1.setType(JavaType.STRING); p1.withValueDeserializer(new JsonDeserializer<String>() { @Override public String deserialize(JsonParser jp, DeserializationContext ctxt, Object instance, String propName) throws IOException, JsonProcessingException { throw new IOException(); } }); p1.withValueDeserializer(new JsonDeserializer<Integer>() { @Override public Integer deserialize(JsonParser jp, DeserializationContext ctxt, Object instance, String propName) throws IOException, JsonProcessingException { throw new IOException(); } }); BeanProperty p2 = new BeanProperty(); p2.setName
@Test public void testSettableAnyProperty() throws Exception { SettableAnyProperty p1 = new SettableAnyProperty(this.property1, this.setter, this.type, this.valueDeser); assertEquals(p1.getProperty(), this.property1); assertEquals(p1.getType(), this.type); assertEquals(p1.getValueDeserializer(), this.valueDeser); SettableAnyProperty p2 = new SettableAnyProperty(this.property2, this.setter, this.type, this.valueDeser); assertEquals(p2.getProperty(), this.property2); assertEquals(p2.getType(), this.type); assertEquals(p2
@Test public void testAnyProperty() throws Exception { SettableAnyProperty p1 = new SettableAnyProperty(this.property1, this.setter, JavaType.INT, this.valueDeser); assertEquals(p1.getProperty(), this.property1); assertEquals(p1.getType(), JavaType.INT); assertEquals(p1.getValueDeserializer(), this.valueDeser); SettableAnyProperty p2 = new SettableAnyProperty(this.property2, this.setter, JavaType.INT, this.valueDeser); assertEquals(p2.getProperty(), this.property2); assertEquals(p2.getType(), JavaType.INT); assertEquals(
@Test public void testAnyProperty() throws Exception { SettableAnyProperty p1 = new SettableAnyProperty(this.property1, this.setter, JavaType.INT, this.valueDeser); assertEquals(p1.getProperty(), this.property1); assertEquals(p1.getType(), JavaType.INT); assertEquals(p1.getValueDeserializer(), this.valueDeser); SettableAnyProperty p2 = new SettableAnyProperty(this.property2, this.setter, JavaType.INT, this.valueDeser); assertEquals(p2.getProperty(), this.property2); assertEquals(p2.getType(), JavaType.INT); assertEquals(
@Test public void testAnyProperty() throws Exception { SettableAnyProperty p1 = new SettableAnyProperty(this.property1, this.setter, JavaType.INT, this.valueDeser); assertEquals(p1.getProperty(), this.property1); assertEquals(p1.getType(), JavaType.INT); assertEquals(p1.getValueDeserializer(), this.valueDeser); SettableAnyProperty p2 = new SettableAnyProperty(this.property2, this.setter, JavaType.INT, this.valueDeser); assertEquals(p2.getProperty(), this.property2); assertEquals(p2.getType(), JavaType.INT); assertEquals(
@Test public void testAnyProperty() throws Exception { SettableAnyProperty p1 = new SettableAnyProperty(this.property1, this.setter, JavaType.INT, this.valueDeser); SettableAnyProperty p2 = new SettableAnyProperty(this.property2, this.setter, JavaType.INT, this.valueDeser); p1.withValueDeserializer(this.valueDeser); p2.withValueDeserializer(this.valueDeser); assertEquals(p1.getProperty(), p2.getProperty()); assertEquals(p1.getType(), p2.getType()); assertEquals(p1.getValueDeserializer(), this.valueDeser); assertEquals(p2
@Test public void testWithValueDeserializer() { SettableAnyProperty anyProp = anyProp.withValueDeserializer(new JsonDeserializer<Object>() { @Override public Object deserialize(JsonParser jp, DeserializationContext ctxt, Object instance, String propName) throws IOException, JsonProcessingException { return null; } @Override public Object deserialize(JsonParser jp, DeserializationContext ctxt, Object instance, String propName) throws IOException, JsonProcessingException { return null; } }); assertTrue(anyProp.hasValueDeserializer()); assertEquals(anyProp.getProperty(), anyProp.getProperty()); assertEquals(anyProp.getType(), anyProp.getType()); assertEquals(anyProp.toString(), anyProp.
@Test public void testWithValueDeserializer() throws IOException { SettableAnyProperty anyProperty = anyProperty.withValueDeserializer(new JsonDeserializer<String>() { @Override public String deserialize(JsonParser jp, DeserializationContext ctxt, Object instance, String propName) throws IOException, JsonProcessingException { return "test"; } }); assertEquals("test", anyProperty.getPropertyName()); assertEquals("test", anyProperty.getType().getTypeName()); assertEquals("test", anyProperty.toString()); assertTrue(anyProperty.hasValueDeserializer()); assertEquals("test", anyProperty.getProperty().getName()); assertEquals("test", anyProperty.getType().getTypeName()); assertEquals("test", anyProperty.
@Test public void testGetProperty() { BeanProperty p = anyProperty.getProperty(); Assert.assertEquals("name", p.getName()); Assert.assertEquals(java.lang.String.class, p.getType()); Assert.assertEquals(java.util.Date.class, p.getGetter().getType()); Assert.assertEquals(java.util.Date.class, p.getSetter().getType()); Assert.assertEquals(java.util.Date.class, p.getType()); Assert.assertEquals(java.util.Date.class, p.getValueDeserializer().getType()); Assert.assertEquals(java.util.Date.class, p.getValueDeserializer().get
@Test public void testHasValueDeserializer() { SettableAnyProperty property = new SettableAnyProperty(null, null, JavaTypes.STRING, new JsonDeserializer<String>() { @Override public String deserialize(JsonParser jp, DeserializationContext ctxt, Object instance, String propName) throws IOException, JsonProcessingException { return null; } }); property.withValueDeserializer(new JsonDeserializer<String>() { @Override public String deserialize(JsonParser jp, DeserializationContext ctxt, Object instance, String propName) throws IOException, JsonProcessingException { return null; } }); Assert.assertTrue(property.hasValueDeserializer()); property.withValueDeserializer(new JsonDeserializer<Integer>() { @Override public Integer
@Test public void testGetType() { SettableAnyProperty prop = new SettableAnyProperty(new BeanProperty("name", String.class), null, JavaType.STRING, new JsonDeserializer<String>() { @Override public String deserialize(JsonParser jp, JsonDeserializationContext context, String propName, Object value) throws IOException, JsonProcessingException { return null; } }); assertEquals(String.class, prop.getType().getRawType()); }
@Test public void testDeserializeAndSet() throws Exception { String json1 = "{\\n" + " \\"name\\" : \\"John\\",\\n" + " \\"age\\" : 10\\n" + "}"; String json2 = "{\\n" + " \\"name\\" : \\"John\\",\\n" + " \\"age\\" : 20\\n" + "}"; String json3 = "{\\n" + " \\"name\\" : \\"John\\",\\n" + " \\"age\\" : 30\\n" + "}"; String json4 = "{\\n" + " \\"name\\" : \\"John\\",\\n
@Test public void testDeserializeAndSet() throws Exception { MockBean bean = new MockBean(); bean.setIntField(123); bean.setBooleanField(true); bean.setByteField((byte)123); bean.setShortField((short)123); bean.setIntField(123); bean.setLongField(123L); bean.setFloatField(123.45f); bean.setDoubleField(123.45d); bean.setFloatField(123.45d); assertEquals(123.45d, bean.getIntField()); assertEquals(123.45d, bean.getBooleanField()); assertEquals(123.45d, bean.getFloatField()); assert
@Test public void testDeserializer() throws Exception { String json = "{\\n" + " \\"name\\" : \\"test\\",\\n" + " \\"type\\" : \\"java.lang.String\\",\\n" + " \\"properties\\" : [\\n" + " {\\n" + " \\"name\\" : \\"string\\",\\n" + " \\"type\\" : \\"java.lang.String\\",\\n" + " \\"properties\\" : [\\n" + " {\\n" + " \\"name\\" : \\"string\\",\\n" + " \\"type\\" : \\"java.lang.String
@Test public void testDeserializer() throws Exception { String json = "{\\"value\\":\\"test\\"}"; JsonParser jp = mock(JsonParser.class); DeserializationContext ctxt = mock(DeserializationContext.class); when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NULL); when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); assertEquals("test", classUnderTest.deserialize(jp, ctxt)); verify(jp).getCurrentToken(); verify(jp).getCurrentToken(); verify(valueDeserializer).deserialize(jp, ctxt); }
@Test public void testDeserializer() throws Exception { JsonDeserializer<String> stringDeserializer = new JsonDeserializer<String>() { @Override public String deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { return "test"; } @Override public String deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { return "test"; } }; Object instance = new Object(); instance.deserialize(jp, null); assertEquals("test", instance.toString()); instance.deserializeAndSet(jp, null, instance, "test"); assertEquals("test", instance.toString()); instance.deserializeAndSet(jp, null, instance, "test"); assertEquals("test", instance
@Test public void testDeserializer() throws Exception { String json = "{\\n" + " \\"name\\" : \\"test\\",\\n" + " \\"type\\" : \\"java.lang.String\\",\\n" + " \\"properties\\" : [\\n" + " {\\n" + " \\"name\\" : \\"test1\\",\\n" + " \\"type\\" : \\"java.lang.String\\",\\n" + " \\"properties\\" : [\\n" + " {\\n" + " \\"name\\" : \\"test2\\",\\n" + " \\"type\\" : \\"java.lang
@Test public void testSet() throws IOException { MyObject myObject = new MyObject(); String name = "test"; myObject.setName(name); MyObject2 myObject2 = new MyObject2(); myObject2.setName(name); myObject2.setMyObject2(myObject); MyObject3 myObject3 = new MyObject3(); myObject3.setName(name); myObject3.setMyObject3(myObject3); assertEquals(name, myObject3.getName()); assertEquals(name, myObject3.getMyObject3().getName()); assertEquals(name, myObject3.getMyObject3().getMyObject2().getName());
@Test public void testSet() throws IOException { MyObject myObject = new MyObject(); myObject.setString("test"); assertEquals("test", myObject.getString()); myObject.setInt(123); assertEquals(123, myObject.getInt()); myObject.setBoolean(true); assertEquals(true, myObject.getBoolean()); myObject.setByte((byte)123); assertEquals(123, myObject.getByte()); myObject.setShort((short)123); assertEquals(123, myObject.getShort()); myObject.setInt(123); assertEquals(123, myObject.getInt()); myObject.setByte((byte)123); assert
@Test public void testSet() throws IOException { MyObject myObject = new MyObject(); MyObjectProperty myProperty = new MyObjectProperty(); myProperty.setName("name"); myProperty.setType(MyObject.class); myProperty.setValue("test"); myObject.setMyProperty(myProperty); MyObjectProperty myProperty2 = new MyObjectProperty(); myProperty2.setName("name2"); myProperty2.setType(MyObject.class); myObject.setMyProperty2(myProperty2); MyObjectProperty myObjectProperty3 = new MyObjectProperty(); myObjectProperty3.setName("name3"); myObjectProperty3.setType(MyObject.
@Test public void testConstructWithoutSuperTypes() { try { AnnotatedClass.constructWithoutSuperTypes(String.class, new AnnotationIntrospector() { @Override public Class<?> annotationType() { return String.class; } @Override public List<Class<?>> superTypes() { return Collections.emptyList(); } @Override public Class<? extends Annotation> annotationType() { return List.class; } @Override public List<Annotation> getAnnotations() { return Collections.emptyList(); } @Override public Class<? extends Annotation> annotationType() { return List.class; } @Override public Class<? extends Annotation> annotationType() { return List.class; } @Override public Map<String, AnnotatedField> fields() {
@Test public void testConstructWithoutSuperTypes() { AnnotatedClass.Builder builder = new AnnotatedClass.Builder(); builder.withAnnotation(Annotations.class, new AnnotationIntrospector() { @Override public Class<?> annotationType() { return this.getClass(); } @Override public List<Class<?>> superTypes() { return Collections.emptyList(); } @Override public Class<? extends Annotation> annotationType() { return this.getClass(); } @Override public Map<String, AnnotatedField> fields() { return Collections.emptyMap(); } @Override public Class<? extends Annotation> annotationType() { return this.getClass(); } @Override public Class<? extends Annotation> annotationType() { return this.getClass(); }
@Test public void resolveCreators() { MyClass tc = new MyClass(); tc._constructors = new ArrayList<Constructor<?>>(); tc._constructors.add(new Constructor<MyClass>() { @Override public Class<?> getParameterTypes() { return MyClass.class; } }); tc._constructors.add(new Constructor<MyClass>() { @Override public Class<?> getParameterTypes() { return MyClass.class; } }); tc._constructors.add(new Constructor<MyClass>() { @Override public Class<?> getParameterTypes() { return MyClass.class; } }); tc._constructors.add(new Constructor<MyClass>() { @Override public Class<?
@Test public void testBaseTypeName() throws Exception { assertEquals(String.class.getName(), new TypeDeserializerBase(String.class, TypeIdResolver.EMPTY, "foo", true, String.class).baseTypeName()); assertEquals(Integer.class.getName(), new TypeDeserializerBase(Integer.class, TypeIdResolver.EMPTY, "foo", true, Integer.class).baseTypeName()); assertEquals(Long.class.getName(), new TypeDeserializerBase(Long.class, TypeIdResolver.EMPTY, "foo", true, Long.class).baseTypeName()); assertEquals(Double.class.getName(), new TypeDeserializerBase(Double.class, TypeIdResolver.EMPTY, "foo", true,
@Test public void testResolveAbstractType() { }
@Test public void testResolveAbstractType() { Assert.assertNull(new SimpleTypeResolver().resolveAbstractType(null, null)); Assert.assertNull(new SimpleTypeResolver().resolveAbstractType(null, new Object())); Assert.assertNull(new SimpleTypeResolver().resolveAbstractType(null, new Object())); Assert.assertNull(new SimpleTypeResolver().resolveAbstractType(null, new Object())); Assert.assertNull(new SimpleTypeResolver().resolveAbstractType(null, new Object())); Assert.assertNull(new SimpleTypeResolver().resolveAbstractType(null, new Object())); Assert.assertNull(new SimpleTypeResolver().resolveAbstractType(null, new Object()));
@Test public void testSqlDateSerializer() { SqlDateSerializer serializer = new SqlDateSerializer(); ObjectMapper mapper = new ObjectMapper(); java.sql.Date date = new java.sql.Date(); String result = mapper.writeValueAsString(date); Assert.assertNotNull(result); result = mapper.writeValueAsString(date); Assert.assertNotNull(result); result = mapper.writeValueAsString(date); Assert.assertNotNull(result); result = mapper.writeValueAsString(date); Assert.assertNotNull(result); result = mapper.writeValueAsString(date); Assert.assertNotNull(result); result = mapper.writeValueAsString(date); Assert.assertNotNull(result); result = mapper.write
@Test public void testDateSerializer() throws IOException, JsonGenerationException { Date value = new Date(); SqlDateSerializer serializer = new SqlDateSerializer(); serializer.serialize(value, jgen, null); Mockito.verify(jgen, Mockito.times(1)).writeString(value.toString()); }
@Test public void testDateSerializer() throws IOException, JsonGenerationException { SqlDateSerializer serializer = new SqlDateSerializer(); Date value = new Date(); ByteArrayOutputStream baos = new ByteArrayOutputStream(); serializer.serialize(value, baos, null); ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray()); ObjectMapper mapper = new ObjectMapper(); JsonNode actualObj = mapper.readTree(bais); Assert.assertEquals(value.toString(), actualObj.get("date").asText()); }
@Test public void testIdFromValueAndType() { final ClassNameIdResolver resolver = new ClassNameIdResolver(new JavaType(MyType.class), new TypeFactory()); assertEquals("myId", resolver.idFromValueAndType("myValue", MyType.class)); assertEquals("myId2", resolver.idFromValueAndType("myValue2", MyType.class)); assertEquals("myId3", resolver.idFromValueAndType("myValue3", MyType.class)); assertEquals("myId4", resolver.idFromValueAndType("myValue4", MyType.class)); assertEquals("myId5", resolver.idFromValueAndType("myValue5
@Test public void test() { final ClassNameIdResolver resolver = new ClassNameIdResolver(); resolver.registerSubtype(String.class, "string"); assertEquals("string_id", resolver._idFromValueAndType("string", String.class)); assertEquals("string_id", resolver._idFromValueAndType("string", String.class)); assertEquals("string_id", resolver._idFromValueAndType("string", String.class)); assertEquals("string_id", resolver._idFromValueAndType("string", String.class)); assertEquals("string_id", resolver._idFromValueAndType("string", String.class)); assertEquals("string_id", resolver._idFromValue
@Test public void buildWriter() { BeanPropertyWriter w = new SimpleBeanPropertyWriter(); w.setClazz(SimpleBean.class); w.setClazz(SimpleBean2.class); w.setClazz(SimpleBean3.class); w.setClazz(SimpleBean4.class); w.setClazz(SimpleBean5.class); w.setClazz(SimpleBean6.class); w.setClazz(SimpleBean7.class); w.setClazz(SimpleBean8.class); w.setClazz(SimpleBean9.class); w.setClazz(SimpleBean10.class); w.setClazz(SimpleBean11.class); w.setClazz(SimpleBean12.
@Test public void testInnerClassProperty() { SettableBeanProperty src = new SettableBeanProperty() .withName("foo") .withValueDeserializer(new JsonDeserializer<String>() { @Override public String deserialize(JsonParser jp, DeserializationContext ctxt, Object bean) throws IOException, JsonProcessingException { throw new IOException("test"); } }); SettableBeanProperty dest = new InnerClassProperty(src, "bar") .withName("baz") .withValueDeserializer(new JsonDeserializer<String>() { @Override public String deserialize(JsonParser jp, DeserializationContext ctxt, Object bean) throws IOException, JsonProcessingException { throw new IOException("test"); } }); assertEquals("foo",
@Test public void testInnerClassProperty() { SettableBeanProperty src = new SettableBeanProperty() .withName("foo") .withValueDeserializer(new JsonDeserializer<String>() { @Override public String deserialize(JsonParser jp, DeserializationContext ctxt, Object bean) throws IOException, JsonProcessingException { return "foo"; } }); InnerClassProperty test = new InnerClassProperty(src, "bar"); assertEquals("foo", test.name); assertEquals("bar", test.withName("bar")); assertEquals("foo", test.withValueDeserializer(new JsonDeserializer<String>() { @Override public String deserialize(JsonParser jp, DeserializationContext ctxt, Object bean) throws
@Test public void testInnerClassProperty() { SettableBeanProperty src = new SettableBeanProperty() .withName("foo") .withValueDeserializer(new JsonDeserializer<String>() { @Override public String deserialize(JsonParser jp, DeserializationContext ctxt, Object bean) throws IOException, JsonProcessingException { return "foo"; } }); InnerClassProperty src2 = new InnerClassProperty(src, "bar") .withName("baz") .withValueDeserializer(new JsonDeserializer<String>() { @Override public String deserialize(JsonParser jp, DeserializationContext ctxt, Object bean) throws IOException, JsonProcessingException { return "baz"; } }); assertEquals("foo", src2.
@Test public void testInnerClassProperty() { SettableBeanProperty src = new SettableBeanProperty() .withName("foo") .withValueDeserializer(new JsonDeserializer<String>() { @Override public String deserialize(JsonParser jp, DeserializationContext ctxt, Object bean) throws IOException, JsonProcessingException { return "foo"; } }); InnerClassProperty test = new InnerClassProperty(src, "bar"); test.withName("baz"); test.withValueDeserializer(new JsonDeserializer<String>() { @Override public String deserialize(JsonParser jp, DeserializationContext ctxt, Object bean) throws IOException, JsonProcessingException { return "baz"; } }); assertEquals("foo", test.
@Test public void testDeserializeAndSet() throws Exception { InnerClassProperty prop1=new InnerClassProperty("prop1", "string"); InnerClassProperty prop2=new InnerClassProperty("prop2", "string"); InnerClassProperty prop3=new InnerClassProperty("prop3", "int"); InnerClassProperty prop4=new InnerClassProperty("prop4", "long"); InnerClassProperty prop5=new InnerClassProperty("prop5", "float"); InnerClassProperty prop6=new InnerClassProperty("prop6", "long"); prop1.withValueDeserializer(new JsonStringDeserializer()); prop2.withValueDeserializer(new JsonStringDeserializer()); prop3.withValueDeserializer(new JsonStringDeserializer
@Test public void test() throws Exception { InnerClassProperty prop1=new InnerClassProperty("prop1", "val1"); InnerClassProperty prop2=new InnerClassProperty("prop2", "val2"); InnerClassProperty prop3=new InnerClassProperty("prop3", "val3"); final InnerClassProperty prop4=new InnerClassProperty("prop4", "val4"); final InnerClassProperty prop5=new InnerClassProperty("prop5", "val5"); final InnerClassProperty prop6=new InnerClassProperty("prop6", "val6"); final InnerClassProperty prop7=new InnerClassProperty("prop7", "val7"); final InnerClassProperty prop8=new Inner
@Test public void test() throws Exception { InnerClassProperty prop1=new InnerClassProperty("prop1", "val1"); InnerClassProperty prop2=new InnerClassProperty("prop2", "val2"); InnerClassProperty prop3=new InnerClassProperty("prop3", "val3"); final InnerClassProperty prop4=new InnerClassProperty("prop4", "val4"); final InnerClassProperty prop5=new InnerClassProperty("prop5", "val5"); final InnerClassProperty prop6=new InnerClassProperty("prop6", "val6"); final InnerClassProperty prop7=new InnerClassProperty("prop7", "val7"); final InnerClassProperty prop8=new Inner
@Test public void test() throws Exception { InnerClassProperty prop1=new InnerClassProperty("prop1", "prop1"); InnerClassProperty prop2=new InnerClassProperty("prop2", "prop2"); InnerClassProperty prop3=new InnerClassProperty("prop3", "prop3"); prop1.withValueDeserializer(new JsonStringDeserializer()); prop2.withValueDeserializer(new JsonStringDeserializer()); prop3.withValueDeserializer(new JsonStringDeserializer()); JsonParser jp = mock(JsonParser.class); when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NULL); prop1.deserializeAndSet(jp, null, null); assertNull(prop1.get
@Test public void testDeserializeAndSet() throws Exception { InnerClassProperty prop1=new InnerClassProperty("prop1", "val1"); InnerClassProperty prop2=new InnerClassProperty("prop2", "val2"); InnerClassProperty prop3=new InnerClassProperty("prop3", "val3"); final InnerClassProperty prop4=new InnerClassProperty("prop4", "val4"); final InnerClassProperty prop5=new InnerClassProperty("prop5", "val5"); final InnerClassProperty prop6=new InnerClassProperty("prop6", "val6"); final InnerClassProperty prop7=new InnerClassProperty("prop7", "val7"); final InnerClassProperty prop8=
@Test public void test() throws Exception { InnerClassProperty prop1=new InnerClassProperty("prop1", "val1"); InnerClassProperty prop2=new InnerClassProperty("prop2", "val2"); InnerClassProperty prop3=new InnerClassProperty("prop3", "val3"); final InnerClassProperty prop4=new InnerClassProperty("prop4", "val4"); final InnerClassProperty prop5=new InnerClassProperty("prop5", "val5"); final InnerClassProperty prop6=new InnerClassProperty("prop6", "val6"); final InnerClassProperty prop7=new InnerClassProperty("prop7", "val7"); final InnerClassProperty prop8=new Inner
@Test public void testDeserializeAndSet() throws IOException, JsonProcessingException { InnerClassProperty prop1=new InnerClassProperty("prop1", "string"); InnerClassProperty prop2=new InnerClassProperty("prop2", "string"); InnerClassProperty prop3=new InnerClassProperty("prop3", "int"); InnerClassProperty prop4=new InnerClassProperty("prop4", "long"); InnerClassProperty prop5=new InnerClassProperty("prop5", "float"); InnerClassProperty prop6=new InnerClassProperty("prop6", "long"); InnerClassProperty prop7=new InnerClassProperty("prop7", "float"); InnerClassProperty prop8=new InnerClassProperty("prop8", "
@Test public void test() throws IOException, JsonProcessingException { final InnerClassProperty prop1=new InnerClassProperty("prop1", "string"); final InnerClassProperty prop2=new InnerClassProperty("prop2", "int"); final InnerClassProperty prop3=new InnerClassProperty("prop3", "long"); final InnerClassProperty prop4=new InnerClassProperty("prop4", "float"); final InnerClassProperty prop5=new InnerClassProperty("prop5", "int"); final InnerClassProperty prop6=new InnerClassProperty("prop6", "long"); final InnerClassProperty prop7=new InnerClassProperty("prop7", "float"); final InnerClassProperty prop8=new InnerClass
@Test public void testSet() throws Exception { InnerClassProperty prop1=new InnerClassProperty("prop1", "string"); InnerClassProperty prop2=new InnerClassProperty("prop2", "string"); InnerClassProperty prop3=new InnerClassProperty("prop3", "int"); InnerClassProperty prop4=new InnerClassProperty("prop4", "long"); InnerClassProperty prop5=new InnerClassProperty("prop5", "float"); InnerClassProperty prop6=new InnerClassProperty("prop6", "long"); InnerClassProperty prop7=new InnerClassProperty("prop7", "string"); InnerClassProperty prop8=new InnerClassProperty("prop8", "float"); Settable
@Test public void testSet() throws Exception { String[][] lines = new String[][] { {"foo", "bar"}, {"foo", "bar"}, {"foo", "bar"}, {"foo", "bar"}, {"foo", "bar"}, {"foo", "bar"}, {"foo", "bar"}, {"foo", "bar"}, {"foo", "bar"}, {"foo", "bar"}, {"foo", "bar"}, {"foo", "bar"}, {"foo", "bar"}, {"foo", "bar"}, {"foo", "bar"}, {"foo", "bar"}, {"foo", "bar"}, {"foo", "bar"},
@Test public void testSet() throws Exception { SettableBean bean = new SettableBean(); InnerClassProperty prop1=new InnerClassProperty("prop1", "prop1"); InnerClassProperty prop2=new InnerClassProperty("prop2", "prop2"); InnerClassProperty prop3=new InnerClassProperty("prop3", "prop3"); prop1.withValueDeserializer(new JsonDeserializer<String>() { @Override public String deserialize(JsonParser jp, DeserializationContext ctxt, Object object) throws IOException, JsonProcessingException { throw new AssertionError(); } }); prop2.withValueDeserializer(new JsonDeserializer<String>() { @Override public String deserialize(JsonParser jp, Deserialization
@Test public void testJsonSchema() throws IOException { String json = "{\\n" + " \\"schema\\": {\\n" + " \\"type\\": \\"object\\",\\n" + " \\"properties\\": {\\n" + " \\"type\\": \\"string\\"\\n" + " },\\n" + " \\"properties\\": {\\n" + " \\"type\\": \\"object\\",\\n" + " \\"properties\\": {\\n" + " \\"type\\": \\"string\\"\\n" + " },\\n" + " \\"properties\\": {\\n" + " \\"type
@Test public void testJsonSchema() { ObjectNode schema = JsonNodeFactory.instance.objectNode(); JsonSchema schema1 = new JsonSchema(schema); Assert.assertEquals(schema, schema1.getSchemaNode()); JsonSchema schema2 = new JsonSchema(schema); Assert.assertEquals(schema, schema2.getSchemaNode()); JsonSchema schema3 = new JsonSchema(JsonNodeFactory.instance.objectNode()); Assert.assertEquals(schema, schema3.getSchemaNode()); JsonSchema schema4 = new JsonSchema(JsonNodeFactory.instance.objectNode()); Assert.assertEquals(schema, schema4.getSchemaNode()); }
@Test public void testGetSchemaNode() { String line = "[\\n" + " {\\n" + " \\"type\\": \\"object\\",\\n" + " \\"properties\\": {\\n" + " \\"prop1\\": \\"value1\\",\\n" + " \\"prop2\\": \\"value2\\"\\n" + " },\\n" + " {\\n" + " \\"type\\": \\"object\\",\\n" + " \\"prop1\\": \\"value1\\",\\n" + " \\"prop2\\": \\"value2\\"\\n" + " }\\n"
@Test public void testGetSchemaNode() { JsonSchema schema = new JsonSchema(JsonNodeFactory.instance.objectNode()); JsonNode schemaNode = schema.getSchemaNode(); assertThat(schemaNode).isNotNull(); assertThat(schemaNode.get("test").asText()).isEqualTo("test"); schemaNode = schema.getSchemaNode(); assertThat(schemaNode).isNotNull(); assertThat(schemaNode.get("test").asText()).isEqualTo("test"); schemaNode = schema.getSchemaNode(); assertThat(schemaNode).isNotNull(); assertThat(schemaNode.get("test").asText()).isEqualTo("test"); schemaNode = schema.get
@Test public void equals() { JsonSchema schema1 = new JsonSchema(new ObjectNode("{\\"type\\":\\"object\\"}")); JsonSchema schema2 = new JsonSchema(new ObjectNode("{\\"type\\":\\"object\\"}")); JsonSchema schema3 = new JsonSchema(new ObjectNode("{\\"type\\":\\"object\\"}")); JsonSchema schema4 = new JsonSchema(new ObjectNode("{\\"type\\":\\"object\\"}")); JsonSchema schema5 = new JsonSchema(new ObjectNode("{\\"type\\":\\"object\\"}")); assertTrue(schema1.equals(schema1)); assertTrue(schema1.equals(schema2)); assertTrue(schema
@Test public void equals() { JsonSchema schema1 = new JsonSchema(new ObjectNode("{\\"type\\":\\"object\\"}")); JsonSchema schema2 = new JsonSchema(new ObjectNode("{\\"type\\":\\"object\\"}")); JsonSchema schema3 = new JsonSchema(new ObjectNode("{\\"type\\":\\"object\\"}")); JsonSchema schema4 = new JsonSchema(new ObjectNode("{\\"type\\":\\"object\\"}")); JsonSchema schema5 = new JsonSchema(new ObjectNode("{\\"type\\":\\"object\\"}")); Assert.assertTrue(schema1.equals(schema1)); Assert.assertTrue(schema1.equals(schema2));
@Test public void equals() { JsonSchema schema1 = new JsonSchema(new ObjectNode("{\\"type\\":\\"object\\"}")); JsonSchema schema2 = new JsonSchema(new ObjectNode("{\\"type\\":\\"object\\"}")); JsonSchema schema3 = new JsonSchema(new ObjectNode("{\\"type\\":\\"object\\"}")); JsonSchema schema4 = new JsonSchema(new ObjectNode("{\\"type\\":\\"object\\"}")); JsonSchema schema5 = new JsonSchema(new ObjectNode("{\\"type\\":\\"object\\"}")); JsonSchema schema6 = new JsonSchema(new ObjectNode("{\\"type\\":\\"object\\"}")); Assert.assert
@Test public void testEquals() { JsonSchema schema1 = new JsonSchema(new ObjectNode("{\\"type\\":\\"object\\"}")); JsonSchema schema2 = new JsonSchema(new ObjectNode("{\\"type\\":\\"object\\"}")); JsonSchema schema3 = new JsonSchema(new ObjectNode("{\\"type\\":\\"object\\"}")); JsonSchema schema4 = new JsonSchema(new ObjectNode("{\\"type\\":\\"object\\"}")); JsonSchema schema5 = new JsonSchema(new ObjectNode("{\\"type\\":\\"object\\"}")); JsonSchema schema6 = new JsonSchema(new ObjectNode("{\\"type\\":\\"object\\"}")); JsonSchema
@Test public void testEquals() { JsonSchema schema1 = new JsonSchema(new ObjectNode("{\\"type\\":\\"object\\",\\"properties\\":{\\"foo\\":\\"bar\\"}}")); JsonSchema schema2 = new JsonSchema(new ObjectNode("{\\"type\\":\\"object\\",\\"properties\\":{\\"foo\\":\\"bar\\"}}")); JsonSchema schema3 = new JsonSchema(new ObjectNode("{\\"type\\":\\"object\\",\\"properties\\":{\\"foo\\":\\"baz\\"}}")); JsonSchema schema4 = new JsonSchema(new ObjectNode("{\\"type\\":\\"object\\",\\"properties\\":{\\"foo\\":
@Test public void testEquals() { JsonSchema schema1 = new JsonSchema(new ObjectNode("{\\"type\\":\\"object\\"}")); JsonSchema schema2 = new JsonSchema(new ObjectNode("{\\"type\\":\\"object\\"}")); JsonSchema schema3 = new JsonSchema(new ObjectNode("{\\"type\\":\\"object\\"}")); JsonSchema schema4 = new JsonSchema(new ObjectNode("{\\"type\\":\\"object\\"}")); JsonSchema schema5 = new JsonSchema(new ObjectNode("{\\"type\\":\\"object\\"}")); JsonSchema schema6 = new JsonSchema(new ObjectNode("{\\"type\\":\\"object\\"}")); Assert.
@Test public void equals() { JsonSchema schema1 = new JsonSchema(new ObjectNode("{\\"type\\":\\"object\\"}")); JsonSchema schema2 = new JsonSchema(new ObjectNode("{\\"type\\":\\"object\\"}")); JsonSchema schema3 = new JsonSchema(new ObjectNode("{\\"type\\":\\"object\\"}")); JsonSchema schema4 = new JsonSchema(new ObjectNode("{\\"type\\":\\"object\\"}")); JsonSchema schema5 = new JsonSchema(new ObjectNode("{\\"type\\":\\"object\\"}")); JsonSchema schema6 = new JsonSchema(new ObjectNode("{\\"type\\":\\"object\\"}")); JsonSchema schema
@Test public void getDefaultSchemaNode() { JsonNode schemaNode = JsonSchema.getDefaultSchemaNode(); Assert.assertNotNull(schemaNode); Assert.assertEquals("any", schemaNode.get("type").asText()); }
@Test public void getDefaultSchemaNode() { JsonNode schemaNode = JsonSchema.getDefaultSchemaNode(); Assert.assertNotNull(schemaNode); Assert.assertEquals("any", schemaNode.get("type").asText()); }
@Test public void getDefaultSchemaNode() { JsonNode schemaNode = JsonSchema.getDefaultSchemaNode(); Assert.assertNotNull(schemaNode); Assert.assertEquals("any", schemaNode.get("type").asText()); }
@Test public void getDefaultSchemaNode() { JsonNode schemaNode = JsonSchema.getDefaultSchemaNode(); Assert.assertNotNull(schemaNode); Assert.assertEquals("any", schemaNode.get("type").asText()); }
@Test public void testWithClassIntrospector() { ClassIntrospector ci = ClassIntrospectorBuilder.buildDefaultClassIntrospector(); BaseSettings settings = new BaseSettings(ci, new AnnotationIntrospectorBuilder().build(), new VisibilityChecker<Object>(), TypeFactory.DefaultTypeResolverBuilder.INSTANCE, TypeResolverBuilder.DefaultTypeResolverBuilder.INSTANCE, new Locale("en"), TimeZone.getDefault(), null, null); BaseSettings newSettings = settings.withClassIntrospector(ci); assertEquals(ci, newSettings.getClassIntrospector()); assertSame(ci, newSettings.withClassIntrospector(ci)); }
@Test public void testWithClassIntrospector() { ClassIntrospector ci = new ClassIntrospector() { @Override public ClassIntrospector getMethodIntrospector() { return null; } @Override public AnnotationIntrospector getMethodIntrospector() { return null; } @Override public AnnotationIntrospector getMethodIntrospector2() { return null; } @Override public AnnotationIntrospector getMethodIntrospector3() { return null; } }; BaseSettings settings = new BaseSettings(ci, new AnnotationIntrospector() { @Override public ClassIntrospector getMethodIntrospector() { return ci; } @Override public AnnotationIntrospector getMethodIntrospector2() { return ci;
@Test public void testClassIntrospector() { ClassIntrospector ci = new ClassIntrospector() { @Override public ClassIntrospector getClassIntrospector() { return null; } }; BaseSettings settings = new BaseSettings(ci, new AnnotationIntrospector() { @Override public ClassIntrospector getAnnotationIntrospector() { return new AnnotationIntrospector() { @Override public ClassIntrospector getAnnotationIntrospector() { return new AnnotationIntrospector() { @Override public boolean hasProperty(String propName) { return true; } @Override public boolean hasProperty(String propName) { return false; } @Override public boolean hasProperty(String propName) { return false;
@Test(expected = IllegalArgumentException.class) public void differentTimeZone() { final BaseSettings settings = new BaseSettings(new ClassIntrospector(), new AnnotationIntrospectorImpl(), new VisibilityCheckerImpl(), TypeFactory.getDefault(), TypeResolverBuilder.getDefault(), Locale.getDefault(), TimeZone.getDefault(), null); settings.with(TimeZone.getDefault()); }
@Test(expected = IllegalArgumentException.class) public void nullTimeZone() { ClassIntrospector ci = new ClassIntrospector(); AnnotationIntrospectoraiai = new AnnotationIntrospectorImpl(ci); BaseSettings settings = new BaseSettings(ci, aiai, null, null, null, null, null, null, null, null, null); settings.with((TimeZone) null); }
@Test(expected = IllegalArgumentException.class) public void testInvalidTimeZone() { BaseSettings settings = new BaseSettings(null, null, null, null, null, null, null, null, null, null); settings.with(TimeZone.getTimeZone("America/Los_Angeles")); }
@Test(expected = IllegalArgumentException.class) public void testDefaultTimeZone() { final BaseSettings settings = new BaseSettings(null, null, null, null, null, null, null, null, null, null, null); settings.with(TimeZone.getDefault()); }
@Test(expected = IllegalArgumentException.class) public void testDefault() { final BaseSettings settings = new BaseSettings(new ClassIntrospector(), new AnnotationIntrospector(), new VisibilityChecker<Object>(null), TypeFactory.getDefaultTypeFactory(), TypeResolverBuilder.getDefaultTypeResolverBuilder(), new Locale("en", "US"), TimeZone.getDefault(), null, null); settings.with(TimeZone.getDefault()); }
@Test(expected = IllegalArgumentException.class) public void withBadTimeZone() { BaseSettings settings = new BaseSettings(new ClassIntrospector(), new AnnotationIntrospector(), new VisibilityChecker<Object>(), TypeFactory.getDefault(), TypeResolverBuilder.getDefault(), Locale.getDefault(), TimeZone.getDefault(), null); settings.with(TimeZone.getDefault()); }
@Test public void testGetLocale() { Set<Locale> locales = new HashSet<Locale>(); locales.add(Locale.ENGLISH); locales.add(Locale.FRENCH); Locale settings = new BaseSettings(new ClassIntrospector(), new AnnotationIntrospector(), new VisibilityChecker<Object>(Object.class), new TypeFactory(), new TypeResolverBuilder<Object>(), new DateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS"), new PropertyNamingStrategy(), new TypeFactory(), new TypeResolverBuilder<Object>(), Locale.ENGLISH, TimeZone.getDefault(), Locale.FRENCH, TimeZone.getDefault(), null) .withLocale(Locale
@Test public void testGetLocale() { Locale settings = new BaseSettings().withLocale(Locale.GERMAN); assertEquals(Locale.GERMAN, settings.getLocale()); settings = new BaseSettings().withLocale(Locale.CANADA_FRENCH); assertEquals(Locale.CANADA_FRENCH, settings.getLocale()); settings = new BaseSettings().withLocale(Locale.CANADA_FRENCH); assertEquals(Locale.CANADA_FRENCH, settings.getLocale()); settings = new BaseSettings().withLocale(Locale.CANADA_FRENCH); assertEquals(Locale.CANADA_FRENCH
@Test public void testShortBuilder() { ShortBuilder b1 = instance.getShortBuilder(); ShortBuilder b2 = instance._shortBuilder(); Assert.assertEquals(b1.toString(), b2.toString()); }
@Test public void testShortBuilder() { ShortBuilder b1 = instance.getShortBuilder(); ShortBuilder b2 = instance._shortBuilder(); assertEquals(b1.toString(), b2.toString()); }
@Test public void testShortBuilder() { ShortBuilder b1=new ShortBuilder(); ShortBuilder b2=new ShortBuilder(); ShortBuilder b3=new ShortBuilder(); Assert.assertEquals(b1, b2.getShortBuilder()); Assert.assertEquals(b1, b3.getShortBuilder()); Assert.assertEquals(b2, b3.getShortBuilder()); Assert.assertEquals(b3, b2.getShortBuilder()); }
@Test public void testShortBuilder() { ShortBuilder b1 = instance.getShortBuilder(); ShortBuilder b2 = instance._shortBuilder(); assertEquals(b1.toString(), b2.toString()); }
@Test public void testLongBuilder() { BooleanBuilder b1 = new BooleanBuilder(); BooleanBuilder b2 = new BooleanBuilder(); BooleanBuilder b3 = new BooleanBuilder(); BooleanBuilder b4 = b1.getLongBuilder(); Assert.assertEquals(true, b1._booleanBuilder); Assert.assertEquals(true, b2._booleanBuilder); Assert.assertEquals(true, b3._booleanBuilder); Assert.assertEquals(true, b4._booleanBuilder); Assert.assertEquals(true, b1._booleanBuilder); Assert.assertEquals(true, b2._booleanBuilder); Assert.assertEquals(true, b3._booleanBuilder); Assert.assertEquals(true, b4
@Test public void testLongBuilder() { BooleanBuilder b1=new BooleanBuilder(); BooleanBuilder b2=new BooleanBuilder(); BooleanBuilder b3=new BooleanBuilder(); BooleanBuilder b4=new BooleanBuilder(); BooleanBuilder b5=new BooleanBuilder(); BooleanBuilder b6=new BooleanBuilder(); BooleanBuilder b7=new BooleanBuilder(); BooleanBuilder b8=new BooleanBuilder(); BooleanBuilder b9=new BooleanBuilder(); BooleanBuilder b10=new BooleanBuilder(); BooleanBuilder b11=new BooleanBuilder(); BooleanBuilder b12=new BooleanBuilder(); BooleanBuilder b13=new BooleanBuilder(); BooleanBuilder b14=new BooleanBuilder(); BooleanBuilder b21=new BooleanBuilder(); BooleanBuilder b22
@Test public void testLongBuilder() { LongBuilder b1=new LongBuilder(); LongBuilder b2=new LongBuilder(); Assert.assertEquals(b1.getLongBuilder(), b2); Assert.assertEquals(b1.getLongBuilder(), b2); }
@Test public void testLongBuilder() { BooleanBuilder b1=new BooleanBuilder(); BooleanBuilder b2=new BooleanBuilder(); BooleanBuilder b3=new BooleanBuilder(); BooleanBuilder b4=new BooleanBuilder(); BooleanBuilder b5=new BooleanBuilder(); BooleanBuilder b6=new BooleanBuilder(); BooleanBuilder b7=new BooleanBuilder(); BooleanBuilder b8=new BooleanBuilder(); BooleanBuilder b9=new BooleanBuilder(); BooleanBuilder b10=new BooleanBuilder(); BooleanBuilder b11=new BooleanBuilder(); BooleanBuilder b12=new BooleanBuilder(); BooleanBuilder b13=new BooleanBuilder(); BooleanBuilder b14=new BooleanBuilder(); BooleanBuilder b21=new BooleanBuilder(); BooleanBuilder b22
@Test public void testDoubleBuilder() { DoubleBuilder b1 = instance.getDoubleBuilder(); DoubleBuilder b2 = instance._doubleBuilder(); assertEquals(b1, b2); }
@Test public void testDoubleBuilder() { DoubleBuilder b1=new DoubleBuilder(); DoubleBuilder b2=new DoubleBuilder(); DoubleBuilder b3=new DoubleBuilder(); b1.add((byte) 0); b1.add((short) 0); b1.add((long) 0); b1.add((float) 0); b1.add((double) 1); b2.add((double) 2); b2.add((byte) 3); b2.add((short) 4); b2.add((long) 5); b2.add((float) 6); b2.add((double) 7); b2.add((double) 8); b2.add
@Test public void testDoubleBuilder() { DoubleBuilder b1 = instance._doubleBuilder(); DoubleBuilder b2 = instance._doubleBuilder(); assertEquals(b1, b2); assertNotSame(b1, b2); }
@Test public void testDoubleBuilder() { DoubleBuilder b1 = instance.getDoubleBuilder(); DoubleBuilder b2 = instance.getDoubleBuilder(); assertEquals(b1, b2); }
@Test public void testShortBuilder() { ShortBuilder b = new ShortBuilder(); b.append((byte) 0x01); b.append((byte) 0x02); b.append((short) 0x03); b.append((short) 0x04); b.append((short) 0x05); b.append((short) 0x06); b.append((short) 0x07); b.append((short) 0x08); b.append((short) 0x09); b.append((short) 0x10); b.append((short) 0x11); b.append((short) 0x12); b.append((short) 0x13); b
@Test public void test_constructArray() { assertArrayEquals(new short[]{1,2,3}, _constructArray(2)); assertArrayEquals(new short[]{1,2,3}, _constructArray(3)); assertArrayEquals(new short[]{1,2,3}, _constructArray(4)); assertArrayEquals(new short[]{1,2,3,4}, _constructArray(5)); assertArrayEquals(new short[]{1,2,3,4}, _constructArray(6)); assertArrayEquals(new short[]{1,2,3,4}, _constructArray(7)); assertArrayEquals(new short[]{1,2,
@Test public void test_constructArray() { assertArrayEquals( new short[]{0, 1, 2, 3}, new short[]{_byte(0), _byte(1), _byte(2), _byte(3) } ); assertArrayEquals( new short[]{0, 1, 2, 3}, new short[]{_byte(0), _byte(1), _byte(2), _byte(3) } ); assertArrayEquals( new short[]{0, 1, 2, 3}, new short[]{_byte(0), _byte(1), _byte(2), _byte(3) } ); assertArrayEquals( new short[]{0, 1,
@Test public void testLongBuilder() { String[][] data = new String[][] { new String[] { "1", "2", "3" }, new String[] { "4", "5", "6" }, new String[] { "7", "8", "9" }, new String[] { "10", "11", "12" }, new String[] { "13", "14", "15", "16" }, new String[] { "17", "18", "19" }, new String[] { "19", "20", "21", "22", "23" }, new String[] { "21", "22", "23", "24" }, new String[]
@Test public void test_constructArray() { assertArrayEquals(new long[]{1,2,3}, _constructArray(2)); assertArrayEquals(new long[]{1,2,3,4}, _constructArray(3)); assertArrayEquals(new long[]{1,2,3,4}, _constructArray(4)); assertArrayEquals(new long[]{1,2,3,4}, _constructArray(5)); assertArrayEquals(new long[]{1,2,3,4}, _constructArray(6)); assertArrayEquals(new long[]{1,2,3,4}, _constructArray(7)); assertArrayEquals(new long[]{
@Test public void test_constructArray() { assertArrayEquals( new long[]{1, 2, 3, 4}, new long[]{_1, _2, _3, _4} ); assertArrayEquals( new long[]{1, 2, 3, 4}, new long[]{_1, _2, _3, _4} ); assertArrayEquals( new long[]{1, 2, 3, 4}, new long[]{_1, _2, _3, _4} ); assertArrayEquals( new long[]{1, 2, 3, 4}, new long[]{_1, _2, _3, _4} ); assertArrayEquals( new long
@Test public void testDoubleBuilder() { DoubleBuilder b1 = new DoubleBuilder(); b1._add(1); b1._add(2); b1._add(3); DoubleBuilder b2 = new DoubleBuilder(); b2._add(4); b2._add(5); DoubleBuilder b3 = new DoubleBuilder(); b3._add(6); b3._add(7); DoubleBuilder b4 = new DoubleBuilder(); b4._add(8); b4._add(9); DoubleBuilder b5 = new DoubleBuilder(); b5._add(1); b5._add(2); b5._add(3); b5._add(4); b5._
@Test public void test_constructArray() { double[] d1 = _constructArray(2); double[] d2 = _constructArray(3); Assert.assertEquals(d1.length, d2.length); Assert.assertEquals(d1[0], d2[0], 0.01); Assert.assertEquals(d1[1], d2[1], 0.01); Assert.assertEquals(d2[2], d2[2], 0.01); double[] d3 = _constructArray(4); double[] d4 = _constructArray(5); Assert.assertEquals(d3.length, d4.length); Assert.assertEquals(d3
@Test public void test_constructArray() { double[] d1 = _constructArray(2); double[] d2 = _constructArray(3); Assert.assertEquals(d1.length, d2.length); Assert.assertEquals(d1[0], d2[0], 0.01); Assert.assertEquals(d1[1], d2[1], 0.01); Assert.assertEquals(d1[2], d2[2], 0.01); Assert.assertEquals(d2[3], d2[3], 0.01); }
@Test public void getArrayComparator() { final String[] data1 = new String[] {"1", "2", "3", "4", "5"}; final String[] data2 = new String[] {"1", "2", "3", "4", "5"}; final String[] data3 = new String[] {"1", "2", "3", "4", "5"}; final String[] data4 = new String[] {"1", "2", "3", "4", "5"}; final String[] data5 = new String[] {"1", "2", "3", "4", "5"}; final String[] data6 = new String[] {"1", "2",
@Test public void getArrayComparator() { final String[] data1 = new String[] {"1", "2", "3", "4", "5", "6", "7", "8", "9"}; final String[] data2 = new String[] {"1", "2", "3", "4", "5", "6", "7", "8", "9"}; final String[] data3 = new String[] {"1", "2", "3", "4", "5", "6", "7", "8", "9"}; final String[] data4 = new String[] {"1", "2", "3", "4", "5", "6", "7
@Test public void getArrayComparator() { final ArrayList<String> values = new ArrayList<String>(); values.add("1"); values.add("2"); values.add("3"); values.add("4"); values.add("5"); values.add("6"); values.add("7"); values.add("8"); values.add("9"); values.add("10"); values.add("11"); values.add("12"); values.add("13"); values.add("14"); values.add("15"); values.add("16"); values.add("17"); values.add("18"); values.add("19"); values.add("20"); values.add("21"); values
@Test public void getArrayComparator() { final String[] data1 = new String[] {"1", "2", "3", "4", "5", "6", "7", "8", "9"}; final String[] data2 = new String[] {"1", "2", "3", "4", "5", "6", "7", "8", "9"}; final String[] data3 = new String[] {"1", "2", "3", "4", "5", "6", "7", "8", "9"}; final String[] data4 = new String[] {"1", "2", "3", "4", "5", "6", "7
@Test public void getArrayComparator() { final String[] data1 = new String[] {"1", "2", "3", "4", "5"}; final String[] data2 = new String[] {"1", "2", "3", "4", "5"}; final String[] data3 = new String[] {"1", "2", "3", "4", "5"}; final String[] data4 = new String[] {"1", "2", "3", "4", "5"}; final String[] data5 = new String[] {"1", "2", "3", "4", "5"}; final String[] data6 = new String[] {"1", "2",
@Test public void getArrayComparator() { final String[] data1 = new String[] {"1", "2", "3", "4", "5", "6", "7", "8", "9"}; final String[] data2 = new String[] {"1", "2", "3", "4", "5", "6", "7", "8", "9"}; final String[] data3 = new String[] {"1", "2", "3", "4", "5", "6", "7", "8", "9"}; final String[] data4 = new String[] {"1", "2", "3", "4", "5", "6", "7
@Test public void getArrayComparator() { final List<String> lines = Arrays.asList("1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21", "22", "23", "24", "25", "26", "26", "25", "26", "26", "26", "26", "26", "26", "26", "26", "26", "26", "26", "26", "26", "26", "26",
@Test public void getArrayComparator() { final String[] data1 = new String[] {"1", "2", "3", "4", "5", "6", "7", "8", "9"}; final String[] data2 = new String[] {"1", "2", "3", "4", "5", "6", "7", "8", "9"}; final String[] data3 = new String[] {"1", "2", "3", "4", "5", "6", "7", "8", "9"}; final String[] data4 = new String[] {"1", "2", "3", "4", "5", "6", "7
@Test public void getArrayComparator() { final String[] data1 = new String[] {"1", "2", "3", "4", "5", "6", "7", "8", "9"}; final String[] data2 = new String[] {"1", "2", "3", "4", "5", "6", "7", "8", "9"}; final String[] data3 = new String[] {"1", "2", "3", "4", "5", "6", "7", "8", "9"}; final String[] data4 = new String[] {"1", "2", "3", "4", "5", "6", "7
@Test public void getArrayComparator() { final ArrayList<String> values = new ArrayList<String>(); values.add("1"); values.add("2"); values.add("3"); values.add("4"); values.add("5"); values.add("6"); values.add("7"); values.add("8"); values.add("9"); values.add("10"); values.add("11"); values.add("12"); values.add("13"); values.add("14"); values.add("15"); values.add("16"); values.add("17"); values.add("18"); values.add("19"); values.add("20"); values.add("21"); values
@Test public void getArrayComparator() { final ArrayList<String> values = new ArrayList<String>(); values.add("1"); values.add("2"); values.add("3"); values.add("4"); values.add("5"); values.add("6"); values.add("7"); values.add("8"); values.add("9"); values.add("10"); values.add("11"); values.add("12"); values.add("13"); values.add("14"); values.add("15"); values.add("16"); values.add("17"); values.add("18"); values.add("19"); values.add("20"); values.add("21"); values
@Test public void getArrayComparator() { final String[] data1 = new String[] {"1", "2", "3", "4", "5", "6", "7", "8", "9"}; final String[] data2 = new String[] {"1", "2", "3", "4", "5", "6", "7", "8", "9"}; final String[] data3 = new String[] {"1", "2", "3", "4", "5", "6", "7", "8", "9"}; final String[] data4 = new String[] {"1", "2", "3", "4", "5", "6", "7
@Test public void getArrayComparator() { final String[] data1 = new String[] {"1", "2", "3", "4", "5", "6", "7", "8", "9"}; final String[] data2 = new String[] {"1", "2", "3", "4", "5", "6", "7", "8", "9"}; final String[] data3 = new String[] {"1", "2", "3", "4", "5", "6", "7", "8", "9"}; final String[] data4 = new String[] {"1", "2", "3", "4", "5", "6", "7
@Test public void getArrayComparator() { final String[] data1 = new String[] {"1", "2", "3", "4", "5", "6", "7", "8", "9"}; final String[] data2 = new String[] {"1", "2", "3", "4", "5", "6", "7", "8", "9"}; final String[] data3 = new String[] {"1", "2", "3", "4", "5", "6", "7", "8", "9"}; final String[] data4 = new String[] {"1", "2", "3", "4", "5", "6", "7
@Test public void getArrayComparator() { final String[] data1 = new String[] {"1", "2", "3", "4", "5", "6", "7", "8", "9"}; final String[] data2 = new String[] {"1", "2", "3", "4", "5", "6", "7", "8", "9"}; final String[] data3 = new String[] {"1", "2", "3", "4", "5", "6", "7", "8", "9"}; final String[] data4 = new String[] {"1", "2", "3", "4", "5", "6", "7
@Test public void testWithAbstractTypeResolver() { List<AbstractTypeResolver> abstractTypeResolvers = new ArrayList<AbstractTypeResolver>(); abstractTypeResolvers.add(new AbstractTypeResolver() { @Override public TypeResolver getTypeResolver() { return TypeResolver.get(String.class); } }); abstractTypeResolvers.add(new AbstractTypeResolver() { @Override public TypeResolver getTypeResolver() { return TypeResolver.get(Integer.class); } }); abstractTypeResolvers.add(new AbstractTypeResolver() { @Override public TypeResolver getTypeResolver() { return TypeResolver.get(String.class); } }); DeserializerFactoryConfig config = new DeserializerFactoryConfig() .withAbstractTypeResolver(AbstractType
@Test public void testWithAbstractTypeResolver() { List<AbstractTypeResolver> abstractTypeResolvers = new ArrayList<AbstractTypeResolver>(); abstractTypeResolvers.add(new MockTypeResolver()); abstractTypeResolvers.add(new MockTypeResolver()); AbstractTypeResolver r1 = new MockAbstractTypeResolver(abstractTypeResolvers); AbstractTypeResolver r2 = new MockAbstractTypeResolver(abstractTypeResolvers); AbstractTypeResolver r3 = new MockAbstractTypeResolver(null); AbstractTypeResolver r4 = new MockAbstractTypeResolver(null); AbstractTypeResolver r5 = new MockAbstractTypeResolver(abstractTypeResolvers); DeserializerFactoryConfig config = new DeserializerFactoryConfig() .withAbstractTypeResolver(r1)
@Test public void testWithAbstractTypeResolver() { assertNotNull("Deserializers should not be null", _deserializerFactory.withAbstractTypeResolver(_resolver1)); assertNotNull("Deserializers should not be null", _deserializerFactory.withAbstractTypeResolver(_resolver2)); assertNotNull("Deserializers should not be null", _deserializerFactory.withAbstractTypeResolver(_resolver3)); }
@Test public void testWithAbstractTypeResolver() { List<AbstractTypeResolver> abstractTypeResolvers = new ArrayList<AbstractTypeResolver>(); abstractTypeResolvers.add(TypeResolver.get(String.class)); abstractTypeResolvers.add(TypeResolver.get(Boolean.class)); abstractTypeResolvers.add(TypeResolver.get(Byte.class)); abstractTypeResolvers.add(TypeResolver.get(Short.class)); abstractTypeResolvers.add(TypeResolver.get(Integer.class)); abstractTypeResolvers.add(TypeResolver.get(Long.class)); abstractTypeResolvers.add(TypeResolver.get(Float.class)); abstractTypeResolvers.add(TypeResolver.get(Double.class
@Test public void testUnwrappingBeanPropertyWriter() throws Exception { BeanPropertyWriter propertyWriter = new UnwrappingBeanPropertyWriter(this.writer, this.nameTransformer); propertyWriter.serializeAsField(this.bean, this.jgen, this.provider); }
@Test public void testUnwrappingBeanPropertyWriter() throws Exception { BeanPropertyWriter propertyWriter = new UnwrappingBeanPropertyWriter(new DefaultBeanPropertyWriter(), new DefaultNameTransformer()); propertyWriter.assignSerializer(new JsonSerializer<Object>() { @Override public JsonSerializer<Object> _findAndAddDynamic(PropertySerializerMap map, Class<?> type, SerializerProvider provider) throws JsonMappingException { return new JsonSerializer<Object>() { @Override public <T> T _findAndAddDynamic(PropertySerializerMap map, Class<?> type, SerializerProvider provider) throws JsonMappingException { return super._findAndAddDynamic(map, type, provider); } @Override public String serialize
@Test public void testUnwrappingBeanPropertyWriter() throws Exception { NameTransformer nameTransformer = new DefaultNameTransformer(); UnwrappingBeanPropertyWriter propertyWriter = new UnwrappingBeanPropertyWriter(new DefaultBeanPropertyWriter(), nameTransformer); propertyWriter.rename(nameTransformer); JsonGenerator jgen = mock(JsonGenerator.class); propertyWriter.serializeAsField(new Object(), jgen, null); verify(jgen).close(); }
@Test public void serializeAsField() throws Exception { SimpleNameTransformer nameTransformer = new SimpleNameTransformer("name"); SimpleNameBean bean = new SimpleNameBean(); bean.setName(nameTransformer); JsonGenerator jgen = mock(JsonGenerator.class); SerializerProvider provider = mock(SerializerProvider.class); new UnwrappingBeanPropertyWriter(null, nameTransformer).serializeAsField(bean, jgen, provider); verify(jgen).writeFieldName("name"); }
@Test public void serializeAsField() throws Exception { SimpleNameTransformer nameTransformer = new SimpleNameTransformer("name"); SimpleNameTransformer nameTransformer2 = new SimpleNameTransformer("name2"); SimpleNameTransformer nameTransformer3 = new SimpleNameTransformer("name3"); SimpleNameTransformer nameTransformer4 = new SimpleNameTransformer("name4"); SimpleNameTransformer nameTransformer5 = new SimpleNameTransformer("name5"); SimpleNameTransformer nameTransformer6 = new SimpleNameTransformer("name6"); SimpleNameTransformer nameTransformer7 = new SimpleNameTransformer("name7"); SimpleNameTransformer nameTransformer8 = new SimpleNameTransformer("name8"); SimpleNameTransformer nameTransformer9 = new SimpleNameTransformer("name9"); SimpleNameTransformer name
@Test public void serializeAsField() throws Exception { SimpleNameTransformer nameTransformer = new SimpleNameTransformer(); SimpleNameTransformer nameTransformer2 = new SimpleNameTransformer(); SimpleNameTransformer nameTransformer3 = new SimpleNameTransformer(); SimpleNameTransformer nameTransformer4 = new SimpleNameTransformer(); SimpleNameTransformer nameTransformer5 = new SimpleNameTransformer(); SimpleNameTransformer nameTransformer6 = new SimpleNameTransformer(); SimpleNameTransformer nameTransformer7 = new SimpleNameTransformer(); SimpleNameTransformer nameTransformer8 = new SimpleNameTransformer(); SimpleNameTransformer nameTransformer9 = new SimpleNameTransformer(); SimpleNameTransformer nameTransformer10 = new SimpleNameTransformer(); SimpleNameTransformer nameTransformer11 = new SimpleNameTransformer(); SimpleNameTransformer nameTransformer12
@Test public void serializeAsField() throws Exception { JsonSerializer<Object> ser = new JsonSerializer<Object>() { @Override public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws Exception { super.serialize(value, jgen, provider); } }; SimpleNameTransformer nameTransformer = new SimpleNameTransformer(); SimpleNameTransformer nameTransformer2 = new SimpleNameTransformer(); SimpleNameTransformer nameTransformer3 = new SimpleNameTransformer(); SimpleNameTransformer nameTransformer4 = new SimpleNameTransformer(); SimpleNameTransformer nameTransformer5 = new SimpleNameTransformer(); SimpleNameTransformer nameTransformer6 = new SimpleNameTransformer(); SimpleNameTransformer nameTransformer7 = new SimpleNameTransformer(); SimpleNameTransformer name
@Test public void serializeAsField() throws Exception { SimpleNameTransformer nameTransformer = new SimpleNameTransformer(); SimpleNameTransformer nameTransformer2 = new SimpleNameTransformer(); SimpleNameTransformer nameTransformer3 = new SimpleNameTransformer(); SimpleNameTransformer nameTransformer4 = new SimpleNameTransformer(); SimpleNameTransformer nameTransformer5 = new SimpleNameTransformer(); SimpleNameTransformer nameTransformer6 = new SimpleNameTransformer(); SimpleNameTransformer nameTransformer7 = new SimpleNameTransformer(); SimpleNameTransformer nameTransformer8 = new SimpleNameTransformer(); SimpleNameTransformer nameTransformer9 = new SimpleNameTransformer(); SimpleNameTransformer nameTransformer10 = new SimpleNameTransformer(); SimpleNameTransformer nameTransformer11 = new SimpleNameTransformer(); SimpleNameTransformer nameTransformer12
@Test public void serializeAsField() throws Exception { UnwrappingBeanPropertyWriter w = new UnwrappingBeanPropertyWriter(null, null); SimpleNameTransformer nameTransformer = new SimpleNameTransformer(); w.setName(nameTransformer); w.assignSerializer(new JsonSerializer<Object>() { @Override public JsonSerializer<Object> serialize(Object value, JsonGenerator jgen, SerializerProvider prov) throws Exception { return new JsonSerializer<Object>() { @Override public boolean isUnwrappingSerializer() { return true; } @Override public JsonSerializer<Object> serializeWithType(Object value, JsonGenerator jgen, SerializerProvider prov) throws Exception { return null; } @Override public JsonSerializer
@Test public void serializeAsField() throws Exception { SimpleNameTransformer nameTransformer = new SimpleNameTransformer(); SimpleNameTransformer nameTransformer2 = new SimpleNameTransformer(); SimpleNameTransformer nameTransformer3 = new SimpleNameTransformer(); SimpleNameTransformer nameTransformer4 = new SimpleNameTransformer(); SimpleNameTransformer nameTransformer5 = new SimpleNameTransformer(); SimpleNameTransformer nameTransformer6 = new SimpleNameTransformer(); SimpleNameTransformer nameTransformer7 = new SimpleNameTransformer(); SimpleNameTransformer nameTransformer8 = new SimpleNameTransformer(); SimpleNameTransformer nameTransformer9 = new SimpleNameTransformer(); SimpleNameTransformer nameTransformer10 = new SimpleNameTransformer(); SimpleNameTransformer nameTransformer11 = new SimpleNameTransformer(); SimpleNameTransformer nameTransformer12
@Test public void serializeAsField() throws Exception { UnwrappingBeanPropertyWriter w = new UnwrappingBeanPropertyWriter(null, null); JsonGenerator jgen = mock(JsonGenerator.class); SerializerProvider provider = mock(SerializerProvider.class); w.setSerializer(new JsonSerializer<Object>() { @Override public JsonSerializer<Object> createSerializer() { return new JsonSerializer<Object>() { @Override public void serialize(Object value, JsonGenerator jgen, SerializerProvider prov) throws Exception { super.createSerializer(); } @Override public void serializeWithType(Object value, JsonGenerator jgen, SerializerProvider provider, JsonSerializer<Object> ser) throws Exception { super.serialize
@Test public void serializeAsField() throws Exception { SimpleNameTransformer nameTransformer = new SimpleNameTransformer(); SimpleNameTransformer nameTransformer2 = new SimpleNameTransformer(); SimpleNameTransformer nameTransformer3 = new SimpleNameTransformer(); SimpleNameTransformer nameTransformer4 = new SimpleNameTransformer(); SimpleNameTransformer nameTransformer5 = new SimpleNameTransformer(); SimpleNameTransformer nameTransformer6 = new SimpleNameTransformer(); SimpleNameTransformer nameTransformer7 = new SimpleNameTransformer(); SimpleNameTransformer nameTransformer8 = new SimpleNameTransformer(); SimpleNameTransformer nameTransformer9 = new SimpleNameTransformer(); SimpleNameTransformer nameTransformer10 = new SimpleNameTransformer(); SimpleNameTransformer nameTransformer11 = new SimpleNameTransformer(); SimpleNameTransformer nameTransformer12
@Test public void serializeAsField() throws Exception { SimpleNameTransformer nameTransformer = new SimpleNameTransformer("name"); SimpleNameBean bean = new SimpleNameBean(); bean.setName(nameTransformer); SimpleNameBean bean2 = new SimpleNameBean(); bean2.setName(nameTransformer); SimpleNameBean bean3 = new SimpleNameBean(); bean3.setName(nameTransformer); SimpleNameBean bean4 = new SimpleNameBean(); bean4.setName(nameTransformer); SimpleNameBean bean5 = new SimpleNameBean(); bean5.setName(nameTransformer); SimpleNameBean bean6 = new SimpleNameBean(); bean6.setName(nameTransformer); SimpleNameBean bean7 =
@Test public void testAssignSerializer() throws Exception { JsonSerializer<Object> ser = new JsonSerializer<Object>() { @Override public void serializeAsField(Object bean, JsonGenerator jgen, SerializerProvider provider) throws Exception { super.serializeAsField(bean, jgen, provider); } @Override public void assignSerializer(JsonSerializer<Object> ser) throws Exception { super.assignSerializer(ser); } @Override public void serializeAsField(Object bean, JsonGenerator jgen, SerializerProvider provider) throws Exception { super.serializeAsField(bean, jgen, provider); } @Override public void assignSerializer(JsonSerializer<Object> ser) throws Exception { super.assignSerializer(ser
@Test public void testAssignSerializer() throws Exception { JsonSerializer<Object> ser = new JsonSerializer<Object>() { @Override public void serializeAsField(Object bean, JsonGenerator jgen, SerializerProvider provider) throws Exception { super.serializeAsField(bean, jgen, provider); } @Override public Object deserializeAsField(Object bean, JsonGenerator jgen, SerializerProvider provider) throws Exception { return null; } @Override public Object deserializeAsField(Object bean, JsonGenerator jgen, SerializerProvider provider) throws Exception { return null; } @Override public Object deserializeAsField(Object bean, JsonGenerator jgen, SerializerProvider provider) throws Exception { return null; } @Override public Object
@Test public void testAssignSerializer() throws Exception { JsonSerializer<Object> ser = new JsonSerializer<Object>() { @Override public void serializeAsField(Object bean, JsonGenerator jgen, SerializerProvider provider) throws Exception { super.serializeAsField(bean, jgen, provider); } @Override public Object deserializeAsField(Object bean, JsonGenerator jgen, SerializerProvider provider) throws Exception { return null; } @Override public Object deserializeAsField(Object bean, JsonGenerator jgen, SerializerProvider provider) throws Exception { return null; } @Override public Object deserializeAsField(Object bean, JsonGenerator jgen, SerializerProvider provider) throws Exception { return null; } @Override public Object
@Test public void testAssignSerializer() throws Exception { JsonSerializer<Object> ser = new JsonSerializer<Object>() { @Override public void serializeAsField(Object bean, JsonGenerator jgen, SerializerProvider provider) throws Exception { super.serializeAsField(bean, jgen, provider); } @Override public void assignSerializer(JsonSerializer<Object> ser) throws Exception { super.assignSerializer(ser); } @Override public void serializeAsField(Object bean, JsonGenerator jgen, SerializerProvider provider) throws Exception { super.serializeAsField(bean, jgen, provider); } @Override public void assignSerializer(JsonSerializer<Object> ser) throws Exception { super.assignSerializer(ser
@Test public void testAssignSerializer() throws Exception { JsonSerializer<Object> ser = new JsonSerializer<Object>() { @Override public void serializeAsField(Object bean, JsonGenerator jgen, SerializerProvider provider) throws Exception { super.serializeAsField(bean, jgen, provider); } @Override public boolean isUnwrappingSerializer() { return false; } @Override public NameTransformer nameTransformer(NameTransformer nameTransformer) { return nameTransformer; } @Override public JsonSerializer<Object> unwrappingSerializer(NameTransformer nameTransformer) { return nameSerializer; } @Override public JsonSerializer<Object> unwrappingSerializer(NameTransformer nameTransformer) { return nameSerializer; } @Override public
@Test public void testAssignSerializer() throws Exception { JsonSerializer<Object> ser = new JsonSerializer<Object>() { @Override public void serializeAsField(Object bean, JsonGenerator jgen, SerializerProvider provider) throws Exception { super.serializeAsField(bean, jgen, provider); } @Override public Object deserializeAsField(Object bean, JsonGenerator jgen, SerializerProvider provider) throws Exception { return null; } @Override public Object deserializeAsField(Object bean, JsonGenerator jgen, SerializerProvider provider) throws Exception { return null; } @Override public Object deserializeAsField(Object bean, JsonGenerator jgen, SerializerProvider provider) throws Exception { return null; } @Override public Object
@Test public void createContextual() throws JsonMappingException { SerializerProvider provider = Mockito.mock(SerializerProvider.class); BeanProperty property = Mockito.mock(BeanProperty.class); Mockito.when(property.getMember()).thenReturn(null); Mockito.when(property.getTypeFactory()).thenReturn(new SimpleTypeFactory()); Mockito.when(provider.getAnnotationIntrospector()).thenReturn(new AnnotationIntrospector()); Mockito.when(provider.constructType(Mockito.eq(String.class))).thenReturn(String.class); Mockito.when(provider.constructTypeParameters(Mockito.eq(String.class), Mock
@Test public void createContextual() throws JsonMappingException { SerializerProvider provider = new SerializerProvider() { @Override public Class<?> getTypeFactory() { return Object.class; } @Override public Class<?> annotationType() { return Object.class; } @Override public Class<? extends AnnotationIntrospector> annotationType() { return AnnotationIntrospector.class; } @Override public AnnotatedMember getMember() { return null; } }; BeanProperty property = mock(BeanProperty.class); JsonSerializer<?> jsonSerializer = _testee.createContextual(provider, property); assertTrue(jsonSerializer instanceof JsonSerializer); }
@Test public void serializeWithType() throws IOException { BeanPropertyWriter[] properties = new BeanPropertyWriter[1]; BeanPropertyWriter[] filteredProperties = new BeanPropertyWriter[1]; SimpleTypeSerializer typeSerializer = new SimpleTypeSerializer(); BeanSerializerBase serializer = new BeanSerializerBase(SimpleType.class, null, properties, filteredProperties) { @Override public void serializeFields(Object object, JsonGenerator jgen, SerializerProvider provider) throws JsonMappingException, JsonGenerationException { super.serializeFields(object, jgen, provider); } @Override public void writeCustomTypeSuffixForObject(Object object, JsonGenerator jgen, SerializerProvider provider) throws JsonMappingException { super.writeCustomTypeSuffixFor
@Test public void serializeWithType() throws IOException { BeanPropertyWriter[] props = new BeanPropertyWriter[1]; props[0] = new BeanPropertyWriter() { @Override public void writeProperty(Object object, JsonGenerator jgen, SerializerProvider provider) { } @Override public void writeCustomTypePrefixForObject(Object object, JsonGenerator jgen, SerializerProvider provider) { } @Override public void writeCustomTypeSuffixForObject(Object object, JsonGenerator jgen, SerializerProvider provider) { } }; SimpleTypeSerializer typeSerializer = new SimpleTypeSerializer(); BeanSerializerBase serializer = new BeanSerializerBase(SimpleType.class, null, props, typeSerializer); serializer.serializeWithType(new
@Test public void serializeWithType_customTypeId() throws IOException { BeanPropertyWriter[] properties = new BeanPropertyWriter[1]; properties[0] = new BeanPropertyWriterImpl(null); SimpleBean bean = new SimpleBean(); bean.setField1("aaa"); bean.setField2("bbb"); bean.setField3("ccc"); BeanSerializerBase serializer = new SimpleBeanSerializerBase(SimpleBean.class, null, properties, null); serializer.serializeWithType(bean, jgen, new DefaultSerializerProvider(), new DefaultTypeSerializer()); jgen.flush(); String expected = "{\\"field1\\":\\"aaa\\",\\"field2\\":\\"bbb\\",\\"field3
@Test public void serializeWithType() throws IOException { BeanPropertyWriter[] properties = new BeanPropertyWriter[1]; BeanPropertyWriter[] filteredProperties = new BeanPropertyWriter[1]; SimpleTypeSerializer typeSer = new SimpleTypeSerializer(); BeanSerializerBase serializer = new BeanSerializerBase(SimpleType.class, null, null, null) { @Override public void serializeFields(BeanPropertyWriter[] properties, JsonGenerator jgen, SerializerProvider provider) throws JsonMappingException, JsonGenerationException { super.serializeFields(properties, provider); } @Override public void writeCustomTypeSuffixForObject(BeanPropertyWriter[] properties, JsonGenerator jgen, SerializerProvider provider) throws JsonGenerationException { super.writeFields(
@Test public void serializeWithType() throws IOException { final SimpleTypeSerializer typeSerializer = new SimpleTypeSerializer(SimpleType.class); final SimpleTypeSerializerBuilder builder = new SimpleTypeSerializerBuilder(SimpleType.class); BeanSerializerBase serializer = new BeanSerializerBase(SimpleType.class, builder, new BeanPropertyWriter[] {}, new BeanPropertyWriter[] {}); serializer.serializeWithType(new SimpleType(), builder, null, typeSerializer); }
@Test public void serializeWithType() throws IOException { BeanPropertyWriter[] properties = new BeanPropertyWriter[1]; BeanPropertyWriter[] filteredProperties = new BeanPropertyWriter[1]; SimpleTypeSerializer typeSer = new SimpleTypeSerializer(); BeanSerializerBase serializer = new BeanSerializerBase(SimpleType.class, null, properties, filteredProperties) { @Override public void serializeFields(BeanPropertyWriter[] properties, JsonGenerator jgen, SerializerProvider provider) throws JsonMappingException, JsonGenerationException { super.serializeFields(properties, jgen, provider); } }; serializer.serializeWithType(new SimpleBean(), jgen, null, typeSer); }
@Test public void serializeWithType() throws IOException { BeanPropertyWriter[] properties = new BeanPropertyWriter[1]; BeanPropertyWriter[] filteredProperties = new BeanPropertyWriter[1]; SimpleTypeSerializer typeSer = new SimpleTypeSerializer(); BeanSerializerBase serializer = new BeanSerializerBase(SimpleType.class, null, properties, filteredProperties) { @Override public void writeCustomTypePrefixForObject(Object object, JsonGenerator jgen, SerializerProvider provider) { super.writeCustomTypePrefixForObject(object, jgen, provider); } @Override public void writeCustomTypeSuffixForObject(Object object, JsonGenerator jgen, SerializerProvider provider) { super.writeCustomTypeSuffixForObject(object,
@Test public void serializeWithType() throws IOException { BeanPropertyWriter[] properties = new BeanPropertyWriter[1]; BeanPropertyWriter[] filteredProperties = new BeanPropertyWriter[1]; SimpleTypeSerializer typeSer = new SimpleTypeSerializer(); BeanSerializerBase serializer = new BeanSerializerBase(SimpleType.class, null, null, null) { @Override public void serializeFields(BeanPropertyWriter[] properties, JsonGenerator jgen, SerializerProvider provider) throws JsonMappingException, JsonGenerationException { super.serializeFields(properties, provider); } @Override public void writeCustomTypeSuffixForObject(BeanPropertyWriter[] properties, JsonGenerator jgen, SerializerProvider provider) throws JsonGenerationException { super.writeFields(
@Test public void serializeWithType() throws IOException { final SimpleTypeSerializer typeSerializer = new SimpleTypeSerializer(); final SimpleTypeSerializerBuilder builder = new SimpleTypeSerializerBuilder(); BeanSerializerBase serializer = new BeanSerializerBase(SimpleType.class, builder, null, null) { @Override public void serializeWithType(Object object, JsonGenerator jgen, SerializerProvider provider, TypeSerializer typeSerializer) throws IOException, JsonGenerationException { super.serializeWithType(object, jgen, provider, typeSerializer); } }; final SimpleType simpleType = new SimpleType(); SimpleType simpleType2 = new SimpleType(); SimpleType simpleType3 = new SimpleType(); SimpleType simpleType4 = new SimpleType
@Test public void serializeWithObjectId() throws IOException, JsonGenerationException { ObjectIdWriter objectIdWriter = mock(ObjectIdWriter.class); final SimpleSerializerProvider provider = new SimpleSerializerProvider(); final SimpleSerializer simpleSerializer = mock(SimpleSerializer.class); final ObjectIdWriter objectIdWriter = mock(ObjectIdWriter.class); final SimpleSerializer simpleSerializer2 = mock(SimpleSerializer.class); final SimpleSerializer simpleSerializer3 = mock(SimpleSerializer.class); final ObjectIdWriter objectIdWriter = mock(ObjectIdWriter.class); final SimpleSerializer simpleSerializer4 = mock(SimpleSerializer.class); final SimpleSerializer simpleSerializer5 = mock(SimpleSerializer.class); final SimpleSerializer simpleSerializer6 = mock(SimpleSerializer.class); final
@Test public void serializeWithObjectId() throws IOException, JsonGenerationException { ObjectIdWriter objectIdWriter = mock(ObjectIdWriter.class); final SimpleSerializerProvider provider = new SimpleSerializerProvider(); final SimpleBean bean = new SimpleBean(); BeanPropertyWriter[] properties = new BeanPropertyWriter[] { mock(BeanPropertyWriter.class), mock(BeanPropertyWriter.class)}; BeanPropertyWriter[] filteredProperties = new BeanPropertyWriter[] { mock(BeanPropertyWriter.class), mock(BeanPropertyWriter.class)}; when(provider.findObjectId(bean, generator)).thenReturn(objectIdWriter); serializer.serializeWithObjectId(bean, generator, provider, true); verify(objectIdWriter).serialize(object
@Test public void serializeFieldsFiltered_throwsException_throwsException() throws Exception { JsonGenerator jgen = mock(JsonGenerator.class); SerializerProvider provider = mock(SerializerProvider.class); when(provider.getActiveView()).thenReturn(null); BeanSerializerBuilder builder = new BeanSerializerBuilder(); BeanPropertyWriter[] properties = new BeanPropertyWriter[]{new BeanPropertyWriter("name", true), new BeanPropertyWriter("age", true)}; BeanSerializerBase src = new BeanSerializerBase(String.class, builder, properties, null); try { src.serializeFieldsFiltered(new TestBean(), jgen, provider); Assert.fail("Expected exception"); } catch (Exception e) { Assert.
@Test public void serializeFieldsFiltered() throws Exception { SimpleBean bean = new SimpleBean(); BeanPropertyWriter[] props = new BeanPropertyWriter[1]; props[0] = new BeanPropertyWriter() { @Override public void serializeAsField(Object bean, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { super.serializeAsField(bean, jgen, provider); } @Override public void serializeAsField(Object bean, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { super.serializeAsField(bean, jgen, provider); } @Override public void serializeAsField(Object bean, JsonGenerator jgen, SerializerProvider provider) throws IOException,
@Test public void serializeFieldsFiltered() throws Exception { SimpleBeanSerializerBuilder builder = new SimpleBeanSerializerBuilder(); BeanPropertyWriter[] properties = new BeanPropertyWriter[1]; BeanPropertyWriter[] filteredProperties = new BeanPropertyWriter[1]; SimpleBean simpleBean = new SimpleBean(); SimpleBean simpleBean2 = new SimpleBean(); SimpleBean simpleBean3 = new SimpleBean(); SimpleBean simpleBean4 = new SimpleBean(); SimpleBean simpleBean5 = new SimpleBean(); SimpleBean simpleBean6 = new SimpleBean(); SimpleBean simpleBean7 = new SimpleBean(); SimpleBean simpleBean8 = new SimpleBean(); SimpleBean simpleBean9 = new SimpleBean(); SimpleBean simpleBean10 = new SimpleBean
@Test public void serializeFieldsFiltered() throws Exception { SimpleBean bean = new SimpleBean(); BeanPropertyWriter[] props = new BeanPropertyWriter[1]; props[0] = new BeanPropertyWriter() { @Override public void serializeAsField(Bean bean, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { super.serializeAsField(bean, jgen, provider); } @Override public void serializeAsField(Bean bean, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { super.serializeAsField(bean, jgen, provider); } @Override public void serializeAsField(Bean bean, JsonGenerator jgen, SerializerProvider provider) throws IOException,
@Test public void simple_serialization() throws Exception { SimpleSerializerBuilder builder = new SimpleSerializerBuilder(); SimpleSerializer simpleSerializer = builder.build(SimpleSerializer.class); SimpleSerializerProvider provider = new SimpleSerializerProvider(); SimpleSerializer simpleSerializer2 = new SimpleSerializer(SimpleSerializer.class); SimpleSerializer simpleSerializer3 = new SimpleSerializer(SimpleSerializer.class); SimpleSerializer simpleSerializer4 = new SimpleSerializer(SimpleSerializer.class); SimpleSerializer simpleSerializer5 = new SimpleSerializer(SimpleSerializer.class); SimpleSerializer simpleSerializer6 = new SimpleSerializer(SimpleSerializer.class); SimpleSerializer simpleSerializer7 = new SimpleSerializer(SimpleSerializer.class); SimpleSerializer simpleSerializer8 = new SimpleSerializer(SimpleSerializer
@Test public void serializeFieldsFiltered_noFilter() throws IOException, JsonGenerationException { SimpleBean testBean = new SimpleBean(); JsonGenerator jgen = mock(JsonGenerator.class); SerializerProvider provider = mock(SerializerProvider.class); when(provider.getActiveView()).thenReturn(testBean); BeanPropertyFilter filter = new BeanPropertyFilter(); filter.serializeAsField(testBean, jgen, provider); verify(jgen, times(1)).writeFieldName(eq("field1")); verify(jgen, times(1)).writeFieldName(eq("field2")); verify(jgen, times(1)).writeObject(eq(testBean)); }
@Test public void serializeFieldsFiltered() throws Exception { SimpleBean bean = new SimpleBean(); BeanPropertyWriter[] properties = new BeanPropertyWriter[1]; properties[0] = new BeanPropertyWriter() { @Override public void serializeAsField(Bean bean, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { super.serializeAsField(bean, jgen, provider); } @Override public void serializeAsField(Bean bean, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { super.serializeAsField(bean, jgen, provider); } @Override public void serializeAsField(Bean bean, JsonGenerator jgen, SerializerProvider provider) throws IOException,
@Test public void serializeFieldsFiltered_throwsException() throws Exception { SimpleBean bean = new SimpleBean(); BeanPropertyWriter[] properties = new BeanPropertyWriter[1]; BeanPropertyWriter[] filteredProperties = new BeanPropertyWriter[1]; BeanPropertyFilter filter = new BeanPropertyFilter() { @Override public boolean serializeAsField(Bean bean, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { throw new StackOverflowError(); } @Override public void serializeAsField(Bean bean, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { throw new StackOverflowError(); } }; SimpleSerializerBuilder builder = new SimpleSerializerBuilder(); SimpleSerializerProvider provider = new SimpleSerializer
@Test public void serializeFieldsFiltered_throwsException() throws Exception { SimpleBeanType type = new SimpleBeanType(); BeanSerializerBuilder builder = new BeanSerializerBuilder(type); SimpleBeanType beanType = new SimpleBeanType(); BeanPropertyWriter[] properties = new BeanPropertyWriter[1]; BeanPropertyWriter[] filteredProperties = new BeanPropertyWriter[1]; BeanPropertyFilter filter = new BeanPropertyFilter() { @Override public boolean serializeAsField(SimpleBean simpleBean, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { throw new StackOverflowError(); } @Override public void serializeAsField(SimpleBean simpleBean, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGeneration
@Test public void serializeFieldsFiltered_throwsException() throws IOException, JsonGenerationException { final SimpleBeanType type = new SimpleBeanType(); type.setField1("field1"); type.setField2("field2"); final SimpleBeanType type2 = new SimpleBeanType(); type2.setField1("field1"); type2.setField2("field2"); final SimpleBeanType type3 = new SimpleBeanType(); type3.setField1("field1"); type3.setField2("field2"); type3.setField3("field3"); final SimpleBeanType type4 = new SimpleBeanType(); type4.setField1("field1"); type4.setField
@Test public void serializeFieldsFiltered() throws Exception { SimpleBeanType type = new SimpleBeanType(); BeanSerializerBuilder builder = new BeanSerializerBuilder(type); BeanPropertyWriter[] properties = new BeanPropertyWriter[]{new BeanPropertyWriter("field1", true), new BeanPropertyWriter("field2", true)}; SimpleSerializerProvider provider = new SimpleSerializerProvider(); SimpleBeanType beanType = new SimpleBeanType(); beanType.setField1("field1"); beanType.setField2("field2"); SimpleBeanType beanType1 = new SimpleBeanType(); beanType1.setField1("field1"); beanType1.setField2("field2"); SimpleBeanType beanType2 =
@Test public void serializeFieldsFiltered_noFilters() throws Exception { SimpleValueBean testBean = new SimpleValueBean(); JsonGenerator jgen = mock(JsonGenerator.class); SerializerProvider provider = mock(SerializerProvider.class); when(provider.getActiveView()).thenReturn(null); BeanPropertyFilter filter = new BeanPropertyFilter(); filter.serializeAsField(testBean, jgen, provider); verify(jgen, times(0)).writeStartObject(); verify(jgen, times(0)).writeObject(any(SimpleValueBean.class)); verify(jgen, times(0)).writeObject(any(SimpleValueBean.class)); verifyNoMoreInteractions(
@Test public void serializeFieldsFiltered_throwsException() throws IOException, JsonGenerationException { final SimpleBeanType type = new SimpleBeanType(); BeanSerializerBuilder builder = new BeanSerializerBuilder(type); BeanPropertyWriter[] properties = new BeanPropertyWriter[]{new BeanPropertyWriter("strProp1", true), new BeanPropertyWriter("strProp2", true), new BeanPropertyWriter("strProp3", true)}; SimpleSerializerProvider provider = new SimpleSerializerProvider(); provider.setActiveView(type); BeanSerializerBase src = new BeanSerializerBase(type, builder, properties, null); expectedException.expect(JsonMappingException.class); expectedException.expectMessage("Infinite recursion (StackOverflowError)"
@Test public void findFilter() { MockBeanPropertyFilter filter = new MockBeanPropertyFilter(); MockSerializerProvider provider = new MockSerializerProvider(); provider.setFilterProvider(filter); SimpleSerializerProvider serializerProvider = new SimpleSerializerProvider(); serializerProvider.setFilterProvider(filter); BeanPropertyFilter result = serializerProvider.findFilter(provider); assertEquals(filter, result); }
@Test public void findFilter() { MockBeanPropertyFilter filter = new MockBeanPropertyFilter(); MockSerializerProvider provider = new MockSerializerProvider(); provider.setFilterProvider(filter); MockBeanPropertyFilter filtered = new MockBeanPropertyFilter(); filtered.addFilter(filter); MockBeanPropertyFilter filtered2 = new MockBeanPropertyFilter(); filtered2.addFilter(filtered); MockBeanPropertyFilter filtered3 = new MockBeanPropertyFilter(); filtered3.addFilter(filtered2); MockBeanPropertyFilter filtered4 = new MockBeanPropertyFilter(); filtered4.addFilter(filtered3); MockBeanPropertyFilter filtered5 = new MockBeanPropertyFilter(); filtered5.addFilter(filtered4); MockBeanPropertyFilter
@Test public void findFilter() throws IOException, JsonMappingException { MockBeanPropertyFilter filter = new MockBeanPropertyFilter(); MockFilterProvider provider = new MockFilterProvider(); provider.setFilterProvider(filter); SimpleSerializerProvider serializerProvider = new SimpleSerializerProvider(); serializerProvider.setFilterProvider(provider); SimpleSerializerProvider serializerProvider2 = new SimpleSerializerProvider(); serializerProvider2.setFilterProvider(provider); SimpleSerializerProvider serializerProvider3 = new SimpleSerializerProvider(); serializerProvider3.setFilterProvider(filterProvider2); SimpleSerializerProvider serializerProvider4 = new SimpleSerializerProvider(); serializerProvider4.setFilterProvider(filterProvider2); SimpleSerializerProvider serializerProvider5 = new SimpleSerializerProvider(); serializerProvider
@Test public void findFilter() { MockBeanPropertyFilter filter = new MockBeanPropertyFilter(); SimpleSerializerProvider provider = new SimpleSerializerProvider(); provider.addSerializerProvider(filter); MockBeanPropertyFilter filtered = new MockBeanPropertyFilter(); MockBeanPropertyFilter filtered2 = new MockBeanPropertyFilter(); filtered2.addFilter(filter); MockBeanPropertyFilter filtered3 = new MockBeanPropertyFilter(); filtered3.addFilter(filter2); MockBeanPropertyFilter filtered4 = new MockBeanPropertyFilter(); filtered4.addFilter(filter1); MockBeanPropertyFilter filtered5 = new MockBeanPropertyFilter(); filtered5.addFilter(filter3); MockBeanPropertyFilter filtered6 = new MockBeanProperty
@Test public void findFilter() { MockBeanPropertyFilter filter = new MockBeanPropertyFilter(); MockSerializerProvider provider = new MockSerializerProvider(); provider.addFilter(filter); MockBeanPropertyFilter filtered = new MockBeanPropertyFilter(); MockBeanPropertyFilter filtered2 = new MockBeanPropertyFilter(); filtered2.addFilter(filtered); MockBeanPropertyFilter filtered3 = new MockBeanPropertyFilter(); filtered3.addFilter(filtered2); MockBeanPropertyFilter filtered4 = new MockBeanPropertyFilter(); filtered4.addFilter(filtered3); MockBeanPropertyFilter filtered5 = new MockBeanPropertyFilter(); filtered5.addFilter(filtered4); MockBeanPropertyFilter filtered6 = new MockBeanPropertyFilter
@Test public void findFilter() { MockBeanPropertyFilter filter = new MockBeanPropertyFilter(); MockSerializerProvider provider = new MockSerializerProvider(); provider.addFilter(filter); MockBeanPropertyFilter filtered = new MockBeanPropertyFilter(); MockBeanPropertyFilter filtered2 = new MockBeanPropertyFilter(); filtered2.addFilter(filtered); MockBeanPropertyFilter filtered3 = new MockBeanPropertyFilter(); filtered3.addFilter(filtered2); MockBeanPropertyFilter filtered4 = new MockBeanPropertyFilter(); filtered4.addFilter(filtered3); MockBeanPropertyFilter filtered5 = new MockBeanPropertyFilter(); filtered5.addFilter(filtered4); MockBeanPropertyFilter filtered6 = new MockBeanPropertyFilter
@Test public void schema() { SimpleSerializerProvider provider = new SimpleSerializerProvider(); BeanPropertyWriter[] props = new BeanPropertyWriter[1]; props[0] = new BeanPropertyWriter("prop1", new SimpleBeanPropertyWriter("prop2", new SimpleBeanPropertyWriter("prop3", new SimpleBeanPropertyWriter("prop4", new SimpleBeanPropertyWriter("prop5", new SimpleBeanPropertyWriter("prop6", new SimpleBeanPropertyWriter("prop7", new SimpleBeanPropertyWriter("prop8", new SimpleBeanPropertyWriter("prop9", new SimpleBeanPropertyWriter("prop10", new SimpleBeanPropertyWriter("prop11", new SimpleBeanPropertyWriter("prop12", new SimpleBeanPropertyWriter("
@Test public void simple() { SimpleSerializerProvider provider = new SimpleSerializerProvider(); BeanPropertyWriter[] props = new BeanPropertyWriter[] { new BeanPropertyWriter("prop1"), new BeanPropertyWriter("prop2"), new BeanPropertyWriter("prop3"), new BeanPropertyWriter("prop4"), new BeanPropertyWriter("prop5"), new BeanPropertyWriter("prop6"), new BeanPropertyWriter("prop7"), new BeanPropertyWriter("prop8"), new BeanPropertyWriter("prop9"), new BeanPropertyWriter("prop10"), new BeanPropertyWriter("prop11"), new BeanPropertyWriter("prop12"), new BeanPropertyWriter("prop13") }; Simple
@Test public void testOrderProperties() { List<BeanPropertyWriter> properties = new ArrayList<BeanPropertyWriter>(); for (int i = 0; i < 10; i++) { properties.add(new BeanPropertyWriter(String.valueOf(i))); } serializationConfig.setOrder(true); List<BeanPropertyWriter> rest = serializationConfig.changeProperties(serializationConfig, null, properties); for (BeanPropertyWriter writer : rest) { System.out.println(writer.toString()); } }
@Test public void testOrderProperties() { List<BeanPropertyWriter> properties = new ArrayList<BeanPropertyWriter>(); BeanPropertyWriter writer1 = new BeanPropertyWriter("prop1", config.getSerializer()); BeanPropertyWriter writer2 = new BeanPropertyWriter("prop2", config.getSerializer()); properties.add(writer1); properties.add(writer2); SerializationConfig config = new SerializationConfig(); List<BeanPropertyWriter> newProperties = config.orderProperties(config, null, properties); assertEquals(2, newProperties.size()); assertEquals("prop1", newProperties.get(0).toString()); assertEquals("prop2", newProperties.get(1).toString()); }
@Test public void testOrderProperties() { List<BeanPropertyWriter> properties = new ArrayList<BeanPropertyWriter>(); for (int i = 0; i < 10; i++) { properties.add(new BeanPropertyWriter(String.valueOf(i))); } serializationConfig.setOrderDelimiter(\'\\n\'); List<BeanPropertyWriter> orderProperties = serializationConfig.orderProperties(serializationConfig, null, properties); for (BeanPropertyWriter p : orderProperties) { System.out.println(p.toString()); } for (BeanPropertyWriter p : properties) { System.out.println(p.toString()); } }
@Test public void testOrderProperties() { List<BeanPropertyWriter> properties = new ArrayList<BeanPropertyWriter>(); for (int i = 0; i < 10; i++) { properties.add(new BeanPropertyWriter(String.valueOf(i))); } serializationConfig.setOrderMode(SerializationConfig.OrderMode.ASC); List<BeanPropertyWriter> orderProperties = serializationConfig.orderProperties(serializationConfig, null, properties); Assert.assertEquals(10, orderProperties.size()); for (int i = 0; i < 10; i++) { Assert.assertEquals(String.valueOf(i), orderProperties.get(i).toString()); } }
@Test public void testPOJOPropertiesCollector() { final MapperConfig<String> config = new MapperConfig<String>() { @Override public boolean isAnnotationProcessingEnabled() { return false; } @Override public Class<? extends Annotation> annotationType() { return null; } @Override public boolean isAnnotationProcessingEnabled() { return false; } @Override public String getDefaultVisibilityChecker() { return null; } @Override public boolean isAnnotationProcessingEnabled() { return false; } @Override public Class<? extends Annotation> annotationType() { return null; } @Override public boolean isAnnotationProcessingEnabled() { return false; } @Override public Class<? extends Annotation> annotationType() { return null; } @Override public boolean isAnnotationProcessing
@Test public void testPOJOPropertiesCollector() { final MapperConfig<?> config = new MapperConfig<Void>() { @Override public boolean isAnnotationProcessingEnabled() { return false; } @Override public Class<?> annotationType() { return null; } @Override public AnnotatedClass<?> getClassDef() { return null; } @Override public boolean isAnnotationProcessingEnabled() { return false; } @Override public VisibilityChecker getDefaultVisibilityChecker() { return null; } }; final POJOPropertiesCollector collector = new POJOPropertiesCollector(config, true, null, null, null); final POJOPropertyBuilder builder1 = collector._addProperty("foo"); final POJOPropertyBuilder builder2 = collector._add
@Test public void testPOJOPropertiesCollector() { final MapperConfig<?> config = new MapperConfig<Void>() { @Override public boolean isAnnotationProcessingEnabled() { return false; } @Override public Class<?> getType() { return null; } @Override public boolean isAnnotationProcessingEnabled() { return false; } @Override public boolean isDefaultVisibilityChecker() { return false; } @Override public Class<? extends Annotation> annotationType() { return null; } @Override public VisibilityChecker getVisibilityChecker() { return null; } }; final POJOPropertiesCollector collector = new POJOPropertiesCollector(config, true, null, null, null); collector._addProperties(); Map<String, POJOPropertyBuilder
@Test public void testPOJOPropertiesCollector() { final MapperConfig<?> config = new MapperConfig<Void>() { @Override public boolean isAnnotationProcessingEnabled() { return false; } @Override public Class<?> getType() { return Void.class; } @Override public boolean isAnnotationProcessingEnabled() { return true; } @Override public boolean isDefault() { return false; } @Override public AnnotationIntrospector getAnnotationIntrospector() { return null; } @Override public boolean isDefaultVisibilityChecker() { return false; } @Override public Class<?> annotationType() { return null; } @Override public AnnotatedClass<?> getClassDef() { return null; } @Override public String getName() { return
@Test public void testPOJOPropertiesCollector() { final MapperConfig<?> config = new MapperConfig<Void>() { @Override public boolean isAnnotationProcessingEnabled() { return false; } @Override public Class<?> getType() { return Void.class; } @Override public boolean isAnnotationProcessingEnabled() { return true; } @Override public boolean isDefault() { return false; } @Override public AnnotationIntrospector getAnnotationIntrospector() { return null; } @Override public boolean isDefaultVisibilityChecker() { return false; } @Override public Class<?> annotationType() { return null; } @Override public AnnotatedClass<?> getClassDef() { return null; } }; final String mutatorPrefix = "
@Test public void testGetters() { final MapperConfig<?> config = new MapperConfig<String>() { @Override public boolean isAnnotationProcessingEnabled() { return false; } @Override public Class<?> annotationType() { return null; } @Override public AnnotatedClass<?> getClassDef() { return null; } @Override public String getDefaultVisibilityChecker() { return null; } }; final POJOPropertiesCollector collector = new POJOPropertiesCollector(config, true, null, getClassDef(), "setX"); assertEquals("x", collector._mutatorPrefix); assertEquals("y", collector._mutatorPrefix); assertEquals("z", collector._mutatorPrefix); }
@Test public void test() { final MapperConfig<?> config = new MapperConfig<Void>() { @Override public boolean isAnnotationProcessingEnabled() { return false; } @Override public Class<?> getType() { return null; } @Override public boolean isAnnotationProcessingEnabled() { return false; } @Override public boolean isDefault() { return false; } }; final POJOPropertiesCollector collector = new POJOPropertiesCollector(config, true, null, null, null); collector._addProperties(); assertEquals(1, collector._getPropertyMap().size()); assertEquals("foo", collector._getPropertyMap().get("foo")); assertEquals("bar", collector._getPropertyMap().get("bar")
@Test public void testPOJOPropertiesCollector() { final MapperConfig<?> config = new MapperConfig<Void>() { @Override public boolean isAnnotationProcessingEnabled() { return false; } @Override public Class<?> getType() { return null; } @Override public boolean isAnnotationProcessingEnabled() { return false; } @Override public VisibilityChecker getVisibilityChecker() { return null; } }; final POJOPropertiesCollector collector = new POJOPropertiesCollector(config, true, null, null, null); collector._addProperties(); assertEquals(2, collector.getProperties().size()); assertTrue(collector.getProperties().containsKey("foo")); assertTrue(collector.getProperties().containsKey("
@Test public void test() { final MapperConfig<?> config = new MapperConfig<Void>() { @Override public Class<?> getType() { return Void.class; } @Override public boolean isAnnotationProcessingEnabled() { return false; } @Override public boolean isDefaultVisibilityChecker() { return true; } }; final POJOPropertiesCollector collector = new POJOPropertiesCollector(config, true, null, null, null); assertNull(collector._visibilityChecker()); assertNull(collector._visibilityChecker(null)); assertNull(collector._visibilityChecker(null, true)); assertNull(collector._visibilityChecker(null, false)); assertNull(collector._visibilityChecker(null, true)); assertNull(collector
@Test public void test_JsonValueGetters_1() throws Exception { MapperConfig<?> config = new MapperConfig<Object>() { @Override public Class<?> getType() { return Object.class; } @Override public List<AnnotatedMethod> getGetters() { return null; } @Override public List<AnnotatedMethod> getJsonValueMethod() { return null; } }; Map<String, POJOPropertyBuilder> properties = new LinkedHashMap<String, POJOPropertyBuilder>(); properties.put("foo", new POJOPropertyBuilder("foo")); properties.put("bar", new POJOPropertyBuilder("bar")); properties.put("baz", new POJOPropertyBuilder("baz
@Test public void testGetJsonValueMethod() throws Exception { TestCollector collector = new TestCollector(); collector._jsonValueGetters = new List<AnnotatedMethod>(); collector._jsonValueGetters.add(new AnnotatedMethod() { @Override public void invoke(Object obj) { obj.toString(); } }); assertNull(collector.getJsonValueMethod()); collector._jsonValueGetters.clear(); collector._jsonValueGetters.add(new AnnotatedMethod() { @Override public void invoke(Object obj) { obj.toString(); } }); assertNull(collector.getJsonValueMethod()); collector._jsonValueGetters.add(new AnnotatedMethod() { @Override public void invoke(Object obj) {
@Test public void test_getPropertyMap() { Map<String, POJOPropertyBuilder> propertyMap = collector._getPropertyMap(); for (String key: propertyMap.keySet()) { POJOPropertyBuilder builder = propertyMap.get(key); assertNotNull(builder); } }
@Test public void test_getPropertyMap() { Map<String, POJOPropertyBuilder> properties = _collector._getPropertyMap(); assertTrue(properties.size() > 0); }
@Test public void testCollect() { Map<String, Map<String, Object>> properties = new HashMap<String, Map<String, Object>>(); Map<String, Object> foo = new HashMap<String, Object>(); Map<String, Object> bar = new HashMap<String, Object>(); Map<String, Object> baz = new HashMap<String, Object>(); properties.put("foo", foo); properties.put("bar", bar); properties.put("baz", baz); properties.put("foo", foo); properties.put("baz", baz); properties.put("foo", bar); properties.put("baz", baz); Map<String, Map<String, Object
@Test public void testCollect() { Map<String, Map<String, Map<String, Object>>> properties = new LinkedHashMap<String, Map<String, Object>>(); Map<String, Object> foo = new LinkedHashMap<String, Object>(); foo.put("foo", foo); properties.put("foo", foo); Map<String, Map<String, Object>> bar = new LinkedHashMap<String, Map<String, Object>>(); Map<String, Object> baz = new LinkedHashMap<String, Object>(); baz.put("baz", baz); properties.put("baz", bar); properties.put("baz", baz); properties.put("baz", bar); properties.put("
@Test public void testCollect() { Map<String, Map<String, List<String>>> properties = new HashMap<String, Map<String, List<String>>>(); Map<String, List<String>> properties1 = new HashMap<String, List<String>>(); Map<String, List<String>> properties2 = new HashMap<String, List<String>>(); Map<String, List<String>> properties3 = new HashMap<String, List<String>>(); Map<String, List<String>> properties4 = new HashMap<String, List<String>>(); properties1.put("a", properties1); properties1.put("b", properties2); properties1.put("c", properties
@Test public void testCollect() { Map<String, Map<String, List<String>>> properties = new HashMap<String, Map<String, List<String>>>(); Map<String, List<String>> foo = new HashMap<String, List<String>>(); Map<String, List<String>> bar = new HashMap<String, List<String>>(); Map<String, List<String>> baz = new HashMap<String, List<String>>(); properties.put("foo", foo); properties.put("bar", bar); properties.put("baz", baz); properties.put("baz", baz); properties.put("baz", bar); properties.put("baz", baz);
@Test public void testCollect() { Map<String, Map<String, List<String>>> properties = new HashMap<String, Map<String, List<String>>>(); Map<String, List<String>> properties1 = new HashMap<String, List<String>>(); Map<String, List<String>> properties2 = new HashMap<String, List<String>>(); Map<String, List<String>> properties3 = new HashMap<String, List<String>>(); properties1.put("prop1", properties1); properties1.put("prop2", properties2); properties2.put("prop3", properties3); properties2.put("prop4", properties3); properties3.put("
@Test public void testCollect() { Map<String, Map<String, List<String>>> properties = new HashMap<String, Map<String, List<String>>>(); Map<String, List<String>> properties1 = new HashMap<String, List<String>>(); Map<String, List<String>> properties2 = new HashMap<String, List<String>>(); Map<String, List<String>> properties3 = new HashMap<String, List<String>>(); Map<String, List<String>> properties4 = new HashMap<String, List<String>>(); properties.put("a", properties1); properties.put("b", properties2); properties.put("c", properties3); properties
@Test public void testCollect() { Map<String, Map<String, List<String>>> properties = new HashMap<String, Map<String, List<String>>>(); Map<String, List<String>> properties1 = new HashMap<String, List<String>>(); Map<String, List<String>> properties2 = new HashMap<String, List<String>>(); Map<String, List<String>> properties3 = new HashMap<String, List<String>>(); Map<String, List<String>> properties4 = new HashMap<String, List<String>>(); properties1.put("a", properties1); properties1.put("b", properties2); properties1.put("c", properties
@Test public void testCollect() { final POJOPropertiesCollector collector = new POJOPropertiesCollector() { @Override protected void _addFields() { } @Override protected void _addMethods() { } @Override protected void _addCreators() { } @Override protected void _removeUnwantedProperties() { } @Override protected void _addMethods() { } @Override protected void _addCreators() { } @Override protected void _removeUnwantedProperties() { } @Override protected void _addMethods() { } @Override protected void _addCreators() { } @Override protected void _removeUnwantedProperties() { } @Override protected boolean isEnabled(MapperConfig<?> config) { return false;
@Test public void testCollect() { POJOPropertiesCollector collector = new POJOPropertiesCollector() { @Override protected void _addFields() { } @Override protected void _addMethods() { } @Override protected void _addCreators() { } @Override protected void _addMethods() { } @Override protected void _removeUnwantedProperties() { } @Override protected void _addCreators() { } @Override protected void _addMethods() { } @Override protected void _removeUnwantedProperties() { } @Override protected boolean isEnabled(MapperConfig<?> config) { return false; } @Override protected boolean isEnabled(MapperConfig<?> config) { return false; } }; collector.collect
@Test public void testCollect() { final POJOPropertiesCollector collector = new POJOPropertiesCollector() { @Override protected void addFields() { } @Override protected void addMethods() { } @Override protected void addCreators() { } @Override protected void addMethods() { } @Override protected void addCreators() { } @Override protected void addMethods() { } @Override protected void addCreators() { } @Override protected void addMethods() { } @Override protected void addCreators() { } @Override protected boolean isEnabled(MapperConfig<?> config) { return false; } @Override protected boolean isEnabled(MapperConfig<?> config) { return false; } @Override protected PropertyNaming
@Test public void testCollect() { Map<String, POJOPropertyBuilder> properties = new HashMap<String, POJOPropertyBuilder>(); properties.put("a", new POJOPropertyBuilder("a")); properties.put("b", new POJOPropertyBuilder("b")); properties.put("c", new POJOPropertyBuilder("c")); properties.put("d", new POJOPropertyBuilder("d")); properties.put("e", new POJOPropertyBuilder("e")); properties.put("f", new POJOPropertyBuilder("f")); properties.put("g", new POJOPropertyBuilder("g")); properties.put("h", new POJOPropertyBuilder("h
@Test public void testCollect() { final POJOPropertiesCollector collector = new POJOPropertiesCollector() { @Override protected void _addFields() { } @Override protected void _addMethods() { } @Override protected void _addCreators() { } @Override protected void _removeUnwantedProperties() { } @Override protected void _addMethods() { } @Override protected void _addCreators() { } @Override protected void _removeUnwantedProperties() { } @Override protected void _addMethods() { } @Override protected void _addCreators() { } @Override protected void _removeUnwantedProperties() { } @Override protected void _addFields() { } @Override protected void _addMethods
@Test public void testCollect() { Map<String, POJOPropertyBuilder> properties = new HashMap<String, POJOPropertyBuilder>(); properties.put("a", new POJOPropertyBuilder("a")); properties.put("b", new POJOPropertyBuilder("b")); properties.put("c", new POJOPropertyBuilder("c")); properties.put("d", new POJOPropertyBuilder("d")); properties.put("e", new POJOPropertyBuilder("e")); properties.put("f", new POJOPropertyBuilder("f")); properties.put("g", new POJOPropertyBuilder("g")); properties.put("h", new POJOPropertyBuilder("h
@Test public void testCollect() { final MapperConfig<?> config = new MapperConfig<Object>() { @Override public boolean isEnabled(boolean useWrapPER_NAME_AS_PROPERTY_NAME) { return useWrapPER_NAME_AS_PROPERTY_NAME; } @Override public Class<? extends Annotation> annotationType() { return null; } @Override public Class<? extends Annotation> annotationType() { return null; } @Override public boolean isEnabled(boolean useWrapPER_NAME_AS_PROPERTY_NAME) { return false; } @Override public Class<? extends Annotation> annotationType() { return null; } @Override public boolean isEnabled(boolean useWrapPER_NAME_AS_PROPERTY_NAME)
@Test public void testCollect() { final MapperConfig<?> config = new MapperConfig<Object>() { @Override public boolean isEnabled(Class<?> clazz) { return false; } @Override public boolean isEnabled(Class<?> clazz) { return false; } @Override public boolean isEnabled(Class<?> clazz) { return false; } @Override public boolean isEnabled(Class<?> clazz) { return false; } @Override public boolean isEnabled(Class<?> clazz) { return false; } @Override public boolean isEnabled(Class<?> clazz) { return false; } @Override public boolean isEnabled(Class<?> clazz) { return false; } @Override public boolean isEnabled
@Test public void testCollect() { Map<String, Map<String, List<String>>> properties = new HashMap<String, Map<String, List<String>>>(); Map<String, List<String>> foo = new HashMap<String, List<String>>(); Map<String, List<String>> bar = new HashMap<String, List<String>>(); Map<String, List<String>> baz = new HashMap<String, List<String>>(); properties.put("foo", foo); properties.put("bar", bar); properties.put("baz", baz); properties.put("baz", baz); properties.put("baz", bar); properties.put("baz", baz);
@Test public void testCollect() { final POJOPropertiesCollector collector = new POJOPropertiesCollector() { @Override protected void _addFields() { } @Override protected void _addMethods() { } @Override protected void _addCreators() { } @Override protected void _addMethods() { } @Override protected void _removeUnwantedProperties() { } @Override protected void _addCreators() { } @Override protected void _removeUnwantedProperties() { } @Override protected void _addMethods() { } @Override protected void _addCreators() { } @Override protected void _removeUnwantedProperties() { } @Override protected void _addFields() { } @Override protected void _addMethods
@Test(dataProvider = "properties") public void sortProperties(ClassDef classDef, String[] properties, boolean sort) { classDef.setProperty("test", "test"); classDef.setProperty("test2", "test2"); classDef.setProperty("test3", "test3"); classDef.setProperty("test4", "test4"); classDef.setProperty("test5", "test5"); classDef.setProperty("test6", "test6"); classDef.setProperty("test7", "test7"); classDef.setProperty("test8", "test8"); classDef.setProperty("test9", "test9"); classDef.setProperty("
@Test public void test_sortProperties() { SimpleClassBuilder simpleClassBuilder = new SimpleClassBuilder(); simpleClassBuilder.setName("a"); SimpleClassBuilder simpleClassBuilder2 = new SimpleClassBuilder(); simpleClassBuilder2.setName("b"); SimpleClassBuilder simpleClassBuilder3 = new SimpleClassBuilder(); simpleClassBuilder3.setName("c"); simpleClassBuilder3.setName("d"); SimpleClassBuilder simpleClassBuilder4 = new SimpleClassBuilder(); simpleClassBuilder4.setName("e"); simpleClassBuilder4.setName("f"); SimpleClassBuilder simpleClassBuilder5 = new SimpleClassBuilder(); simpleClassBuilder5.setName("g"); simpleClassBuilder5.
@Test public void simple() { SimpleClassBuilder simpleClassBuilder = new SimpleClassBuilder(); simpleClassBuilder.setName("Test"); SimpleClassBuilder simpleClassBuilder2 = new SimpleClassBuilder(); simpleClassBuilder2.setName("Test2"); SimpleClassBuilder simpleClassBuilder3 = new SimpleClassBuilder(); simpleClassBuilder3.setName("Test3"); SimpleClassBuilder simpleClassBuilder4 = new SimpleClassBuilder(); simpleClassBuilder4.setName("Test4"); SimpleClassBuilder simpleClassBuilder5 = new SimpleClassBuilder(); simpleClassBuilder5.setName("Test5"); SimpleClassBuilder simpleClassBuilder6 = new SimpleClassBuilder(); simpleClassBuilder6.setName("Test6");
@Test public void test_sortProperties() { SimpleClassBuilder simpleClassBuilder = new SimpleClassBuilder(); simpleClassBuilder.setName("a"); SimpleClassBuilder simpleClassBuilder2 = new SimpleClassBuilder(); simpleClassBuilder2.setName("b"); simpleClassBuilder2.setInternalName("c"); SimpleClassBuilder simpleClassBuilder3 = new SimpleClassBuilder(); simpleClassBuilder3.setName("d"); simpleClassBuilder3.setInternalName("e"); SimpleClassBuilder simpleClassBuilder4 = new SimpleClassBuilder(); simpleClassBuilder4.setName("f"); simpleClassBuilder4.setInternalName("g"); SimpleClassBuilder simpleClassBuilder5 = new SimpleClassBuilder(); simpleClass
@Test public void test_sortProperties() { SimpleClassBuilder simpleClassBuilder = new SimpleClassBuilder(); simpleClassBuilder.setName("Test"); SimpleClassBuilder simpleClassBuilder2 = new SimpleClassBuilder(); simpleClassBuilder2.setName("Test2"); SimpleClassBuilder simpleClassBuilder3 = new SimpleClassBuilder(); simpleClassBuilder3.setName("Test3"); SimpleClassBuilder simpleClassBuilder4 = new SimpleClassBuilder(); simpleClassBuilder4.setName("Test4"); SimpleClassBuilder simpleClassBuilder5 = new SimpleClassBuilder(); simpleClassBuilder5.setName("Test5"); SimpleClassBuilder simpleClassBuilder6 = new SimpleClassBuilder(); simpleClassBuilder6.setName("
@Test public void simple() { SimpleClassBuilder simpleClassBuilder = new SimpleClassBuilder(); simpleClassBuilder.setName("Simple"); simpleClassBuilder.setInternalName("Simple"); SimpleClassBuilder simpleClassBuilder = new SimpleClassBuilder(); simpleClassBuilder.setName("Simple"); simpleClassBuilder.setInternalName("Simple"); SimpleClassBuilder simpleClassBuilder2 = new SimpleClassBuilder(); simpleClassBuilder2.setName("Simple"); simpleClassBuilder2.setInternalName("Simple"); simpleClassBuilder2.setInternalName("Simple"); SimpleClassBuilder simpleClassBuilder3 = new SimpleClassBuilder(); simpleClassBuilder3.setName("Simple"); simpleClassBuilder3.setInternalName("Simple");
@Test public void simple() { SimpleClassBuilder simpleClassBuilder = new SimpleClassBuilder(); simpleClassBuilder.setName("a"); simpleClassBuilder.setInternalName("b"); SimpleClassBuilder simpleClassBuilder2 = new SimpleClassBuilder(); simpleClassBuilder2.setName("c"); simpleClassBuilder2.setInternalName("d"); SimpleClassBuilder simpleClassBuilder3 = new SimpleClassBuilder(); simpleClassBuilder3.setName("e"); simpleClassBuilder3.setInternalName("f"); simpleClassBuilder3.setInternalName("g"); SimpleClassBuilder simpleClassBuilder4 = new SimpleClassBuilder(); simpleClassBuilder4.setName("h"); simpleClassBuilder4.setInternalName
@Test public void test_sortProperties() { SimpleClassBuilder simpleClassBuilder = new SimpleClassBuilder(); simpleClassBuilder.setName("a"); SimpleClassBuilder simpleClassBuilder2 = new SimpleClassBuilder(); simpleClassBuilder2.setName("b"); SimpleClassBuilder simpleClassBuilder3 = new SimpleClassBuilder(); simpleClassBuilder3.setName("c"); SimpleClassBuilder simpleClassBuilder4 = new SimpleClassBuilder(); simpleClassBuilder4.setName("d"); SimpleClassBuilder simpleClassBuilder5 = new SimpleClassBuilder(); simpleClassBuilder5.setName("e"); SimpleClassBuilder simpleClassBuilder6 = new SimpleClassBuilder(); simpleClassBuilder6.setName("f"); simpleClass
@Test public void test_sortProperties() { SimpleClassBuilder simpleClassBuilder = new SimpleClassBuilder(); simpleClassBuilder.setName("a"); SimpleClassBuilder simpleClassBuilder2 = new SimpleClassBuilder(); simpleClassBuilder2.setName("b"); SimpleClassBuilder simpleClassBuilder3 = new SimpleClassBuilder(); simpleClassBuilder3.setName("c"); simpleClassBuilder3.setName("d"); SimpleClassBuilder simpleClassBuilder4 = new SimpleClassBuilder(); simpleClassBuilder4.setName("e"); simpleClassBuilder4.setName("f"); SimpleClassBuilder simpleClassBuilder5 = new SimpleClassBuilder(); simpleClassBuilder5.setName("g"); simpleClassBuilder5.
@Test public void test_sortProperties() { SimpleClassBuilder simpleClassBuilder = new SimpleClassBuilder(); simpleClassBuilder.setName("a"); SimpleClassBuilder simpleClassBuilder2 = new SimpleClassBuilder(); simpleClassBuilder2.setName("b"); SimpleClassBuilder simpleClassBuilder3 = new SimpleClassBuilder(); simpleClassBuilder3.setName("c"); SimpleClassBuilder simpleClassBuilder4 = new SimpleClassBuilder(); simpleClassBuilder4.setName("d"); SimpleClassBuilder simpleClassBuilder5 = new SimpleClassBuilder(); simpleClassBuilder5.setName("e"); SimpleClassBuilder simpleClassBuilder6 = new SimpleClassBuilder(); simpleClassBuilder6.setName("f"); simpleClass
@Test public void test_sortProperties() { SimpleClassBuilder simpleClassBuilder = new SimpleClassBuilder(); simpleClassBuilder.setName("Test"); SimpleClassBuilder simpleClassBuilder2 = new SimpleClassBuilder(); simpleClassBuilder2.setName("Test2"); SimpleClassBuilder simpleClassBuilder3 = new SimpleClassBuilder(); simpleClassBuilder3.setName("Test3"); SimpleClassBuilder simpleClassBuilder4 = new SimpleClassBuilder(); simpleClassBuilder4.setName("Test4"); SimpleClassBuilder simpleClassBuilder5 = new SimpleClassBuilder(); simpleClassBuilder5.setName("Test5"); SimpleClassBuilder simpleClassBuilder6 = new SimpleClassBuilder(); simpleClassBuilder6.setName("
@Test public void test_addFields() { final SimpleType type = new SimpleType(); final AnnotationIntrospector annotationIntrospector = type.getAnnotationIntrospector(); final MapperConfig<?> config = new MapperConfig<SimpleType>() { @Override public boolean isEnabled(MapperFeature.ALLOW_FINAL_FIELDS_AS_MUTATORS) { return false; } @Override public Class<?> getClassDef() { return type.getClassDef(); } @Override public List<AnnotatedField> fields() { return Collections.emptyList(); } @Override public boolean isEnabled(MapperFeature.ALLOW_FINAL_FIELDS_AS_MUTATORS) { return false; } @
@Test public void testAddFields() throws Exception { TestBean bean1 = new TestBean(); bean1.stringField = "stringField"; bean1.stringField2 = "stringField2"; bean1.stringField3 = "stringField3"; bean1.stringField4 = "stringField4"; bean1.stringField5 = "stringField5"; bean1.stringField6 = "stringField6"; TestBean bean2 = new TestBean(); bean2.stringField = "stringField"; bean2.stringField3 = "stringField3"; bean2.stringField4 = "stringField4"; bean2.stringField5 = "stringField5"; bean2.
@Test public void testAddFields() { final SimpleType type = new SimpleType(); final AnnotationIntrospector ai = new AnnotationIntrospector() { @Override public AnnotationIntrospector getAnnotationIntrospector() { return ai; } @Override public boolean isEnabled(MapperFeature.ALLOW_FINAL_FIELDS_AS_MUTATORS) { return true; } @Override public boolean isEnabled(MapperFeature.ALLOW_FINAL_FIELDS_AS_MUTATORS) { return true; } @Override public void addField(AnnotatedField f, String name, boolean visible, boolean ignore) { } @Override public void addProperty(AnnotatedField f, String name, boolean visible, boolean
@Test public void test_addFields() throws Exception { final SimpleType type = new SimpleType(); final AnnotationIntrospector ai = new AnnotationIntrospector() { @Override public AnnotationIntrospector getAnnotationIntrospector() { return type; } @Override public boolean isEnabled(MapperFeature.ALLOW_FINAL_FIELDS_AS_MUTATORS) { return false; } @Override public boolean isEnabled(MapperFeature.ALLOW_FINAL_FIELDS_AS_MUTATORS) { return false; } @Override public void addField(AnnotatedField f, String name, boolean visible, boolean ignore) { } @Override public void addField(AnnotatedField f, String name, boolean visible
@Test public void _addCreators() { @SuppressWarnings("unchecked") final AnnotationIntrospector mockIntrospector = mock(AnnotationIntrospector.class); @SuppressWarnings("unchecked") final AnnotatedClass mockClass = mock(AnnotatedClass.class); @SuppressWarnings("unchecked") final List<AnnotatedConstructor> mockConstructors = mock(List.class); @SuppressWarnings("unchecked") final List<AnnotatedMethod> mockStaticMethods = mock(List.class); @SuppressWarnings("unchecked") final List<POJOPropertyBuilder> mockPropertyBuilders = mock(List.class); @SuppressWarnings("unchecked") final List<POJOPropertyBuilder> mockPropertyBuilders2 = mock(List.class); @Suppress
@Test(expected = IllegalArgumentException.class) public void addCreators() { AnnotationIntrospector ai = new AnnotationIntrospector() { @Override public Class<? extends Annotation> annotationType() { return null; } @Override public int getParameterCount() { return 0; } @Override public Class<? extends Annotation> annotationType() { return null; } @Override public Class<? extends Annotation> annotationType() { return null; } @Override public Class<? extends Annotation> annotationType() { return null; } @Override public Class<? extends Annotation> annotationType() { return null; } @Override public Class<? extends Annotation> annotationType() { return null; } @Override public Class<? extends Annotation> annotationType() { return null; } @Override
@Test public void addCreators() { @SuppressWarnings("unchecked") final AnnotationIntrospector ai = mock(AnnotationIntrospector.class); final AnnotatedClass classDef = mock(AnnotatedClass.class); when(classDef.getConstructors()).thenReturn(Collections.singletonList(new AnnotatedConstructor())); when(classDef.getStaticMethods()).thenReturn(Collections.singletonList(new AnnotatedMethod())); when(classDef.getSimpleMethods()).thenReturn(Collections.singletonList(new AnnotatedMethod())); @SuppressWarnings("unchecked") final POJOPropertiesCollector<EOL> collector = new POJOPropertiesCollector<EOL>(null, false, null, classDef, null);
@Test public void addCreators() { TestData data = new TestData(); data.test1 = true; data.test2 = true; data.test3 = true; data.test4 = true; data.test5 = true; data.test6 = true; data.test7 = true; data.test8 = true; data.test9 = true; data.test10 = true; data.test11 = true; data.test12 = true; data.test13 = true; data.test14 = true; data.test15 = true; data.test16 = true; data.test17 = true; data.test18 = true; data.test19 =
@Test public void addCreators() { TestData data = new TestData(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 31, 32, 33, 34, 34,35, 36, 37, 40, 45, 46, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47
@Test public void addCreators() { TestData data = new TestData(); data.test1 = true; data.test2 = true; data.test3 = true; data.test4 = true; data.test5 = true; data.test6 = true; data.test7 = true; data.test8 = true; data.test9 = true; data.test10 = true; data.test11 = true; data.test12 = true; data.test13 = true; data.test14 = true; data.test15 = true; data.test16 = true; data.test17 = true; data.test18 = true; data.test19 =
@Test public void test_addCreators() throws Exception { TestData data = new TestData(); DataCollector<?> collector = data.getCollector(); collector._addCreators(); Assert.assertEquals(1, collector._classDef.getConstructors().length); Assert.assertEquals(1, collector._classDef.getStaticMethods().length); Assert.assertEquals(1, collector._classDef.getConstructor(0).getParameterCount()); Assert.assertEquals(1, collector._classDef.getMethod(0).getParameterCount()); Assert.assertEquals(1, collector._classDef.getMethod(1).getParameterCount()); Assert.assertEquals(1, collector._classDef.
@Test public void addCreators() { AnnotationIntrospector mockIntrospector = mock(AnnotationIntrospector.class); AnnotatedClass mockClass = mock(AnnotatedClass.class); when(mockClass.getConstructors()).thenReturn(Collections.singletonList(new AnnotatedConstructor())); when(mockClass.getStaticMethods()).thenReturn(Collections.singletonList(new AnnotatedMethod())); when(mockClass.getSimpleMethods()).thenReturn(Collections.singletonList(new AnnotatedMethod())); when(mockIntrospector.getAnnotationIntrospector()).thenReturn(mockIntrospector); when(mockClass.getStaticMethods()).thenReturn(Collections.singletonList(new
@Test public void testAddMethods() throws Exception { final TestPOJOPropertiesCollector collector = new TestPOJOPropertiesCollector(); collector._addMethods(); assertEquals(2, collector.getPropertyNames().size()); assertTrue(collector.getPropertyNames().contains("a")); assertTrue(collector.getPropertyNames().contains("b")); assertTrue(collector.getPropertyNames().contains("c")); assertTrue(collector.getPropertyNames().contains("d")); collector._addMethods(); assertEquals(2, collector.getPropertyNames().size()); assertTrue(collector.getPropertyNames().contains("a")); assertTrue(collector.getPropertyNames().contains("b")); assertTrue(collector.getPropertyNames().contains("
@Test public void testAddMethods() throws Exception { final TestPOJOPropertiesCollector collector = new TestPOJOPropertiesCollector(); collector._addMethods(); assertEquals(2, collector.getPropertyNames().size()); assertTrue(collector.getPropertyNames().contains("a")); assertTrue(collector.getPropertyNames().contains("b")); assertTrue(collector.getPropertyNames().contains("c")); assertTrue(collector.getPropertyNames().contains("d")); assertTrue(collector.getPropertyNames().contains("e")); assertTrue(collector.getPropertyNames().contains("f")); assertTrue(collector.getPropertyNames().contains("g")); assertTrue(collector.getPropertyNames().contains("h")); assert
@Test public void test_addMethods() throws Exception { final TestPOJOPropertiesCollector collector = new TestPOJOPropertiesCollector(); final String className = TestPOJO.class.getSimpleName(); final AnnotatedMethod m1 = new AnnotatedMethod(className, "m1", 0); final AnnotatedMethod m2 = new AnnotatedMethod(className, "m2", 0); final AnnotatedMethod m3 = new AnnotatedMethod(className, "m3", 0); final AnnotatedMethod m4 = new AnnotatedMethod(className, "m4", 0); final AnnotatedMethod m5 = new AnnotatedMethod(className, "m5", 0); final AnnotatedMethod m6 = new AnnotatedMethod(className, "m6", 0
@Test public void testAddMethods() throws Exception { final TestPOJOPropertiesCollector collector = new TestPOJOPropertiesCollector(); collector._addMethods(); assertEquals(2, collector.getPropertyNames().size()); assertTrue(collector.getPropertyNames().contains("a")); assertTrue(collector.getPropertyNames().contains("b")); assertTrue(collector.getPropertyNames().contains("c")); assertTrue(collector.getPropertyNames().contains("d")); assertTrue(collector.getPropertyNames().contains("e")); assertTrue(collector.getPropertyNames().contains("f")); assertTrue(collector.getPropertyNames().contains("g")); assertTrue(collector.getPropertyNames().contains("h")); assert
@Test public void testAddMethods() throws Exception { TestPOJOPropertiesCollector collector = new TestPOJOPropertiesCollector(); collector._addMethods(); collector._addMethods(); }
@Test public void test_addGetterMethod() throws Exception { final POJOPropertiesCollector collector = new POJOPropertiesCollector(new MapperConfig<Object>(), false, JavaType.OBJECT, getClassName(), "test_addGetterMethod"); final String className = getClass().getName().replace(\'.\', \'/\') + "." + getClass().getName().replace(\'.\', \'/\') + "." + getClass().getName().replace(\'.\', \'/\') + "." + getClass().getName().replace(\'.\', \'/\') + "." + getClass().getName().replace(\'.\', \'/\') + "." + getClass().getName().replace(\'.\', \'/\') + "." + getClass().getName().replace
@Test public void testAddMethods() throws Exception { final TestPOJOPropertiesCollector collector = new TestPOJOPropertiesCollector(); collector._addMethods(); collector._addMethods(); assertEquals(2, collector.getPropertyNames().size()); assertTrue(collector.getPropertyNames().contains("a")); assertTrue(collector.getPropertyNames().contains("b")); assertTrue(collector.getPropertyNames().contains("c")); assertTrue(collector.getPropertyNames().contains("d")); assertTrue(collector.getPropertyNames().contains("e")); assertTrue(collector.getPropertyNames().contains("f")); assertTrue(collector.getPropertyNames().contains("g")); assertTrue(collector.getPropertyNames().contains
@Test public void test_addSetterMethod() throws Exception { final POJOPropertiesCollector collector = new POJOPropertiesCollector(new MapperConfig<Object>(), false, JavaType.OBJECT, getClassName(), "test_addSetterMethod"); final String className = getClass().getName(); final AnnotatedMethod m1 = getMethod(className, "test_addSetterMethod1"); final AnnotatedMethod m2 = getMethod(className, "test_addSetterMethod2"); final AnnotatedMethod m3 = getMethod(className, "test_addSetterMethod3"); final AnnotatedMethod m4 = getMethod(className, "test_addSetterMethod4"); final AnnotatedMethod m5 = getMethod(className, "test_addSetterMethod5"); final
@Test(expected = IllegalArgumentException.class) public void noSetter() throws Exception { Method m = Foo.class.getDeclaredMethod("getFoo"); AnnotationIntrospector ai = new AnnotationIntrospector(m); Method f = Foo.class.getDeclaredMethod("getFoo"); ai.setAnnotation(f); foo._addGetterMethod(m, ai); }
@Test public void accessorTest() { SimpleAccessor accessor = new SimpleAccessor(); accessor.setProperty("a", "b"); accessor.setProperty("b", "c"); accessor.setProperty("d", "d"); accessor.setProperty("e", "e"); accessor.setProperty("f", "f"); accessor.setProperty("g", "g"); accessor.setProperty("h", "h"); accessor.setProperty("i", "i"); accessor.setProperty("j", "j"); accessor.setProperty("k", "k"); accessor.setProperty("l", "l"); accessor.setProperty("d", "d"); accessor.setProperty("e", "e"); accessor.
@Test(expected = IllegalArgumentException.class) public void methodWithNoGetterAnnotation() { AnnotationIntrospector ai = new AnnotationIntrospector(); Method m = Foo.class.getDeclaredMethod("getFoo"); m.setAccessible(true); new Foo()._addGetterMethod(m, ai); }
@Test(expected = IllegalArgumentException.class) public void methodWithNoGetterAnnotation() { AnnotationIntrospectorai = new AnnotationIntrospector(); Method m = Foo.class.getDeclaredMethod("getFoo"); m.setAccessible(true); new Foo()._addGetterMethod(m, ai); }
@Test(expected = IllegalArgumentException.class) public void nothing() { AnnotationIntrospector ai = new AnnotationIntrospector() { @Override public boolean hasAnyGetterAnnotation(AnnotatedMethod m) { return false; } @Override public boolean hasAsValueAnnotation(AnnotatedMethod m) { return false; } @Override public String getName() { return null; } @Override public void addGetterMethod(AnnotatedMethod m, AnnotationIntrospector ai) { } @Override public String getName() { return ""; } @Override public boolean hasAsValueAnnotation(AnnotatedMethod m) { return false; } @Override public void addGetterMethod(AnnotatedMethod m, AnnotationIntrospector ai) { } @Override public String getName
@Test public void jsonValueGetters() { Constructor<TestClass> constructor = TestClass.class.getDeclaredConstructor(); Constructor<TestClass> testClass = constructor.newInstance(); AnnotationIntrospector introspector = new AnnotationIntrospector(); try { testClass._addGetterMethod(null, introspector); Assert.fail(); } catch (NullPointerException e) { } try { testClass._addGetterMethod(testClass, null); Assert.fail(); } catch (NullPointerException e) { } try { testClass._addGetterMethod(testClass, null); Assert.fail(); } catch (NullPointerException e) { } try { testClass._addGetterMethod(testClass, null
@Test public void jsonValueGetters() { AnnotationIntrospector ai = new AnnotationIntrospector() { @Override public List<AnnotatedMethod> getAllMethods() { return null; } @Override public boolean hasAnyGetterAnnotation(AnnotatedMethod m) { return false; } @Override public boolean hasAsValueAnnotation(AnnotatedMethod m) { return false; } @Override public String getName() { return null; } @Override public String getName2() { return null; } @Override public boolean hasAsValueAnnotation(AnnotatedMethod m) { return false; } @Override public String getName3() { return null; } @Override public boolean hasAsValueAnnotation(AnnotatedMethod m) { return false; } @Override
@Test public void getter() { Constructor<MyClass> constructor = MyClass.class.getDeclaredConstructor(); assertFalse(constructor.isAccessible()); MyClass myClass = (MyClass) constructor.newInstance(); AnnotationIntrospector ai = new AnnotationIntrospector(); myClass._addGetterMethod(null, ai); assertFalse(constructor.isAccessible()); myClass._addGetterMethod(m1, ai); assertTrue(constructor.isAccessible()); myClass._addGetterMethod(m2, ai); assertTrue(constructor.isAccessible()); myClass._addGetterMethod(m3, ai); assertTrue(constructor.isAccessible()); myClass._addGetterMethod(m4, ai);
@Test(expected = IllegalArgumentException.class) public void methodWithNoGetter() { AnnotationIntrospector ai = new AnnotationIntrospector() { @Override public void anyGetterAnnotation(AnnotatedMethod m) { m.setName(null); } @Override public boolean hasAsValueAnnotation(AnnotatedMethod m) { return false; } @Override public String getName() { return null; } @Override public boolean hasAsValueAnnotation(AnnotatedMethod m) { return false; } @Override public boolean hasAnyGetterAnnotation(AnnotatedMethod m) { return false; } @Override public String getName() { return ""; } @Override public boolean hasAsValueAnnotation(AnnotatedMethod m) { return false; } @Override public
@Test public void getter() { Constructor<MyClass> constructor = MyClass.class.getDeclaredConstructor(); assertFalse(constructor.isAccessible()); MyClass myClass = (MyClass) constructor.newInstance(); AnnotationIntrospector ai = new AnnotationIntrospector(); myClass._addGetterMethod(null, ai); assertFalse(constructor.isAccessible()); myClass._addGetterMethod(m1, ai); assertTrue(constructor.isAccessible()); myClass._addGetterMethod(m2, ai); assertTrue(constructor.isAccessible()); myClass._addGetterMethod(m3, ai); assertTrue(constructor.isAccessible()); myClass._addGetterMethod(m4, ai);
@Test(expected = IllegalArgumentException.class) public void nothing() { AnnotationIntrospector at = new AnnotationIntrospector(); at.addGetterMethod(null, null); at.addGetterMethod(null, new AnnotationIntrospector() { @Override public String findNameForGetter(AnnotatedMethod m) { return null; } @Override public String findNameForGetter(AnnotatedMethod m) { return ""; } @Override public boolean hasAnyGetterAnnotation(AnnotatedMethod m) { return false; } @Override public boolean hasAsValueAnnotation(AnnotatedMethod m) { return false; } @Override public String getName() { return null; } @Override public boolean hasAsValueAnnotation(AnnotatedMethod m) {
@Test public void getter() { Constructor<MyClass> constructor = MyClass.class.getDeclaredConstructor(); Method m = constructor.getDeclaredMethod("getMyClass"); AnnotationIntrospector ai = new AnnotationIntrospector(m); myClass._addGetterMethod(m, ai); Assert.assertEquals("myClass", myClass._class.getSimpleName()); myClass._addGetterMethod(m, ai); Assert.assertEquals("myClass", myClass._class.getSimpleName()); myClass._addGetterMethod(m, ai); Assert.assertEquals("myClass", myClass._class.getSimpleName()); myClass._addGetterMethod(m, null); Assert.assert
@Test public void getter() { Constructor<MyClass> constructor = MyClass.class.getDeclaredConstructor(); final MyClass myClass = constructor.newInstance(); AnnotationIntrospector ai = new AnnotationIntrospector() { @Override public boolean hasAnyGetterAnnotation(AnnotatedMethod m) { return true; } @Override public boolean hasAsValueAnnotation(AnnotatedMethod m) { return true; } @Override public String getName() { return null; } }; MyClass myClass2 = (MyClass) clazz.newInstance(); myClass2.setName("foo"); myClass2._addGetterMethod(m, ai); Assert.assertEquals("foo", myClass2.getName()); }
@Test(expected = IllegalArgumentException.class) public void methodWithNoGetterAnnotation() { AnnotationIntrospector ai = new AnnotationIntrospector(); Method m = Foo.class.getDeclaredMethod("getFoo"); m.setAccessible(true); new Foo()._addGetterMethod(m, ai); }
@Test public void getter() { Constructor<MyClass> constructor = MyClass.class.getDeclaredConstructor(); Method m = constructor.getDeclaredMethod("getMyClass"); AnnotationIntrospector ai = new AnnotationIntrospector(m); myClass._addGetterMethod(m, ai); Assert.assertEquals(1, myClass._getGetterMethods().size()); Assert.assertEquals(0, myClass._getGetterMethods().size()); myClass._setGetterMethods(null); myClass._addGetterMethod(m, ai); Assert.assertEquals(1, myClass._getGetterMethods().size()); Assert.assertEquals(0, myClass._getGetterMethods().size()); myClass._
@Test public void getter() { Constructor<MyClass> constructor = MyClass.class.getDeclaredConstructor(); final MyClass myClass = constructor.newInstance(); AnnotationIntrospector introspector = new AnnotationIntrospector() { @Override public void anyGetterAnnotation(AnnotatedMethod m) { } @Override public void anyGetterAnnotation(AnnotatedMethod m) { } @Override public void anyGetterAnnotation(AnnotatedMethod m) { } @Override public void anyGetterAnnotation(AnnotatedMethod m) { } @Override public void anyGetterAnnotation(AnnotatedMethod m) { } @Override public void anyGetterAnnotation(AnnotatedMethod m) { } @Override public void anyGetterAnnotation(AnnotatedMethod m) { } @
@Test public void getter() { Constructor<MyClass> constructor = MyClass.class.getDeclaredConstructor(); Method m = constructor.getDeclaredMethod("getMyClass"); AnnotationIntrospector ai = new AnnotationIntrospector(m); myClass._addGetterMethod(m, ai); Assert.assertEquals(1, myClass._getGetterMethods().size()); Assert.assertEquals("myClass", myClass._getGetterMethods().get(0).getMethodName()); myClass._addGetterMethod(m, ai); Assert.assertEquals(2, myClass._getGetterMethods().size()); Assert.assertEquals("myClass", myClass._getGetterMethods().get(0).getMethodName());
@Test public void accessorTest() { SimpleAccessor accessor = new SimpleAccessor(); accessor.setProperty("a", "b"); accessor.setProperty("b", "c"); accessor.setProperty("d", "d"); accessor.setProperty("e", "e"); accessor.setProperty("f", "f"); accessor.setProperty("g", "g"); accessor.setProperty("h", "h"); accessor.setProperty("i", "i"); accessor.setProperty("j", "j"); accessor.setProperty("k", "k"); accessor.setProperty("l", "l"); accessor.setProperty("d", "d"); accessor.setProperty("e", "e"); accessor.
@Test(expected = IllegalArgumentException.class) public void methodWithNoGetter() { AnnotationIntrospector ai = new AnnotationIntrospector(); Method m = Foo.class.getDeclaredMethod("getFoo"); m.setAccessible(true); new Foo()._addGetterMethod(m, ai); }
@Test public void testAddSetterMethod() throws Exception { final TestPOJOPropertiesCollector collector = new TestPOJOPropertiesCollector(); final AnnotationIntrospector ai = new AnnotationIntrospector() { @Override public String findNameForDeserialization(AnnotatedMethod m) { return null; } @Override public boolean hasIgnoreMarker(AnnotatedMethod m) { return false; } @Override public void addSetterMethod(AnnotatedMethod m, String propName, boolean visible, boolean ignore) { super._addSetterMethod(m, propName, visible, ignore); } @Override public void addSetterMethod(AnnotatedMethod m, String propName, boolean visible, boolean ignore) { super._addSetterMethod(m, propName, visible,
@Test public void testAddSetterMethod() throws Exception { final TestBean bean1 = new TestBean(); final TestBean bean2 = new TestBean(); final TestBean bean3 = new TestBean(); bean1._setTestBean(bean2); bean2._setTestBean(bean3); final TestBean bean4 = new TestBean(); bean4._setTestBean(bean1); final TestBean bean5 = new TestBean(); bean5._setTestBean(bean3); final TestBean bean6 = new TestBean(); bean6._setTestBean(bean4); bean4._setTestBean(bean5); final TestBean bean7 = new TestBean(); bean7.setTestBean
@Test public void testAddSetterMethod() throws Exception { final TestPOJOPropertiesCollector collector = new TestPOJOPropertiesCollector(); final String className = TestPOJO.class.getPackage().getName().replace(\'.\', \'/\') + "." + TestPOJO.class.getName().replace(\'.\', \'/\') + "." + TestPOJO.class.getName().replace(\'.\', \'/\') + "." + TestPOJO.class.getName().replace(\'.\', \'/\') + "." + TestPOJO.class.getName().replace(\'.\', \'/\') + "." + TestPOJO.class.getName().replace(\'.\', \'/\') + "." +
@Test public void testAddSetterMethod() { final TestBean bean = new TestBean(); final POJOPropertiesCollector collector = new POJOPropertiesCollector(new MapperConfig<TestBean>() { @Override public Class<?> getType() { return TestBean.class; } @Override public String getSimpleName() { return null; } @Override public boolean isSetterVisible(TestBean bean) { return false; } @Override public boolean hasIgnoreMarker(TestBean bean) { return false; } @Override public void addSetterMethod(AnnotatedMethod m, String propName, boolean visible, boolean ignore) { } }, false, null, null, null) { @Override public void addSetterMethod(AnnotatedMethod m,
@Test public void testAddSetterMethod() throws Exception { TestPOJOPropertiesCollector collector = new TestPOJOPropertiesCollector(); collector._addSetterMethod(MySetter.class.getDeclaredMethod("setMyField"), new AnnotationIntrospector() { @Override public String findNameForDeserialization(AnnotatedMethod m) { return "myField"; } @Override public String getSimpleName() { return null; } @Override public boolean hasIgnoreMarker(AnnotatedMethod m) { return false; } @Override public void addSetterMethod(AnnotatedMethod m, String explName, boolean visible, boolean ignore) { } @Override public void addSetterMethod(AnnotatedMethod m, String explName, boolean visible, boolean ignore
@Test public void testAddSetterMethod() { final TestPOJOPropertiesCollector collector = new TestPOJOPropertiesCollector(); final AnnotationIntrospector ai = new AnnotationIntrospector() { @Override public String findNameForDeserialization(AnnotatedMethod m) { return null; } @Override public boolean hasIgnoreMarker(AnnotatedMethod m) { return false; } @Override public void addSetterMethod(AnnotatedMethod m, String propName, boolean visible, boolean ignore) { super._addSetterMethod(m, propName, visible, ignore); } @Override public void addSetterMethod(AnnotatedMethod m, String propName, boolean visible, boolean ignore) { super._addSetterMethod(m, propName, visible, ignore);
@Test public void testAddSetterMethod() throws Exception { final TestPOJOPropertiesCollector collector = new TestPOJOPropertiesCollector(); final String className = TestPOJO.class.getPackage().getName().replace(\'.\', \'/\') + "." + TestPOJO.class.getName().replace(\'.\', \'/\') + TestPOJO.class.getName().replace(\'.\', \'/\') + TestPOJO.class.getName().replace(\'.\', \'/\') + TestPOJO.class.getName().replace(\'.\', \'/\') + TestPOJO.class.getName().replace(\'.\', \'/\') + TestPOJO.class.getName().replace(\'
@Test public void testAddSetterMethod() throws Exception { TestPOJOPropertiesCollector collector = new TestPOJOPropertiesCollector(); collector._addSetterMethod(MySetter.class.getDeclaredMethod("setMyField"), new AnnotationIntrospector(null)); collector._addSetterMethod(MySetter.class.getDeclaredMethod("setMyField2"), new AnnotationIntrospector(null)); collector._addSetterMethod(MySetter.class.getDeclaredMethod("setMyField3"), new AnnotationIntrospector(null)); collector._addSetterMethod(MySetter.class.getDeclaredMethod("setMyField4"), new AnnotationIntrospector(null)); collector._addSetterMethod(My
@Test public void testAddSetterMethod() { final TestPOJOPropertiesCollector collector = new TestPOJOPropertiesCollector(); final AnnotationIntrospector ai = new AnnotationIntrospector() { @Override public boolean isSetterVisible(AnnotatedMethod m) { return true; } @Override public String findNameForDeserialization(AnnotatedMethod m) { return null; } @Override public boolean hasIgnoreMarker(AnnotatedMethod m) { return false; } @Override public void addSetterMethod(AnnotatedMethod m, String propName, boolean visible, boolean ignore) { } @Override public void addSetterMethod(AnnotatedMethod m, String propName, boolean visible, boolean ignore) { } @Override public String findNameForDeserialization(
@Test public void testAddSetterMethod() throws Exception { final TestPOJOPropertiesCollector collector = new TestPOJOPropertiesCollector(); final AnnotationIntrospector ai = new AnnotationIntrospector() { @Override public boolean hasIgnoreMarker(AnnotatedMethod m) { return false; } @Override public String findNameForDeserialization(AnnotatedMethod m) { return null; } @Override public boolean hasIgnoreMarker(AnnotatedMethod m) { return false; } @Override public void _addSetterMethod(AnnotatedMethod m, String propName, boolean visible, boolean ignore) { } @Override public void _addSetterMethod(AnnotatedMethod m, String propName, boolean visible, boolean ignore) { } @Override public String findName
@Test public void testSetters() throws Exception { final TestBean bean1 = new TestBean(); final TestBean bean2 = new TestBean(); final TestBean bean3 = new TestBean(); final TestBean bean4 = new TestBean(); bean1._setTestBean(bean2); bean2._setTestBean(bean3); bean3._setTestBean(bean4); final TestBean bean4 = new TestBean(); bean4._setTestBean(bean4); final TestBean bean5 = new TestBean(); bean5._setTestBean(bean4); bean4._setTestBean(bean5); final TestBean bean6 = new TestBean(); bean6._setTestBean(
@Test public void test_addInjectables() { TestPOJOPropertiesCollector tc = new TestPOJOPropertiesCollector(); tc._addInjectables(); assertEquals(2, tc.getPropertyNames().size()); assertTrue(tc.getPropertyNames().contains("a")); assertTrue(tc.getPropertyNames().contains("b")); assertTrue(tc.getPropertyNames().contains("c")); assertTrue(tc.getPropertyNames().contains("d")); assertTrue(tc.getPropertyNames().contains("e")); assertTrue(tc.getPropertyNames().contains("f")); assertTrue(tc.getPropertyNames().contains("g")); assertTrue(tc.getPropertyNames().contains("h")); assert
@Test public void testAddInjectables() throws Exception { TestPOJOPropertiesCollector collector = new TestPOJOPropertiesCollector(); collector._addInjectables(); assertEquals(2, collector.getPropertyNames().size()); assertTrue(collector.getPropertyNames().contains("a")); assertTrue(collector.getPropertyNames().contains("b")); assertTrue(collector.getPropertyNames().contains("c")); assertTrue(collector.getPropertyNames().contains("d")); assertTrue(collector.getPropertyNames().contains("e")); assertTrue(collector.getPropertyNames().contains("f")); assertTrue(collector.getPropertyNames().contains("g")); assertTrue(collector.getPropertyNames().contains("h"));
@Test public void testAddInjectables() throws Exception { TestPOJOPropertiesCollector b = new TestPOJOPropertiesCollector(); b._addInjectables(); assertEquals(2, b.getPropMap().size()); assertTrue(b.getPropMap().containsKey("a")); assertTrue(b.getPropMap().containsKey("b")); assertTrue(b.getPropMap().containsKey("c")); assertTrue(b.getPropMap().containsKey("d")); assertTrue(b.getPropMap().containsKey("e")); assertTrue(b.getPropMap().containsKey("f")); assertTrue(b.getPropMap().containsKey("g
@Test public void testAddInjectables() { TestPOJOPropertiesCollector collector = new TestPOJOPropertiesCollector(); collector._addInjectables(); collector._addInjectables(); }
@Test public void testAddInjectables() throws Exception { TestPOJOPropertiesCollector collector = new TestPOJOPropertiesCollector(); collector._addInjectables(); collector._addInjectables(); }
@Test public void testAddInjectables() throws Exception { TestPOJOPropertiesCollector b = new TestPOJOPropertiesCollector(); b._addInjectables(); assertEquals(2, b.getPropMap().size()); assertTrue(b.getPropMap().containsKey("a")); assertTrue(b.getPropMap().containsKey("b")); assertTrue(b.getPropMap().containsKey("c")); assertTrue(b.getPropMap().containsKey("d")); assertTrue(b.getPropMap().containsKey("e")); assertTrue(b.getPropMap().containsKey("f")); assertTrue(b.getPropMap().containsKey("g
@Test public void test_addInjectables() { TestPOJOPropertiesCollector b = new TestPOJOPropertiesCollector(); b._addInjectables(); assertEquals(2, b.getPropMap().size()); assertTrue(b.getPropMap().containsKey("a")); assertTrue(b.getPropMap().containsKey("b")); assertTrue(b.getPropMap().containsKey("c")); assertTrue(b.getPropMap().containsKey("d")); assertTrue(b.getPropMap().containsKey("e")); assertTrue(b.getPropMap().containsKey("f")); assertTrue(b.getPropMap().containsKey("g")
@Test public void test_addInjectables() { MyClass2 myClass = new MyClass2(); Map<String, Object> props = new HashMap<String, Object>(); props.put("prop1", "prop1_value"); props.put("prop2", "prop2_value"); props.put("prop3", "prop3_value"); MyClass2 myClass2 = new MyClass2(); Map<String, Object> props2 = new HashMap<String, Object>(); props2.put("prop1", "prop1_value"); props2.put("prop2", "prop2_value"); props2.put("prop3", "prop3_value");
@Test public void testDoAddInjectable() throws Exception { MapperConfig<?> config = new MapperConfig<Object>() { @Override public Class<?> getType() { return null; } @Override public String getJsonValueMethod() { return null; } @Override public String getPrimaryClassName() { return null; } @Override public String getPrimaryMethodName() { return null; } @Override public List<String> getPrimaryFields() { return null; } @Override public List<String> getPrimaryFields() { return null; } @Override public List<String> getPrimaryFields2() { return null; } @Override public List<String> getPrimaryFields3() { return null; } @Override public List<String> getPrimaryFields
@Test public void testDoAddInjectable() throws Exception { Map<Object, AnnotatedMember> map = new LinkedHashMap<Object, AnnotatedMember>(); Map.Entry<Object, AnnotatedMember> entry = new Map.Entry<Object, AnnotatedMember>(); map._addInjectable(entry.getKey(), entry.getValue()); map._addInjectable(entry.getValue(), entry.getKey()); map._addInjectable(entry.getValue(), entry.getKey()); map._addInjectable(entry.getValue(), entry.getKey()); map._addInjectable(entry.getValue(), entry.getKey()); map._addInjectable(entry.getValue(), entry.getKey()); map._addInjectable
@Test(expected = IllegalArgumentException.class) public void addInjectable() throws Exception { Map<Object, AnnotatedMember> map = new LinkedHashMap<Object, AnnotatedMember>(); map.put("foo", new AnnotatedMember(Foo.class)); map.put("bar", new AnnotatedMember(Bar.class)); map.put("baz", new AnnotatedMember(Baz.class)); MapperConfig<?> config = new MapperConfig<Object>() { @Override public Class<?> getType() { return Foo.class; } @Override public Map<String, Object> getPropertyMap() { Map<String, Object> propertyMap = new HashMap<String, Object>(); propertyMap.put("foo", new
@Test public void test_removeUnwantedProperties() { Map<String, POJOPropertyBuilder> properties = new HashMap<String, POJOPropertyBuilder>(); properties.put("a", new POJOPropertyBuilder("a")); properties.put("b", new POJOPropertyBuilder("b")); properties.put("c", new POJOPropertyBuilder("c")); properties.put("d", new POJOPropertyBuilder("d")); properties.put("e", new POJOPropertyBuilder("e")); properties.put("f", new POJOPropertyBuilder("f")); properties.put("g", new POJOPropertyBuilder("g")); properties.put("h", new POJO
@Test public void testRemoveUnwantedProperties() { Map<String, POJOPropertyBuilder> properties = new HashMap<String, POJOPropertyBuilder>(); properties.put("a", new POJOPropertyBuilder("a")); properties.put("b", new POJOPropertyBuilder("b")); properties.put("c", new POJOPropertyBuilder("c")); properties.put("d", new POJOPropertyBuilder("d")); properties.put("e", new POJOPropertyBuilder("e")); properties.put("f", new POJOPropertyBuilder("f")); properties.put("g", new POJOPropertyBuilder("g")); properties.put("h", new POJOProperty
@Test public void testRemoveUnwantedProperties() throws Exception { Map<String, POJOPropertyBuilder> props = new HashMap<String, POJOPropertyBuilder>(); props.put("a", new POJOPropertyBuilder("a")); props.put("b", new POJOPropertyBuilder("b")); props.put("c", new POJOPropertyBuilder("c")); props.put("d", new POJOPropertyBuilder("d")); props.put("e", new POJOPropertyBuilder("e")); props.put("f", new POJOPropertyBuilder("f")); props.put("g", new POJOPropertyBuilder("g")); props.put("h", new PO
@Test public void testRemoveUnwantedProperties() { Map<String, POJOPropertyBuilder> properties = new HashMap<String, POJOPropertyBuilder>(); properties.put("foo", new POJOPropertyBuilder("foo")); properties.put("bar", new POJOPropertyBuilder("bar")); properties.put("baz", new POJOPropertyBuilder("baz")); Map<String, List<POJOPropertyBuilder>> propertiesMap = new HashMap<String, List<POJOPropertyBuilder>>(); propertiesMap.put("foo", new ArrayList<POJOPropertyBuilder>()); propertiesMap.put("bar", new ArrayList<POJOPropertyBuilder>()); propertiesMap.put("baz", new
@Test public void test_removeUnwantedProperties() { Map<String, POJOPropertyBuilder> properties = new HashMap<String, POJOPropertyBuilder>(); properties.put("foo", new POJOPropertyBuilder("foo")); properties.put("bar", new POJOPropertyBuilder("bar")); properties.put("baz", new POJOPropertyBuilder("baz")); Map<String, List<POJOPropertyBuilder>> propertiesMap = new HashMap<String, List<POJOPropertyBuilder>>(); propertiesMap.put("foo", new ArrayList<POJOPropertyBuilder>()); propertiesMap.put("bar", new ArrayList<POJOPropertyBuilder>()); propertiesMap.put("baz",
@Test public void test_removeUnwantedProperties() { Map<String, POJOPropertyBuilder> properties = new HashMap<String, POJOPropertyBuilder>(); properties.put("a", new POJOPropertyBuilder("a")); properties.put("b", new POJOPropertyBuilder("b")); properties.put("c", new POJOPropertyBuilder("c")); properties.put("d", new POJOPropertyBuilder("d")); properties.put("e", new POJOPropertyBuilder("e")); properties.put("f", new POJOPropertyBuilder("f")); properties.put("g", new POJOPropertyBuilder("g")); properties.put("h", new POJO
@Test public void testRemoveUnwantedProperties() { Map<String, POJOPropertyBuilder> properties = new HashMap<String, POJOPropertyBuilder>(); properties.put("a", new POJOPropertyBuilder("a")); properties.put("b", new POJOPropertyBuilder("b")); properties.put("c", new POJOPropertyBuilder("c")); properties.put("d", new POJOPropertyBuilder("d")); properties.put("e", new POJOPropertyBuilder("e")); properties.put("f", new POJOPropertyBuilder("f")); properties.put("g", new POJOPropertyBuilder("g")); properties.put("h", new POJOProperty
@Test public void testRemoveUnwantedProperties() throws Exception { Map<String, POJOPropertyBuilder> properties = new HashMap<String, POJOPropertyBuilder>(); properties.put("a", new POJOPropertyBuilder("a")); properties.put("b", new POJOPropertyBuilder("b")); properties.put("c", new POJOPropertyBuilder("c")); properties.put("d", new POJOPropertyBuilder("d")); properties.put("e", new POJOPropertyBuilder("e")); properties.put("f", new POJOPropertyBuilder("f")); properties.put("g", new POJOPropertyBuilder("g")); properties.put("h", new PO
@Test public void testRemoveUnwantedProperties() { Map<String, POJOPropertyBuilder> properties = new HashMap<String, POJOPropertyBuilder>(); properties.put("a", new POJOPropertyBuilder("a")); properties.put("b", new POJOPropertyBuilder("b")); properties.put("c", new POJOPropertyBuilder("c")); properties.put("d", new POJOPropertyBuilder("d")); properties.put("e", new POJOPropertyBuilder("e")); properties.put("f", new POJOPropertyBuilder("f")); properties.put("g", new POJOPropertyBuilder("g")); properties.put("h", new POJOProperty
@Test public void _renameProperties() { Map<String, POJOPropertyBuilder> props1 = new HashMap<String, POJOPropertyBuilder>(); props1.put("foo", new POJOPropertyBuilder("foo")); props1.put("bar", new POJOPropertyBuilder("bar")); props1.put("baz", new POJOPropertyBuilder("baz")); Map<String, POJOPropertyBuilder> props2 = new HashMap<String, POJOPropertyBuilder>(); props2.put("foo", new POJOPropertyBuilder("foo")); props2.put("bar", new POJOPropertyBuilder("bar")); props2.put("baz", new POJO
@Test public void test_renameProperties() { Map<String, POJOPropertyBuilder> props1 = new HashMap<String, POJOPropertyBuilder>(); props1.put("foo", new POJOPropertyBuilder("foo")); props1.put("bar", new POJOPropertyBuilder("bar")); props1.put("baz", new POJOPropertyBuilder("baz")); Map<String, POJOPropertyBuilder> props2 = new HashMap<String, POJOPropertyBuilder>(); props2.put("foo", new POJOPropertyBuilder("foo")); props2.put("bar", new POJOPropertyBuilder("bar")); props2.put("baz", new PO
@Test public void _renameProperties() { Map<String, POJOPropertyBuilder> props1 = new HashMap<String, POJOPropertyBuilder>(); props1.put("foo", new POJOPropertyBuilder("foo")); props1.put("bar", new POJOPropertyBuilder("bar")); props1.put("baz", new POJOPropertyBuilder("baz")); Map<String, POJOPropertyBuilder> props2 = new HashMap<String, POJOPropertyBuilder>(); props2.put("foo", new POJOPropertyBuilder("foo")); props2.put("bar", new POJOPropertyBuilder("bar")); props2.put("baz", new POJO
@Test public void test_renameProperties() { Map<String, POJOPropertyBuilder> props1 = new HashMap<String, POJOPropertyBuilder>(); props1.put("foo", new POJOPropertyBuilder("foo")); props1.put("bar", new POJOPropertyBuilder("bar")); props1.put("baz", new POJOPropertyBuilder("baz")); Map<String, POJOPropertyBuilder> props2 = new HashMap<String, POJOPropertyBuilder>(); props2.put("foo", new POJOPropertyBuilder("foo")); props2.put("bar", new POJOPropertyBuilder("bar")); props2.put("baz", new PO
@Test public void test_renameProperties() { Map<String, POJOPropertyBuilder> props1 = new HashMap<String, POJOPropertyBuilder>(); props1.put("foo", new POJOPropertyBuilder("foo")); props1.put("bar", new POJOPropertyBuilder("bar")); props1.put("baz", new POJOPropertyBuilder("baz")); Map<String, POJOPropertyBuilder> props2 = new HashMap<String, POJOPropertyBuilder>(); props2.put("foo", new POJOPropertyBuilder("foo")); props2.put("bar", new POJOPropertyBuilder("bar")); props2.put("baz", new PO
@Test public void test_renameProperties() { Map<String, POJOPropertyBuilder> props = new HashMap<String, POJOPropertyBuilder>(); props.put("foo", new POJOPropertyBuilder("foo")); props.put("bar", new POJOPropertyBuilder("bar")); props.put("baz", new POJOPropertyBuilder("baz")); props.put("baz", new POJOPropertyBuilder("baz")); final POJOPropertiesCollector obj = new POJOPropertiesCollector(new MapperConfig<String>(), false, null, null, null); obj.properties.put("foo", new POJOPropertyBuilder("foo")); obj.properties.put("bar
@Test public void test_renameProperties() { Map<String, POJOPropertyBuilder> properties = new HashMap<String, POJOPropertyBuilder>(); properties.put("foo", new POJOPropertyBuilder().setName("foo")); properties.put("bar", new POJOPropertyBuilder().setName("bar")); properties.put("baz", new POJOPropertyBuilder().setName("baz")); properties.put("baz", new POJOPropertyBuilder().setName("baz")); properties.put("baz", new POJOPropertyBuilder().setName("baz")); properties.put("baz", new POJOPropertyBuilder().setName("baz"));
@Test public void test_renameProperties() { Map<String, POJOPropertyBuilder> props1 = new HashMap<String, POJOPropertyBuilder>(); props1.put("foo", new POJOPropertyBuilder("foo")); props1.put("bar", new POJOPropertyBuilder("bar")); props1.put("baz", new POJOPropertyBuilder("baz")); Map<String, POJOPropertyBuilder> props2 = new HashMap<String, POJOPropertyBuilder>(); props2.put("foo", new POJOPropertyBuilder("foo")); props2.put("bar", new POJOPropertyBuilder("bar")); props2.put("baz", new PO
@Test public void test_renameProperties() { Map<String, POJOPropertyBuilder> props1 = new HashMap<String, POJOPropertyBuilder>(); props1.put("foo", new POJOPropertyBuilder("foo")); props1.put("bar", new POJOPropertyBuilder("bar")); props1.put("baz", new POJOPropertyBuilder("baz")); Map<String, POJOPropertyBuilder> props2 = new HashMap<String, POJOPropertyBuilder>(); props2.put("foo", new POJOPropertyBuilder("foo")); props2.put("bar", new POJOPropertyBuilder("bar")); props2.put("baz", new PO
@Test public void test_renameProperties() { Map<String, POJOPropertyBuilder> props1 = new HashMap<String, POJOPropertyBuilder>(); props1.put("foo", new POJOPropertyBuilder("foo")); props1.put("bar", new POJOPropertyBuilder("bar")); props1.put("baz", new POJOPropertyBuilder("baz")); Map<String, POJOPropertyBuilder> props2 = new HashMap<String, POJOPropertyBuilder>(); props2.put("foo", new POJOPropertyBuilder("foo")); props2.put("bar", new POJOPropertyBuilder("bar")); props2.put("baz", new PO
@Test public void test_renameProperties() { Map<String, POJOPropertyBuilder> properties = new HashMap<String, POJOPropertyBuilder>(); properties.put("foo", new POJOPropertyBuilder("foo", "foo")); properties.put("bar", new POJOPropertyBuilder("bar", "bar")); properties.put("baz", new POJOPropertyBuilder("baz", "baz")); properties.put("baz", new POJOPropertyBuilder("baz", "baz")); properties.put("foo", new POJOPropertyBuilder("foo", "foo")); properties.put("bar", new POJOPropertyBuilder("bar", "bar")); properties.
@Test public void test_renameProperties() { Map<String, POJOPropertyBuilder> properties = new HashMap<String, POJOPropertyBuilder>(); properties.put("foo", new POJOPropertyBuilder().setName("foo")); properties.put("bar", new POJOPropertyBuilder().setName("bar")); properties.put("baz", new POJOPropertyBuilder().setName("baz")); properties.put("baz", new POJOPropertyBuilder().setName("baz")); properties.put("baz2", new POJOPropertyBuilder().setName("baz2")); properties.put("baz3", new POJOPropertyBuilder().setName("b
@Test public void _renameProperties() { Map<String, POJOPropertyBuilder> props1 = new HashMap<String, POJOPropertyBuilder>(); props1.put("foo", new POJOPropertyBuilder("foo")); props1.put("bar", new POJOPropertyBuilder("bar")); props1.put("baz", new POJOPropertyBuilder("baz")); Map<String, POJOPropertyBuilder> props2 = new HashMap<String, POJOPropertyBuilder>(); props2.put("foo", new POJOPropertyBuilder("foo")); props2.put("bar", new POJOPropertyBuilder("bar")); props2.put("baz", new POJO
@Test public void test_renameProperties() { Map<String, POJOPropertyBuilder> props1 = new HashMap<String, POJOPropertyBuilder>(); props1.put("foo", new POJOPropertyBuilder("foo")); props1.put("bar", new POJOPropertyBuilder("bar")); props1.put("baz", new POJOPropertyBuilder("baz")); Map<String, POJOPropertyBuilder> props2 = new HashMap<String, POJOPropertyBuilder>(); props2.put("foo", new POJOPropertyBuilder("foo")); props2.put("bar", new POJOPropertyBuilder("bar")); props2.put("baz", new PO
@Test public void test_renameProperties() { Map<String, POJOPropertyBuilder> props1 = new HashMap<String, POJOPropertyBuilder>(); props1.put("foo", new POJOPropertyBuilder("foo")); props1.put("bar", new POJOPropertyBuilder("bar")); props1.put("baz", new POJOPropertyBuilder("baz")); Map<String, POJOPropertyBuilder> props2 = new HashMap<String, POJOPropertyBuilder>(); props2.put("foo", new POJOPropertyBuilder("foo")); props2.put("bar", new POJOPropertyBuilder("bar")); props2.put("baz", new PO
@Test public void _renameProperties() { Map<String, POJOPropertyBuilder> props = new HashMap<String, POJOPropertyBuilder>(); props.put("foo", new POJOPropertyBuilder("foo")); props.put("bar", new POJOPropertyBuilder("bar")); props.put("baz", new POJOPropertyBuilder("baz")); props.put("baz", new POJOPropertyBuilder("baz")); new POJOPropertiesCollector(new MapperConfig<>(), false, null, null, null).setProperties(props); new POJOPropertiesCollector(new MapperConfig<>(), false, null, null, null).setProperties(props); new POJOPropertiesCollector
@Test public void test_renameProperties() { Map<String, POJOPropertyBuilder> properties1 = new HashMap<String, POJOPropertyBuilder>(); properties1.put("foo", new POJOPropertyBuilder("foo")); properties1.put("bar", new POJOPropertyBuilder("bar")); Map<String, POJOPropertyBuilder> properties2 = new HashMap<String, POJOPropertyBuilder>(); properties2.put("foo", new POJOPropertyBuilder("foo")); properties2.put("bar", new POJOPropertyBuilder("bar")); Map<String, POJOPropertyBuilder> properties3 = new HashMap<String, POJOPropertyBuilder>(); properties3.put("
@Test public void test_renameProperties() { Map<String, POJOPropertyBuilder> props1 = new HashMap<String, POJOPropertyBuilder>(); props1.put("foo", new POJOPropertyBuilder("foo")); props1.put("bar", new POJOPropertyBuilder("bar")); props1.put("baz", new POJOPropertyBuilder("baz")); Map<String, POJOPropertyBuilder> props2 = new HashMap<String, POJOPropertyBuilder>(); props2.put("foo", new POJOPropertyBuilder("foo")); props2.put("bar", new POJOPropertyBuilder("bar")); props2.put("baz", new PO
@Test public void _renameProperties() { Map<String, POJOPropertyBuilder> properties = new HashMap<String, POJOPropertyBuilder>(); properties.put("foo", new POJOPropertyBuilder().setName("foo")); properties.put("bar", new POJOPropertyBuilder().setName("bar")); properties.put("baz", new POJOPropertyBuilder().setName("baz").setInternalName("baz")); properties.put("baz", new POJOPropertyBuilder().setName("baz").setInternalName("baz")); properties.put("baz", new POJOPropertyBuilder().setName("baz").setInternalName("baz"));
@Test public void test_renameProperties() { Map<String, POJOPropertyBuilder> props1 = new HashMap<String, POJOPropertyBuilder>(); props1.put("foo", new POJOPropertyBuilder("foo")); props1.put("bar", new POJOPropertyBuilder("bar")); props1.put("baz", new POJOPropertyBuilder("baz")); Map<String, POJOPropertyBuilder> props2 = new HashMap<String, POJOPropertyBuilder>(); props2.put("foo", new POJOPropertyBuilder("foo")); props2.put("bar", new POJOPropertyBuilder("bar")); props2.put("baz", new PO
@Test public void testSimple() { final TestConfig config = new TestConfig(); final POJOPropertiesCollector collector = new POJOPropertiesCollector(config, false, null, null, null); collector._properties.put("foo", new POJOPropertyBuilder("foo", "foo")); collector._properties.put("bar", new POJOPropertyBuilder("bar", "bar")); collector._properties.put("baz", new POJOPropertyBuilder("baz", "baz")); collector._renameUsing(new PropertyNamingStrategy() { @Override public void apply(POJOPropertyBuilder b) { Assert.assertEquals("foo", b.getName()); Assert.assertEquals("bar", b.get
@Test(expected = IllegalArgumentException.class) public void renameUsing() { new TestPOJOPropertiesCollector(_config, false, null, null, null); new TestPOJOPropertiesCollector(_config, false, null, null, null)._renameUsing(new PropertyNamingStrategy() { @Override public String[] getNames() { return new String[0]; } @Override public String[] getNames2() { return new String[0]; } @Override public String[] getNames3() { return new String[0]; } @Override public String[] getNames4() { return new String[0]; } @Override public String[] getNames5() { return new String[0]; } @Override public String[]
@Test public void test_renameUsing() { final TestConfig config = new TestConfig(); final POJOPropertiesCollector collector = new POJOPropertiesCollector(config, false, null, null, null); final PropertyNamingStrategy namingStrategy = new PropertyNamingStrategy() { @Override public void apply(POJOPropertyBuilder b) { } @Override public void apply(POJOPropertyBuilder b) { } @Override public void apply(POJOPropertyBuilder b) { } @Override public void apply(POJOPropertyBuilder b) { } @Override public void apply(POJOPropertyBuilder b) { } @Override public void apply(POJOPropertyBuilder b) { } @Override public void apply(POJOProperty
@Test public void test_property() throws Exception { Map<String, POJOPropertyBuilder> props = new LinkedHashMap<String, POJOPropertyBuilder>(); POJOPropertyBuilder builder = new POJOPropertyBuilder("foo", null, false); props.put("foo", builder); POJOPropertyBuilder builder2 = new POJOPropertyBuilder("bar", null, false); props.put("bar2", builder2); POJOPropertyBuilder builder3 = new POJOPropertyBuilder("baz", null, false); props.put("baz", builder3); POJOPropertyBuilder builder4 = new POJOPropertyBuilder("foo", null, false); props.put("baz2", builder4);
@Test public void test_property() { Map<String, POJOPropertyBuilder> props = new LinkedHashMap<String, POJOPropertyBuilder>(); props.put("a", new POJOPropertyBuilder("a", null, false)); props.put("b", new POJOPropertyBuilder("b", null, false)); props.put("c", new POJOPropertyBuilder("c", null, false)); props.put("d", new POJOPropertyBuilder("d", null, false)); props.put("e", new POJOPropertyBuilder("e", null, false)); props.put("f", new POJOPropertyBuilder("f", null, false)); props.put("g", new POJO
@Test public void test_property() { Map<String, POJOPropertyBuilder> props = new LinkedHashMap<String, POJOPropertyBuilder>(); POJOPropertyBuilder b1 = new POJOPropertyBuilder("a", null, false); POJOPropertyBuilder b2 = new POJOPropertyBuilder("b", null, false); props.put("a", b1); props.put("b", b2); POJOPropertyBuilder b3 = new POJOPropertyBuilder("c", null, false); props.put("c", b3); POJOPropertyBuilder b4 = new POJOPropertyBuilder("d", null, false); props.put("d", b4); POJOPropertyBuilder b
@Test public void test_property() { Map<String, POJOPropertyBuilder> properties = new LinkedHashMap<String, POJOPropertyBuilder>(); properties.put("foo", new POJOPropertyBuilder("foo", _annotationIntrospector, true)); properties.put("bar", new POJOPropertyBuilder("bar", _annotationIntrospector, true)); properties.put("baz", new POJOPropertyBuilder("baz", _annotationIntrospector, true)); POJOPropertyBuilder b1 = new POJOPropertyBuilder("baz", _annotationIntrospector, true); POJOPropertyBuilder b2 = new POJOPropertyBuilder("foo", _annotationIntrospector, true); POJO
@Test public void test_property() { Map<String, POJOPropertyBuilder> properties = new LinkedHashMap<String, POJOPropertyBuilder>(); properties.put("a", new POJOPropertyBuilder("a", null, false)); properties.put("b", new POJOPropertyBuilder("b", null, false)); properties.put("c", new POJOPropertyBuilder("c", null, false)); properties.put("d", new POJOPropertyBuilder("d", null, false)); properties.put("e", new POJOPropertyBuilder("e", null, false)); properties.put("f", new POJOPropertyBuilder("f", null, false)); properties.put("g", new POJO
@Test public void test_property() { Map<String, POJOPropertyBuilder> props = new HashMap<String, POJOPropertyBuilder>(); POJOPropertyBuilder b1 = new POJOPropertyBuilder("a", null, false); POJOPropertyBuilder b2 = new POJOPropertyBuilder("b", null, false); props.put("a", b1); props.put("b", b2); POJOPropertyBuilder b3 = new POJOPropertyBuilder("c", null, false); props.put("c", b3); POJOPropertyBuilder b4 = new POJOPropertyBuilder("d", null, false); props.put("d", b4); POJOPropertyBuilder b
@Test public void test_find_naming_strategy() { class MyCustomPropertyNamingStrategy extends MyCustomPropertyNamingStrategy { private static final long serialVersionUID = 1L; } class MyCustomPropertyNamingStrategy extends MyCustomPropertyNamingStrategy { private static final long serialVersionUID = 1L; } class MyCustomPropertyNamingStrategy extends MyCustomPropertyNamingStrategy { private static final long serialVersionUID = 1L; } class MyCustomPropertyNamingStrategy extends MyCustomPropertyNamingStrategy { private static final long serialVersionUID = 1L; } class MyCustomPropertyNamingStrategy extends MyCustomPropertyNamingStrategy { private static final long serialVersionUID = 1L; } class MyCustomPropertyNamingStrategy extends MyCustomPropertyNamingStrategy { private static final long serialVersionUID =
@Test public void testSimpleProperty() { SimplePropertyNamingStrategy pns = new SimplePropertyNamingStrategy(); SimplePropertyNamingStrategy pns1 = new SimplePropertyNamingStrategy(); SimplePropertyNamingStrategy pns2 = new SimplePropertyNamingStrategy(); SimplePropertyNamingStrategy pns3 = new SimplePropertyNamingStrategy(); assertSame(pns, pns1.getNamingStrategy()); assertSame(pns1, pns2.getNamingStrategy()); assertSame(pns2, pns3.getNamingStrategy()); assertSame(pns1, pns1.getNamingStrategy()); assertSame(pns2, pns2.getNamingStrategy()); assertSame(pns3, pns3
@Test public void testGetPropertyNamingStrategy() { class MyCustomPropertyNamingStrategy extends MyCustomPropertyNamingStrategy { private static final long serialVersionUID = 1L; @Override protected PropertyNamingStrategy newNamingStrategyInstance(MapperConfig<?> config, Class<?> clazz, Class<?> clazz) { return new MyCustomPropertyNamingStrategy(); } } class MyCustomPropertyNamingStrategy extends MyCustomPropertyNamingStrategy { private static final long serialVersionUID = 1L; @Override protected PropertyNamingStrategy newNamingStrategyInstance(MapperConfig<?> config, Class<?> clazz, Class<?> clazz) { return new MyCustomPropertyNamingStrategy(); } } MyCustomPropertyNamingStrategy myCustomPropertyNamingStrategy = new MyCustomPropertyNamingStrategy
@Test public void testGetPropertyNamingStrategy() { class MyCustomPropertyNamingStrategy extends MyCustomPropertyNamingStrategy {} MyCustomPropertyNamingStrategy myCustomPropertyNamingStrategy = new MyCustomPropertyNamingStrategy(); assertEquals(myCustomPropertyNamingStrategy.getClass(), MyCustomPropertyNamingStrategy.class); assertEquals(myCustomPropertyNamingStrategy.getClass(), MyCustomPropertyNamingStrategy.class); MyCustomPropertyNamingStrategy customPropertyNamingStrategy = new MyCustomPropertyNamingStrategy(); assertEquals(myCustomPropertyNamingStrategy.getClass(), customPropertyNamingStrategy.getClass()); assertEquals(myCustomPropertyNamingStrategy.getClass(), customPropertyNamingStrategy.getClass()); assertEquals(myCustomPropertyNamingStrategy.
@Test public void test_deserializeIfNatural() throws IOException, JsonProcessingException { when(jsonParserMock.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); when(jsonParserMock.getText()).thenReturn("test"); assertEquals("test", _deserializer._deserializeIfNatural(jsonParserMock, null)); when(jsonParserMock.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); when(jsonParserMock.getText()).thenReturn("test2"); assertEquals("test2", _deserializer._deserializeIfNatural(jsonParserMock, null)); when(jsonParserMock.getCurrentToken()).thenReturn(Json
@Test public void testObjectReader() { ObjectReader reader = new ObjectReader(null, new DeserializationConfig() { @Override public boolean useRootWrapping() { return true; } @Override public JavaType valueType() { return JavaType.STRING; } @Override public String useRootName(String name) { return name; } @Override public JsonFactory jsonFactory() { return new JsonFactory(); } @Override public ObjectReader with(DeserializationFeature feature) { return new ObjectReader(null, new DeserializationConfig() { @Override public JavaType valueType() { return JavaType.STRING; } @Override public boolean useRootWrapping() { return true; } @Override public JsonDeserializer<Object>
@Test public void testObjectReader() { ObjectReader reader = new ObjectReader(null, new DeserializationConfig() { @Override public boolean useRootWrapping() { return true; } @Override public JavaType valueType() { return JavaType.STRING; } @Override public String useRootName(String name) { return name; } @Override public JsonFactory newJsonFactory() { return new JsonFactory(); } @Override public JsonDeserializer<Object> newJsonDeserializer() { return new JsonDeserializer<Object>() { @Override public Object read(JsonNodeFactory jsonNodeFactory) { return null; } @Override public Object read(JsonNodeFactory jsonNodeFactory) { return null; } @Override public void
@Test public void testObjectReader() { MockDeserializationConfig config = new MockDeserializationConfig(); ObjectReader reader = new ObjectReader(new SimpleObjectReader(), config); assertEquals(reader._context, config); assertEquals(reader._rootDeserializers, config.rootDeserializers); assertEquals(reader._jsonFactory, config.jsonFactory); assertEquals(reader._rootNames, config.rootNames); assertEquals(reader._valueType, config.valueType); assertEquals(reader._valueToUpdate, config.valueToUpdate); assertEquals(reader._schema, config.schema()); assertEquals(reader._injectableValues, config.injectableValues); assertEquals(reader._unwrapRoot, config
@Test public void testObjectReader() { MockDeserializationConfig config = new MockDeserializationConfig(); config.setUseRootWrapping(true); ObjectReader reader = new ObjectReader(new SimpleObjectReader(), config); assertEquals(reader._rootName, reader.getRootName()); assertEquals(reader._context, reader.getContext()); assertEquals(reader._rootDeserializer, reader._rootDeserializer); assertEquals(reader._valueType, reader._valueType); assertEquals(reader._valueToUpdate, reader._valueToUpdate); assertEquals(reader._schema, reader._schema); assertEquals(reader._injectableValues, reader._injectableValues); assertEquals(reader._unwrapRoot, reader._un
@Test public void testObjectReader() { MockDeserializationConfig config = new MockDeserializationConfig(); ObjectReader reader = new ObjectReader(new SimpleObjectReader(config), config); assertEquals(reader._jsonFactory, config.getJsonFactory()); assertEquals(reader._rootDeserializer, config.getRootDeserializer()); assertEquals(reader._rootNames, config.getRootNames()); assertEquals(reader._valueType, config.getValueType()); assertEquals(reader._valueToUpdate, config.getValueToUpdate()); assertEquals(reader._schema, config.getSchema()); assertEquals(reader._injectableValues, config.injectableValues()); assertEquals(reader._unwrapRoot, config.useRootWrapping());
@Test public void testObjectReader() { MockDeserializationConfig config = new MockDeserializationConfig(); config.setUseRootWrapping(true); ObjectReader reader = new ObjectReader(new SimpleObjectReader(), config); assertEquals(reader._rootNames, reader._rootNames); assertEquals(reader._context, reader._context); assertEquals(reader._jsonFactory, reader._jsonFactory); assertEquals(reader._rootDeserializer, reader._rootDeserializer); assertEquals(reader._valueToUpdate, reader._valueToUpdate); assertEquals(reader._schema, reader._schema); assertEquals(reader._injectableValues, reader._injectableValues); assertEquals(reader._unwrapRoot, reader._unwrapRoot
@Test public void testObjectReader() { SimpleDeserializationConfig config = new SimpleDeserializationConfig(); ObjectReader reader = new ObjectReader(new SimpleDeserializationConfig(), config); assertEquals(reader._valueType, SimpleDeserializationConfig.class); assertEquals(reader._context, config); assertEquals(reader._rootDeserializer, config.rootDeserializer); assertEquals(reader._valueType, SimpleDeserializationConfig.class); assertEquals(reader._jsonFactory, config.jsonFactory); assertEquals(reader._rootNames, config.rootNames); assertEquals(reader._valueType, SimpleDeserializationConfig.class); assertEquals(reader._valueToUpdate, config.valueToUpdate); assertEquals(reader._
@Test public void testObjectReader() { ObjectReader reader = new ObjectReader(new SimpleObjectReader(), new SimpleDeserializationConfig()) { @Override public boolean useRootWrapping() { return true; } }; assertEquals(reader._rootDeserializer, reader._rootDeserializer); assertEquals(reader._context, reader._context); assertEquals(reader._rootNames, reader._rootNames); assertEquals(reader._valueType, reader._valueType); assertEquals(reader._valueToUpdate, reader._valueToUpdate); assertEquals(reader._schema, reader._schema); assertEquals(reader._injectableValues, reader._injectableValues); assertEquals(reader._unwrapRoot, reader._unwrapRoot);
@Test public void testObjectReader() { MockDeserializationConfig config = new MockDeserializationConfig(); ObjectReader reader = new ObjectReader(new SimpleObjectReader(), config); assertEquals(reader._valueToUpdate, reader._valueToUpdate); reader.with(JsonFactory.createObjectNodeFactory()); assertEquals(reader._valueToUpdate, reader._valueToUpdate); reader.with(JsonFactory.createObjectNodeFactory()); assertEquals(reader._valueToUpdate, reader._valueToUpdate); reader.with(JsonFactory.createObjectNodeFactory()); assertEquals(reader._valueToUpdate, reader._valueToUpdate); reader.with(JsonFactory.createObjectNodeFactory()); assertEquals(reader._valueToUpdate, reader._valueToUpdate
@Test public void testObjectReader() { ObjectReader reader = new ObjectReader(null, new DeserializationConfig() { @Override public JavaType getType() { return JavaType.STRING; } @Override public boolean useRootWrapping() { return true; } @Override public boolean useValueType() { return true; } @Override public boolean useValueToUpdate() { return true; } @Override public FormatSchema schema() { return FormatSchema.JSON; } @Override public List<String> getRootNames() { return Collections.emptyList(); } @Override public List<String> getValueTypes() { return Collections.emptyList(); } @Override public JsonFactory newJsonFactory() { return null; } @Override public
@Test public void testObjectReader() { MockDeserializationConfig config = new MockDeserializationConfig(); config.setUseRootWrapping(true); ObjectReader reader = new ObjectReader(null, config, null, null, null, null, null, null); assertEquals(null, reader._injectableValues); assertEquals(null, reader._context); assertEquals(null, reader._rootDeserializers); assertEquals(null, reader._jsonFactory); assertEquals(null, reader._rootNames); assertEquals(null, reader._valueType); assertEquals(null, reader._valueToUpdate); assertEquals(null, reader._schema); assertEquals(null, reader._dataFormatReaders); }
@Test public void testUnwrapRoot() { SimpleDeserializationConfig config = new SimpleDeserializationConfig(); config.useRootWrapping = true; ObjectReader reader = new SimpleObjectReader(null, config); reader._unwrapRoot = true; reader._context = null; reader._rootDeserializers = null; reader._jsonFactory = null; reader._rootNames = null; reader._valueType = null; reader._valueToUpdate = null; reader._schema = null; reader._injectableValues = null; reader._dataFormatReaders = null; reader._unwrapRoot = true; reader._context = null; reader._rootDeserializer = null; reader._dataFormatReaders = null; reader.withRoot
@Test public void testObjectReader() { ObjectReader reader = new ObjectReader(new SimpleObjectReader(), new SimpleDeserializationConfig()) { @Override public boolean useRootWrapping() { return true; } @Override public ObjectReader with(DeserializationFeature feature) { return feature; } }; assertEquals(reader._dataFormatReaders, reader._dataFormatReaders); assertEquals(reader._context, reader._context); assertEquals(reader._rootDeserializers, reader._rootDeserializers); assertEquals(reader._jsonFactory, reader._jsonFactory); assertEquals(reader._rootNames, reader._rootNames); assertEquals(reader._valueType, reader._valueType); assertEquals(reader._injectable
@Test public void testWithHandler() { DeserializationConfig config = new DeserializationConfig() { @Override public Class<? extends Annotation> annotationType() { return null; } @Override public DeserializationFeature[] feature() { return new DeserializationFeature[0]; } }; ObjectReader reader = new ObjectReader(new DefaultDeserializationConfig(config), config) .withHandler(new DeserializationProblemHandler() { @Override public void handle(JsonNode jsonNode, DeserializationFeature feature) { } @Override public void handle(JsonNode jsonNode, DeserializationFeature feature) { } @Override public void handle(JsonNode jsonNode, DeserializationFeature feature) { } @
@Test public void testWithHandler() { DeserializationConfig config = new DeserializationConfig() { @Override public void withHandler(DeserializationProblemHandler h) { } @Override public void withHandler(DeserializationProblemHandler h) { } @Override public void withHandler(DeserializationProblemHandler h) { } @Override public void withHandler(DeserializationProblemHandler h) { } @Override public void withHandler(DeserializationProblemHandler h) { } @Override public void withHandler(DeserializationProblemHandler h) { } @Override public void withHandler(DeserializationProblemHandler h) { } @Override public void withHandler(DeserializationProblemHandler h) { } @Override public void withHandler
@Test public void testReadValue() throws IOException, JsonProcessingException { Date date = new Date(); SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); Date date2 = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); Date date3 = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); Date date4 = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); Date date5 = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.
@Test public void testReadValue() throws IOException, JsonProcessingException { final Object value = new Object(); final ObjectMapper mapper = new ObjectMapper() { @Override public Class<?> loadClass(String name, boolean resolve) throws IOException { return name; } @Override public Class<?> loadClass(String name, boolean resolve) throws IOException { return name; } @Override public Class<?> loadClass(String name, boolean resolve) throws IOException { return name; } @Override public Class<?> loadClass(String name, boolean resolve) throws IOException { return name; } @Override public Class<?> loadClass(String name, boolean resolve) throws IOException { return name; } @Override public Class<?> loadClass(String name, boolean resolve)
@Test public void test() throws IOException, JsonProcessingException { Date date = new Date(); SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); format.setTimeZone(TimeZone.getTimeZone("UTC")); JsonFactory f = new JsonFactory(); JsonParser parser = f.createParser("{\\"date\\":\\"" + date.getTime() + "\\"}"); reader.readValue(parser); assertEquals(date.getTime(), parser.nextNode().get("date").getAsDate().getTime()); assertEquals(date.getTime(), parser.nextNode().get("date").getAsDate().getTime()); }
@Test public void testBindAndClose() throws IOException, JsonParseException, JsonMappingException { FormatSchema schema = FormatSchema.builder(null).build(); ObjectReader reader = new ObjectReader(null, null, null, schema, null); JsonParser jp = Mockito.mock(JsonParser.class); Mockito.when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); Mockito.when(jp.nextToken()).thenReturn(JsonToken.END_OBJECT); Mockito.when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); Mockito.when(jp.nextToken()).thenReturn(JsonToken.END_OBJECT);
@Test(expected = JsonParseException.class) public void testJsonParseException() throws JsonParseException, JsonMappingException, IOException { JsonParser jp = Mockito.mock(JsonParser.class); Mockito.when(jp.nextToken()).thenReturn(JsonToken.NULL); Mockito.when(jp.nextToken()).thenReturn(JsonToken.VALUE_NULL); Mockito.when(jp.nextToken()).thenReturn(JsonToken.VALUE_INT); Mockito.when(jp.nextToken()).thenReturn(JsonToken.VALUE_DOUBLE); Mockito.when(jp.nextToken()).thenReturn(JsonToken.VALUE_STRING); Mockito.when(
@Test public void testBindAndClose() throws JsonParseException, JsonMappingException, IOException { SimpleType valueToUpdate = new SimpleType(); SimpleType valueToUpdate2 = new SimpleType(); SimpleType valueToUpdate3 = new SimpleType(); SimpleType valueToUpdate4 = new SimpleType(); SimpleType valueToUpdate5 = new SimpleType(); SimpleType valueToUpdate6 = new SimpleType(); JsonParser jp = Mockito.mock(JsonParser.class); Mockito.doReturn(valueToUpdate).when(jp).nextToken(); Mockito.doReturn(valueToUpdate2).when(jp).nextToken(); Mockito.doReturn(valueToUpdate3).when(jp).nextToken(); Mockito.doReturn(
@Test public void test_with_serializationConfig() { final DeserializationConfig config = new DeserializationConfig(); final ObjectReader reader = new ObjectReader(null, config) { @Override public ObjectReader with(DeserializationConfig config) { return reader._with(config); } }; final DeserializationConfig newConfig = new DeserializationConfig() { @Override public ObjectReader with(DeserializationConfig config) { return reader._with(newConfig); } }; final ObjectReader reader2 = reader.with(config); final DeserializationConfig newConfig2 = new DeserializationConfig() { @Override public ObjectReader with(DeserializationConfig config) { return reader._with(
@Test public void testObjectReader() { Date date = new Date(); DeserializationConfig config = DeserializationConfig.builder() .withDeserializationFeature(DeserializationFeature.DATE) .withType(Date.class) .withValueToUpdate(date) .withFormatDetection(FormatDetection.JSON) .build(); ObjectReader reader = new ObjectReader(null, config) .with(config) .with(date); assertTrue(reader.next(date)); assertTrue(reader.next(date)); assertTrue(reader.next(date)); assertTrue(reader.next(date)); assertTrue(reader.next(date)); assertTrue(reader.next(date)); assertTrue(reader
@Test public void testObjectReader() { Date date = new Date(); DeserializationConfig config = DeserializationConfig.builder() .withDeserializationFeature(DeserializationFeature.DATE) .withType(Date.class) .withValueToUpdate(date) .withFormatDetection(FormatDetection.JSON) .build(); ObjectReader reader = new ObjectReader(new ObjectMapper(), config) .with(config) .with(FormatSchema.JSON); List<DeserializationFeature> features = reader.getFeatures(); assertEquals(3, features.size()); assertEquals(date, features.get(0).getType()); assertEquals(date, features.get(1).getType()); assertEquals(date
@Test public void testObjectReader() { ObjectReader reader = new ObjectReader(new ObjectReader(new DeserializationConfig()), new DeserializationConfig()) .with(new DeserializationConfig()) .with(new DeserializationConfig()) .with(new DeserializationConfig()) .with(new DeserializationConfig()) .with(new DeserializationConfig()) .with(new DeserializationConfig()) .with(new DeserializationConfig()) .with(new ObjectReader(new DeserializationConfig()) .with(new DeserializationConfig()) .with(new DeserializationConfig()) .with(new ObjectReader(new DeserializationConfig()) .with(new Deserialization
@Test public void testContainedTypeCount() { CollectionLikeType type = CollectionLikeType.construct(List.class, Type.INT_TYPE); assertEquals(1, type.containedTypeCount()); type = CollectionLikeType.construct(List.class, Type.INT_TYPE); assertEquals(1, type.containedTypeCount()); type = CollectionLikeType.construct(List.class, Type.INT_TYPE); assertEquals(1, type.containedTypeCount()); type = CollectionLikeType.construct(List.class, Type.INT_TYPE); assertEquals(1, type.containedTypeCount()); type = CollectionLikeType.construct(List.class, Type.
@Test public void testContainedTypeCount() { assertEquals(1, CollectionLikeType.construct(List.class, Type.INT_TYPE).containedTypeCount()); assertEquals(1, CollectionLikeType.construct(List.class, Type.INT_TYPE).containedTypeCount(0)); assertEquals(1, CollectionLikeType.construct(List.class, Type.INT_TYPE).containedTypeCount(1)); assertEquals(2, CollectionLikeType.construct(List.class, Type.INT_TYPE).containedTypeCount(2)); assertEquals(3, CollectionLikeType.construct(List.class, Type.INT_TYPE).containedTypeCount(3
@Test public void testBuildCanonicalName() { CollectionLikeType type = CollectionLikeType.construct(List.class, Type.INT_TYPE); assertEquals("List<Integer>", type.buildCanonicalName()); type = CollectionLikeType.construct(List.class, Type.INT_TYPE); assertEquals("List<Integer>", type.buildCanonicalName()); type = CollectionLikeType.construct(List.class, Type.INT_TYPE); assertEquals("List<Integer>", type.buildCanonicalName()); type = CollectionLikeType.construct(List.class, Type.INT_TYPE); assertEquals("List<Integer>", type.buildCanonicalName()); type = CollectionLikeType.construct
@Test public void testBuildCanonicalName() { CollectionLikeType type = CollectionLikeType.construct(List.class, SimpleType.INT_TYPE); assertEquals("List<Integer>", type.buildCanonicalName()); type = CollectionLikeType.construct(List.class, SimpleType.INT_TYPE); assertEquals("List<Integer>", type.buildCanonicalName()); type = CollectionLikeType.construct(List.class, SimpleType.INT_TYPE); assertEquals("List<Integer>", type.buildCanonicalName()); type = CollectionLikeType.construct(List.class, SimpleType.INT_TYPE); assertEquals("List<Integer>", type.buildCanonicalName()); type = Collection
@Test public void testBuildCanonicalName() { CollectionLikeType type = CollectionLikeType.construct(List.class, SimpleType.INT_TYPE); assertEquals("List<Integer>", type.buildCanonicalName()); type = CollectionLikeType.construct(List.class, SimpleType.INT_TYPE); assertEquals("List<Integer>", type.buildCanonicalName()); type = CollectionLikeType.construct(List.class, SimpleType.INT_TYPE); assertEquals("List<Integer>", type.buildCanonicalName()); type = CollectionLikeType.construct(List.class, SimpleType.INT_TYPE); assertEquals("List<Integer>", type.buildCanonicalName()); type = Collection
@Test public void testBuildCanonicalName() { CollectionLikeType type = CollectionLikeType.construct(List.class, DefaultTypes.LIST); assertEquals("List<String>", type.buildCanonicalName()); type = CollectionLikeType.construct(List.class, DefaultTypes.LIST); assertEquals("List<String>", type.buildCanonicalName()); type = CollectionLikeType.construct(List.class, DefaultTypes.LIST); assertEquals("List<String>", type.buildCanonicalName()); type = CollectionLikeType.construct(List.class, DefaultTypes.LIST); assertEquals("List<String>", type.buildCanonicalName()); type = CollectionLikeType.construct(List.class
@Test public void testBuildCanonicalName() { CollectionLikeType type = CollectionLikeType.construct(List.class, SimpleType.INT_TYPE); assertEquals("List<Integer>", type.buildCanonicalName()); type = CollectionLikeType.construct(List.class, SimpleType.INT_TYPE); assertEquals("List<Integer>", type.buildCanonicalName()); type = CollectionLikeType.construct(List.class, SimpleType.INT_TYPE); assertEquals("List<Integer>", type.buildCanonicalName()); type = CollectionLikeType.construct(List.class, SimpleType.INT_TYPE); assertEquals("List<Integer>", type.buildCanonicalName()); type = Collection
@Test public void testBuildCanonicalName() { CollectionLikeType type = CollectionLikeType.construct(List.class, SimpleType.INT_TYPE); assertEquals("List<Integer>", type.buildCanonicalName()); type = CollectionLikeType.construct(List.class, SimpleType.INT_TYPE); assertEquals("List<Integer>", type.buildCanonicalName()); type = CollectionLikeType.construct(List.class, SimpleType.INT_TYPE); assertEquals("List<Integer>", type.buildCanonicalName()); type = CollectionLikeType.construct(List.class, SimpleType.INT_TYPE); assertEquals("List<Integer>", type.buildCanonicalName()); type = Collection
@Test public void testBuildCanonicalName() { CollectionLikeType type = CollectionLikeType.construct(List.class, SimpleType.INT_TYPE); assertEquals("List<Integer>", type.buildCanonicalName()); type = CollectionLikeType.construct(List.class, SimpleType.INT_TYPE); assertEquals("List<Integer>", type.buildCanonicalName()); type = CollectionLikeType.construct(List.class, SimpleType.INT_TYPE); assertEquals("List<Integer>", type.buildCanonicalName()); type = CollectionLikeType.construct(List.class, SimpleType.INT_TYPE); assertEquals("List<Integer>", type.buildCanonicalName()); type = Collection
@Test public void testBuildCanonicalName() { CollectionLikeType type = CollectionLikeType.construct(List.class, SimpleType.INT_TYPE); assertEquals("List<Integer>", type.buildCanonicalName()); type = CollectionLikeType.construct(List.class, SimpleType.INT_TYPE); assertEquals("List<Integer>", type.buildCanonicalName()); type = CollectionLikeType.construct(List.class, SimpleType.INT_TYPE); assertEquals("List<Integer>", type.buildCanonicalName()); type = CollectionLikeType.construct(List.class, SimpleType.INT_TYPE); assertEquals("List<Integer>", type.buildCanonicalName()); type = Collection
@Test public void test() throws IOException, JsonProcessingException { StringWriter out = new StringWriter(); JsonGenerator jgen = new JsonFactory().createGenerator(out); new MockTypeSerializer().serialize(jgen, new DefaultSerializerProvider()); jgen.flush(); String result = out.toString(); Assert.assertTrue(result.contains("int")); Assert.assertTrue(result.contains("long")); Assert.assertTrue(result.contains("float")); Assert.assertTrue(result.contains("double")); }
@Test public void testMap() throws IOException, JsonProcessingException { TypeBase<Map<String, Integer>> typeBase = new TypeBase<Map<String, Integer>>(Map.class, 0, new HashMap<String, Integer>(), new HashMap<String, Integer>()); StringWriter out = new StringWriter(); JsonGenerator jgen = new JsonFactory().createGenerator(out); typeBase.serialize(jgen, new DefaultSerializerProvider()); jgen.flush(); String result = out.toString(); Assert.assertTrue(result.contains("map")); Assert.assertTrue(result.contains("int")); Assert.assertTrue(result.contains("long")); Assert.assertTrue(result.contains("
@Test public void testArrayOfObjects() { ObjectWriter writer = new ObjectWriter(new ObjectMapper(), new SerializationConfig().with(FormatSchema.ARRAY_OF_OBJECT)); writer.with(TimeZone.getTimeZone("UTC")); assertEquals( "[{\\"type\\":\\"array\\",\\"items\\":[\\"a\\",\\"b\\"]},{\\"type\\":\\"array\\",\\"items\\":[\\"c\\"]},{\\"type\\":\\"array\\",\\"items\\":[\\"d\\"]},{\\"type\\":\\"array\\",\\"items\\":[\\"e\\"]},{\\"type\\":\\"array\\",\\"items\\":[\\"f
@Test public void testArrayOfPrimitives() { ObjectWriter w = new ObjectWriter(new ObjectMapper(), new SerializationConfig().with(SerializationFeature.ARRAY_OF_PRIMITIVES)); w.with(TimeZone.getTimeZone("UTC")); w.with(TimeZone.getTimeZone("Etc/UTC")); w.with(TimeZone.getTimeZone("Etc/UTC")); w.with(TimeZone.getTimeZone("Etc/UTC")); w.with(TimeZone.getTimeZone("Etc/UTC")); w.with(TimeZone.getTimeZone("Etc/UTC")); w.with(TimeZone.getTimeZone("Etc/UTC")); w.with(TimeZone.
@Test public void testObjectWriter() { ObjectWriter w = new ObjectWriter(new ObjectMapper(), new SerializationConfig().with(FormatSchema.JSON_SERIALIZER)); w.with(FormatSchema.JSON_ARRAY); w.with(FormatSchema.JSON_ARRAY); w.with(FormatSchema.JSON_ARRAY); w.with(FormatSchema.JSON_ARRAY); w.with(FormatSchema.JSON_ARRAY); w.with(FormatSchema.JSON_ARRAY); w.with(FormatSchema.JSON_ARRAY); w.with(FormatSchema.JSON_ARRAY); w.with(FormatSchema.JSON_ARRAY); w.with(FormatSchema.JSON_ARRAY); w.with
@Test(expected = JsonMappingException.class) public void testJsonMappingException() throws IOException, JsonProcessingException { Map<String, Object> value = new HashMap<String, Object>(); value.put("key1", "value1"); value.put("key2", "value2"); ObjectMapper mapper = new ObjectMapper(); JsonFactory jsonFactory = new JsonFactory() { @Override public JsonGenerator createGenerator(JsonGenerator jgen) throws IOException, JsonMappingException { throw new JsonMappingException(); } }; ObjectWriter w = new ObjectWriter() { @Override public void with(SerializationFeature feature) throws JsonMappingException, JsonProcessingException { throw new JsonMappingException(); } }; w.writeValueAsString
@Test(expected = JsonMappingException.class) public void testWriteValueAsBytesThrowsException() throws IOException, JsonProcessingException { SimpleSerializationConfig config = new SimpleSerializationConfig(true, true, Charset.forName("UTF-8")); ObjectWriter w = new ObjectWriter(null, config); w.writeValueAsBytes(new Object()); }
@Test(expected = JsonMappingException.class) public void testWriteValueAsBytesThrowsException() throws IOException, JsonProcessingException { when(_jsonFactory.createGenerator(any(ByteArrayOutputStream.class), any(JsonEncoding.class), any(Object.class))) .thenThrow(new JsonProcessingException(JsonProcessingException.class)); _writer.writeValueAsBytes(new Object()); }
@Test(expected = JsonMappingException.class) public void testWriteValueAsBytesThrowsMappingException() throws IOException, JsonProcessingException { SimpleSerializationConfig config = new SimpleSerializationConfig(true, true, Charset.forName("UTF-8")); ObjectWriter w = new ObjectWriter(null, config); w.writeValueAsBytes(new Object()); }
@Test(expected = JsonMappingException.class) public void testJsonMappingException() throws IOException, JsonProcessingException { when(_jsonFactory.createGenerator(any(ByteArrayOutputStream.class), any(JsonEncoding.class), any(Object.class))).thenThrow(JsonProcessingException.class); _writer.writeValueAsBytes(new Object()); }
@Test(expected = JsonMappingException.class) public void testWriteValueAsBytesThrowsException() throws JsonProcessingException { SimpleSerializationConfig config = new SimpleSerializationConfig(true, true, Charset.forName("UTF-8")); ObjectWriter w = new ObjectWriter(mapper, config, JavaType.BOOLEAN, new DefaultPrettyPrinter(), new FormatSchema(null, null, null)); w.writeValueAsBytes(new Object()); }
@Test(expected = JsonMappingException.class) public void testWriteValueAsBytesThrowsException() throws JsonProcessingException { SimpleSerializationConfig config = new SimpleSerializationConfig(true, true, Charset.forName("UTF-8")); ObjectWriter writer = new ObjectWriter(null, config, TypeRegistry.getDefault(), new DefaultPrettyPrinter(), new FormatSchema(TypeRegistry.getDefault())); writer.writeValueAsBytes(new Object()); }
@Test(expected = JsonMappingException.class) public void testWriteValueAsBytesThrowsException() throws JsonProcessingException { SimpleSerializationConfig config = new SimpleSerializationConfig(true, true, Charset.forName("UTF-8")); ObjectWriter w = new ObjectWriter(mapper, config, TypeFactory.defaultInstance(), new DefaultPrettyPrinter(), new FormatSchema(TypeFactory.defaultInstance())); w.writeValueAsBytes(new Object()); }
@Test public void testConfigAndWriteValue() throws IOException, JsonGenerationException, JsonMappingException { final SimpleSerializationConfig config = new SimpleSerializationConfig() { @Override public boolean isEnabled(SerializationFeature.CLOSE_CLOSEABLE) { return true; } @Override public JavaType rootType() { return JavaType.STRING; } @Override public SimpleSerializer<String> _serializerProvider() { return new SimpleSerializer<String>() { @Override public String serializeValue(JsonGenerator jgen, Object value, SerializationConfig config) { return null; } @Override public void serializeValue(JsonGenerator jgen, Object value, SerializationConfig config) { } @Override public boolean isEnabled(SerializationFeature.CLOSE_
@Test public void testConfigAndWriteValue() throws IOException, JsonGenerationException, JsonMappingException { final SimpleSerializationConfig config = new SimpleSerializationConfig() { @Override public boolean isEnabled(SerializationFeature.CLOSE_CLOSEABLE) { return true; } @Override public JavaType rootType() { return JavaType.STRING; } @Override public SimpleSerializer<String> _serializerProvider() { return new SimpleSerializer<String>() { @Override public String serializeValue(JsonGenerator jgen, Object value, SerializationConfig config) { return null; } @Override public void serializeValue(JsonGenerator jgen, Object value, SerializationConfig config) { } @Override public boolean isEnabled(SerializationFeature.CLOSE_
@Test public void testFindValue() { assertNull(JsonNodeFactory.instance.createObjectNode()); assertNull(JsonNodeFactory.instance.createArrayNode().add("foo")); assertNull(JsonNodeFactory.instance.createArrayNode().add("bar")); assertNull(JsonNodeFactory.instance.createObjectNode().add("baz")); assertNull(JsonNodeFactory.instance.createArrayNode().add("baz")); assertNull(JsonNodeFactory.instance.createObjectNode().add("foo")); assertNull(JsonNodeFactory.instance.createArrayNode().add("bar")); assertNull(JsonNodeFactory.instance.createObjectNode().add("b
@Test public void testFindParent() { List<JsonNode> children = new ArrayList<JsonNode>(); children.add(JsonNodeFactory.instance.objectNode()); children.add(JsonNodeFactory.instance.objectNode()); children.add(JsonNodeFactory.instance.objectNode()); children.add(JsonNodeFactory.instance.objectNode()); List<JsonNode> findChildren = new ArrayList<JsonNode>(); findChildren.add(JsonNodeFactory.instance.objectNode()); findChildren.add(JsonNodeFactory.instance.objectNode()); findChildren.add(JsonNodeFactory.instance.objectNode()); findChildren.add(JsonNodeFactory.instance.objectNode()); findChildren
@Test public void createSimpleDeserializer() throws Exception { SimpleDeserializationContext ctxt = mock(SimpleDeserializationContext.class); when(ctxt.getTypeFactory()).thenReturn(typeFactory); SimpleDeserializationConfig config = mock(SimpleDeserializationConfig.class); when(ctxt.getConfig()).thenReturn(config); SimpleConverter<Object, Object> b = mock(SimpleConverter.class); when(config.findPOJOBuilder()).thenReturn(b); SimpleConverter<Object, Object> conv = mock(SimpleConverter.class); when(config.findDeserializationConverter()).thenReturn(conv); when(ctxt.getTypeFactory()).thenReturn(typeFactory); when(
@Test public void createSimpleDeserializer() throws Exception { SimpleDeserializationContext ctxt = mock(SimpleDeserializationContext.class); DeserializerFactory factory = mock(DeserializerFactory.class); SimpleBean bean = mock(SimpleBean.class); when(ctxt.getConfig()).thenReturn(config); when(ctxt.getTypeFactory()).thenReturn(factory); SimpleBean bean2 = mock(SimpleBean.class); when(ctxt.getBean2()).thenReturn(bean2); SimpleBean bean3 = mock(SimpleBean.class); when(ctxt.getBean3()).thenReturn(bean3); SimpleBean bean4 = mock(SimpleBean.class); when(bean3.get
@Test public void testEnumDeserializer2() throws JsonMappingException { SimpleDeserializationContext ctxt = new SimpleDeserializationContext(); Configuration config = new Configuration(); DeserializerFactory factory = new DefaultDeserializationFactory(config); JavaType type = mock(JavaType.class); BeanDescription beanDesc = mock(BeanDescription.class); when(beanDesc.findExpectedFormat(null)).thenReturn(JsonFormat.Value.STRING); JsonDeserializer<?> d = _createDeserializer2(ctxt, factory, type, beanDesc); Assert.assertTrue(d instanceof EnumDeserializer); d = _createDeserializer2(ctxt, factory, type, beanDesc); Assert.assertTrue(d instanceof EnumDeserializer); d = _
@Test(expected=JsonMappingException.class) public void testModifyTypeByAnnotation() throws JsonMappingException { ClassPathResource res = new ClassPathResource("test1.json"); ClassPathResource res2 = new ClassPathResource("test2.json"); ClassPathResource res3 = new ClassPathResource("test3.json"); ClassPathResource res4 = new ClassPathResource("test4.json"); ClassPathResource res5 = new ClassPathResource("test5.json"); ClassPathResource res6 = new ClassPathResource("test6.json"); ClassPathResource res7 = new ClassPathResource("test7.json"); ClassPathResource res8 = new ClassPathResource("test8
@Test public void testModifyTypeByAnnotation() throws JsonMappingException { ClassPathResource resource = new ClassPathResource("testModifyTypeByAnnotation.json"); ClassPathResource a = resource.getFile(); ClassPathResource b = new ClassPathResource("testModifyTypeByAnnotation.json"); ClassPathResource c = new ClassPathResource("testModifyTypeByAnnotation.json"); ClassPathResource d = new ClassPathResource("testModifyTypeByAnnotation.json"); ClassPathResource e = new ClassPathResource("testModifyTypeByAnnotation.json"); ClassPathResource f = new ClassPathResource("testModifyTypeByAnnotation.json"); ClassPathResource g = new ClassPathResource("testModifyTypeByAnnotation.
@Test(expected=JsonMappingException.class) public void testModifyTypeByAnnotation() throws Exception { ClassPathResource res = new ClassPathResource("testModifyTypeByAnnotation.json"); ClassPathResource res1 = new ClassPathResource("testModifyTypeByAnnotation1.json"); ClassPathResource res2 = new ClassPathResource("testModifyTypeByAnnotation2.json"); ClassPathResource res3 = new ClassPathResource("testModifyTypeByAnnotation3.json"); ClassPathResource res4 = new ClassPathResource("testModifyTypeByAnnotation4.json"); ClassPathResource res5 = new ClassPathResource("testModifyTypeByAnnotation5.json"); ClassPathResource res6 = new Class
@Test(expected=JsonMappingException.class) public void testModifyTypeByAnnotation() throws Exception { ClassPathResource res = new ClassPathResource("test1.json"); ClassPathResource res2 = new ClassPathResource("test2.json"); ClassPathResource res3 = new ClassPathResource("test3.json"); ClassPathResource res4 = new ClassPathResource("test4.json"); ClassPathResource res5 = new ClassPathResource("test5.json"); doReturn(res).when(ctxt).getResource(res); doReturn(res2).when(ctxt).getResource(res3); doReturn(res4).when(ctxt).getResource(res5); do
@Test(expected=JsonMappingException.class) public void testModifyTypeByAnnotation() throws Exception { Class clazz = ClassAsData.class; ClassAsData data = new ClassAsData(); SimpleDeserializationContext ctxt = new SimpleDeserializationContext(clazz, data); SimpleDeserializationBuilder builder = new SimpleDeserializationBuilder(); SimpleDeserializationContext ctxt2 = new SimpleDeserializationContext(ctxt2, data); SimpleDeserializationContext ctxt3 = new SimpleDeserializationContext(ctxt3, data); SimpleDeserializationBuilder builder2 = new SimpleDeserializationBuilder(); SimpleDeserializationContext ctxt4 = new SimpleDeserializationContext(ctxt4, data); SimpleDeserializationContext ctxt5 = new SimpleDeserialization
@Test(expected=JsonMappingException.class) public void testModifyTypeByAnnotation() throws JsonMappingException { Class<?> clazz = Class.forName("io.opendaylight.yang.gen.v1.urn.opendaylight.openjdk8.internal.json.mapper.SimpleSerializationTest$SimpleSerializationTest$SimpleSerializationTest$SimpleSerializationTest$SimpleSerializationTest$SimpleSerializationTest"); SimpleSerializationTest$SimpleSerializationTest$SimpleSerializationTest$SimpleSerializationTest$SimpleSerializationTest$SimpleSerializationTest$SimpleSerializationTest$SimpleSerializationTest$SimpleSerializationTest$SimpleSerializationTest$SimpleSerializationTest$SimpleSerializationTest$SimpleSerializationTest$SimpleSerializationTest$Simple
@Test(expected=JsonMappingException.class) public void testModifyTypeByAnnotation() throws Exception { Class<?> type = Class.forName("java.util.Map"); Class<?>subtype = Class.forName("java.util.List"); Class<?> keyClass = Class.forName("java.util.Map"); Class<?> subType = Class.forName("java.util.List"); doReturn(type).when(ctxt).getAnnotationIntrospector(); doReturn(subType).when(ctxt).findDeserializationType(eq(type), any(Annotated.class)); doReturn(keyClass).when(ctxt).findDeserializationKeyType(eq(type), any(
@Test(expected=JsonMappingException.class) public void testModifyTypeByAnnotation() throws JsonMappingException { Class<?> clazz = Class.forName("io.opendaylight.yang.gen.v1.urn.opendaylight.openjdk8.internal.jsonmapping.SimpleSerializationTest$SimpleSerializationTest$SimpleSerializationTest"); SimpleSerializationTest$SimpleSerializationTest$SimpleSerializationTest$SimpleSerializationTest$SimpleSerializationTest$SimpleSerializationTest$SimpleSerializationTest$SimpleSerializationTest$SimpleSerializationTest$SimpleSerializationTest$SimpleSerializationTest$SimpleSerializationTest$SimpleSerializationTest$SimpleSerializationTest$SimpleSerializationTest$SimpleSerializationTest$SimpleSerializationTest$SimpleSerialization
@Test(expected=JsonMappingException.class) public void testModifyTypeByAnnotation() throws Exception { Class<?> type = Class.forName("java.util.Map"); Class<?> subclass = Class.forName("java.util.List"); Class<?> keyClass = Class.forName("java.util.Map"); Class<?> subType = Class.forName("java.util.List"); doReturn(type).when(ctxt).getAnnotationIntrospector(); doReturn(subclass).when(ctxt).findDeserializationType(eq(type), any(Annotated.class)); doReturn(keyClass).when(ctxt).findDeserializationKeyType(eq(type), any(Type
@Test public void test_verifyAsClass() throws Exception { Assert.assertEquals(String.class, _verifyAsClass(null, null, String.class)); Assert.assertEquals(String.class, _verifyAsClass(123, null, String.class)); Assert.assertEquals(Long.class, _verifyAsClass(123L, null, Long.class)); Assert.assertEquals(Double.class, _verifyAsClass(123.1, null, Double.class)); Assert.assertEquals(Double.class, _verifyAsClass(123.1d, null, Double.class)); Assert.assertEquals(Double.class, _verifyAsClass(123.1d,
@Test(expected = IllegalStateException.class) public void testValidateAsClassThrowsIllegalStateException() throws Exception { Class<?> cls = Object.class; Method m = cls.getDeclaredMethod("verifyAsClass", Object.class, Object.class); m.setAccessible(true); m.invoke(cls, "verifyAsClass", null, Object.class); }
@Test(expected = IllegalStateException.class) public void testValidateAsClassThrowsIllegalStateException() throws Exception { Class<?> cls = Object.class; _verifyAsClass(cls, "testValidateAsClassThrowsIllegalStateException", cls); }
@Test(expected = IllegalStateException.class) public void testValidateAsClassThrowsIllegalStateException() { Class<?> cls = _verifyAsClass(new Object(), "testMethod", Object.class); }
@Test(expected = IllegalStateException.class) public void testValidateAsClass() throws Exception { Class<?> cls = Object.class; _verifyAsClass(cls, "testMethod", cls); }
@Test(expected = IllegalStateException.class) public void testVerifyAsClassThrowsIllegalStateException() { Class<?> cls = _verifyAsClass(new Object(), "testMethod", Object.class); }
@Test public void testEmptyIterator() throws IOException { assertThat(iterator.hasNext(), is(false)); assertThat(iterator.next(), nullValue()); assertThat(iterator.hasNext(), is(true)); assertThat(iterator.next(), nullValue()); assertThat(iterator.hasNext(), is(true)); assertThat(iterator.next(), nullValue()); assertThat(iterator.hasNext(), is(true)); assertThat(iterator.next(), nullValue()); assertThat(iterator.hasNext(), is(false)); assertThat(iterator.next(), nullValue()); assertThat(iterator.hasNext(), is(false)); assertThat(iterator.next(), nullValue()); assertThat(iterator.
@Test public void testReadAll() throws Exception { assertThat(iterator.hasNext(), is(false)); assertThat(iterator.next(), nullValue()); assertThat(iterator.hasNext(), is(true)); assertThat(iterator.next(), nullValue()); assertThat(iterator.hasNext(), is(true)); assertThat(iterator.next(), nullValue()); assertThat(iterator.hasNext(), is(true)); assertThat(iterator.next(), nullValue()); assertThat(iterator.hasNext(), is(false)); assertThat(iterator.next(), nullValue()); assertThat(iterator.hasNext(), is(false)); assertThat(iterator.next(), nullValue()); assertThat(iterator.
@Test public void testReadAll() throws Exception { assertThat(iterator.hasNext(), is(true)); assertThat(iterator.next(), nullValue()); assertThat(iterator.hasNext(), is(false)); assertThat(iterator.next(), nullValue()); assertThat(iterator.hasNext(), is(true)); assertThat(iterator.next(), nullValue()); assertThat(iterator.hasNext(), is(true)); assertThat(iterator.next(), nullValue()); assertThat(iterator.hasNext(), is(false)); assertThat(iterator.next(), nullValue()); assertThat(iterator.hasNext(), is(false)); assertThat(iterator.next(), nullValue()); assertThat(iterator.
@Test public void testEmptyIterator() throws IOException { assertThat(MappingIterator.emptyIterator().hasNext(), is(false)); assertThat(MappingIterator.emptyIterator().nextValue(), nullValue()); assertThat(MappingIterator.emptyIterator().hasNext(), is(true)); assertThat(MappingIterator.emptyIterator().nextValue(), nullValue()); assertThat(MappingIterator.emptyIterator().nextValue(), nullValue()); assertThat(MappingIterator.emptyIterator().hasNext(), is(true)); assertThat(MappingIterator.emptyIterator().nextValue(), nullValue()); assertThat(MappingIterator.emptyIterator().nextValue(), nullValue()); assertThat(MappingIterator.emptyIterator().hasNext(), is(
@Test public void testEmptyIterator() throws IOException { assertThat(MappingIterator.emptyIterator().hasNext(), is(false)); assertThat(MappingIterator.emptyIterator().nextValue(), nullValue()); assertThat(MappingIterator.emptyIterator().hasNext(), is(true)); assertThat(MappingIterator.emptyIterator().nextValue(), nullValue()); assertThat(MappingIterator.emptyIterator().nextValue(), nullValue()); assertThat(MappingIterator.emptyIterator().hasNext(), is(true)); assertThat(MappingIterator.emptyIterator().nextValue(), nullValue()); assertThat(MappingIterator.emptyIterator().nextValue(), nullValue()); assertThat(MappingIterator.emptyIterator().hasNext(), is(
@Test public void testReadAll() throws IOException { assertThat(iterator.hasNext(), is(false)); assertThat(iterator.next(), nullValue()); assertThat(iterator.hasNext(), is(true)); assertThat(iterator.next(), nullValue()); assertThat(iterator.hasNext(), is(true)); assertThat(iterator.next(), nullValue()); assertThat(iterator.hasNext(), is(true)); assertThat(iterator.next(), nullValue()); assertThat(iterator.hasNext(), is(false)); assertThat(iterator.next(), nullValue()); assertThat(iterator.hasNext(), is(false)); assertThat(iterator.next(), nullValue()); assertThat(iterator.
@Test public void testEmptyIterator() throws IOException { assertThat(iterator.hasNext(), is(false)); assertThat(iterator.nextValue(), nullValue()); assertThat(iterator.hasNext(), is(true)); assertThat(iterator.nextValue(), nullValue()); assertThat(iterator.hasNext(), is(true)); assertThat(iterator.nextValue(), nullValue()); assertThat(iterator.hasNext(), is(false)); assertThat(iterator.nextValue(), nullValue()); assertThat(iterator.hasNext(), is(false)); assertThat(iterator.nextValue(), nullValue()); assertThat(iterator.hasNext(), is(false)); assertThat(iterator.nextValue(), nullValue
@Test public void testReadAll() throws Exception { assertThat(iterator.hasNextValue(), equalTo(true)); assertThat(iterator.nextValue(), nullValue()); assertThat(iterator.hasNextValue(), equalTo(false)); assertThat(iterator.nextValue(), nullValue()); assertThat(iterator.hasNextValue(), equalTo(true)); assertThat(iterator.nextValue(), nullValue()); assertThat(iterator.hasNextValue(), equalTo(true)); assertThat(iterator.nextValue(), nullValue()); assertThat(iterator.hasNextValue(), equalTo(false)); assertThat(iterator.nextValue(), nullValue()); assertThat(iterator.hasNextValue(), equalTo(
@Test public void testReadAll() throws IOException { assertThat(iterator.hasNextValue(), equalTo(true)); assertThat(iterator.nextValue(), equalTo(1)); assertThat(iterator.hasNextValue(), equalTo(false)); assertThat(iterator.nextValue(), equalTo(2)); assertThat(iterator.hasNextValue(), equalTo(true)); assertThat(iterator.nextValue(), equalTo(3)); assertThat(iterator.hasNextValue(), equalTo(true)); assertThat(iterator.nextValue(), equalTo(4)); assertThat(iterator.hasNextValue(), equalTo(true)); assertThat(iterator.nextValue(), equalTo(5)); assertThat
@Test public void testEmptyIterator() throws IOException { assertThat(iterator.hasNext(), is(false)); assertThat(iterator.nextValue(), nullValue()); assertThat(iterator.hasNext(), is(true)); assertThat(iterator.nextValue(), nullValue()); assertThat(iterator.hasNext(), is(true)); assertThat(iterator.nextValue(), nullValue()); assertThat(iterator.hasNext(), is(true)); assertThat(iterator.nextValue(), nullValue()); assertThat(iterator.hasNext(), is(true)); assertThat(iterator.nextValue(), nullValue()); assertThat(iterator.hasNext(), is(true)); assertThat(iterator.nextValue(), nullValue
@Test public void testHasNext() throws Exception { assertFalse(Iterator.emptyIterator().hasNext()); assertFalse(Iterator.emptyIterator().next()); assertTrue(Iterator.emptyIterator().hasNext()); assertTrue(Iterator.emptyIterator().nextValue()); assertTrue(Iterator.emptyIterator().hasNext()); assertTrue(Iterator.emptyIterator().nextValue()); assertTrue(Iterator.emptyIterator().nextValue()); assertTrue(Iterator.emptyIterator().nextValue()); assertTrue(Iterator.emptyIterator().nextValue()); assertTrue(Iterator.emptyIterator().nextValue()); assertTrue(Iterator.emptyIterator().nextValue()); assertTrue(Iterator.emptyIterator().nextValue()); assertTrue(Iterator.empty
@Test(expected = RuntimeJsonMappingException.class) public void testHasNextOnRuntimeJsonMappingException() throws IOException { JsonDeserializer<String> stringDeserializer = new JsonDeserializer<String>() { @Override public String deserialize(JsonReader reader, DeserializationContext context) throws IOException { throw new RuntimeJsonMappingException("TEST"); } }; JsonDeserializer<Integer> intDeserializer = new JsonDeserializer<Integer>() { @Override public Integer deserialize(JsonReader reader, DeserializationContext context) throws IOException { throw new RuntimeJsonMappingException("TEST"); } }; JsonDeserializer<String> stringDeserializer = new JsonDeserializer<String>() { @Override public String deserialize(JsonReader reader, Deserial
@Test public void testHasNextValue() throws Exception { assertFalse(iterator.hasNext()); assertFalse(iterator.hasNext()); assertFalse(iterator.hasNext()); assertTrue(iterator.hasNext()); assertTrue(iterator.nextValue()); assertTrue(iterator.hasNext()); assertTrue(iterator.nextValue()); assertTrue(iterator.hasNext()); assertTrue(iterator.nextValue()); assertTrue(iterator.hasNext()); assertTrue(iterator.nextValue()); assertTrue(iterator.hasNext()); assertTrue(iterator.nextValue()); assertTrue(iterator.hasNext()); assertTrue(iterator.nextValue()); assertTrue(iterator.hasNext()); assertTrue(iterator.nextValue());
@Test public void testNext() throws Exception { String json = "{\\n" + " \\"a\\": 1,\\n" + " \\"b\\": 2,\\n" + " \\"c\\": 3,\\n" + " \\"d\\": [\\n" + " \\"e\\",\\n" + " \\"f\\",\\n" + " \\"g\\",\\n" + " \\"h\\",\\n" + " \\"i\\",\\n" + " \\"j\\",\\n" + " \\"k\\",\\n" + " \\"l\\",\\n" + " \\"
@Test(expected = RuntimeJsonMappingException.class) public void testNext_RuntimeJsonMappingException() throws IOException { JsonDeserializer<String> deserializer = new JsonDeserializer<String>() { @Override public String deserialize(JsonReader reader, DeserializationContext context) throws IOException { throw new RuntimeJsonMappingException("test"); } }; JsonDeserializer<String> deserializer = new JsonDeserializer<String>() { @Override public String deserialize(JsonReader reader, DeserializationContext context) throws IOException { throw new RuntimeJsonMappingException("test"); } }; JsonDeserializer<Integer> intDeserializer = new JsonDeserializer<Integer>() { @Override public Integer deserialize(JsonReader reader, DeserializationContext context
@Test public void testNextValue() throws Exception { String testString = "{\\n" + " \\"a\\": 1,\\n" + " \\"b\\": 2,\\n" + " \\"c\\": 3,\\n" + " \\"d\\": [\\n" + " \\"e\\",\\n" + " \\"f\\",\\n" + " \\"g\\",\\n" + " \\"h\\",\\n" + " \\"i\\",\\n" + " \\"j\\",\\n" + " \\"k\\",\\n" + " \\"l\\",\\n" + "
@Test public void testHasNextValue() throws Exception { assertFalse(Iterator.emptyIterator().hasNextValue()); assertFalse(Iterator.emptyIterator().nextValue()); assertFalse(Iterator.emptyIterator().hasNextValue()); assertTrue(Iterator.emptyIterator().hasNextValue()); assertTrue(Iterator.emptyIterator().nextValue()); assertTrue(Iterator.emptyIterator().nextValue()); assertTrue(Iterator.emptyIterator().nextValue()); assertTrue(Iterator.emptyIterator().nextValue()); assertTrue(Iterator.emptyIterator().nextValue()); assertTrue(Iterator.emptyIterator().nextValue()); assertTrue(Iterator.emptyIterator().nextValue()); assertTrue(Iterator.emptyIterator().nextValue()); assert
@Test public void testHasNextValue() throws Exception { assertTrue(Iterator.emptyIterator().hasNextValue()); assertFalse(Iterator.emptyIterator().hasNextValue()); assertFalse(Iterator.emptyIterator().nextValue()); assertFalse(Iterator.emptyIterator().hasNextValue()); assertTrue(Iterator.emptyIterator().nextValue()); assertTrue(Iterator.emptyIterator().nextValue()); assertTrue(Iterator.emptyIterator().nextValue()); assertTrue(Iterator.emptyIterator().nextValue()); assertTrue(Iterator.emptyIterator().nextValue()); assertTrue(Iterator.emptyIterator().nextValue()); assertTrue(Iterator.emptyIterator().nextValue()); assertTrue(Iterator.emptyIterator().nextValue()); assert
@Test public void testHasNextValue() throws Exception { assertTrue(Iterator.emptyIterator().hasNextValue()); assertFalse(Iterator.emptyIterator().hasNextValue()); assertFalse(Iterator.emptyIterator().nextValue()); assertFalse(Iterator.emptyIterator().hasNextValue()); assertTrue(Iterator.emptyIterator().nextValue()); assertTrue(Iterator.emptyIterator().hasNextValue()); assertTrue(Iterator.emptyIterator().nextValue()); assertTrue(Iterator.emptyIterator().nextValue()); assertTrue(Iterator.emptyIterator().nextValue()); assertTrue(Iterator.emptyIterator().nextValue()); assertTrue(Iterator.emptyIterator().nextValue()); assertTrue(Iterator.emptyIterator().nextValue());
@Test public void testHasNextValue() throws Exception { assertTrue(Iterator.emptyIterator().hasNextValue()); assertFalse(Iterator.emptyIterator().hasNextValue()); JsonParser t = mock(JsonParser.class); when(t.getCurrentToken()).thenReturn(null); assertFalse(Iterator.emptyIterator().hasNextValue()); when(t.nextToken()).thenReturn(JsonToken.END_ARRAY); assertFalse(Iterator.emptyIterator().hasNextValue()); when(t.getCurrentToken()).thenReturn(t); assertFalse(Iterator.emptyIterator().hasNextValue()); when(t.nextToken()).thenReturn(t); when(t.getCurrent
@Test public void testHasNextValue() throws Exception { JsonParser jp = mock(JsonParser.class); when(jp.nextToken()).thenReturn(null); MappingIterator<String> it = new MappingIterator<String>(String.class, jp, null, null, false, null); assertFalse(it.hasNextValue()); assertFalse(it.hasNextValue()); when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); assertFalse(it.hasNextValue()); when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); assertTrue(it.hasNextValue()); when(jp.nextToken()).thenReturn(Json
@Test public void testHasNextValue() throws Exception { JsonParser jp = mock(JsonParser.class); when(jp.nextToken()).thenReturn(null); MappingIterator<String> it = new MappingIterator<String>(String.class, jp, null, null); assertFalse(it.hasNextValue()); assertFalse(it.hasNextValue()); when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); assertFalse(it.hasNextValue()); when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); assertFalse(it.hasNextValue()); when(jp.nextToken()).thenReturn(JsonToken.END_
@Test public void testHasNextValue() throws Exception { assertFalse(Iterator.emptyIterator().hasNextValue()); assertFalse(Iterator.emptyIterator().nextValue()); assertFalse(Iterator.emptyIterator().hasNextValue()); assertTrue(Iterator.emptyIterator().hasNextValue()); assertTrue(Iterator.emptyIterator().nextValue()); assertTrue(Iterator.emptyIterator().nextValue()); assertTrue(Iterator.emptyIterator().nextValue()); assertTrue(Iterator.emptyIterator().nextValue()); assertTrue(Iterator.emptyIterator().nextValue()); assertTrue(Iterator.emptyIterator().nextValue()); assertTrue(Iterator.emptyIterator().nextValue()); assertTrue(Iterator.emptyIterator().nextValue()); assert
@Test public void testHasNextValue() throws Exception { assertFalse(Iterator.emptyIterator().hasNextValue()); assertFalse(Iterator.emptyIterator().nextValue()); assertFalse(Iterator.emptyIterator().hasNextValue()); assertFalse(Iterator.emptyIterator().nextValue()); assertTrue(Iterator.emptyIterator().hasNextValue()); assertTrue(Iterator.emptyIterator().nextValue()); assertTrue(Iterator.emptyIterator().nextValue()); assertTrue(Iterator.emptyIterator().nextValue()); assertTrue(Iterator.emptyIterator().nextValue()); assertTrue(Iterator.emptyIterator().nextValue()); assertTrue(Iterator.emptyIterator().nextValue()); assertTrue(Iterator.emptyIterator().nextValue()); assert
@Test public void testHasNextValue() throws Exception { JsonParser jp = jp("{\\n" + " \\"a\\": 1,\\n" + " \\"b\\": 2,\\n" + " \\"c\\": 3,\\n" + " \\"d\\": 4,\\n" + " \\"e\\": 5,\\n" + " \\"f\\": 6,\\n" + " \\"g\\": 7,\\n" + " \\"h\\": [\\n" + " \\"i\\",\\n" + " \\"j\\",\\n" + " \\"k\\",\\n" +
@Test public void testHasNextValue() throws Exception { assertFalse(Iterator.emptyIterator().hasNextValue()); assertFalse(Iterator.emptyIterator().nextValue()); assertFalse(Iterator.emptyIterator().hasNextValue()); assertTrue(Iterator.emptyIterator().hasNextValue()); assertTrue(Iterator.emptyIterator().nextValue()); assertTrue(Iterator.emptyIterator().nextValue()); assertTrue(Iterator.emptyIterator().nextValue()); assertTrue(Iterator.emptyIterator().nextValue()); assertTrue(Iterator.emptyIterator().nextValue()); assertTrue(Iterator.emptyIterator().nextValue()); assertTrue(Iterator.emptyIterator().nextValue()); assertTrue(Iterator.emptyIterator().nextValue()); assert
@Test public void testHasNextValue() throws Exception { assertTrue(Iterator.emptyIterator().hasNextValue()); assertFalse(Iterator.emptyIterator().hasNextValue()); assertFalse(Iterator.emptyIterator().nextValue()); assertFalse(Iterator.emptyIterator().hasNextValue()); assertTrue(Iterator.emptyIterator().nextValue()); assertTrue(Iterator.emptyIterator().nextValue()); assertTrue(Iterator.emptyIterator().nextValue()); assertTrue(Iterator.emptyIterator().nextValue()); assertTrue(Iterator.emptyIterator().nextValue()); assertTrue(Iterator.emptyIterator().nextValue()); assertTrue(Iterator.emptyIterator().nextValue()); assertTrue(Iterator.emptyIterator().nextValue()); assert
@Test public void testHasNextValue() throws Exception { JsonParser jp = mock(JsonParser.class); when(jp.nextToken()).thenReturn(null); MappingIterator<String> it = new MappingIterator<String>(String.class, jp, null, null); assertFalse(it.hasNextValue()); assertFalse(it.hasNextValue()); when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); assertFalse(it.hasNextValue()); when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); assertFalse(it.hasNextValue()); when(jp.nextToken()).thenReturn(JsonToken.END_
@Test public void testHasNextValue() throws Exception { assertFalse(Iterator.emptyIterator().hasNextValue()); assertFalse(Iterator.emptyIterator().nextValue()); assertFalse(Iterator.emptyIterator().hasNextValue()); assertFalse(Iterator.emptyIterator().nextValue()); assertTrue(Iterator.emptyIterator().hasNextValue()); assertTrue(Iterator.emptyIterator().nextValue()); assertTrue(Iterator.emptyIterator().nextValue()); assertTrue(Iterator.emptyIterator().nextValue()); assertTrue(Iterator.emptyIterator().nextValue()); assertTrue(Iterator.emptyIterator().nextValue()); assertTrue(Iterator.emptyIterator().nextValue()); assertTrue(Iterator.emptyIterator().nextValue()); assert
@Test public void testHasNextValue() throws Exception { assertTrue(Iterator.emptyIterator().hasNextValue()); assertFalse(Iterator.emptyIterator().hasNextValue()); assertFalse(Iterator.emptyIterator().nextValue()); assertFalse(Iterator.emptyIterator().hasNextValue()); assertTrue(Iterator.emptyIterator().nextValue()); assertTrue(Iterator.emptyIterator().hasNextValue()); assertTrue(Iterator.emptyIterator().nextValue()); assertTrue(Iterator.emptyIterator().nextValue()); assertTrue(Iterator.emptyIterator().nextValue()); assertTrue(Iterator.emptyIterator().nextValue()); assertTrue(Iterator.emptyIterator().nextValue()); assertTrue(Iterator.emptyIterator().nextValue());
@Test(expected = NoSuchElementException.class) public void testNextValue() throws IOException { final JsonParser mockParser = mock(JsonParser.class); final JsonDeserializer mockDeserializer = mock(JsonDeserializer.class); final JsonParser mockParser2 = mock(JsonParser.class); final JsonDeserializer mockDeserializer2 = mock(JsonDeserializer.class); final JsonParser mockParser3 = mock(JsonParser.class); final JsonDeserializer mockDeserializer3 = mock(JsonDeserializer.class); final JsonParser mockParser1 = mock(JsonParser.class); final JsonParser mockParser2 = mock(JsonParser.class); final JsonDeserializer mockDeserializer1 = mock(JsonDeserializer.class); final JsonDeserializer mockDeserializer2
@Test(expected = NoSuchElementException.class) public void testNextValue() throws IOException { final JsonParser mockParser = mock(JsonParser.class); final JsonDeserializer mockDeserializer = mock(JsonDeserializer.class); final JsonParser mockParser1 = mock(JsonParser.class); final JsonParser mockParser2 = mock(JsonParser.class); final JsonDeserializer mockDeserializer1 = mock(JsonDeserializer.class); final JsonDeserializer mockDeserializer2 = mock(JsonDeserializer.class); final JsonParser mockParser3 = mock(JsonParser.class); final JsonDeserializer mockDeserializer3 = mock(JsonDeserializer.class); final JsonParser mockParser4 = mock(JsonParser.class); final JsonParser mockParser5
@Test(expected = NoSuchElementException.class) public void testNextValue() throws IOException { final JsonParser jp = mock(JsonParser.class); final DeserializationContext ctxt = mock(DeserializationContext.class); final JsonDeserializer deserializer = mock(JsonDeserializer.class); final JsonParser parser = mock(JsonParser.class); when(jp.nextValue()).thenAnswer(new Answer<Object>() { @Override public Object answer(InvocationOnMock invocation) throws Throwable { return new Object(); } }); when(parser.nextToken()).thenAnswer(new Answer<Object>() { @Override public Object answer(InvocationOnMock invocation) throws Throwable { return new Object(); } }); when(parser
@Test(expected = NoSuchElementException.class) public void testNextValue() throws IOException { final JsonParser mockParser = mock(JsonParser.class); final JsonDeserializer mockDeserializer = mock(JsonDeserializer.class); final JsonParser mockParser1 = mock(JsonParser.class); final JsonParser mockParser2 = mock(JsonParser.class); final JsonDeserializer mockDeserializer1 = mock(JsonDeserializer.class); final JsonDeserializer mockDeserializer2 = mock(JsonDeserializer.class); final JsonParser mockParser3 = mock(JsonParser.class); when(mockParser1.nextValue()).thenAnswer(new Answer<Object>() { @Override public Object answer(InvocationOnMock invocation) throws Throwable {
@Test(expected = NoSuchElementException.class) public void testNextValue() throws IOException { final JsonParser mockParser = mock(JsonParser.class); final JsonDeserializer mockDeserializer = mock(JsonDeserializer.class); final JsonParser mockParser1 = mock(JsonParser.class); final JsonParser mockParser2 = mock(JsonParser.class); final JsonDeserializer mockDeserializer1 = mock(JsonDeserializer.class); final JsonDeserializer mockDeserializer2 = mock(JsonDeserializer.class); final JsonParser mockParser3 = mock(JsonParser.class); when(mockParser1.nextValue()).thenAnswer(new Answer<Object>() { @Override public Object answer(InvocationOnMock invocation) throws Throwable {
@Test(expected = NoSuchElementException.class) public void testNextValue() throws IOException { final JsonParser mockParser = mock(JsonParser.class); final JsonDeserializer mockDeserializer = mock(JsonDeserializer.class); final JsonParser mockParser2 = mock(JsonParser.class); final JsonDeserializer mockDeserializer2 = mock(JsonDeserializer.class); final JsonParser mockParser3 = mock(JsonParser.class); final JsonParser mockParser4 = mock(JsonParser.class); final JsonDeserializer mockDeserializer3 = mock(JsonDeserializer.class); final JsonDeserializer mockDeserializer4 = mock(JsonDeserializer.class); final JsonParser mockParser5 = mock(JsonParser.class); final JsonParser mockParser6
@Test(expected = NoSuchElementException.class) public void testNextValue() throws IOException { final JsonParser jp = mock(JsonParser.class); final DeserializationContext ctxt = mock(DeserializationContext.class); final JsonDeserializer deserializer = mock(JsonDeserializer.class); final JsonParser parser = mock(JsonParser.class); final JsonValue value = mock(JsonValue.class); when(parser.nextValue()).thenAnswer(new Answer<Object>() { @Override public Object answer(InvocationOnMock invocation) throws Throwable { return value; } }); when(parser.nextToken()).thenAnswer(new Answer<Object>() { @Override public Object answer(InvocationOnMock invocation) throws
@Test(expected = NoSuchElementException.class) public void testNextValue() throws IOException { final JsonParser mockParser = mock(JsonParser.class); final JsonDeserializer mockDeserializer = mock(JsonDeserializer.class); final JsonParser mockParser2 = mock(JsonParser.class); final JsonDeserializer mockDeserializer2 = mock(JsonDeserializer.class); final JsonParser mockParser3 = mock(JsonParser.class); final JsonParser mockParser4 = mock(JsonParser.class); final JsonDeserializer mockDeserializer3 = mock(JsonDeserializer.class); final JsonParser mockParser5 = mock(JsonParser.class); final JsonParser mockParser6 = mock(JsonParser.class); final JsonParser mockParser7
@Test(expected = NoSuchElementException.class) public void testParsingException() throws IOException { JsonParser jp = mock(JsonParser.class); when(jp.nextToken()).thenThrow(new IOException()); MappingIterator<String> iter = new MappingIterator<String>(String.class, jp, null, new JsonDeserializer<String>() { @Override public String deserialize(JsonParser jp, DeserializationContext context) throws IOException { throw new IOException(); } @Override public String deserialize(JsonParser jp, DeserializationContext context) throws IOException { throw new IOException(); } }); iter.nextValue(); }
@Test(expected = NoSuchElementException.class) public void testNextValue() throws IOException { final JsonParser mockParser = mock(JsonParser.class); final JsonDeserializer mockDeserializer = mock(JsonDeserializer.class); final JsonParser mockParser2 = mock(JsonParser.class); final JsonDeserializer mockDeserializer2 = mock(JsonDeserializer.class); final JsonParser mockParser3 = mock(JsonParser.class); final JsonParser mockParser4 = mock(JsonParser.class); final JsonDeserializer mockDeserializer3 = mock(JsonDeserializer.class); final JsonDeserializer mockDeserializer4 = mock(JsonDeserializer.class); final JsonParser mockParser5 = mock(JsonParser.class); final JsonParser mockParser6
@Test public void testSerialize() throws IOException, JsonProcessingException { JsonGenerator jg = mock(JsonGenerator.class); SerializerProvider provider = mock(SerializerProvider.class); when(provider.getConfig()).thenReturn(new Base64Config()); BinaryNode node = new BinaryNode("hello".getBytes(StandardCharsets.UTF_8)); node.serialize(jg, provider); verify(jg).writeBinary(eq(config.getBase64Variant()), eq(node.binaryValue()), eq(0), eq(node.binaryValue().length)); }
@Test public void test() throws IOException, JsonProcessingException { StringWriter writer = new StringWriter(); JsonGenerator jg = new JsonFactory().createGenerator(writer); BinaryNode binaryNode = new BinaryNode("Hello, world!".getBytes(StandardCharsets.UTF_8)); binaryNode.serialize(jg, new DefaultSerializerProvider()); jg.flush(); String actual = writer.toString(); String expected = "{\\"data\\":\\"Hello, world!\\"}"; assertEquals(expected, actual); }
@Test public void testInitialCapacity() { ObjectBuffer buf = new ObjectBuffer(); assertEquals(0, buf.initialCapacity()); ObjectBuffer buf2 = new ObjectBuffer(); assertEquals(0, buf2.initialCapacity()); ObjectBuffer buf3 = new ObjectBuffer(); assertEquals(0, buf3.initialCapacity()); ObjectBuffer buf4 = new ObjectBuffer(); assertEquals(0, buf4.initialCapacity()); ObjectBuffer buf5 = new ObjectBuffer(); assertEquals(0, buf5.initialCapacity()); ObjectBuffer buf6 = new ObjectBuffer(); assertEquals(0, buf6.initialCapacity()); ObjectBuffer buf7 = new ObjectBuffer(); assertEquals(0, buf7.initialCapacity()); }
@Test public void testInitialCapacity() { ObjectBuffer buf = new ObjectBuffer(); Assert.assertEquals(0, buf.initialCapacity()); buf._reset(); Assert.assertEquals(0, buf.initialCapacity()); buf._reset(); Assert.assertEquals(0, buf.initialCapacity()); buf._reset(); Assert.assertEquals(0, buf.initialCapacity()); buf._reset(); Assert.assertEquals(0, buf.initialCapacity()); buf._reset(); Assert.assertEquals(0, buf.initialCapacity()); }
@Test public void testNull() throws Exception { when(jsonParser.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); assertNull(objectDeserializer.deserialize(jsonParser, mock(DeserializationContext.class))); when(jsonParser.getCurrentToken()).thenReturn(JsonToken.VALUE_NULL); assertNull(objectDeserializer.deserialize(jsonParser, mock(DeserializationContext.class))); when(jsonParser.getCurrentToken()).thenReturn(JsonToken.VALUE_NULL); assertNull(objectDeserializer.deserialize(jsonParser, mock(DeserializationContext.class))); when(jsonParser.getCurrentToken()).thenReturn(JsonToken.VALUE_
@Test public void testNull() throws Exception { assertNull(new UntypedObjectDeserializer().deserialize(jp, mock(DeserializationContext.class))); assertNull(new UntypedObjectDeserializer().deserialize(jp, mock(DeserializationContext.class))); assertNull(new UntypedObjectDeserializer().deserialize(jp, mock(DeserializationContext.class))); assertNull(new UntypedObjectDeserializer().deserialize(jp, mock(DeserializationContext.class))); assertNull(new UntypedObjectDeserializer().deserialize(jp, mock(DeserializationContext.class))); assertNull(new UntypedObjectDeserializer().deserialize(jp, mock(DeserializationContext.class))); }
@Test public void testMapArrayToArray() throws Exception { when(jsonParser.nextToken()).thenAnswer(new Answer<JsonToken>() { @Override public JsonToken answer(InvocationOnMock invocation) throws Throwable { return jp.nextToken(); } }); when(jsonParser.nextToken()).thenAnswer(new Answer<JsonToken>() { @Override public JsonToken answer(InvocationOnMock invocation) throws Throwable { return jp.nextToken(); } }); when(jsonParser.nextToken()).thenAnswer(new Answer<JsonToken>() { @Override public JsonToken answer(InvocationOnMock invocation) throws Throwable { return jp.nextToken(); } }); Object[] result = new Object[
@Test void mapObject() throws Exception { JsonParser jp = mock(JsonParser.class); when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); Object value1 = new Object(); Object value2 = new Object(); when(jp.getText()).thenReturn("a"); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.nextToken()).thenReturn(JsonToken.VALUE_STRING); when(jp.getText()).thenReturn("b"); when(jp.nextToken()).thenReturn(JsonToken.VALUE_NUMBER); when(jp.nextToken()).thenReturn(JsonToken.VALUE_
@Test void mapObject() throws Exception { JsonParser jp = mock(JsonParser.class); when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); Object value1 = new Object(); Object value2 = new Object(); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.getText()).thenReturn("a"); when(jp.nextToken()).thenReturn(JsonToken.VALUE_STRING); when(jp.getText()).thenReturn("b"); when(jp.nextToken()).thenReturn(JsonToken.VALUE_NUMBER); when(jp.nextToken()).thenReturn(JsonToken.VALUE_
@Test void mapObject() throws Exception { JsonParser jp = mock(JsonParser.class); DeserializationContext ctxt = mock(DeserializationContext.class); when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); Object value1 = new Object(); Object value2 = new Object(); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.readObject(value1)).thenReturn(value1); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.readObject(value2)).thenReturn(value2); Map<String, Object> map = new LinkedHashMap<String
@Test void mapObject() throws Exception { JsonParser jp = mock(JsonParser.class); when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); Object value1 = new Object(); Object value2 = new Object(); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.readObject(value1)).thenReturn(value1); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.readObject(value2)).thenReturn(value2); Map<String, Object> map = new LinkedHashMap<String, Object>(); map.put("a", "b"); map
@Test void mapObject() throws Exception { JsonParser jp = mock(JsonParser.class); when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); LinkedHashMap<String, Object> map = new LinkedHashMap<String, Object>(); map.put("a", "b"); map.put("c", "d"); Map<String, Object> expected = new LinkedHashMap<String, Object>(); expected.put("a", "b"); expected.put("c", "d"); assertThat(map.mapObject(jp, null)).isEqualTo(expected); verify(jp, atLeastOnce()).nextToken(); verify(jp, atLeastOnce()).nextToken
@Test void mapObject() throws Exception { JsonParser jp = mock(JsonParser.class); when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); Object value1 = new Object(); Object value2 = new Object(); Object value3 = new Object(); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.getText()).thenReturn("a"); when(jp.nextToken()).thenReturn(JsonToken.VALUE_STRING); when(jp.getText()).thenReturn("b"); when(jp.nextToken()).thenReturn(JsonToken.VALUE_NUMBER); when(jp.nextToken()).then
@Test void mapObject() throws Exception { String field1 = "field1"; String field2 = "field2"; String value1 = "value1"; String value2 = "value2"; JsonParser jp = mock(JsonParser.class); when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); when(jp.nextToken()).thenReturn(JsonToken.VALUE_STRING); when(jp.getText()).thenReturn(field1).thenReturn(value1).thenReturn(value2); Map<String, Object> result = new LinkedHashMap<String, Object>(); result.put(field1, value1); result.put(field2, value
@Test void mapObject() throws Exception { JsonParser jp = mock(JsonParser.class); DeserializationContext ctxt = mock(DeserializationContext.class); when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); doNothing().when(jp).getText(); doNothing().when(jp).nextToken(); doNothing().when(jp).nextToken(); doNothing().when(jp).getText(); doNothing().when(jp).nextToken(); doNothing().when(jp).nextToken(); doNothing().when(jp).getText(); doNothing().when(jp).nextToken(); doNothing().when(jp).nextToken(); doNothing().when(
@Test void mapObject() throws Exception { JsonParser jp = mock(JsonParser.class); DeserializationContext ctxt = mock(DeserializationContext.class); when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); Object value1 = new Object(); Object value2 = new Object(); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.readObject(value1)).thenReturn(value1); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.readObject(value2)).thenReturn(value2); Map<String, Object> result = (Map<
@Test void mapObject() throws Exception { JsonParser jp = mock(JsonParser.class); when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); Object value1 = new Object(); Object value2 = new Object(); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.getText()).thenReturn("a"); when(jp.nextToken()).thenReturn(JsonToken.VALUE_STRING); when(jp.getText()).thenReturn("b"); when(jp.nextToken()).thenReturn(JsonToken.VALUE_NUMBER); when(jp.nextToken()).thenReturn(JsonToken.VALUE_
@Test void mapObject() throws Exception { JsonParser jp = mock(JsonParser.class); when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); Object value1 = new Object(); Object value2 = new Object(); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.readObject(value1)).thenReturn(value1); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.readObject(value2)).thenReturn(value2); Map<String, Object> map = new LinkedHashMap<String, Object>(); map.put("a", value1); map
@Test void mapObject() throws Exception { JsonParser jp = mock(JsonParser.class); when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); Object value1 = new Object(); Object value2 = new Object(); Object value3 = new Object(); when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); when(jp.getText()).thenReturn("a"); when(jp.nextToken()).thenReturn(JsonToken.VALUE_STRING); when(jp.getText()).thenReturn("b"); when(jp.nextToken()).thenReturn(JsonToken.VALUE_NUMBER); when(jp.nextToken()).then
@Test public void mapArrayToArray() throws Exception { when(jsonParser.nextToken()).thenReturn(JsonToken.END_ARRAY); assertArrayEquals(new Object[0], simple.mapArrayToArray(jsonParser, mock(DeserializationContext.class))); when(jsonParser.nextToken()).thenReturn(JsonToken.END_ARRAY); assertArrayEquals(new Object[0], simple.mapArrayToArray(jsonParser, mock(DeserializationContext.class))); when(jsonParser.nextToken()).thenReturn(JsonToken.END_ARRAY); assertArrayEquals(new Object[0], simple.mapArrayToArray(jsonParser, mock(DeserializationContext.class))
@Test public void testMapArrayToArray() throws Exception { String[] strings = new String[]{"a", "b", "c"}; when(jsonParser.nextToken()).thenReturn(JsonToken.END_ARRAY); when(jsonParser.nextToken()).thenReturn(JsonToken.END_ARRAY); when(jsonParser.nextToken()).thenReturn(JsonToken.END_ARRAY); when(jsonParser.nextToken()).thenReturn(JsonToken.END_ARRAY); Object[] deserialized = mock(Object[].class); when(deserialized.deserialize(jsonParser, null)).thenReturn(strings[0]); when(deserialized.deserializeWithType(
@Test public void testMapArrayToArray() throws Exception { when(jsonParser.nextToken()).thenAnswer(new Answer<JsonToken>() { @Override public JsonToken answer(InvocationOnMock invocation) throws Throwable { return jp.nextToken(); } }); when(jsonParser.nextToken()).thenAnswer(new Answer<JsonToken>() { @Override public JsonToken answer(InvocationOnMock invocation) throws Throwable { return jp.nextToken(); } }); when(jsonParser.nextToken()).thenAnswer(new Answer<JsonToken>() { @Override public JsonToken answer(InvocationOnMock invocation) throws Throwable { return jp.nextToken(); } }); assertArrayEquals(new Object[
@Test public void testMapArrayToArray() throws IOException, JsonProcessingException { String[] values = new String[]{"a", "b", "c"}; when(jsonParser.nextToken()).thenReturn(JsonToken.END_ARRAY); when(jsonParser.nextToken()).thenReturn(JsonToken.START_OBJECT); when(jsonParser.readObject()).thenReturn(values[0], values[1], values[2], values[3], values[4], values[5], values[6], values[7], values[8], values[9], values[10], values[11], values[12], values[13], values[14], values[15], values
@Test public void testMapArrayToArray() throws Exception { String[] values = new String[]{"a", "b", "c"}; when(jsonParser.nextToken()).thenReturn(JsonToken.START_ARRAY); when(jsonParser.nextToken()).thenReturn(JsonToken.END_ARRAY); when(jsonParser.readObject()).thenReturn(values); Object[] result = mock(Object[].class); when(result.length()).thenReturn(values.length); when(result[0].toString()).thenReturn("a"); when(result[1].toString()).thenReturn("b"); when(result[2].toString()).thenReturn("c
@Test public void mapArrayToArray() throws Exception { when(jsonParser.nextToken()).thenReturn(JsonToken.END_ARRAY); assertArrayEquals(new Object[0], do.mapArrayToArray(jsonParser, mock(DeserializationContext.class))); when(jsonParser.nextToken()).thenReturn(JsonToken.END_ARRAY); assertArrayEquals(new Object[0], do.mapArrayToArray(jsonParser, mock(DeserializationContext.class))); when(jsonParser.nextToken()).thenReturn(JsonToken.END_ARRAY); assertArrayEquals(new Object[0], do.mapArrayToArray(jsonParser, mock(DeserializationContext.class))
@Test public void testMapArrayToArray() throws IOException, JsonProcessingException { String[] expected=new String[]{"a", "b", "c"}; when(jsonParser.nextToken()).thenReturn(JsonToken.END_ARRAY); when(jsonParser.nextToken()).thenReturn(JsonToken.START_OBJECT); when(jsonParser.readObject()).thenReturn(expected[0], expected[1], expected[2], expected[3], expected[4], expected[5], expected[6], expected[7], expected[8], expected[9], expected[10], expected[11], expected[12], expected[13], expected[14], expected[15], expected
@Test public void testMapArrayToArray() throws Exception { String[] expected = new String[]{"a", "b", "c"}; when(jsonParser.nextToken()).thenReturn(JsonToken.START_ARRAY); when(jsonParser.nextToken()).thenReturn(JsonToken.END_ARRAY); Object[] actual = mock(Object[].class); when(jsonParser.readObject()).thenReturn(expected[0]); when(jsonParser.nextToken()).thenReturn(JsonToken.END_ARRAY); when(jsonParser.readObject()).thenReturn(expected[1]); when(jsonParser.nextToken()).thenReturn(JsonToken.END_ARRAY
@Test public void testMapArrayToArray() throws IOException, JsonProcessingException { Object[] values=new Object[1]; when(jsonParser.nextToken()).thenReturn(JsonToken.START_ARRAY); when(jsonParser.nextToken()).thenReturn(JsonToken.END_ARRAY); values[0] = "a"; values[1] = "b"; assertEquals(values[0], "a"); assertEquals(values[1], "b"); assertEquals(values[2], "c"); when(jsonParser.nextToken()).thenReturn(JsonToken.END_ARRAY); values[0] = "d"; values[1] = "e"; assertEquals(values[
@Test public void testMapArrayToArray() throws Exception { when(jsonParser.nextToken()).thenAnswer(new Answer<JsonToken>() { @Override public JsonToken answer(InvocationOnMock invocation) throws Throwable { return jp.nextToken(); } }); when(jsonParser.nextToken()).thenAnswer(new Answer<JsonToken>() { @Override public JsonToken answer(InvocationOnMock invocation) throws Throwable { return jp.nextToken(); } }); when(jsonParser.nextToken()).thenAnswer(new Answer<JsonToken>() { @Override public JsonToken answer(InvocationOnMock invocation) throws Throwable { return jp.nextToken(); } }); assertArrayEquals(new Object[
@Test public void testDateDeserializer() { JsonDeserializer<Date> d = DateBasedDeserializer.find(Date.class, "date"); Assert.assertNotNull(d); Assert.assertEquals(DateDeserializer.instance, d); d = DateBasedDeserializer.find(java.util.Date.class, "date"); Assert.assertNotNull(d); Assert.assertEquals(DateDeserializer.instance, d); d = DateBasedDeserializer.find(java.sql.Date.class, "date"); Assert.assertNotNull(d); Assert.assertEquals(DateDeserializer.instance, d); d = DateBasedDeserializer.find(java.sql.Time.class, "date"); Assert.assertNotNull(
@Test public void testDateDeserializer() throws Exception { JsonDeserializer<Date> d = DateBasedDeserializer.find(Date.class, "test"); Assert.assertNotNull(d); Assert.assertEquals(DateDeserializer.instance, d); d = DateBasedDeserializer.find(java.sql.Date.class, "test"); Assert.assertNotNull(d); Assert.assertEquals(DateDeserializer.instance, d); d = DateBasedDeserializer.find(java.sql.Date.class, "test"); Assert.assertNotNull(d); Assert.assertEquals(DateDeserializer.instance, d); d = DateBasedDeserializer.find(java.sql.Date.class, "test"); Assert.assert
@Test public void testDateDeserializer() throws Exception { Date d = new Date(); SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); Calendar cal = Calendar.getInstance(); cal.setTime(d); SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); Calendar cal2 = Calendar.getInstance(); cal2.setTime(d); SimpleDateFormat sdf2 = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); sdf2.setTimeZone(TimeZone.getTimeZone("GMT")); Date d2 = sdf.
@Test public void testDateDeserializer() throws Exception { Date d = new Date(); SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); Calendar cal = Calendar.getInstance(); cal.setTimeInMillis(d.getTimeInMillis()); cal.setTimeZone(TimeZone.getTimeZone("GMT")); Calendar cal2 = Calendar.getInstance(); cal2.setTimeInMillis(d.getTimeInMillis()); cal2.setTimeZone(TimeZone.getTimeZone("GMT")); Calendar cal3 = Calendar.getInstance(); cal
@Test public void testDateDeserializer() throws Exception { Date d = new Date(); SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); Calendar cal = Calendar.getInstance(); cal.setTimeInMillis(d.getTimeInMillis()); cal.setTimeZone(TimeZone.getTimeZone("GMT")); Calendar cal2 = Calendar.getInstance(); cal2.setTimeInMillis(d.getTimeInMillis()); cal2.setTimeZone(TimeZone.getTimeZone("GMT")); Calendar cal3 = Calendar.getInstance(); cal
@Test public void testDateDeserializer() throws Exception { Date d = new Date(); SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); Calendar cal = Calendar.getInstance(); cal.setTime(d); SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); Calendar cal2 = Calendar.getInstance(); cal2.setTime(d); Calendar cal3 = Calendar.getInstance(); cal3.setTime(df.parse("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'")); cal3.setTimeZone(TimeZone
@Test public void testDateBasedDeserializer() throws Exception { String[][] tests = new String[][] { new String[] {"yyyy-MM-dd", "yyyy-MM-dd"}, new String[] {"yyyy-MM-dd", "yyyy-MM-dd"}, new String[] {"yyyy-MM-dd", "yyyy-MM-dd"}, new String[] {"yyyy-MM-dd", "yyyy-MM-dd"}, new String[] {"yyyy-MM-dd", "yyyy-MM-dd"}, new String[] {"yyyy-MM-dd", "yyyy-MM-dd"}, new String[] {"yyyy-MM-dd", "yyyy-MM-dd
@Test public void testDateBasedDeserializer() throws Exception { final SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); df.setTimeZone(TimeZone.getTimeZone("GMT")); DateBasedDeserializer<Date> d = new DateBasedDeserializer<Date>(Date.class, df, "yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); assertEquals(d.getClass(), Date.class); assertEquals(d.getDateFormat(), df.getDateFormat()); assertEquals(d.getFormatString(), "yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z
@Test public void testDateBasedDeserializer() throws Exception { final SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); df.setTimeZone(TimeZone.getTimeZone("GMT")); DateBasedDeserializer<Date> d = new DateBasedDeserializer<Date>() { @Override public Date parseDate(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { return Date.from(jp); } }; assertEquals(d.getClass(), Date.class); assertEquals(d.getDateFormat(), df.getDateFormat()); assertEquals(d.getFormatString(), "yyyy-MM-dd\'T\'HH:mm
@Test public void testDateBasedDeserializer() throws Exception { final SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); df.setTimeZone(TimeZone.getTimeZone("GMT")); DateBasedDeserializer<Date> d = new DateBasedDeserializer<Date>(Date.class, df, "yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); assertEquals(d.getClass(), Date.class); assertEquals(d.getDateFormat(), df.getDateFormat()); assertEquals(d.getFormatString(), "yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z
@Test public void testCreateContextual() throws Exception { DateBasedDeserializer<Date> d = new DateBasedDeserializer<Date>(new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"), new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"), "yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); Date d1 = d.createContextual(new DeserializationContext(d, null), null); Date d2 = d.createContextual(new DeserializationContext(d2, null), null); Date d3 = d.
@Test public void testCreateContextual() throws Exception { DateBasedDeserializer<Date> d = new DateBasedDeserializer<Date>(Date.class, new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"), "yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); Date d1 = d.createContextual(new DeserializationContext(d, null), null); Date d2 = d.createContextual(new DeserializationContext(d2, null), null); Date d3 = d.createContextual(new DeserializationContext(d3, null), null); Date d4
@Test public void testCreateContextual() throws Exception { DateBasedDeserializer<Date> d1 = new DateBasedDeserializer<Date>(Date.class); Date d1_1 = d1.createContextual(d1, null); Date d1_2 = d1.createContextual(d1_1, null); Date d1_3 = d1.createContextual(d1_2, null); Date d1_4 = d1.createContextual(d1_3, null); Date d1_5 = d1.createContextual(d1_5, null); Date d1_6 = d1.createContextual(d1_6
@Test public void testCreateContextual() throws Exception { DateBasedDeserializer<Date> d = new DateBasedDeserializer<Date>(Date.class, new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"), "yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); Date d1 = d.createContextual(new DeserializationContext(d, null), null); Date d2 = d.createContextual(new DeserializationContext(d2, null), null); Date d3 = d.createContextual(new DeserializationContext(d3, null), null); Date d4
@Test public void testCreateContextual() throws Exception { DateBasedDeserializer<Date> d1 = new DateBasedDeserializer<Date>(Date.class, new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"), "yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); DateBasedDeserializer<Date> d2 = new DateBasedDeserializer<Date>(Date.class, new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"), "yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); DateBasedDeserializer<
@Test public void testCreateContextual() throws Exception { DateBasedDeserializer<Date> d = new DateBasedDeserializer<Date>(); Date d1 = new Date(10, 0, 1); Date d2 = new Date(10, 0, 2); Date d3 = new Date(10, 0, 3); Date d4 = new Date(10, 0, 4); Date d5 = new Date(10, 0, 5); Date d6 = new Date(10, 0, 6); Date d7 = new Date(10, 0, 7); Date d8 = new Date(10, 0, 8); Date d9 = new Date(10, 0, 9); Date d10
@Test public void testCreateContextual() throws Exception { DateBasedDeserializer<Date> d1 = new DateBasedDeserializer<Date>(Date.class); Date d1_1 = d1.createContextual(new DeserializationContext(d1), null); Date d1_2 = d1.createContextual(new DeserializationContext(d1), null); Date d1_3 = d1.createContextual(new DeserializationContext(d1), null); Date d2_1 = d1.createContextual(new DeserializationContext(d2), null); Date d2_2 = d2.createContextual(new DeserializationContext(
@Test public void testCreateContextual() throws Exception { DateBasedDeserializer<Date> d = new DateBasedDeserializer<Date>(Date.class, new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"), "yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); Date d1 = d.createContextual(new DeserializationContext(d, null), null); Date d2 = d.createContextual(new DeserializationContext(d2, null), null); Date d3 = d.createContextual(new DeserializationContext(d3, null), null); Date d4
@Test public void testCreateContextual() throws Exception { DateBasedDeserializer<Date> d = new DateBasedDeserializer<Date>(Date.class); Date d1 = new Date(10, 0, 1); Date d2 = new Date(10, 0, 2); Date d3 = new Date(10, 0, 3); Date d4 = new Date(10, 0, 4); Date d5 = new Date(10, 0, 5); Date d6 = new Date(10, 0, 6); Date d7 = new Date(10, 0, 7); Date d8 = new Date(10, 0, 8); Date d9 = new Date(10, 0, 9
@Test public void testCreateContextual() throws Exception { DateBasedDeserializer<Date> ddf = new DateBasedDeserializer<Date>(new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"), new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"), "yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); Date d1 = ddf.createContextual(new DefaultDeserializationContext(d1), null); Date d2 = ddf.createContextual(new DefaultDeserializationContext(d2), null); Assert.assertEquals(d
@Test public void testCreateContextual() throws Exception { DateBasedDeserializer<Date> d1 = new DateBasedDeserializer<Date>(Date.class, new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"), "yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); DateBasedDeserializer<Date> d2 = new DateBasedDeserializer<Date>(Date.class, new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"), "yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); DateBasedDeserializer<
@Test public void testDateDeserializer() throws Exception { SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); SimpleDateFormat joda = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); joda.setTimeZone(TimeZone.getTimeZone("GMT")); Calendar cal = Calendar.getInstance(); cal.setTimeInMillis(0); cal.set(Calendar.YEAR, 0); cal.set(Calendar.MONTH, 0); cal.set(Calendar.DAY_OF_MONTH, 1); cal.set(Calendar.HOUR_OF_DAY, 0); cal.set(Calendar.
@Test public void testDateDeserializer() throws Exception { SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); format.setTimeZone(TimeZone.getTimeZone("GMT")); SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); sdf.setTimeZone(TimeZone.getTimeZone("GMT")); String[] lines = new String[]{"yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'", "yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'", "yyyy-MM-dd\'T\'
@Test public void testDateDeserializer() throws Exception { SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); SimpleDateFormat joda = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); joda.setTimeZone(TimeZone.getTimeZone("GMT")); Calendar cal = Calendar.getInstance(); cal.setTimeInMillis(0); cal.set(Calendar.HOUR_OF_DAY, 0); cal.set(Calendar.MINUTE, 0); cal.set(Calendar.SECOND, 0); cal.set(Calendar.MILLISECOND, 0); Calendar expected = Calendar.getInstance(); expected
@Test public void test_parseDate() throws Exception { SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); Calendar cal = Calendar.getInstance(); cal.setTime(new Date(0)); cal.set(Calendar.HOUR_OF_DAY, 0); cal.set(Calendar.MINUTE, 0); cal.set(Calendar.SECOND, 0); cal.setTimeZone(TimeZone.getTimeZone("GMT")); String date = sdf.format(cal); JsonParser jp = jpFactory.createParser(
@Test public void testDateDeserializer() throws Exception { SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); SimpleDateFormat joda = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); joda.setTimeZone(TimeZone.getTimeZone("GMT")); Calendar cal = Calendar.getInstance(); cal.setTimeInMillis(0); cal.set(Calendar.HOUR_OF_DAY, 0); cal.set(Calendar.MINUTE, 0); cal.set(Calendar.SECOND, 0); cal.set(Calendar.MILLISECOND, 0); cal.setTimeZone(TimeZone.getTimeZone
@Test public void testDateDeserializer() throws Exception { SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); DateDeserializer d1 = new DateDeserializer() .withDateFormat(df, "yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); DateDeserializer d2 = new DateDeserializer() .withDateFormat(df, "yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'") .withDateFormat(df, "yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); Date d3 = d1.withDateFormat(df,
@Test public void testDateDeserializer() throws Exception { final SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); df.setTimeZone(TimeZone.getTimeZone("GMT")); Date d = new DateDeserializer().withDateFormat(df, "yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); assertEquals(d.getRawDate(), new Date(0)); assertEquals(d.getTimeZone(), TimeZone.getTimeZone("GMT")); d = new DateDeserializer().withDateFormat(df, "yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); assertEquals
@Test public void testDateBasedDeserializer() throws Exception { SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); Date d = new DateDeserializer().withDateFormat(df, "yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); assertEquals(d.getClass(), DateDeserializer.class); assertEquals(d.getDateFormat(), df); assertEquals(d.getFormatStr(), "yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); d = new DateDeserializer().withDateFormat(df, "yyyy-MM-dd\'T\'HH:mm:
@Test public void testDateBasedDeserializer() throws Exception { SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); Date d = new DateDeserializer().withDateFormat(df, "yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); assertEquals(d.getClass(), DateDeserializer.class); assertEquals(d.getDateFormat(), df); assertEquals(d.getFormatStr(), "yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); d = new DateDeserializer().withDateFormat(df, "yyyy-MM-dd\'T\'HH:mm:
@Test public void testTimestampDeserializer() throws Exception { SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); format.setTimeZone(TimeZone.getTimeZone("GMT")); SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); sdf.setTimeZone(TimeZone.getTimeZone("GMT")); String[] lines = new String[]{ "1970-01-01T00:00:00.000Z", "1970-01-01T00:00:00.000Z", "1970-01-01T00:00:00.000Z",
@Test public void testDateBasedDeserializer() throws Exception { SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); format.setTimeZone(TimeZone.getTimeZone("GMT")); SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); sdf.setTimeZone(TimeZone.getTimeZone("GMT")); String date = sdf.format(new Date()); String json = new String(DateDeserializer.deserialize(new JsonFactory(), new JsonParser(new StringReader(date)), null), "UTF-8"); assertEquals(date, json); }
@Test public void testDateBasedDeserializer() throws Exception { SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); format.setTimeZone(TimeZone.getTimeZone("GMT")); SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); sdf.setTimeZone(TimeZone.getTimeZone("GMT")); String[] lines = new String[]{ "1970-01-01T00:00:00.000Z", "1970-01-01T00:00:00.000Z", "1970-01-01T00:00:00.000Z
@Test public void testTimeZoneDeserializer() throws Exception { SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); df.setTimeZone(TimeZone.getTimeZone("GMT")); DateBasedDeserializer<Date> d = new DateBasedDeserializer<Date>() { @Override public java.util.Date deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonMappingException { return null; } }; TimeZone tz = TimeZone.getTimeZone("GMT"); assertEquals(tz, d.withDateFormat(df, "yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'")); assertEquals(tz
@Test public void testDateBasedDeserializer() throws Exception { final SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); df.setTimeZone(TimeZone.getTimeZone("GMT")); final Calendar cal = Calendar.getInstance(TimeZone.getTimeZone("GMT")); cal.setTimeInMillis(0); cal.set(Calendar.HOUR_OF_DAY, 0); cal.set(Calendar.MINUTE, 0); cal.set(Calendar.SECOND, 0); cal.set(Calendar.MILLISECOND, 0); final Calendar expected = Calendar.getInstance(TimeZone.getTimeZone("GMT")); expected.setTimeInMillis(0); expected
@Test public void testDateBasedDeserializer() throws Exception { DateBasedDeserializer<Date> d = new DateBasedDeserializer<Date>() { @Override public java.util.Date deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { return null; } }; assertEquals(TimeZone.getTimeZone("GMT"), d._deserialize("1970-01-01 00:00:00", null)); assertEquals(TimeZone.getTimeZone("GMT"), d._deserialize("1970-01-01 00:00:00", null)); assertEquals(TimeZone.getTimeZone("GMT"), d._deserialize("1970-01-01 00:00:00
@Test public void testIdFromValueAndType() { Map<String, Object> value = new LinkedHashMap<String, Object>(); value.put("key", "value"); String id = _resolver.idFromValueAndType(value, String.class); Assert.assertEquals(value.get("key"), id); }
@Test public void testIdFromValueAndType() { Set<String> value = new HashSet<String>(); value.add("aaa"); value.add("bbb"); value.add("ccc"); String id = _idRes.idFromValueAndType(value, String.class); Assert.assertEquals(id, "aaa"); id = _idRes.idFromValueAndType(value, Integer.class); Assert.assertEquals(id, "bbb"); value.add("ccc"); value.add("ddd"); id = _idRes.idFromValueAndType(value, Double.class); Assert.assertEquals(id, "ddd"); value.add
@Test public void testTreeTraversingParser() throws IOException, JsonParseException, JsonParseException { final ObjectMapper mapper = new ObjectMapper(); final JsonNode root = mapper.readTree("{\\"a\\":1, \\"b\\":2, \\"c\\":3}"); TreeTraversingParser parser = new TreeTraversingParser(root, new ObjectCodec()); assertEquals("{\\"a\\":1,\\"b\\":2,\\"c\\":3}", mapper.writeValueAsString(parser.nextNode())); assertEquals("{\\"a\\":1,\\"b\\":2,\\"c\\":3}", mapper.writeValueAsString(parser.nextNode())); assertEquals("
@Test public void testTreeTraversingParser() throws IOException, JsonParseException { String json = "{\\"a\\":1, \\"b\\":2, \\"c\\":3, \\"d\\":4}"; String expected = "{\\"a\\":1, \\"b\\":2, \\"c\\":3, \\"d\\":4}"; String expected2 = "{\\"a\\":1, \\"b\\":2, \\"c\\":3, \\"d\\":4}"; String expected3 = "{\\"a\\":1, \\"b\\":2, \\"c\\":3, \\"d\\":4}"; String expected
@Test public void testSimple() throws IOException, JsonParseException { final TreeTraversingParser<JsonNode> p = new TreeTraversingParser<JsonNode>(JsonNodeFactory.instance.objectNode()); p.nextToken(); p.nextToken(); p.nextToken(); p.nextToken(); p.nextToken(); p.nextToken(); p.nextToken(); p.nextToken(); p.nextToken(); p.nextToken(); p.nextToken(); p.nextToken(); p.nextToken(); p.nextToken(); p.nextToken(); p.nextToken(); p.nextToken(); p.nextToken(); p.nextToken(); p.nextToken(); p.nextToken();
@Test public void test() throws IOException, JsonParseException, ParseException { final TreeTraversingParser<JsonNode> jp = new TreeTraversingParser<JsonNode>(JsonNodeFactory.instance.objectNode()); jp.setCodec(new ObjectCodec()); assertNull(jp.nextToken()); jp.setCodec(new ObjectCodec()); assertNotNull(jp.nextToken()); jp.setCodec(new ObjectCodec()); assertNotNull(jp.nextToken()); jp.setCodec(new ObjectCodec()); assertNotNull(jp.nextToken()); jp.setCodec(new ObjectCodec()); assertNotNull(jp.nextToken()); jp.setCodec(new ObjectCodec()); assertNotNull(jp.nextToken()); jp.setCodec(new Object
@Test public void testNextToken() throws IOException, JsonParseException { TreeTraversingParser<JsonNode> p = new TreeTraversingParser<JsonNode>(JsonNodeFactory.instance.objectNode()); p.setCodec(new ObjectCodec()); p.nextToken(); p.nextToken(); p.nextToken(); p.nextToken(); p.nextToken(); p.nextToken(); p.nextToken(); p.nextToken(); p.nextToken(); p.nextToken(); p.nextToken(); p.nextToken(); p.nextToken(); p.nextToken(); p.nextToken(); p.nextToken(); p.nextToken(); p.nextToken(); p.nextToken(); p
@Test public void testNextToken() throws IOException, JsonParseException { final TreeTraversingParser<JsonNode> jp = new TreeTraversingParser<JsonNode>(JsonNodeFactory.instance.objectNode()); jp.setCodec(new ObjectCodec()); assertNull(jp.nextToken()); jp.setCodec(new ObjectCodec()); assertNotNull(jp.nextToken()); jp.setCodec(new ObjectCodec()); assertNull(jp.nextToken()); jp.setCodec(new ObjectCodec()); assertNotNull(jp.nextToken()); jp.setCodec(new ObjectCodec()); assertNotNull(jp.nextToken()); jp.setCodec(new ObjectCodec()); assertNotNull(jp.nextToken()); jp.setCodec(new
@Test public void testSimple() throws IOException, JsonParseException { final JsonRootNode n = Json.createObjectNode(); n.put("foo", "bar"); final JsonTraversingParser<JsonNode> xp = new TreeTraversingParser<JsonNode>(n); xp.setCodec(new ObjectCodec()); final JsonParser p = xp.nextToken(); p.nextNode(); p.nextNode(); p.nextNode(); p.nextNode(); p.nextNode(); p.nextNode(); p.nextNode(); p.nextNode(); p.nextNode(); p.nextNode(); p.nextNode(); p.nextNode(); p.nextNode(); p.nextNode(); p.next
@Test public void testSimple() throws IOException, JsonParseException, ParseException { final TreeTraversingParser<JsonNode> jp = new TreeTraversingParser<JsonNode>(JsonNodeFactory.instance.objectNode()); jp.nextToken(); jp.nextToken(); jp.nextToken(); }
@Test public void testNextToken() throws IOException, JsonParseException { TreeTraversingParser<JsonNode> p = new TreeTraversingParser<JsonNode>(JsonNodeFactory.instance.objectNode()); p.setCodec(new ObjectCodec()); p.nextToken(); p.nextToken(); p.nextToken(); p.nextToken(); p.nextToken(); p.nextToken(); p.nextToken(); p.nextToken(); p.nextToken(); p.nextToken(); p.nextToken(); p.nextToken(); p.nextToken(); p.nextToken(); p.nextToken(); p.nextToken(); p.nextToken(); p.nextToken(); p.nextToken(); p
@Test public void testNextToken() throws IOException, JsonParseException { final JsonParser p = new JsonParser(); final JsonNode n = p.objectNode(); p.nextNode(); p.nextNode(); p.nextNode(); p.nextNode(); p.nextNode(); p.nextNode(); p.nextNode(); p.nextNode(); p.nextNode(); p.nextNode(); p.nextNode(); p.nextNode(); p.nextNode(); p.nextNode(); p.nextNode(); p.nextNode(); p.nextNode(); p.nextNode(); p.nextNode(); p.nextNode(); p.nextNode(); p.nextNode(); p.nextNode();
@Test public void testNextToken() throws IOException, JsonParseException { final JsonNode n = JsonUtils.createObjectNode().put("foo", "bar"); final TreeTraversingParser<JsonNode> xp = new TreeTraversingParser<JsonNode>(n); xp.setCodec(new ObjectCodec()); final JsonParser p = xp.nextToken(); p.nextToken(); p.nextToken(); p.nextToken(); p.nextToken(); p.nextToken(); p.nextToken(); p.nextToken(); p.nextToken(); p.nextToken(); p.nextToken(); p.nextToken(); p.nextToken(); p.nextToken(); p.nextToken(); p.nextToken
@Test public void test() throws IOException, JsonParseException, ParseException { final TreeTraversingParser<JsonNode> jp = new TreeTraversingParser<JsonNode>(JsonNodeFactory.instance.objectNode()); jp.setCodec(new ObjectCodec()); jp.nextToken(); jp.nextToken(); jp.nextToken(); assertEquals(JsonNodeFactory.instance.objectNode(), jp.getRequestContext()); jp.nextToken(); assertEquals(JsonNodeFactory.instance.objectNode(), jp.getRequestContext()); jp.nextToken(); assertEquals(JsonNodeFactory.instance.objectNode(), jp.getRequestContext()); jp.nextToken(); assertEquals(JsonNodeFactory.instance.objectNode(), jp.
@Test public void testNextToken() throws IOException, JsonParseException { TreeTraversingParser<JsonNode> p = new TreeTraversingParser<JsonNode>(JsonNodeFactory.instance.objectNode()); p.setCodec(new ObjectCodec()); p.nextToken(); p.nextToken(); p.nextToken(); p.nextToken(); p.nextToken(); p.nextToken(); p.nextToken(); p.nextToken(); p.nextToken(); p.nextToken(); p.nextToken(); p.nextToken(); p.nextToken(); p.nextToken(); p.nextToken(); p.nextToken(); p.nextToken(); p.nextToken(); p.nextToken(); p
@Test public void testNextToken() throws IOException, JsonParseException { final TreeTraversingParser<JsonNode> jp = new TreeTraversingParser<JsonNode>(JsonNodeFactory.instance.objectNode()); jp.setCodec(new ObjectCodec()); JsonToken t = jp.nextToken(); assertNotNull(t); assertEquals("test", t.getCurrentName()); jp.setCodec(new ObjectCodec()); t = jp.nextToken(); assertNotNull(t); assertEquals("test2", t.getCurrentName()); jp.setCodec(new ObjectCodec()); t = jp.nextToken(); assertNotNull(t); assertEquals("test3", t.getCurrentName()); jp.setCodec(new ObjectCodec
@Test public void testGetText() throws IOException { TreeTraversingParser j = new TreeTraversingParser(JsonNodeFactory.instance.objectNode()); j.nextToken(); j.setText("foo"); assertEquals("foo", j.getText()); j.nextToken(); j.setText("bar"); assertEquals("bar", j.getText()); j.nextToken(); j.setText("baz"); assertEquals("baz", j.getText()); j.nextToken(); j.setText("baz"); assertEquals("baz", j.getText()); j.nextToken(); j.setText("baz"); assertEquals("baz", j.getText());
@Test public void testGetText() throws IOException { TreeTraversingParser j = new TreeTraversingParser(JsonNodeFactory.instance.objectNode()); j.nextToken(); j.setText("test"); assertEquals("test", j.getText()); j.nextToken(); assertEquals("test", j.getText()); j.nextToken(); assertEquals("test", j.getText()); j.nextToken(); assertEquals("test", j.getText()); j.nextToken(); assertEquals("test", j.getText()); j.nextToken(); assertEquals("test", j.getText()); j.nextToken(); assertEquals("test", j.getText()); j.nextToken
@Test public void testGetText() throws IOException { TreeTraversingParser parser = new TreeTraversingParser(JsonNodeFactory.instance.objectNode()); assertNull(parser.getText()); parser.nextToken(); assertNull(parser.getText()); parser.nextToken(); assertEquals("test", parser.getText()); parser.nextToken(); assertEquals("test", parser.getText()); parser.nextToken(); assertEquals("test", parser.getText()); parser.nextToken(); assertEquals("test", parser.getText()); parser.nextToken(); assertEquals("test", parser.getText()); parser.nextToken(); assertEquals("test", parser.getText()); parser.nextToken();
@Test public void testGetText() throws IOException { TreeTraversingParser j = new TreeTraversingParser(JsonNodeFactory.instance.objectNode()); j.nextToken(); j.setText("test"); assertEquals("test", j.getText()); j.nextToken(); j.setText("test2"); assertEquals("test2", j.getText()); j.nextToken(); j.setText("test3"); assertEquals("test3", j.getText()); j.nextToken(); j.setText("test4"); assertEquals("test4", j.getText()); j.nextToken(); j.setText("test5"); assertEquals("test5", j.get
@Test public void testGetTextCharacters() throws Exception { String[][] lines = new String[][] { new String[] {"a", "b"}, new String[] {"c", "d"}, new String[] {"e", "f"}, new String[] {"g", "h"}, new String[] {"i", "j"} }; for (int i = 0; i < lines.length; i++) { for (int j = 0; j < lines[i].length; j++) { char[] text = lines[i].getTextCharacters(); for (int j = 0; j < lines[j].length; j++) { Assert.assertEquals(text[j
@Test public void testGetText() { String[][] lines = new String[][] { new String[] {"a", "b"}, new String[] {"c"}, new String[] {"d"}, new String[] {"e"}, new String[] {"f"}, new String[] {"g"}, new String[] {"h"}, new String[] {"i"} }; for (int i = 0; i < lines.length; i++) { for (int j = 0; j < lines[i].length; j++) { for (int k = 0; k < lines[j].length; k++) { assertEquals(lines[i][j], lines[j][k
@Test public void testGetTextLength() throws IOException, JsonParseException { assertEquals(0, new TreeTraversingParser(JsonNodeFactory.instance.objectNode()).getTextLength()); assertEquals(1, new TreeTraversingParser(JsonNodeFactory.instance.objectNode()).getTextLength()); assertEquals(2, new TreeTraversingParser(JsonNodeFactory.instance.objectNode()).getTextLength()); assertEquals(3, new TreeTraversingParser(JsonNodeFactory.instance.objectNode()).getTextLength()); assertEquals(4, new TreeTraversingParser(JsonNodeFactory.instance.objectNode()).getTextLength()); }
@Test public void testGetTextLength() throws IOException, JsonParseException { assertEquals("foo", new String(parser.getText(), "UTF-8")); assertEquals("foo", new String(parser.getText(), "UTF-8")); assertEquals("foo", new String(parser.getText(), "UTF-8")); assertEquals("foo", new String(parser.getText(), "UTF-8")); assertEquals("foo", new String(parser.getText(), "UTF-8")); assertEquals("foo", new String(parser.getText(), "UTF-8")); assertEquals("foo", new String(parser.getText(), "UTF-8"));
@Test public void testGetTextOffset() throws IOException, JsonParseException { assertEquals(0, new TreeTraversingParser(JsonUtils.createObjectNode("{\\"foo\\": \\"bar\\"}")).getTextOffset()); assertEquals(0, new TreeTraversingParser(JsonUtils.createObjectNode("{\\"foo\\": \\"bar\\"}")).getTextOffset()); assertEquals(0, new TreeTraversingParser(JsonUtils.createObjectNode("{\\"foo\\": \\"bar\\"}")).getTextOffset()); assertEquals(0, new TreeTraversingParser(JsonUtils.createObjectNode("{\\"foo\\": \\"bar\\"}")).get
@Test public void testGetTextOffset() throws IOException, JsonParseException { assertEquals(0, new TreeTraversingParser(JsonUtils.createObjectNode("{\\"foo\\":1}")).getTextOffset()); assertEquals(0, new TreeTraversingParser(JsonUtils.createObjectNode("{\\"foo\\":2}")).getTextOffset()); assertEquals(0, new TreeTraversingParser(JsonUtils.createObjectNode("{\\"foo\\":3}")).getTextOffset()); assertEquals(0, new TreeTraversingParser(JsonUtils.createObjectNode("{\\"foo\\":4}")).getTextOffset()); assertEquals(0, new TreeTraversing
@Test public void testTimeZoneSerializer() throws IOException { SerializerProvider provider=new MockSerializerProvider(); TypeSerializer typeSer=new MockTypeSerializer(); serializer.instance=Optional.of(typeSer); serializer.serializeWithType(TimeZone.parse("Africa/Nairobi"), jgen, provider, typeSer); Assert.assertNotNull(jgen.toString()); }
@Test public void testSerializeWithType_TimeZone() throws IOException, JsonGenerationException { serializer.serializeWithType(TimeZone.getTimeZone("PST"), jgen, provider, typeSer); Mockito.verify(typeSer).writeTypePrefixForScalar(TimeZone.getTimeZone("PST"), jgen, TimeZone.class); Mockito.verify(typeSer).writeTypeSuffixForScalar(TimeZone.getTimeZone("PST"), jgen, TimeZone.class); }
@Test public void testTimeZoneSerializer() throws IOException, JsonGenerationException { serializer.serializeWithType(TimeZone.getTimeZone("PST"), jgen, provider, new TypeSerializer() { @Override public void writeTypePrefixForScalar(TimeZone value, JsonGenerator jgen, TimeZone class) throws IOException, JsonGenerationException { } @Override public void writeTypeSuffixForScalar(TimeZone value, JsonGenerator jgen, TimeZone class) throws IOException, JsonGenerationException { } }); Mockito.verify(jgen, Mockito.times(1)).writeFieldName(Mockito.anyString()); Mockito.verify(jgen, Mockito.times(1)).writeFieldName(Mockito.anyString
@Test public void testTimeZoneSerializer() throws IOException, JsonGenerationException { SerializerProvider provider = mock(SerializerProvider.class); TypeSerializer typeSerializer = mock(TypeSerializer.class); when(provider.getTypeSerializer()).thenReturn(typeSerializer); TimeZoneSerializer serializer = new TimeZoneSerializer(); serializer.serialize(TimeZone.getTimeZone("PST"), jgen, provider); verify(typeSerializer).writeTypePrefixForScalar(TimeZone.getTimeZone("PST"), jgen, TimeZone.class); verify(typeSerializer).writeTypeSuffixForScalar(TimeZone.getTimeZone("PST"), jgen, TimeZone.class); }
@Test public void testTimeZoneSerializer() throws IOException, JsonGenerationException { serializer.serializeWithType(TimeZone.getTimeZone("PST"), jgen, provider, new TypeSerializer() { @Override public void writeTypeSuffixForScalar(TimeZone value, JsonGenerator jgen, Class<TimeZoneSerializer> typeSer) throws IOException, JsonGenerationException { } @Override public void writeTypePrefixForScalar(TimeZone value, JsonGenerator jgen, Class<TimeZoneSerializer> typeSer) throws IOException, JsonGenerationException { } @Override public void writeTypeSuffixForScalar(TimeZone value, JsonGenerator jgen, Class<TimeZoneSerializer> typeSer) throws IOException, JsonGenerationException { } }); Mockito.verify(
@Test public void testBeanSerializerBuilder() { BeanSerializerBuilder builder = new BeanSerializerBuilder(new SimpleBeanDescription()); JsonSerializer<?> serializer = builder.createDummy(); assertTrue(serializer.hasProperties()); assertTrue(serializer.getProperties().length > 0); assertTrue(serializer.getProperties()[0] instanceof BeanPropertyWriter); assertTrue(serializer.getProperties()[1] instanceof BeanPropertyWriter); assertTrue(serializer.getProperties()[2] instanceof BeanPropertyWriter); assertTrue(serializer.getProperties()[3] instanceof BeanPropertyWriter); assertTrue(serializer.getProperties()[4] instanceof BeanPropertyWriter); assertTrue(serializer.getProperties()[5] instanceof
@Test public void testBeanSerializerBuilder() { SimpleBeanDescription desc = new SimpleBeanDescription(); BeanSerializerBuilder b = new BeanSerializerBuilder(desc); assertEquals(desc.getBeanDesc(), b.getBeanDesc()); assertEquals(desc.getProperties().size(), b.getProperties().size()); assertEquals(desc.getProperties().get(0).getDescription(), b.getProperties().get(0).getDescription()); assertEquals(desc.getProperties().get(1).getDescription(), b.getProperties().get(1).getDescription()); assertEquals(desc.getProperties().get(2).getDescription(), b.getProperties().get(2).getDescription()); assertEquals(
@Test public void testBeanSerializerBuilder() { SimpleBeanDescription desc = new SimpleBeanDescription(); BeanSerializerBuilder builder = new BeanSerializerBuilder(desc); builder.setProperties(Arrays.asList(new BeanPropertyWriter[] { new BeanPropertyWriter("prop1", "value1"), new BeanPropertyWriter("prop2", "value2"), new BeanPropertyWriter("prop3", "value3"), new BeanPropertyWriter("prop4", "value4"), new BeanPropertyWriter("prop5", "value5"), new BeanPropertyWriter("prop6", "value6"), new BeanPropertyWriter("prop7", "value7"), new BeanPropertyWriter("prop8", "
@Test public void testBeanSerializerBuilder() { SimpleBeanDescription desc = new SimpleBeanDescription(); BeanSerializerBuilder b = new BeanSerializerBuilder(desc); assertTrue(b.hasProperties()); assertTrue(b.getProperties().length > 0); assertTrue(b.getProperties()[0] instanceof SimpleBeanPropertyWriter); assertTrue(b.getProperties()[1] instanceof SimpleBeanPropertyWriter); assertTrue(b.getProperties()[2] instanceof SimpleBeanPropertyWriter); assertTrue(b.getProperties()[3] instanceof SimpleBeanPropertyWriter); assertTrue(b.getProperties()[4] instanceof SimpleBeanPropertyWriter); assertTrue(b.getProperties()[5]
@Test public void testBeanSerializerBuilder() { SimpleBeanDescription desc = new SimpleBeanDescription(); BeanSerializerBuilder b = new BeanSerializerBuilder(desc); assertTrue(b.hasProperties()); assertTrue(b.getProperties().length > 0); assertTrue(b.getProperties()[0] instanceof SimpleBeanPropertyWriter); assertTrue(b.getProperties()[1] instanceof SimpleBeanPropertyWriter); assertTrue(b.getProperties()[2] instanceof SimpleBeanPropertyWriter); assertTrue(b.getProperties()[3] instanceof SimpleBeanPropertyWriter); assertTrue(b.getProperties()[4] instanceof SimpleBeanPropertyWriter); assertTrue(b.getProperties()[5]
@Test public void testBeanSerializerBuilder() { SimpleBeanDescription desc = new SimpleBeanDescription(); BeanSerializerBuilder builder = new BeanSerializerBuilder(desc); builder.setProperties(new BeanPropertyWriter[] { new BeanPropertyWriter("prop1", "value1"), new BeanPropertyWriter("prop2", "value2"), new BeanPropertyWriter("prop3", "value3"), new BeanPropertyWriter("prop4", "value4") }); builder.setFilteredProperties(new BeanPropertyWriter[] { new BeanPropertyWriter("prop1", "value1"), new BeanPropertyWriter("prop2", "value2"), new BeanPropertyWriter("prop3", "value3"), new Bean
@Test(expected = IllegalArgumentException.class) public void multiple_type_ids() { BeanSerializerBuilder builder = new BeanSerializerBuilder(new SimpleBeanDescription("FooBar")); builder.setTypeId(new AnnotatedMember(Foo.class, Foo.class.getDeclaredField("foo"))); builder.setTypeId(new AnnotatedMember(Foo.class, Foo.class.getDeclaredField("bar"))); builder.setTypeId(new AnnotatedMember(Foo.class, Foo.class.getDeclaredField("baz"))); }
@Test(expected = IllegalArgumentException.class) public void multiple_type_ids() { BeanDescription desc = new DefaultBeanDescription(); BeanSerializerBuilder builder = new BeanSerializerBuilder(desc); builder.setTypeId(new AnnotatedMember(SimpleType.class, SimpleType.class)); builder.setTypeId(new AnnotatedMember(SimpleType.class, SimpleType.class, SimpleType.class)); builder.setTypeId(new AnnotatedMember(SimpleType.class, SimpleType.class, SimpleType.class)); builder.setTypeId(new AnnotatedMember(SimpleType.class, SimpleType.class, SimpleType.class)); }
@Test(expected = IllegalArgumentException.class) public void multiple_type_ids() { BeanDescription desc = new DefaultBeanDescription(); BeanPropertyWriter[] properties = new BeanPropertyWriter[1]; properties[0] = new BeanPropertyWriter("prop1", "value1"); properties[0].setProperties(properties); BeanPropertyWriter[] filteredProperties = new BeanPropertyWriter[1]; filteredProperties[0] = new BeanPropertyWriter("prop2", "value2"); BeanSerializerBuilder builder = new BeanSerializerBuilder(desc); builder.setProperties(filteredProperties); builder.setTypeId(new AnnotatedMember(Foo.class, Foo.class)); builder.setTypeId(new AnnotatedMember(Bar.
@Test(expected = IllegalArgumentException.class) public void multiple_type_ids() { BeanDescription desc = new DefaultBeanDescription(); BeanSerializerBuilder builder = new BeanSerializerBuilder(desc); builder.setTypeId(new AnnotatedMember(SimpleType.class, SimpleType.class)); builder.setTypeId(new AnnotatedMember(SimpleType.class, SimpleType.class)); builder.setTypeId(new AnnotatedMember(SimpleType.class, SimpleType.class)); }
@Test public void testNameForGetterMethod() { MapperConfig<Mapper> config = new MapperConfig<Mapper>(); AnnotatedMethod method = findMethod("getFoo"); String[] lines = config.nameForGetterMethod(config, method, "baz").split("\\n"); assertEquals("baz", lines[0]); }
@Test public void testNameForGetterMethod() { MapperConfig<Integer> config = new MapperConfig<Integer>(); assertEquals("one", config.nameForGetterMethod(config, method1, "one")); assertEquals("one", config.nameForGetterMethod(config, method2, "one")); assertEquals("one", config.nameForGetterMethod(config, method3, "one")); assertEquals("one", config.nameForGetterMethod(config, method4, "one")); assertEquals("one", config.nameForGetterMethod(config, method5, "one")); assertEquals("one", config.nameForGetterMethod(config, method6, "
@Test public void testConstructFromToString() { EnumValues values = EnumValues.constructFromToString(TestEnum.class, new AnnotationIntrospector() { @Override public Class<? extends Enum<?>> annotationType() { return TestEnum.class; } @Override public int numberOfEnums() { return 0; } @Override public int[] values() { return new int[0]; } @Override public int[] values() { return new int[0]; } @Override public boolean[] values() { return new boolean[0]; } @Override public int[] values() { return new int[0]; } @Override public boolean[] values() { return new boolean[0]; } @Override public boolean[] values() {
@Test public void constructFromToString() { EnumValues values = EnumValues.constructFromToString(TestEnum.class, new AnnotationIntrospector() { @Override public Class<? extends Enum<?>> annotationType() { return TestEnum.class; } @Override public int[] values() { return new int[]{1, 2, 3}; } }); assertEquals(4, values.values().size()); assertTrue(values.internalMap().containsKey(TestEnum.ONE)); assertTrue(values.internalMap().containsKey(TestEnum.TWO)); assertTrue(values.internalMap().containsKey(TestEnum.THREE)); assertTrue(values.internalMap().containsKey(TestEnum.FO
@Test public void constructFromToString() { EnumValues values = EnumValues.constructFromToString(TestEnum.class, new AnnotationIntrospector() { @Override public Class<? extends Enum<?>> annotationType() { return TestEnum.class; } @Override public int[] values() { return new int[]{1, 2, 3}; } }); assertEquals(4, values.values().size()); assertTrue(values.internalMap().containsKey(TestEnum.ONE)); assertTrue(values.internalMap().containsKey(TestEnum.TWO)); assertTrue(values.internalMap().containsKey(TestEnum.THREE)); assertTrue(values.internalMap().containsKey(TestEnum.FO
@Test public void constructFromToString() { EnumValues values = EnumValues.constructFromToString(TestEnum.class, new AnnotationIntrospector() { @Override public Class<? extends Enum<?>> annotationType() { return TestEnum.class; } @Override public int enumConstants() { return 0; } }); assertEquals(0, values.values().size()); values.addValueFor(TestEnum.ONE); assertEquals(1, values.values().size()); values.addValueFor(TestEnum.TWO); assertEquals(2, values.values().size()); values.addValueFor(TestEnum.THREE); assertEquals(3, values.values().size()); }
@Test(expected = IllegalArgumentException.class) public void constructFromToString() { EnumValues map = EnumValues.constructFromToString(TestEnum.class, new AnnotationIntrospector() { @Override public Class<? extends Enum<?>> annotationType() { return TestEnum.class; } @Override public int size() { return 0; } }); map.internalMap(); }
@Test public void constructFromToString() { EnumValues values = EnumValues.constructFromToString(TestEnum.class, new AnnotationIntrospector() { @Override public Class<? extends Enum<?>> annotationType() { return TestEnum.class; } @Override public int[] values() { return new int[]{1, 2, 3}; } }); assertEquals(3, values.values().size()); assertTrue(values.internalMap().containsKey(TestEnum.ONE)); assertTrue(values.internalMap().containsKey(TestEnum.TWO)); assertTrue(values.internalMap().containsKey(TestEnum.THREE)); assertTrue(values.internalMap().containsKey(TestEnum.FO
@Test public void testConstructFromToString() { EnumValues values = EnumValues.constructFromToString(TestEnum.class, new AnnotationIntrospector() { @Override public Class<? extends Enum<?>> annotationType() { return TestEnum.class; } @Override public int[] values() { return new int[]{1, 2, 3}; } }); assertEquals(3, values.values().size()); assertTrue(values.internalMap().containsKey(TestEnum.ONE)); assertTrue(values.internalMap().containsKey(TestEnum.TWO)); assertTrue(values.internalMap().containsKey(TestEnum.THREE)); assertTrue(values.internalMap().containsKey(TestEnum.
@Test public void testConstructFromToString() { EnumValues values = EnumValues.constructFromToString(TestEnum.class, new AnnotationIntrospector() { @Override public Class<? extends Enum<?>> annotationType() { return TestEnum.class; } @Override public int count() { return 0; } }); assertEquals(4, values.values().size()); assertTrue(values.values().contains(TestEnum.A)); assertTrue(values.values().contains(TestEnum.B)); assertTrue(values.values().contains(TestEnum.C)); assertTrue(values.values().contains(TestEnum.D)); assertTrue(values.values().contains(TestEnum.E)); }
@Test public void testBigIntegerNode() { Assert.assertEquals(new BigInteger("1"), new BigIntegerNode(new BigInteger("1"))); Assert.assertEquals(new BigInteger("1"), new BigIntegerNode(new BigInteger("1"))); Assert.assertEquals(new BigInteger("1"), new BigIntegerNode(new BigInteger("1"))); Assert.assertEquals(new BigInteger("1"), new BigIntegerNode(new BigInteger("1"))); Assert.assertEquals(new BigInteger("1"), new BigIntegerNode(new BigInteger("1"))); Assert.assertEquals(new BigInteger("1"), new BigIntegerNode(new BigInteger("1"))); Assert.assertEquals(new BigInteger
@Test public void testEqualsAndHashCode() { String s1 = "1"; String s2 = "2"; String s3 = "3"; String s4 = "4"; String s5 = "5"; BigIntegerNode n1 = BigIntegerNode.valueOf(s1); BigIntegerNode n2 = new BigIntegerNode(s2); BigIntegerNode n3 = new BigIntegerNode(s3); BigIntegerNode n4 = new BigIntegerNode(s4); BigIntegerNode n5 = new BigIntegerNode(s5); assertEquals(n1, n2); assertEquals(n1.hashCode(), n2.hashCode()); assertEquals(n1.hashCode(), n3.hashCode()); assertEquals
@Test public void testAsToken() { assertEquals(JsonToken.VALUE_NUMBER_INT, new BigIntegerNode(new BigInteger("123")).asToken()); assertEquals(JsonToken.VALUE_NUMBER_INT, new BigIntegerNode(new BigInteger("123")).asToken()); assertEquals(JsonToken.VALUE_NUMBER_INT, new BigIntegerNode(new BigInteger("123")).asToken()); assertEquals(JsonToken.VALUE_NUMBER_INT, new BigIntegerNode(new BigInteger("123")).asToken()); assertEquals(JsonToken.VALUE_NUMBER_INT, new BigIntegerNode(new BigInteger("123")).asToken()); assertEquals(JsonToken.VALUE_NUMBER_INT, new BigInteger
@Test public void testAsToken() { assertEquals(JsonToken.VALUE_NUMBER_INT, new BigIntegerNode(new BigInteger("1")).asToken()); assertEquals(JsonToken.VALUE_NUMBER_INT, new BigIntegerNode(new BigInteger("2")).asToken()); assertEquals(JsonToken.VALUE_NUMBER_INT, new BigIntegerNode(new BigInteger("3")).asToken()); assertEquals(JsonToken.VALUE_NUMBER_INT, new BigIntegerNode(new BigInteger("4")).asToken()); assertEquals(JsonToken.VALUE_NUMBER_INT, new BigIntegerNode(new BigInteger("5")).asToken()); assertEquals(JsonToken.VALUE_NUMBER_INT, new BigInteger
@Test public void testNumberType() { JsonParser.NumberType expect = JsonParser.NumberType.BIG_INTEGER; assertEquals(expect, new BigIntegerNode(new BigInteger("1")).numberType()); assertEquals(expect, new BigIntegerNode(new BigInteger("2")).numberType()); assertEquals(expect, new BigIntegerNode(new BigInteger("3")).numberType()); assertEquals(expect, new BigIntegerNode(new BigInteger("4")).numberType()); assertEquals(expect, new BigIntegerNode(new BigInteger("5")).numberType()); assertEquals(expect, new BigIntegerNode(new BigInteger("6")).numberType()); assertEquals(expect, new BigIntegerNode(new BigInteger("7")
@Test public void testNumberType() { JsonParser.NumberType expect = JsonParser.NumberType.BIG_INTEGER; assertEquals(expect, new JsonParser().numberType()); }
@Test public void testIsIntegrationNumber() { Assert.assertTrue(new BigIntegerNode(new BigInteger("123")).isIntegrationNumber()); Assert.assertTrue(new BigIntegerNode(new BigInteger("123.456")).isIntegrationNumber()); Assert.assertTrue(new BigIntegerNode(new BigInteger("123.456")).isIntegrationNumber()); Assert.assertTrue(new BigIntegerNode(new BigInteger("123.456")).isIntegrationNumber()); Assert.assertTrue(new BigIntegerNode(new BigInteger("123.456")).isIntegrationNumber()); Assert.assertTrue(new BigIntegerNode(new BigInteger("123.456")).isIntegrationNumber()); Assert.assertTrue(new BigIntegerNode(
@Test public void testIsIntegrationNumber() { assertTrue(new BigIntegerNode(new BigInteger("123")).isIntegrationNumber()); assertTrue(new BigIntegerNode(new BigInteger("123.456")).isIntegrationNumber()); assertTrue(new BigIntegerNode(new BigInteger("123.456")).isIntegrationNumber()); assertTrue(new BigIntegerNode(new BigInteger("123.456")).isIntegrationNumber()); assertTrue(new BigIntegerNode(new BigInteger("123.456")).isIntegrationNumber()); assertTrue(new BigIntegerNode(new BigInteger("123.456")).isIntegrationNumber()); assertTrue(new BigIntegerNode(new BigInteger("123.456")).isIntegrationNumber()); assert
@Test public void testIsBigInteger() { assertTrue(new BigIntegerNode(new BigInteger("1")).isBigInteger()); assertTrue(new BigIntegerNode(new BigInteger("2")).isBigInteger()); assertTrue(new BigIntegerNode(new BigInteger("3")).isBigInteger()); assertTrue(new BigIntegerNode(new BigInteger("4")).isBigInteger()); assertTrue(new BigIntegerNode(new BigInteger("5")).isBigInteger()); assertTrue(new BigIntegerNode(new BigInteger("6")).isBigInteger()); assertTrue(new BigIntegerNode(new BigInteger("7")).isBigInteger()); assertTrue(new BigIntegerNode(new BigInteger("8")).isBigInteger()); assertTrue(new BigIntegerNode(new BigInteger("9
@Test public void testIsBigInteger() { assertTrue(new BigIntegerNode(new BigInteger("1")).isBigInteger()); assertTrue(new BigIntegerNode(new BigInteger("2")).isBigInteger()); assertTrue(new BigIntegerNode(new BigInteger("3")).isBigInteger()); assertTrue(new BigIntegerNode(new BigInteger("4")).isBigInteger()); assertTrue(new BigIntegerNode(new BigInteger("5")).isBigInteger()); assertTrue(new BigIntegerNode(new BigInteger("6")).isBigInteger()); assertTrue(new BigIntegerNode(new BigInteger("7")).isBigInteger()); assertTrue(new BigIntegerNode(new BigInteger("8")).isBigInteger()); assertTrue(new BigIntegerNode(new BigInteger("9
@Test public void testCanConvertToInt() { String[][] lines = new String[][] { { "0", "1" }, { "1", "2" }, { "2", "3" }, { "3", "4" }, { "4", "5" }, { "5", "6" }, { "6", "7" }, { "7", "8" }, { "7", "9" }, { "7", "10" }, { "7", "10" }, { "7", "11" }, { "7", "12" }, { "7", "13" }, { "7", "14" }, { "7", "15
@Test public void testConvertToInt() { Assert.assertTrue(new BigIntegerNode(Integer.MAX_VALUE).canConvertToInt()); Assert.assertTrue(new BigIntegerNode(Integer.MIN_VALUE).canConvertToInt()); Assert.assertTrue(new BigIntegerNode(Integer.MIN_VALUE).canConvertToInt()); Assert.assertTrue(new BigIntegerNode(Integer.MAX_VALUE).canConvertToInt()); Assert.assertTrue(new BigIntegerNode(Long.MAX_VALUE).canConvertToInt()); Assert.assertTrue(new BigIntegerNode(Long.MIN_VALUE).canConvertToInt()); Assert.assertTrue(new BigIntegerNode(Long.MAX_VALUE).canConvertToInt()); Assert.assertTrue(new
@Test public void testCanConvertToLong() { BigIntegerNode node = new BigIntegerNode(new BigInteger("1")); node.setValue(Long.MAX_VALUE); assertTrue(node.canConvertToLong()); node.setValue(Long.MIN_VALUE); assertTrue(node.canConvertToLong()); node.setValue(-1); assertFalse(node.canConvertToLong()); node.setValue(Long.MIN_VALUE); assertFalse(node.canConvertToLong()); node.setValue(Long.MAX_VALUE); assertTrue(node.canConvertToLong()); node.setValue(Long.MIN_VALUE); assertTrue(node.canConvertToLong()); node.setValue(Long.MAX
@Test public void testConvertToLong() { BigIntegerNode node; node = new BigIntegerNode(BigInteger.valueOf(Long.MIN_VALUE)); assertTrue(node.canConvertToLong()); assertFalse(node.canConvertToLong()); node = new BigIntegerNode(Long.MAX_VALUE); assertTrue(node.canConvertToLong()); assertFalse(node.canConvertToLong()); node = new BigIntegerNode(Long.MIN_VALUE + 1); assertTrue(node.canConvertToLong()); assertFalse(node.canConvertToLong()); node = new BigIntegerNode(Long.MAX_VALUE); assertTrue(node.canConvertToLong()); assertFalse(node.canConvertToLong()); node = new BigIntegerNode(Long.
@Test public void testNumberValue() { Number n = new BigIntegerNode(new BigInteger("1")).numberValue(); Assert.assertEquals(1, n.intValue()); Assert.assertEquals(1, n.longValue()); Assert.assertEquals(1.0, n.floatValue(), 0.0); Assert.assertEquals(1.0, n.doubleValue(), 0.0); }
@Test public void testNumberValue() { Assert.assertEquals(1, new BigIntegerNode(new BigInteger("1")).numberValue().intValue()); Assert.assertEquals(2, new BigIntegerNode(new BigInteger("2")).numberValue().intValue()); Assert.assertEquals(3, new BigIntegerNode(new BigInteger("3")).numberValue().intValue()); Assert.assertEquals(4, new BigIntegerNode(new BigInteger("4")).numberValue().intValue()); Assert.assertEquals(5, new BigIntegerNode(new BigInteger("5")).numberValue().intValue()); Assert.assertEquals(6, new BigIntegerNode(new BigInteger("6")).numberValue().intValue()); Assert
@Test public void testIntValue() { Assert.assertEquals(1, new BigIntegerNode(new BigInteger("1")).intValue()); Assert.assertEquals(2, new BigIntegerNode(new BigInteger("2")).intValue()); Assert.assertEquals(3, new BigIntegerNode(new BigInteger("3")).intValue()); Assert.assertEquals(4, new BigIntegerNode(new BigInteger("4")).intValue()); Assert.assertEquals(5, new BigIntegerNode(new BigInteger("5")).intValue()); Assert.assertEquals(6, new BigIntegerNode(new BigInteger("6")).intValue()); Assert.assertEquals(7, new BigIntegerNode(new BigInteger("7")).intValue
@Test public void testIntValue() { String[][] data = new String[][] { new String[] {"1", "2"}, new String[] {"3", "4"}, new String[] {"5", "6"}, new String[] {"7", "8"} }; for (int i = 0; i < data.length; i++) { for (int j = 0; j < data[i].length; j++) { data[i][j] = data[i][j]; } } for (int i = 0; i < data.length; i++) { for (int j = 0; j < data[i].length; j++) { assertEquals
@Test public void testLongValue() { Assert.assertEquals(0, new BigIntegerNode(BigInteger.valueOf(0)).longValue()); Assert.assertEquals(1, new BigIntegerNode(new BigInteger("1")).longValue()); Assert.assertEquals(2, new BigIntegerNode(new BigInteger("2")).longValue()); Assert.assertEquals(3, new BigIntegerNode(new BigInteger("3")).longValue()); Assert.assertEquals(4, new BigIntegerNode(new BigInteger("4")).longValue()); Assert.assertEquals(5, new BigIntegerNode(new BigInteger("5")).longValue()); Assert.assertEquals(6, new BigIntegerNode(new BigInteger("6")).
@Test public void testLongValue() { assertEquals(0, new BigIntegerNode(new BigInteger("0")).longValue()); assertEquals(1, new BigIntegerNode(new BigInteger("1")).longValue()); assertEquals(2, new BigIntegerNode(new BigInteger("2")).longValue()); assertEquals(3, new BigIntegerNode(new BigInteger("3")).longValue()); assertEquals(Long.MAX_VALUE, new BigIntegerNode(Long.MAX_VALUE).longValue()); assertEquals(Long.MIN_VALUE, new BigIntegerNode(Long.MIN_VALUE).longValue()); assertEquals(Long.MAX_VALUE, new BigIntegerNode(Long.MAX_VALUE).longValue()); }
@Test public void testBigIntegerValue() { String[][] lines = new String[][] { new String[][] { new String[] { "0", "1" }, new String[] { "2", "3" }, new String[] { "4", "5" }, new String[] { "6", "7" }, new String[] { "8", "9" }, new String[] { "10", "11" }, new String[] { "12", "13" }, new String[] { "14", "15" } }; for (int i=0; i<lines.length; i++) { BigIntegerNode node = new BigIntegerNode(lines[i]); node.
@Test public void testBigIntegerValue() { assertEquals("0", new BigIntegerNode(new BigInteger("0")).bigIntegerValue().toString()); assertEquals("1", new BigIntegerNode(new BigInteger("1")).bigIntegerValue().toString()); assertEquals("2", new BigIntegerNode(new BigInteger("2")).bigIntegerValue().toString()); assertEquals("3", new BigIntegerNode(new BigInteger("3")).bigIntegerValue().toString()); assertEquals("4", new BigIntegerNode(new BigInteger("4")).bigIntegerValue().toString()); assertEquals("5", new BigIntegerNode(new BigInteger("5")).bigIntegerValue().toString()); assertEquals("6", new BigIntegerNode(new BigInteger("
@Test public void testDoubleValue() { String[][] lines = new String[][] { { "1.0", "1.0" }, { "1.1", "1.1" }, { "1.1", "1.1" }, { "1.1", "1.1" }, { "1.1", "1.1" }, { "1.1", "1.1" }, { "1.1", "1.1" }, { "1.1", "1.1" }, { "1.1", "1.1" }, { "1.1", "1.1" }, { "1.1", "
@Test public void testDoubleValue() { class TestCase { double _doubleValue; public TestCase(double _doubleValue) { this.doubleValue = _doubleValue; } } List<TestCase> testCases = new ArrayList<TestCase>(); testCases.add(new TestCase("1.0", "1.0")); testCases.add(new TestCase("1.0", "1.0")); testCases.add(new TestCase("1.0", "1.0")); testCases.add(new TestCase("1.0", "1.0")); testCases.add(new TestCase("1.0", "1.0")
@Test public void testAsText() { String text = new BigIntegerNode(new BigInteger("123")).asText(); Assert.assertEquals("123", text); text = new BigIntegerNode(new BigInteger("123.456")).asText(); Assert.assertEquals("123.456", text); text = new BigIntegerNode(new BigInteger("123.456")).asText(); Assert.assertEquals("123.456", text); text = new BigIntegerNode(new BigInteger("123.456")).asText(); Assert.assertEquals("123.456", text); text = new BigIntegerNode(new BigInteger("123.456")).asText(); Assert.assertEquals("123
@Test public void testAsText() { Assert.assertEquals("0", new BigIntegerNode(new BigInteger("0")).asText()); Assert.assertEquals("1", new BigIntegerNode(new BigInteger("1")).asText()); Assert.assertEquals("2", new BigIntegerNode(new BigInteger("2")).asText()); Assert.assertEquals("3", new BigIntegerNode(new BigInteger("3")).asText()); Assert.assertEquals("4", new BigIntegerNode(new BigInteger("4")).asText()); Assert.assertEquals("5", new BigIntegerNode(new BigInteger("5")).asText()); Assert.assertEquals("6", new BigIntegerNode(new BigInteger("6")).asText
@Test public void testEquals() { BigIntegerNode n1 = new BigIntegerNode(new BigInteger("1")); BigIntegerNode n2 = new BigIntegerNode(new BigInteger("2")); BigIntegerNode n3 = new BigIntegerNode(new BigInteger("3")); BigIntegerNode n4 = new BigIntegerNode(new BigInteger("4")); BigIntegerNode n5 = new BigIntegerNode(new BigInteger("5")); BigIntegerNode n6 = new BigIntegerNode(new BigInteger("6")); BigIntegerNode n7 = new BigIntegerNode(new BigInteger("7")); BigIntegerNode n8 = new BigIntegerNode(new BigInteger("8")); BigIntegerNode n9 = new BigIntegerNode(new BigInteger("9")); BigIntegerNode n10 =
@Test public void testEquals() { BigIntegerNode n1 = new BigIntegerNode(new BigInteger("1")); BigIntegerNode n2 = new BigIntegerNode(new BigInteger("2")); BigIntegerNode n3 = new BigIntegerNode(new BigInteger("3")); BigIntegerNode n4 = new BigIntegerNode(new BigInteger("4")); BigIntegerNode n5 = new BigIntegerNode(new BigInteger("5")); BigIntegerNode n6 = new BigIntegerNode(new BigInteger("6")); BigIntegerNode n7 = new BigIntegerNode(new BigInteger("7")); BigIntegerNode n8 = new BigIntegerNode(new BigInteger("8")); BigIntegerNode n9 = new BigIntegerNode(new BigInteger("9")); BigIntegerNode n10 =
@Test public void testEquals() { BigIntegerNode n1 = new BigIntegerNode(new BigInteger("1")); BigIntegerNode n2 = new BigIntegerNode(new BigInteger("2")); BigIntegerNode n3 = new BigIntegerNode(new BigInteger("3")); BigIntegerNode n4 = new BigIntegerNode(new BigInteger("4")); BigIntegerNode n5 = new BigIntegerNode(new BigInteger("5")); BigIntegerNode n6 = new BigIntegerNode(new BigInteger("6")); BigIntegerNode n7 = new BigIntegerNode(new BigInteger("7")); BigIntegerNode n8 = new BigIntegerNode(new BigInteger("8")); BigIntegerNode n9 = new BigIntegerNode(new BigInteger("9")); BigIntegerNode n10 =
@Test public void testEquals() { BigIntegerNode n = new BigIntegerNode(new BigInteger("1")); BigIntegerNode n2 = new BigIntegerNode(new BigInteger("2")); BigIntegerNode n3 = new BigIntegerNode(new BigInteger("3")); BigIntegerNode n4 = new BigIntegerNode(new BigInteger("4")); BigIntegerNode n5 = new BigIntegerNode(new BigInteger("5")); BigIntegerNode n6 = new BigIntegerNode(new BigInteger("6")); BigIntegerNode n7 = new BigIntegerNode(new BigInteger("7")); BigIntegerNode n8 = new BigIntegerNode(new BigInteger("8")); BigIntegerNode n9 = new BigIntegerNode(new BigInteger("9")); BigIntegerNode n10 = new
@Test public void testEquals() { BigIntegerNode n1 = new BigIntegerNode(new BigInteger("1")); BigIntegerNode n2 = new BigIntegerNode(new BigInteger("2")); BigIntegerNode n3 = new BigIntegerNode(new BigInteger("3")); BigIntegerNode n4 = new BigIntegerNode(new BigInteger("4")); BigIntegerNode n5 = new BigIntegerNode(new BigInteger("5")); BigIntegerNode n6 = new BigIntegerNode(new BigInteger("6")); BigIntegerNode n7 = new BigIntegerNode(new BigInteger("7")); BigIntegerNode n8 = new BigIntegerNode(new BigInteger("8")); BigIntegerNode n9 = new BigIntegerNode(new BigInteger("9")); BigIntegerNode n10 =
@Test public void testEquals() { BigIntegerNode a = new BigIntegerNode(new BigInteger("1")); BigIntegerNode b = new BigIntegerNode(new BigInteger("2")); BigIntegerNode c = new BigIntegerNode(new BigInteger("3")); BigIntegerNode d = new BigIntegerNode(new BigInteger("4")); BigIntegerNode e = new BigIntegerNode(new BigInteger("5")); BigIntegerNode f = new BigIntegerNode(new BigInteger("6")); BigIntegerNode g = new BigIntegerNode(new BigInteger("7")); BigIntegerNode h = new BigIntegerNode(new BigInteger("8")); BigIntegerNode j = new BigIntegerNode(new BigInteger("9")); BigIntegerNode k = new BigIntegerNode(new BigInteger("10"));
@Test public void testHashCode() { String[][] lines = new String[][] { new String[] {"1", "2", "3"}, new String[] {"1", "2", "3"}, new String[] {"1", "2", "3"}, new String[] {"1", "2", "3"}, new String[] {"1", "2", "3"}, new String[] {"1", "2", "3"}, new String[] {"1", "2", "3"}, new String[] {"1", "2", "3"}, new String[] {"1", "2", "3"}, new String[] {"1", "2", "3
@Test public void testHashCode() { String s1 = "1\\n2\\n3\\n4\\n5\\n6\\n7\\n8\\n9"; String s2 = "1\\n2\\n3\\n4\\n5\\n6\\n7\\n8"; String s3 = "1\\n2\\n3\\n4\\n5\\n6\\n7\\n8"; String s4 = "1\\n2\\n3\\n4\\n5\\n6\\n7\\n8"; String s5 = "1\\n2\\n3\\n4\\n5\\n6\\n7\\
@Test public void testAddColumn() { BooleanNode node = new BooleanNode().addColumn(true); assertEquals("true", node.toString()); node = new BooleanNode().addColumn(false); assertEquals("false", node.toString()); node = new BooleanNode().addColumn(true); assertEquals("true", node.toString()); node = new BooleanNode().addColumn(false); assertEquals("true", node.toString()); node = new BooleanNode().addColumn(true); assertEquals("true", node.toString()); node = new BooleanNode().addColumn(false); assertEquals("false", node.toString()); node = new BooleanNode().addColumn(false); assertEquals("false", node
@Test public void testDecline() { assertEquals(BooleanNode.getTrue(), new BooleanNode().addValue(true).addValue(false)); assertEquals(BooleanNode.getFalse(), new BooleanNode().addValue(false).addValue(true)); assertEquals(BooleanNode.getTrue(), new BooleanNode().addValue(true).addValue(false)); assertEquals(BooleanNode.getFalse(), new BooleanNode().addValue(false).addValue(true)); assertEquals(BooleanNode.getTrue(), new BooleanNode().addValue(true).addValue(false)); assertEquals(BooleanNode.getFalse(), new BooleanNode().addValue(false).addValue(false)); }
@Test public void testFloat() { NumericNode node = numberNode(0.0f); assertEquals(0.0f, node.getValue()); node = numberNode(1.0f); assertEquals(1.0f, node.getValue()); node = numberNode(2.0f); assertEquals(2.0f, node.getValue()); node = numberNode(3.0f); assertEquals(3.0f, node.getValue()); node = numberNode(4.0f); assertEquals(4.0f, node.getValue()); node = numberNode(5.0f); assertEquals(5.0f, node.getValue()); node = numberNode(6
@Test(expected=NullPointerException.class) public void testLongNull() { new NumberNode((long)null).numberNode((long)null); }
@Test(expected=NullPointerException.class) public void testNullPointerException() { new NumericNode().numberNode((byte) null); }
@Test(expected=NullPointerException.class) public void testDoubleNull() { new NumericNode().numberNode((double)null); }
@Test public void testTextNode() { TextNode node = new TextNode().textNode("a"); assertEquals("a", node.getText()); node = new TextNode().textNode("b"); assertEquals("b", node.getText()); node = new TextNode().textNode("c"); assertEquals("c", node.getText()); node = new TextNode().textNode("d"); assertEquals("d", node.getText()); node = new TextNode().textNode("e"); assertEquals("e", node.getText()); node = new TextNode().textNode("f"); assertEquals("f", node.getText()); node = new TextNode().textNode("g");
@Test public void testArrayNode() { String[][] lines = new String[][] { new String[] {"a", "b"}, new String[] {"c", "d"}, new String[] {"e", "f"}, new String[] {"g", "h"}, new String[] {"i", "j"}, new String[] {"k", "l"} }; ArrayNode arrayNode = lines[0].arrayNode(); for (int i=0; i<lines.length; i++) { assertEquals(lines[i].toString(), arrayNode.toString()); } }
@Test public void testObjectNode() { ObjectNode node = new ObjectNode().withValue(Byte.MAX_VALUE).withValue(Byte.MIN_VALUE).withValue(Byte.MAX_VALUE); assertEquals(Byte.MAX_VALUE, node.value()); assertEquals(Byte.MIN_VALUE, node.value()); assertEquals(Byte.MAX_VALUE, node.valueOf(Byte.MAX_VALUE).byteValue()); assertEquals(Byte.MAX_VALUE, node.valueOf(Byte.MIN_VALUE).byteValue()); assertEquals(Byte.MAX_VALUE, node.valueOf(Byte.MAX_VALUE).byteValue()); assertEquals(Byte.MAX_VALUE,
@Test public void testWithAbstractTypeResolver() throws Exception { AbstractTypeResolver resolver = Mockito.mock(AbstractTypeResolver.class); DeserializerFactory factory = _classUnderTest.withAbstractTypeResolver(resolver); assertNotNull(factory); assertSame(resolver, factory.getFactoryConfig().getAbstractTypeResolver()); assertSame(resolver, factory.getFactoryConfig().getAbstractTypeResolver()); }
@Test public void testWithAbstractTypeResolver() throws Exception { String json = "{\\n" + " \\"class\\" : \\"uk.gov.gchq.gaffer.data.deserializer.SimpleDeserializerFactory\\",\\n" + " \\"factoryConfig\\" : {\\n" + " \\"class\\" : \\"uk.gov.gchq.gaffer.data.deserializer.SimpleDeserializerFactory\\",\\n" + " \\"abstractTypeResolver\\" : {\\n" + " \\"class\\" : \\"uk.gov.gchq.gaffer.data.deserializer.SimpleTypeResolver\\",\\
@Test public void testMapAbstractType() throws Exception { DeserializerFactory factory = new BasicDeserializerFactory(new DeserializerFactoryConfig.Builder().build()).withKeyDeserializerModifier(KeyDeserializerModifier.PUBLIC).withValueInstantiators(Arrays.asList(String.class, Integer.class)).build(); JavaType javaType = factory.mapAbstractType(null, String.class); assertNotNull(javaType); assertEquals(String.class, javaType.getRawClass()); javaType = factory.mapAbstractType(null, String.class); assertNotNull(javaType); assertEquals(String.class, javaType.getRawClass()); javaType = factory.mapAbstractType(null, String.class); assertNotNull(
@Test public void testMapAbstractType() throws Exception { DeserializerFactory factory = new BasicDeserializerFactory(new DeserializerFactoryConfig.Builder().build()).withKeyDeserializers(KeyDeserializers.class) .withKeyDeserializerModifier(KeyDeserializers.class) .withValueInstantiators(ValueInstantiators.class) .create(); JavaType javaType = factory.mapAbstractType(null, SimpleType.constructType(String.class, String.class)); assertNotNull(javaType); assertEquals(String.class, javaType.getRawClass()); javaType = factory.mapAbstractType(null, SimpleType.constructType(String.class, String.class)); assertNotNull(javaType); assertEquals
@Test public void testMapAbstractType() throws Exception { DeserializerFactory factory = new BasicDeserializerFactory().withConfig(new DeserializerFactoryConfig.Builder().build()).withKeyDeserializerModifier(KeyDeserializerModifier.PUBLIC).withValueInstantiators(new ValueInstantiators()).build(); JavaType javaType = factory.mapAbstractType(null, SimpleType.constructType(String.class, String.class)); assertNotNull(javaType); assertEquals(String.class, javaType.getRawClass()); javaType = factory.mapAbstractType(null, SimpleType.constructType(Integer.class, Integer.class)); assertNotNull(javaType); assertEquals(Integer.class, javaType.getRawClass());
@Test public void testMapAbstractType() throws Exception { DeserializerFactory factory = new BasicDeserializerFactory(new DeserializerFactoryConfig.Builder().build()).withKeyDeserializerModifier(KeyDeserializerModifier.PUBLIC).build(); JavaType t = factory.mapAbstractType(new DesizationConfig.Builder().build(), new JavaType(String.class, String.class)); Assert.assertEquals(String.class, t.getRawClass()); t = factory.mapAbstractType(new DesizationConfig.Builder().build(), new JavaType(Integer.class, Integer.class)); Assert.assertEquals(Integer.class, t.getRawClass()); t = factory.mapAbstractType(new DesizationConfig
@Test public void testMapAbstractType2() throws Exception { Set<AbstractTypeResolver> abstractTypeResolvers = new HashSet<AbstractTypeResolver>(); AbstractTypeResolver resolver1 = mock(AbstractTypeResolver.class); AbstractTypeResolver resolver2 = mock(AbstractTypeResolver.class); AbstractTypeResolver resolver3 = mock(AbstractTypeResolver.class); when(resolver1.findTypeMapping(any(DeserializationConfig.class), any(JavaType.class))).thenReturn(null); when(resolver2.findTypeMapping(any(DeserializationConfig.class), any(JavaType.class))).thenReturn(null); when(resolver3.findTypeMapping(any(DeserializationConfig.class),
@Test public void testMapAbstractType2() throws JsonMappingException { String json = "{\\n" + " \\"class\\" : \\"org.apache.jackson.datatypes.String\\",\\n" + " \\"string\\" : \\"string\\",\\n" + " \\"int\\" : \\"int\\",\\n" + " \\"long\\" : \\"long\\",\\n" + " \\"float\\" : \\"float\\",\\n" + " \\"double\\" : \\"double\\",\\n" + " \\"stringArray\\" : [\\n" + " \\"string\\",\\n" + " \\"
@Test public void testMapAbstractType2() throws JsonMappingException { Set<AbstractTypeResolver> abstractTypeResolvers = new HashSet<AbstractTypeResolver>(); AbstractTypeResolver resolver1 = mock(AbstractTypeResolver.class); AbstractTypeResolver resolver2 = mock(AbstractTypeResolver.class); abstractTypeResolvers.add(resolver1); abstractTypeResolvers.add(resolver2); when(resolver1.findTypeMapping(any(DeserializationConfig.class), any(JavaType.class))).thenReturn(null); when(resolver2.findTypeMapping(any(DeserializationConfig.class), any(JavaType.class))).thenReturn(null); when(resolver1.findTypeMapping(any(
@Test public void testMapAbstractType2() throws JsonMappingException { Set<AbstractTypeResolver> abstractTypeResolvers = new HashSet<AbstractTypeResolver>(); AbstractTypeResolver resolver1 = mock(AbstractTypeResolver.class); AbstractTypeResolver resolver2 = mock(AbstractTypeResolver.class); abstractTypeResolvers.add(resolver1); abstractTypeResolvers.add(resolver2); when(resolver1.findTypeMapping(any(DeserializationConfig.class), any(JavaType.class))).thenReturn(null); when(resolver2.findTypeMapping(any(DeserializationConfig.class), any(JavaType.class))).thenReturn(null); when(resolver1.findTypeMapping(any(
@Test public void testFindValueInstantiator() throws JsonMappingException { SimpleDeserializationContext ctxt = new SimpleDeserializationContext(); ctxt.setConfig(new SimpleDeserializationConfig() { @Override public Class<?> annotationType() { return SimpleDeserializationContext.class; } @Override public DeserializationContext getContext() { return ctxt; } @Override public BeanDescription getBeanDescription() { return null; } @Override public Class<? extends Annotation> annotationType() { return SimpleDeserializationContext.class; } @Override public AnnotationIntrospector getAnnotationIntrospector() { return mock(AnnotationIntrospector.class); } @Override public Object findValueInstantiator(DeserializationContext ctxt, BeanDescription beanDesc)
@Test public void test_valueInstantiatorInstance() throws JsonMappingException { SimpleKeyDeserializerFactory factory = new SimpleKeyDeserializerFactory(); SimpleKeyDeserializer simpleKeyDeserializer = factory.withKeyDeserializer(SimpleKeyDeserializer.class); SimpleKeyDeserializer simpleKeyDeserializer2 = factory.withKeyDeserializer(SimpleKeyDeserializer.class); SimpleKeyDeserializer simpleKeyDeserializer3 = factory.withKeyDeserializer(SimpleKeyDeserializer.class); SimpleKeyDeserializer simpleKeyDeserializer4 = factory.withKeyDeserializer(SimpleKeyDeserializer.class); SimpleKeyDeserializer simpleKeyDeserializer5 = factory.withKeyDeserializer(SimpleKeyDeserializer.class); SimpleKeyDeserializer simpleKeyDeserializer6 = factory.withKeyDeserializer(SimpleKeyDeserializer.class); Simple
@Test public void test_ValueInstantiatorInstance() throws JsonMappingException { SimpleKeyDeserializerFactory factory = new SimpleKeyDeserializerFactory(); SimpleKeyDeserializer simpleKeyDeserializer = factory.withKeyDeserializer(SimpleKeyDeserializer.class); SimpleKeyDeserializer simpleKeyDeserializer2 = factory.withKeyDeserializer(SimpleKeyDeserializer.class); SimpleKeyDeserializer simpleKeyDeserializer3 = factory.withKeyDeserializer(SimpleKeyDeserializer.class); SimpleKeyDeserializer simpleKeyDeserializer4 = factory.withKeyDeserializer(SimpleKeyDeserializer.class); SimpleKeyDeserializer simpleKeyDeserializer5 = factory.withKeyDeserializer(SimpleKeyDeserializer.class); SimpleKeyDeserializer simpleKeyDeserializer6 = factory.withKeyDeserializer(SimpleKeyDeserializer.class); Simple
@Test public void test_ValueInstantiatorInstance() throws JsonMappingException { SimpleDeserializerFactory factory = new SimpleDeserializerFactory(); SimpleKeyDeserializer simpleKeyDeserializer = factory.withKeyDeserializer(SimpleKeyDeserializer.class); SimpleKeyDeserializer simpleKeyDeserializer2 = factory.withKeyDeserializer(SimpleKeyDeserializer.class); SimpleKeyDeserializer simpleKeyDeserializer3 = factory.withKeyDeserializer(SimpleKeyDeserializer.class); SimpleKeyDeserializer simpleKeyDeserializer4 = factory.withKeyDeserializer(SimpleKeyDeserializer.class); SimpleKeyDeserializer simpleKeyDeserializer5 = factory.withKeyDeserializer(SimpleKeyDeserializer.class); SimpleKeyDeserializer simpleKeyDeserializer6 = factory.withKeyDeserializer(SimpleKeyDeserializer.class); SimpleKeyDeserializer
@Test public void test_ValueInstantiatorInstance() throws JsonMappingException { SimpleDeserializerFactory factory = new SimpleDeserializerFactory(); SimpleKeyDeserializer simpleKeyDeserializer = factory.withKeyDeserializer(SimpleKeyDeserializer.class); SimpleKeyDeserializer simpleKeyDeserializer1 = factory.withKeyDeserializer(SimpleKeyDeserializer.class); SimpleKeyDeserializer simpleKeyDeserializer2 = factory.withKeyDeserializer(SimpleKeyDeserializer.class); SimpleKeyDeserializer simpleKeyDeserializer3 = factory.withKeyDeserializer(SimpleKeyDeserializer.class); SimpleKeyDeserializer simpleKeyDeserializer4 = factory.withKeyDeserializer(SimpleKeyDeserializer.class); SimpleKeyDeserializer simpleKeyDeserializer5 = factory.withKeyDeserializer(SimpleKeyDeserializer.class); SimpleKeyDeserializer
@Test public void testValueInstantiatorInstance() throws JsonMappingException { SimpleDeserializerFactory factory = new SimpleDeserializerFactory(); SimpleKeyDeserializer simpleKeyDeserializer = factory.withKeyDeserializer(SimpleKeyDeserializer.class); SimpleKeyDeserializer simpleKeyDeserializer1 = factory.withKeyDeserializer(SimpleKeyDeserializer.class); SimpleKeyDeserializer simpleKeyDeserializer2 = factory.withKeyDeserializer(SimpleKeyDeserializer.class); SimpleKeyDeserializer simpleKeyDeserializer3 = factory.withKeyDeserializer(SimpleKeyDeserializer.class); SimpleKeyDeserializer simpleKeyDeserializer4 = factory.withKeyDeserializer(SimpleKeyDeserializer.class); SimpleKeyDeserializer simpleKeyDeserializer5 = factory.withKeyDeserializer(SimpleKeyDeserializer.class); SimpleKeyDeserializer simple
@Test public void test_ValueInstantiatorInstance() throws JsonMappingException { SimpleDeserializerFactory factory = new SimpleDeserializerFactory(); SimpleKeyDeserializer simpleKeyDeserializer = factory.withKeyDeserializer(SimpleKeyDeserializer.class); SimpleKeyDeserializer simpleKeyDeserializer2 = factory.withKeyDeserializer(SimpleKeyDeserializer.class); SimpleKeyDeserializer simpleKeyDeserializer3 = factory.withKeyDeserializer(SimpleKeyDeserializer.class); SimpleKeyDeserializer simpleKeyDeserializer4 = factory.withKeyDeserializer(SimpleKeyDeserializer.class); SimpleKeyDeserializer simpleKeyDeserializer5 = factory.withKeyDeserializer(SimpleKeyDeserializer.class); SimpleKeyDeserializer simpleKeyDeserializer6 = factory.withKeyDeserializer(SimpleKeyDeserializer.class); SimpleKeyDeserializer
@Test public void test_valueInstantiatorInstance() throws JsonMappingException { SimpleDeserializerFactory factory = new SimpleDeserializerFactory(); SimpleKeyDeserializer simpleKeyDeserializer = factory.withKeyDeserializer(SimpleKeyDeserializer.class); SimpleKeyDeserializer simpleKeyDeserializer2 = factory.withKeyDeserializer(SimpleKeyDeserializer.class); SimpleKeyDeserializer simpleKeyDeserializer3 = factory.withKeyDeserializer(SimpleKeyDeserializer.class); SimpleKeyDeserializer simpleKeyDeserializer4 = factory.withKeyDeserializer(SimpleKeyDeserializer.class); SimpleKeyDeserializer simpleKeyDeserializer5 = factory.withKeyDeserializer(SimpleKeyDeserializer.class); SimpleKeyDeserializer simpleKeyDeserializer6 = factory.withKeyDeserializer(SimpleKeyDeserializer.class); SimpleKeyDeserializer
@Test public void testValueInstantiatorInstance() throws JsonMappingException { SimpleDeserializerFactory factory = new SimpleDeserializerFactory(); SimpleKeyDeserializer simpleKeyDeserializer = factory.withKeyDeserializer(SimpleKeyDeserializer.class); SimpleKeyDeserializer simpleKeyDeserializer2 = factory.withKeyDeserializer(SimpleKeyDeserializer.class); SimpleKeyDeserializer simpleKeyDeserializer3 = factory.withKeyDeserializer(SimpleKeyDeserializer.class); SimpleKeyDeserializer simpleKeyDeserializer4 = factory.withKeyDeserializer(SimpleKeyDeserializer.class); SimpleKeyDeserializer simpleKeyDeserializer5 = factory.withKeyDeserializer(SimpleKeyDeserializer.class); SimpleKeyDeserializer simpleKeyDeserializer6 = factory.withKeyDeserializer(SimpleKeyDeserializer.class); SimpleKeyDeserializer simple
@Test public void test_ValueInstantiatorInstance() throws JsonMappingException { SimpleDeserializationConfig cfg = new SimpleDeserializationConfig(); cfg.setHandlerInstantiator(new HandlerInstantiator() { @Override public Class<?> valueInstantiatorInstance(DeserializationConfig config, Annotated annotated, Class<?> clazz) { if (clazz == ValueInstantiator.class) { return NoClass.class; } else if (clazz == KeyDeserializer.class) { return KeyDeserializer.class; } else if (clazz == KeyDeserializer.class) { return KeyDeserializer.class; } else if (clazz == KeyDeserializer.class) { return KeyDeserializer.class; } else { throw new IllegalStateException("
@Test public void test_ValueInstantiatorInstance() throws JsonMappingException { SimpleDeserializerFactory factory = new SimpleDeserializerFactory(); SimpleKeyDeserializer simpleKeyDeserializer = factory.withKeyDeserializer(SimpleKeyDeserializer.class); SimpleKeyDeserializer simpleKeyDeserializer2 = factory.withKeyDeserializer(SimpleKeyDeserializer.class); SimpleKeyDeserializer simpleKeyDeserializer3 = factory.withKeyDeserializer(SimpleKeyDeserializer.class); SimpleKeyDeserializer simpleKeyDeserializer4 = factory.withKeyDeserializer(SimpleKeyDeserializer.class); SimpleKeyDeserializer simpleKeyDeserializer5 = factory.withKeyDeserializer(SimpleKeyDeserializer.class); SimpleKeyDeserializer simpleKeyDeserializer6 = factory.withKeyDeserializer(SimpleKeyDeserializer.class); SimpleKeyDeserializer
@Test public void test_ValueInstantiatorInstance() throws JsonMappingException { SimpleKeyDeserializerFactory factory = new SimpleKeyDeserializerFactory(); SimpleKeyDeserializer simpleKeyDeserializer = factory.withKeyDeserializer(SimpleKeyDeserializer.class); SimpleKeyDeserializer simpleKeyDeserializer2 = factory.withKeyDeserializer(SimpleKeyDeserializer.class); SimpleKeyDeserializer simpleKeyDeserializer3 = factory.withKeyDeserializer(SimpleKeyDeserializer.class); SimpleKeyDeserializer simpleKeyDeserializer4 = factory.withKeyDeserializer(SimpleKeyDeserializer.class); SimpleKeyDeserializer simpleKeyDeserializer5 = factory.withKeyDeserializer(SimpleKeyDeserializer.class); SimpleKeyDeserializer simpleKeyDeserializer6 = factory.withKeyDeserializer(SimpleKeyDeserializer.class); Simple
@Test public void constructSimpleProperty() throws JsonMappingException { SimpleBean bean = new SimpleBean(); bean.setIntegerField(123); bean.setStringField("abc"); BeanDescription desc = new BeanDescription(); desc.setBeanType(SimpleBean.class); SimpleBean bean2 = new SimpleBean(); bean2.setIntegerField(123); BeanDescription desc2 = new BeanDescription(); desc2.setBeanType(SimpleBean.class); desc2.setSimpleBean(bean); SimpleBean bean3 = new SimpleBean(); bean3.setIntegerField(123); BeanDescription desc3 = new BeanDescription(); desc3.setBeanType(SimpleBean.class); desc3.setString
@Test public void testCustomArrayDeserializer() throws JsonMappingException { SimpleDeserializerFactory factory = new SimpleDeserializerFactory(); SimpleDeserializerModifier modifier = new SimpleDeserializerModifier(); BeanDeserializerModifier modifier2 = new BeanDeserializerModifier(); BeanDeserializerModifier modifier3 = new BeanDeserializerModifier(); modifier2.modifyArrayDeserializer(factory.getDeserializationContext(), new ArrayType(String.class), new BeanDescription()); modifier3.modifyArrayDeserializer(factory.getDeserializationContext(), new ArrayType(Integer.class), new BeanDescription()); modifier2.modifyMapDeserializer(factory.getDeserializationContext(), new ArrayType(Map.class), new BeanDescription()); modifier3.modifyMapDeserializer(factory.getDeserializationContext(), new ArrayType(
@Test public void createArrayDeserializer() throws JsonMappingException { SimpleDeserializerFactory factory = new SimpleDeserializerFactory(); SimpleDeserializer simpleDeserializer = factory.withDeserializerModifier(new SimpleDeserializerModifier() { @Override public void modifyDeserializer(DeserializationContext ctxt, ArrayType type, BeanDescription beanDesc, JsonDeserializer<?> deser) { super.modifyDeserializer(ctxt, type, beanDesc); } }); SimpleDeserializer simpleDeserializer2 = factory.withDeserializerModifier(new SimpleDeserializerModifier() { @Override public void modifyDeserializer(DeserializationContext ctxt, ArrayType type, BeanDescription beanDesc, JsonDeserializer<?> deser) { super.modifyDeserializer(ctxt, type, beanDesc); } }); SimpleDeserializer simpleDeserializer3 = factory.
@Test public void testCustomArrayDeserializer() throws Exception { DeserializerFactory factory = new DeserializerFactory() { @Override public Deserializer<?> findArrayDeserializer(ArrayType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, Deserializer<?> elementDeserializer) { return null; } }; DeserializerFactory factory2 = new DeserializerFactory() { @Override public Deserializer<?> findCustomArrayDeserializer(ArrayType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, Deserializer<?> elementDeserializer) { return null; } }; DeserializerFactory factory3 = new DeserializerFactory() { @Override public Deserializer<?> withCustomArrayDeserializer(
@Test public void testCustomArrayDeserializer() throws JsonMappingException { DeserializerFactory factory = new DeserializerFactory() { @Override public Deserializer<?> findCustomArrayDeserializer(ArrayType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, Deserializer<?> elementDeserializer) { return null; } }; DeserializerFactory factory2 = new DeserializerFactory() { @Override public Deserializer<?> findCustomArrayDeserializer(ArrayType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, Deserializer<?> elementDeserializer) { return null; } }; DeserializerFactory factory3 = new DeserializerFactory() { @Override public Deserializer<?> findCustom
@Test public void testCustomArrayDeserializer() throws JsonMappingException { DeserializerFactory factory = new DeserializerFactory() { @Override public Deserializer<?> findCustomArrayDeserializer(ArrayType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, Deserializer<?> elementDeserializer) { return null; } }; DeserializerFactory factory2 = new DeserializerFactory() { @Override public Deserializer<?> findCustomArrayDeserializer(ArrayType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, Deserializer<?> elementDeserializer) { return null; } }; DeserializerFactory factory3 = new DeserializerFactory() { @Override public Deserializer<?> findCustom
@Test public void testCustomEnumDeserializer() throws Exception { DeserializationConfig config = _createDeserializationConfig("testCustomEnumDeserializer.json"); BeanDescription desc = Mockito.mock(BeanDescription.class); Mockito.when(desc.getClassName()).thenReturn(CustomEnumDeserializer.class.getName()); Mockito.when(desc.getPropertyNames()).thenReturn(Arrays.asList("a", "b", "c")); CustomEnumDeserializer deserializer = (CustomEnumDeserializer) _findCustomEnumDeserializer(CustomEnum.class, config, desc); Assert.assertNotNull(deserializer); Assert.assertEquals(CustomEnumDeserializer.class, deserializer.getClass()); Assert.assertEquals
@Test public void testCustomEnumDeserializer() throws Exception { DeserializerFactory factory = new DeserializerFactory() { @Override public Deserializer<?> findEnumDeserializer(Class<?> type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException { return new CustomEnumDeserializer(); } }; Deserializer<CustomEnum> deserializer = factory._findCustomEnumDeserializer(CustomEnum.class, null, null); Assert.assertNotNull(deserializer); Assert.assertEquals(CustomEnumDeserializer.class, deserializer.getClass()); }
@Test public void testCustomEnumDeserializer() throws Exception { DeserializationConfig config = _createDeserializationConfig("testCustomEnumDeserializer.json"); BeanDescription desc = Mockito.mock(BeanDescription.class); Mockito.when(desc.getClassName()).thenReturn("testCustomEnumDeserializer"); Mockito.when(desc.getPropertyNames()).thenReturn(Arrays.asList("a", "b", "c")); DeserializerFactory factory = new DeserializerFactory() .withConfig(config) .withKeyDeserializers(Arrays.asList( new KeyDeserializer() { @Override public Class<?> findEnumDeserializer(Class<?> type, DeserializationConfig config, BeanDescription bean
@Test public void testCustomDeserializer() throws JsonMappingException { DeserializerFactory factory = new BasicDeserializerFactory(new DeserializerFactoryConfig()) { @Override public Class<? extends JsonNode> getRootType() { return null; } @Override public DeserializerFactory getConfig() { return null; } @Override public DeserializerFactory createTreeDeserializer(Class<? extends JsonNode> nodeType, Class<? extends BeanDescription> beanDesc, DeserializerFactoryConfig config) throws JsonMappingException { return null; } }; Deserializer<?> deserializer = factory.createTreeDeserializer(null, JavaTypes.STRING, null); Assert.assertEquals(StringDeserializer.class, deserializer.getClass()); deserializer = factory.createTreeDeserializer(null,
@Test public void testCustomDeserializer() throws JsonMappingException { DeserializerFactory factory = new DefaultDeserializerFactory().withConfig(new DeserializerFactoryConfig()); Deserializer<?> deserializer = factory.createTreeDeserializer(null, JavaTypes.STRING, null); Assert.assertTrue(deserializer instanceof StringDeserializer); deserializer = factory.createTreeDeserializer(null, JavaTypes.STRING, null); Assert.assertTrue(deserializer instanceof StringDeserializer); deserializer = factory.createTreeDeserializer(null, JavaTypes.STRING, null); Assert.assertTrue(deserializer instanceof StringDeserializer); deserializer = factory.createTreeDeserializer(null, JavaTypes.STRING, null); Assert.assertTrue(deserializer instanceof StringDeserializer);
@Test public void testCustomDeserializer() throws JsonMappingException { DeserializerFactory factory = new BasicDeserializerFactory(new DeserializerFactoryConfig.Builder().build()); Deserializer<?> deserializer = factory.createTreeDeserializer(null, null, null); Assert.assertNotNull(deserializer); deserializer = factory.createTreeDeserializer(null, null, null); Assert.assertNotNull(deserializer); deserializer = factory.createTreeDeserializer(null, null, null); Assert.assertNotNull(deserializer); deserializer = factory.createTreeDeserializer(null, null, null); Assert.assertNotNull(deserializer); deserializer = factory.createTreeDeserializer(null, null, null); Assert.assertNotNull(deserializer); deserializer
@Test public void testCustomDeserializer() throws JsonMappingException { DeserializerFactory factory = new BasicDeserializerFactory(new DeserializerFactoryConfig.Builder().build()).withKeyDeserializer(KeyDeserializer.class) .withKeyDeserializerModifier(KeyDeserializerModifier.PUBLIC).build(); JsonDeserializer<?> deserializer = factory.createTreeDeserializer(null, JavaTypes.STRING, null); Assert.assertNotNull(deserializer); deserializer = factory.createTreeDeserializer(null, JavaTypes.STRING, null); Assert.assertNotNull(deserializer); deserializer = factory.createTreeDeserializer(null, JavaTypes.STRING, null); Assert.assertNotNull(deserializer); deserializer = factory.createTreeDeserializer(null, JavaTypes
@Test public void testCustomDeserializer() throws JsonMappingException { DeserializerFactory factory = new DefaultDeserializerFactory().withConfig(new DeserializerFactoryConfig.Builder() .withKeyDeserializer(KeyDeserializer.class) .withKeyDeserializerModifier(KeyDeserializerModifier.IMPLICIT) .build()); Deserializer<?> deserializer = factory.createTreeDeserializer(null, null, null); Assert.assertEquals(CustomDeserializer.class, deserializer.getClass()); deserializer = factory.createTreeDeserializer(null, null, null); Assert.assertEquals(CustomDeserializer.class, deserializer.getClass()); deserializer = factory.createTreeDeserializer(null, null, null); Assert.assertEquals(CustomDeserializer.class, deserializer.
@Test public void testFindCustomTreeNodeDeserializer() throws JsonMappingException { DeserializationConfig config = new DeserializationConfig(new Properties()); BeanDescription desc = Mockito.mock(BeanDescription.class); Mockito.when(desc.getClassName()).thenReturn(String.class); Mockito.when(desc.getPropertyNames()).thenReturn(Arrays.asList("field1", "field2")); Mockito.when(desc.getPropertyNames()).thenReturn(Arrays.asList("field3", "field4")); DeserializerFactory factory = new DeserializerFactory() { @Override public Deserializer<?> createDeserializer(Class<? extends JsonNode> type, DeserializationConfig
@Test public void testCustomDeserializer() throws Exception { String json = "{\\n" + " \\"str\\" : \\"foo\\",\\n" + " \\"int\\" : 1,\\n" + " \\"long\\" : 2,\\n" + " \\"float\\" : 3.0,\\n" + " \\"double\\" : 4.0,\\n" + " \\"float\\" : 5.0,\\n" + " \\"long\\" : 6.0,\\n" + " \\"double\\" : 7.0,\\n" + " \\"float\\" : 8.0,\\n" + " \\"double\\" :
@Test public void testCustomDeserializer() throws Exception { DeserializerFactory factory = new DefaultDeserializerFactory().withConfig(new DeserializationConfig.Builder().build()); Deserializer<?> deserializer = factory._findCustomTreeNodeDeserializer(String.class, null, null); Assert.assertNull(deserializer); deserializer = factory._findCustomTreeNodeDeserializer(String.class, null, null); Assert.assertNull(deserializer); deserializer = factory._findCustomTreeNodeDeserializer(String.class, null, null); Assert.assertNull(deserializer); deserializer = factory._findCustomTreeNodeDeserializer(String.class, null, null); Assert.assertNull(deserializer); }
@Test public void findTypeDeserializer() throws JsonMappingException { SimpleDeserializerFactory factory = new SimpleDeserializerFactory(); SimpleSerializer simpleSerializer = factory.withSerializer(SimpleSerializer.class); SimpleSerializer simpleSerializer2 = factory.withSerializer(SimpleSerializer2.class); SimpleSerializer simpleSerializer3 = factory.withSerializer(SimpleSerializer3.class); SimpleSerializer simpleSerializer4 = factory.withSerializer(SimpleSerializer4.class); SimpleSerializer simpleSerializer5 = factory.withSerializer(SimpleSerializer5.class); SimpleSerializer simpleSerializer6 = factory.withSerializer(SimpleSerializer6.class); SimpleSerializer simpleSerializer7 = factory.withSerializer(SimpleSerializer7.class); SimpleSerializer simpleSerializer8 = factory.
@Test public void testCustomDeserializer() throws JsonMappingException { SimpleDeserializerFactory factory = new SimpleDeserializerFactory(); factory.withKeyDeserializers(new KeyDeserializers() { @Override public KeyDeserializer findKeyDeserializer(DeserializationContext ctxt, JavaType type) { return new CustomDeserializer(); } @Override public void modifyKeyDeserializer(DeserializationContext ctxt, JavaType type, DeserializerFactoryConfig config, DeserializerFactoryConfig config) throws JsonMappingException { } @Override public KeyDeserializer createKeyDeserializer(DeserializationContext ctxt, JavaType type) throws JsonMappingException { return new CustomDeserializer(); } @Override public void modifyKeyDeserializer(DeserializationContext ctxt, JavaType type, DeserializerFactoryConfig config)
@Test public void test_createEnumKeyDeserializer() throws JsonMappingException, IOException { String jsonStr = "{\\n" + " \\"class\\" : \\"uk.gov.gchq.gaffer.common.jackson.databinding.converters.JsonValueDeserializer\\",\\n" + " \\"class\\" : \\"uk.gov.gchq.gaffer.common.jackson.databinding.converters.JsonValueDeserializer\\",\\n" + " \\"class\\" : \\"uk.gov.gchq.gaffer.common.jackson.databinding.converters.Json
@Test(expected = JsonMappingException.class) public void createEnumKeyDeserializer() throws JsonMappingException { final SimpleDeserializationContext ctxt = new SimpleDeserializationContext(); ctxt.setConfig(new SimpleDeserializationConfig() { @Override public Class<?> annotationType() { return TestEnum.class; } @Override public boolean canOverrideAccessModifiers() { return true; } @Override public JsonDeserializer<?> createDelegatingKeyDeserializer(DeserializationContext ctxt, Class<?> type, DeserializationConfig config) { return new JsonDeserializer<TestEnum>() { @Override public JsonDeserializer<?> createDelegatingKeyDeserializer(DeserializationContext ctxt, Class<?> type, DeserializationConfig config) {
@Test public void constructEnumKeyDeserializer() throws JsonMappingException { KeyDeserializer deserializer = _createEnumKeyDeserializer(_ctxt, SimpleEnum.class); Assert.assertEquals(SimpleEnum.class, deserializer.getClass()); Assert.assertEquals(1, deserializer.getClass().getDeclaredMethods().length); Assert.assertEquals(0, deserializer.getClass().getDeclaredMethods()[0].getParameterCount()); Assert.assertEquals(0, deserializer.getClass().getDeclaredMethods()[1].getParameterCount()); Assert.assertEquals(1, deserializer.getClass().getDeclaredMethods()[2].getParameterCount()); Assert.assertEquals(1, deserializer.getClass().getDeclaredMethods
@Test(expected = JsonMappingException.class) public void constructDelegatingKeyDeserializer() throws JsonMappingException { JsonParser parser = new JsonParser(); DeserializationContext ctxt = new DeserializationContext(parser, new SimpleDeserializationConfig()); JsonDeserializer<?> des = _createEnumKeyDeserializer(ctxt, SimpleBean.class); Assert.assertNotNull(des); DeserializationContext ctxt2 = new DeserializationContext(ctxt2, new SimpleDeserializationConfig()); des = _createEnumKeyDeserializer(ctxt2, SimpleBean2.class); Assert.assertNotNull(des); DeserializationContext ctxt3 = new DeserializationContext(ctxt3, new SimpleDeserializationConfig()); des =
@Test public void constructEnumKeyDeserializer() throws JsonMappingException { KeyDeserializer deserializer = _createEnumKeyDeserializer(new SimpleDeserializationContext(), SimpleTestEnum.class); assertTrue(deserializer instanceof SimpleKeyDeserializer); KeyDeserializer deserializer2 = _createEnumKeyDeserializer(new SimpleDeserializationContext(), SimpleTestEnum2.class); assertTrue(deserializer2 instanceof SimpleKeyDeserializer); KeyDeserializer deserializer3 = _createEnumKeyDeserializer(new SimpleDeserializationContext(), SimpleTestEnum3.class); assertTrue(deserializer3 instanceof SimpleKeyDeserializer); KeyDeserializer deserializer4 = _createEnumKeyDeserializer(new SimpleDeserializationContext(), SimpleTestEnum4.class); assertTrue(deserializer4 instanceof Simple
@Test public void constructEnumKeyDeserializer() throws JsonMappingException { KeyDeserializer deserializer = _createEnumKeyDeserializer(_ctxt, ClassWithEnum.class); Assert.assertEquals(ClassWithEnum.class, deserializer.getClass()); Assert.assertEquals(ClassWithEnum.class.getName(), deserializer.getClass().getName()); Assert.assertEquals(ClassWithEnum.class.getName(), deserializer.getClass().getName()); Assert.assertEquals(ClassWithEnum.class.getName(), deserializer.getClass().getName()); Assert.assertEquals(ClassWithEnum.class.getName(), deserializer.getClass().getName()); Assert.assertEquals(ClassWithEnum.class.getName(), deserializer.getClass().getName());
@Test(expected = JsonMappingException.class) public void findCustomEnumDeserializer() throws JsonMappingException { JsonParser parser = new JsonParser(); DeserializationContext ctxt = new DeserializationContext(new SimpleDeserializationConfig(), new SimpleDeserializationConfig()); JsonDeserializer<?> deserializer = _createEnumKeyDeserializer(ctxt, SimpleEnum.class); Assert.assertNull(deserializer); deserializer = _createEnumKeyDeserializer(ctxt, SimpleEnum.class); Assert.assertNull(deserializer); deserializer = _createEnumKeyDeserializer(ctxt, SimpleEnum.class); Assert.assertNull(deserializer); deserializer = _createEnumKeyDeserializer(ctxt, SimpleEnum.class); Assert.assertNull(
@Test(expected = JsonMappingException.class) public void constructCustomEnumKeyDeserializer() throws JsonMappingException { JsonKeyBean bean = new JsonKeyBean(); BeanDescription beanDesc = new BeanDescription(); beanDesc.setClazz(MyEnumBean.class); beanDesc.setAnnotationIntrospector(new AnnotationIntrospector() { @Override public boolean hasCreatorAnnotation(AnnotatedMethod factory) { return false; } @Override public Class<?> annotationType() { return MyEnumBean.class; } }); BeanDescription beanDesc2 = new BeanDescription(); beanDesc2.setClazz(MyEnumBean.class); beanDesc2.setAnnotationIntrospector(new AnnotationIntrospector() { @Override
@Test(expected = JsonMappingException.class) public void constructEnumKeyDeserializer() throws JsonMappingException { final ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("sample.xml"); final SimpleDeserializationContext ctxt = context.createDeserializationContext(); ctxt.setConfig(context.getConfig()); final SimpleEnumResolver<?> res = _createEnumKeyDeserializer(ctxt, SimpleEnum.class); assertTrue(res instanceof SimpleEnumResolver); final SimpleEnumResolver<?> res2 = (SimpleEnumResolver<?>) res; assertTrue(res2 instanceof SimpleEnumResolver); final SimpleEnumResolver<?> res3 = (SimpleEnumResolver<?>) res2; assertTrue(res3 instanceof SimpleEnumResolver
@Test public void createEnumKeyDeserializer() throws JsonMappingException { SimpleKeyDeserializer simpleKeyDeserializer = new SimpleKeyDeserializer(); SimpleKeyDeserializer simpleKeyDeserializer2 = new SimpleKeyDeserializer(); SimpleKeyDeserializer simpleKeyDeserializer3 = new SimpleKeyDeserializer(); SimpleKeyDeserializer simpleKeyDeserializer4 = new SimpleKeyDeserializer(); SimpleKeyDeserializer simpleKeyDeserializer5 = new SimpleKeyDeserializer(); SimpleKeyDeserializer simpleKeyDeserializer6 = new SimpleKeyDeserializer(); SimpleKeyDeserializer simpleKeyDeserializer7 = new SimpleKeyDeserializer(); SimpleKeyDeserializer simpleKeyDeserializer8 = new SimpleKeyDeserializer(); SimpleKeyDeserializer simpleKeyDeserializer9 = new SimpleKeyDeserializer(); SimpleKeyDeserializer simpleKeyDeserializer10 = new SimpleKeyDeserializer(); SimpleKeyDeserializer simpleKey
@Test(expected = JsonMappingException.class) public void createEnumKeyDeserializer() throws JsonMappingException { final JsonParser parser = new JsonParser(); final DeserializationContext ctxt = new DeserializationContext(new ClassPathResource("sample.json").getInputStream(), new SimpleDeserializationConfig()); final SimpleDeserializationConfig config = new SimpleDeserializationConfig(new ClassPathResource("sample.json").getInputStream(), new SimpleDeserializationConfig(new ClassPathResource("sample.json").getInputStream(), new SimpleDeserializationConfig(new ClassPathResource("sample.json").getInputStream(), new SimpleDeserializationConfig(new ClassPathResource("sample.json").getInputStream(), new SimpleDeserializationConfig(
@Test public void constructEnumKeyDeserializer() throws JsonMappingException { final KeyDeserializer deserializer1 = _createTestKeyDeserializer(TestEnum.class); final KeyDeserializer deserializer2 = _createTestKeyDeserializer(TestEnum.class); final KeyDeserializer deserializer3 = _createTestKeyDeserializer(TestEnum.class); final KeyDeserializer deserializer4 = _createTestKeyDeserializer(TestEnum.class); final KeyDeserializer deserializer5 = _createTestKeyDeserializer(TestEnum.class); final KeyDeserializer deserializer6 = _createTestKeyDeserializer(TestEnum.class); final KeyDeserializer deserializer7 = _createTestKeyDeserializer(TestEnum.class); final KeyDeserializer deserializer8 = _createTestKeyDeserializer(TestEnum.
@Test public void testFindPropertyTypeDeserializer() throws Exception { Set<NamedType> subtypes = new HashSet<NamedType>(); NamedType t1 = mock(NamedType.class); NamedType t2 = mock(NamedType.class); when(t1.getName()).thenReturn("t1"); when(t2.getName()).thenReturn("t2"); subtypes.add(t1); subtypes.add(t2); NamedType t3 = mock(NamedType.class); NamedType t4 = mock(NamedType.class); when(t3.getName()).thenReturn("t3"); when(t4.getName()).thenReturn("t4"); sub
@Test public void testFindPropertyTypeDeserializer() throws Exception { Set<NamedType> subtypes = new HashSet<NamedType>(); NamedType stringType = NamedType.create(String.class, "string"); subtypes.add(stringType); NamedType stringType2 = NamedType.create(String.class, "string"); subtypes.add(stringType2); NamedType stringType3 = NamedType.create(String.class, "string"); subtypes.add(stringType3); NamedType stringType4 = NamedType.create(String.class, "string"); subtypes.add(stringType4); NamedType stringType5 = NamedType.create(String.class,
@Test(expected=JsonMappingException.class) public void testIllegalKeyType() throws JsonMappingException { ClassA a = new ClassA(); a.setValueHandler(new NoOpValueHandler()); ClassB b = new ClassB(); b.setValueHandler(new NoOpValueHandler()); ClassC c = new ClassC(); c.setValueHandler(new NoOpValueHandler()); ClassC c2 = new ClassC(); c2.setValueHandler(new NoOpValueHandler()); ClassC c3 = new ClassC(); c3.setValueHandler(new NoOpValueHandler()); ClassC c4 = new ClassC(); c4.setValueHandler(new NoOpValueHandler
@Test(expected=JsonMappingException.class) public void testIllegalKeyType() throws JsonMappingException { ClassA a = new ClassA(); a.setValueHandler(new SimpleValueHandler()); ClassB b = new ClassB(); b.setValueHandler(new SimpleValueHandler()); ClassC c = new ClassC(); c.setValueHandler(new SimpleValueHandler()); ClassC c2 = new ClassC(); c2.setValueHandler(new SimpleValueHandler()); ClassC c3 = new ClassC(); c3.setValueHandler(new SimpleValueHandler()); ClassC c4 = new ClassC(); c4.setValueHandler(new SimpleValueHandler()); ClassC c5 =
@Test(expected=JsonMappingException.class) public void testModifyTypeByAnnotationIllegalKey() throws JsonMappingException { ClassA a = new ClassA(); a.setValueHandler(new NoOpValueHandler()); ClassB b = new ClassB(); b.setValueHandler(new NoOpValueHandler()); ClassC c = new ClassC(); c.setValueHandler(new NoOpValueHandler()); ClassC c2 = new ClassC(); c2.setValueHandler(new NoOpValueHandler()); ClassC c3 = new ClassC(); c3.setValueHandler(new NoOpValueHandler()); ClassC c4 = new ClassC(); c4.setValueHandler(new No
@Test public void testSimple() throws Exception { SimpleDeserializer<Integer> x = new SimpleDeserializer<Integer>() { @Override public Integer resolveType(DeserializationContext ctxt, BeanDescription beanDesc, JavaType type, AnnotatedMember member) { return 0; } }; SimpleDeserializer<Integer> y = new SimpleDeserializer<Integer>() { @Override public Integer resolveType(DeserializationContext ctxt, BeanDescription beanDesc, JavaType type, AnnotatedMember member) { return 0; } }; SimpleDeserializer<Integer> z = new SimpleDeserializer<Integer>() { @Override public Integer resolveType(DeserializationContext ctxt, BeanDescription beanDesc, JavaType type, AnnotatedMember member) { return 0;
@Test public void testReportIncompatibleRootType() throws IOException, JsonGenerationException { SimpleSerializationConfig config = new SimpleSerializationConfig(); config.setEnabled(SerializationFeature.WRAP_ROOT_VALUE, true); SimpleSerializer<Integer> ser = new SimpleSerializer<Integer>() { @Override public void serialize(Integer value, JsonGenerator jgen, SerializationConfig config) throws IOException, JsonGenerationException { super.serialize(jgen, value); } @Override public void serializeFieldName(JavaType type, SerializationConfig config) throws IOException, JsonGenerationException { super.serializeFieldName(type, config); } @Override public JsonSerializer<Integer> getDefaultNullValueSerializer(JavaType type, boolean useNullValue) throws IOException,
@Test public void test() throws IOException, JsonProcessingException { BeanDeserializerBuilder builder = new BeanDeserializerBuilder(); BeanDescription desc = new BeanDescription(); Set<String> ignorableProps = new HashSet<String>(); ignorableProps.add("prop1"); ignorableProps.add("prop2"); builder.setIgnorableProperties(ignorableProps); BeanDeserializer d = builder.build(); d.deserialize(jp, null); verify(jp, times(1)).nextToken(); verify(jp, times(1)).nextToken(); verify(jp, times(1)).nextToken(); verify(jp, times(1)).nextToken(); verify(jp, times(1)).next
@Test public void testFieldNameDeserializer() throws Exception { String jsonStr = "{\\n" + " \\"field1\\": \\"value1\\",\\n" + " \\"field2\\": \\"value2\\",\\n" + " \\"field3\\": [\\n" + " {\\n" + " \\"field1\\": \\"value1\\",\\n" + " \\"field2\\": \\"value2\\"\\n" + " },\\n" + " {\\n" + " \\"field1\\": \\"value1\\",\\n" + " \\"field2\\": \\"value2\\"\\
@Test public void test() throws IOException { String jsonStr = "{\\n" + " \\"type\\": \\"string\\",\\n" + " \\"properties\\": {\\n" + " \\"prop1\\": \\"value1\\",\\n" + " \\"prop2\\": \\"value2\\",\\n" + " \\"prop3\\": {\\n" + " \\"prop4\\": \\"value4\\",\\n" + " \\"prop5\\": \\"value5\\",\\n" + " \\"prop6\\": \\"value6\\"\\n" + " }\\n" + " }
@Test public void test() throws Exception { String jsonStr = "{\\n" + " \\"id\\" : \\"123\\",\\n" + " \\"type\\" : \\"string\\",\\n" + " \\"fields\\" : [\\n" + " {\\n" + " \\"name\\" : \\"value\\",\\n" + " \\"typeString\\" : \\"string\\"\\n" + " },\\n" + " {\\n" + " \\"name\\" : \\"value\\",\\n" + " \\"typeString\\" : \\"string\\"\\n" + " }\\n" + " ]\\n"
@Test public void testBoolean() throws IOException { String json = "{\\"value\\":true}"; JsonParser jp = new JsonParser(new StringReader(json)); BeanDeserializerBuilder builder = new BeanDeserializerBuilder(); builder.setBeanDescription(BeanDescription.getDefaultInstance()); builder.setProperties(new SimplePropertyMap()); SettableBeanProperty property = new SettableBeanProperty(); property.setName("value"); property.setType(PropertyType.BOOLEAN); property.setValue(true); builder.addProperty(property); Map<String, SettableBeanProperty> properties = new HashMap<String, SettableBeanProperty>(); properties.put("value", Sets.newHashSet(property)); BeanDeserializer bean
@Test public void testDeserializeFromObject() throws JsonProcessingException, IOException { JsonParser jp = Mockito.mock(JsonParser.class); DeserializationContext ctxt = Mockito.mock(DeserializationContext.class); Mockito.when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); Mockito.when(jp.nextToken()).thenReturn(JsonToken.END_OBJECT); SimpleBean bean = new SimpleBean(); Mockito.when(jsonParser.nextToken()).thenReturn(JsonToken.START_OBJECT); Mockito.when(jsonParser.nextToken()).thenReturn(JsonToken.END_OBJECT); Mockito.when(jsonParser.
@Test public void testDeserializeFromObject() throws JsonProcessingException, IOException { JsonParser jp = Mockito.mock(JsonParser.class); DeserializationContext ctxt = Mockito.mock(DeserializationContext.class); Mockito.when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); Mockito.when(jp.nextToken()).thenReturn(JsonToken.END_OBJECT); SimpleBean bean = new SimpleBean(); Mockito.when(jsonParser.nextToken()).thenReturn(JsonToken.START_OBJECT); Mockito.when(jsonParser.nextToken()).thenReturn(JsonToken.END_OBJECT); Mockito.when(jsonParser.
@Test(expected = JsonProcessingException.class) public void testUnknownProperty() throws JsonProcessingException, IOException { JsonParser jp = Mockito.mock(JsonParser.class); DeserializationContext ctxt = Mockito.mock(DeserializationContext.class); Mockito.when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); Mockito.when(jp.nextToken()).thenReturn(JsonToken.END_OBJECT); Mockito.when(jp.isObject()).thenReturn(false); Mockito.when(jp.isArray()).thenReturn(false); Mockito.when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY
@Test(expected = JsonProcessingException.class) public void deserializeUsingPropertyBased() throws Exception { JsonParser jp = Mockito.mock(JsonParser.class); Mockito.when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); Mockito.when(jp.getCurrentToken()).thenReturn(JsonToken.END_OBJECT); Object val = new Object(); Mockito.when(jp.readObject()).thenReturn(val); Mockito.when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); Mockito.when(jp.getCurrentToken()).thenReturn(JsonToken.END_OBJECT); Mockito.when(jp
@Test public void testDeserializeUsingPropertyBasedWithExternalTypeId() throws JsonProcessingException, IOException { String json = "{\\n" + " \\"class\\" : \\"uk.gov.gchq.gaffer.operation.data.JsonParseException\\",\\n" + " \\"value\\" : {\\n" + " \\"class\\" : \\"uk.gov.gchq.gaffer.operation.data.JsonParseException\\",\\n" + " \\"value\\" : {\\n" + " \\"class\\" : \\"uk.gov.gchq.gaffer.operation.data.JsonParseException\\",\\n" +
@Test public void testDeserializeUsingPropertyBasedWithExternalTypeId() throws JsonProcessingException, IOException { String json = "{\\n" + " \\"class\\" : \\"uk.gov.gchq.gaffer.operation.data.JsonParseException\\",\\n" + " \\"value\\" : {\\n" + " \\"class\\" : \\"uk.gov.gchq.gaffer.operation.data.JsonParseException\\",\\n" + " \\"value\\" : {\\n" + " \\"class\\" : \\"uk.gov.gchq.gaffer.operation.data.JsonParseException\\",\\n" +
@Test public void testDeserializeUsingPropertyBasedWithExternalTypeId() throws JsonProcessingException, IOException { String json = "{\\n" + " \\"class\\" : \\"uk.gov.gchq.gaffer.dynamo.types.Type1\\",\\n" + " \\"class\\" : \\"uk.gov.gchq.gaffer.dynamo.types.Type2\\",\\n" + " \\"class\\" : \\"uk.gov.gchq.gaffer.dynamo.types.Type3\\",\\n" + " \\"class\\" : \\"uk.gov.gchq.gaf
@Test public void test() throws Exception { JsonParser jp = mock(JsonParser.class); DeserializationContext ctxt = mock(DeserializationContext.class); when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); when(jp.getCurrentName()).thenReturn("name"); when(jp.getCodec()).thenReturn(JsonCodec.NULL); when(jp.nextToken()).thenReturn(JsonToken.END_OBJECT); when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); when(jp.getCurrentName()).thenReturn("age"); when(jp.getCodec()).thenReturn(JsonCodec.NULL);
@Test public void test() throws JsonProcessingException, IOException { JsonParser jp = mock(JsonParser.class); DeserializationContext ctxt = mock(DeserializationContext.class); when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); when(jp.getCurrentName()).thenReturn("name"); when(jp.getCodec()).thenReturn(JsonCodec.NULL); when(jp.nextToken()).thenReturn(JsonToken.END_OBJECT); when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); when(jp.getCurrentName()).thenReturn("age"); when(jp.getCodec()).thenReturn(JsonCodec
@Test public void test() throws JsonProcessingException, IOException { JsonParser jp = mock(JsonParser.class); DeserializationContext ctxt = mock(DeserializationContext.class); when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); when(jp.getCurrentName()).thenReturn("name"); when(jp.getCodec()).thenReturn(JsonCodec.NULL); when(jp.nextToken()).thenReturn(JsonToken.END_OBJECT); Object val = new Object(); when(ext.handlePropertyValue(jp, ctxt, "name", null)).thenReturn(true); when(ext.findCreatorProperty("name")).thenReturn(new Settable
@Test public void testDeserializeUsingPropertyBasedWithExternalTypeId() throws JsonProcessingException, IOException { String json = "{\\n" + " \\"class\\" : \\"uk.gov.gchq.gaffer.operation.data.JsonParseException\\",\\n" + " \\"value\\" : {\\n" + " \\"class\\" : \\"uk.gov.gchq.gaffer.operation.data.JsonParseException\\",\\n" + " \\"value\\" : {\\n" + " \\"class\\" : \\"uk.gov.gchq.gaffer.operation.data.JsonParseException\\",\\n" +
@Test public void testDeserializeUsingPropertyBasedWithExternalTypeId() throws JsonProcessingException, IOException { String json = "{\\n" + " \\"class\\" : \\"uk.gov.gchq.gaffer.dynamo.types.Type1\\",\\n" + " \\"class\\" : \\"uk.gov.gchq.gaffer.dynamo.types.Type2\\",\\n" + " \\"class\\" : \\"uk.gov.gchq.gaffer.dynamo.types.Type3\\",\\n" + " \\"class\\" : \\"uk.gov.gchq.gaf
@Test public void test() throws JsonProcessingException, IOException { JsonParser jp = mock(JsonParser.class); DeserializationContext ctxt = mock(DeserializationContext.class); when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); when(jp.getCurrentName()).thenReturn("name"); when(jp.getCodec()).thenReturn(JsonCodec.NULL); when(jp.nextToken()).thenReturn(JsonToken.END_OBJECT); when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); when(jp.getCurrentName()).thenReturn("age"); when(jp.getCodec()).thenReturn(JsonCodec
@Test public void testCreateContextual() throws IOException, JsonMappingException { SerializerProvider provider = Mockito.mock(SerializerProvider.class); BeanProperty property = Mockito.mock(BeanProperty.class); Type type = Mockito.mock(Type.class); Mockito.when(property.getMember()).thenReturn(type); Mockito.when(type.getAnnotationIntrospector()).thenReturn(Mockito.mock(AnnotationIntrospector.class)); Mockito.when(property.getType()).thenReturn(type); Mockito.when(provider.getAnnotationIntrospector()).thenReturn(type); Mockito.when(provider.findFormat((Annotated)
@Test public void testCreateContextual() throws IOException, JsonMappingException { SerializerProvider provider = Mockito.mock(SerializerProvider.class); BeanProperty prop = Mockito.mock(BeanProperty.class); Mockito.when(prop.getMember()).thenReturn(null); Mockito.when(prop.getType()).thenReturn(Object.class); Mockito.when(prop.getAnnotationIntrospector()).thenReturn(Mockito.mock(AnnotationIntrospector.class)); Mockito.when(provider.getAnnotationIntrospector()).thenReturn(Mockito.mock(AnnotationIntrospector.class)); Mockito.when(provider.findFormat((Annotated)
@Test public void testCreateContextual() throws IOException, JsonMappingException { SimpleSerializerProvider provider = new SimpleSerializerProvider(); EnumValues values = new EnumValues(); values.add(ExampleEnum.ONE); values.add(ExampleEnum.TWO); values.add(ExampleEnum.THREE); values.add(ExampleEnum.FOUR); serializer = new EnumSerializer(values, true); serializer.serialize(ExampleEnum.ONE, provider, null); serializer.serialize(ExampleEnum.TWO, provider, null); serializer.serialize(ExampleEnum.FOUR, provider, null); serializer.serialize(ExampleEnum.THREE, provider, null); serializer.serialize(ExampleEnum.FOUR,
@Test public void testGetSchema() throws IOException, JsonGenerationException, JsonMappingException { SerializerProvider provider = Mockito.mock(SerializerProvider.class); Mockito.when(provider.constructType(Mockito.eq(String.class))).thenReturn(PropertyType.STRING); Mockito.when(provider.constructType(Mockito.eq(Integer.class))).thenReturn(PropertyType.INTEGER); Mockito.when(provider.constructType(Mockito.eq(Long.class))).thenReturn(PropertyType.LONG); Mockito.when(provider.constructType(Mockito.eq(Float.class))).thenReturn(PropertyType.FLOAT); Mockito.when(provider.
@Test public void testGetSchema() throws IOException, JsonGenerationException, JsonMappingException { final SerializerProvider provider = new SerializerProvider() { @Override public Type getType() { return null; } @Override public SerializerProvider constructType(TypeHint typeHint) { return null; } @Override public SerializerProvider constructType(TypeHint typeHint) { return null; } @Override public SerializerProvider constructType(TypeHint typeHint) { return null; } @Override public Type getType() { return null; } @Override public SerializerProvider constructType(TypeHint typeHint) { return null; } @Override public SerializerProvider constructType(TypeHint typeHint) { return null; } @Override public Type getType() {
@Test public void testGetSchema() throws IOException, JsonGenerationException { final SerializerProvider provider = new DefaultSerializerProvider(); final ObjectNode schemaNode = new EnumSerializer().getSchema(provider, null); Assert.assertNotNull(schemaNode); Assert.assertNotNull(schemaNode.get("string")); Assert.assertNotNull(schemaNode.get("integer")); Assert.assertNotNull(schemaNode.get("string")); Assert.assertNotNull(schemaNode.get("enum")); Assert.assertNotNull(schemaNode.get("enum")); Assert.assertNotNull(schemaNode.get("enum")); Assert.assertNotNull(schemaNode.get("enum")); Assert.assertNotNull(schemaNode
@Test public void testGetSchema() throws IOException, JsonGenerationException, JsonMappingException { final SerializerProvider provider = new SerializerProvider() { @Override public Type getType() { return null; } @Override public SerializerProvider constructType(TypeHint typeHint) { return null; } @Override public Type getType() { return null; } @Override public SerializerProvider constructType(TypeHint typeHint) { return null; } @Override public SerializerProvider constructType(TypeHint typeHint) { return null; } @Override public Type getType() { return null; } @Override public SerializerProvider constructType(TypeHint typeHint) { return null; } @Override public Type getType() { return null; } @Override public
@Test public void testGetSchema() throws IOException, JsonGenerationException, JsonMappingException { SerializerProvider provider = Mockito.mock(SerializerProvider.class); Mockito.when(provider.constructType(Mockito.eq(String.class))).thenReturn(PropertyType.STRING); Mockito.when(provider.constructType(Mockito.eq(Integer.class))).thenReturn(PropertyType.INTEGER); Mockito.when(provider.constructType(Mockito.eq(Long.class))).thenReturn(PropertyType.LONG); Mockito.when(provider.constructType(Mockito.eq(Float.class))).thenReturn(PropertyType.FLOAT); Mockito.when(provider.
@Test public void testSerializeAsIndex() { final SerializerProvider provider = Mockito.mock(SerializerProvider.class); Mockito.when(provider.isEnabled(SerializationFeature.WRITE_ENUMS_USING_INDEX)).thenReturn(true); Mockito.when(provider.isEnabled(SerializationFeature.WRITE_ENUMS_USING_INDEX)).thenReturn(false); final EnumValues values = new EnumValues(); values.add(TestEnum.ONE); values.add(TestEnum.TWO); values.add(TestEnum.THREE); Mockito.when(provider.isEnabled(SerializationFeature.WRITE_ENUMS_USING_INDEX)).thenReturn(
@Test(expected = IllegalArgumentException.class) public void testUnsupportedShape() { EnumSerializer._isShapeWrittenUsingIndex(TestEnum.class, null, true); }
@Test(expected = IllegalArgumentException.class) public void testUnsupportedShape() { EnumSerializer._isShapeWrittenUsingIndex(null, null, true); }
@Test(expected = IllegalArgumentException.class) public void testUnsupportedShape() { EnumSerializer._isShapeWrittenUsingIndex(null, null, true); }
@Test(expected = IllegalArgumentException.class) public void testUnsupportedShape() { EnumSerializer._isShapeWrittenUsingIndex(null, null, true); }
@Test public void testResetTyped() { Class<?> cls = String.class; serializerCache.resetTyped(cls); assertEquals(cls, serializerCache.getType(cls)); serializerCache.resetTyped(cls); assertEquals(null, serializerCache.getType(cls)); assertEquals(cls, serializerCache.getType(cls)); serializerCache.resetTyped(cls); assertEquals(null, serializerCache.getType(cls)); assertEquals(cls, serializerCache.getType(cls)); serializerCache.resetTyped(cls); assertEquals(null, serializerCache.getType(cls)); assertEquals(cls, serializerCache.getType(cls)); }
@Test public void testResetTyped() throws Exception { SimpleSerializer s1 = new SimpleSerializer(String.class); SimpleSerializer s2 = new SimpleSerializer(String.class); SimpleSerializer s3 = new SimpleSerializer(String.class); _cache.addTypedSerializer(String.class, s1); _cache.addTypedSerializer(String.class, s2); _cache.addTypedSerializer(String.class, s3); _cache.addTypedSerializer(String.class, s4); _cache.addTypedSerializer(String.class, s5); _cache.addTypedSerializer(String.class, s6); _cache.addTypedSerializer(String.class, s7);
@Test public void testResetTyped() { SerializerCache cache=new SerializerCache(); SimpleSerializer s1=new SimpleSerializer(); SimpleSerializer s2=new SimpleSerializer(); SimpleSerializer s3=new SimpleSerializer(); cache.addTypedSerializer(String.class, s1); cache.addTypedSerializer(String.class, s2); cache.addTypedSerializer(String.class, s3); cache.addTypedSerializer(String.class, s1); cache.addTypedSerializer(String.class, s3); cache.addTypedSerializer(String.class, s1); cache.addTypedSerializer(String.class, s2); cache.addTypedSerializer(String.class, s3);
@Test public void testResetTyped() { SerializerCache cache=new SerializerCache(); SimpleSerializer s1=new SimpleSerializer("s1"); SimpleSerializer s2=new SimpleSerializer("s2"); cache.addTypedSerializer(String.class, s1); cache.addTypedSerializer(String.class, s2); cache.addTypedSerializer(String.class, s1); cache.addTypedSerializer(String.class, s2); cache.resetTyped(String.class); assertEquals("s1", cache.get(JavaType.valueOf(String.class))); assertEquals("s2", cache.get(JavaType.valueOf(String.class))); assertEquals("s1",
@Test public void testDefaultSerializerCache() { SerializerCache cache = new SerializerCache(); assertEquals(cache.size(), 0); assertEquals(cache.hashCode(), 0); cache.resetTyped(String.class); assertEquals(cache.size(), 0); assertEquals(cache.hashCode(), 0); cache.addTypedSerializer(String.class, new StringSerializer()); assertEquals(cache.size(), 1); assertEquals(cache.hashCode(), 1); cache.addTypedSerializer(String.class, new StringSerializer()); assertEquals(cache.size(), 2); assertEquals(cache.hashCode(), 2); cache.resetUntyped(String.class); assertEquals(cache.size
@Test public void testResetTyped() { SimpleSerializer s1 = new SimpleSerializer(String.class); SimpleSerializer s2 = new SimpleSerializer(String.class); SimpleSerializer s3 = new SimpleSerializer(String.class); s1.addTypedSerializer(String.class, s1); s2.addTypedSerializer(String.class, s1); s2.addTypedSerializer(String.class, s2); s3.addTypedSerializer(String.class, s2); s3.addTypedSerializer(String.class, s3); s1.resetTyped(String.class); s2.resetTyped(String.class); s3.resetTyped(String.class);
@Test public void testResetTyped() { SimpleSerializer s1 = new SimpleSerializer(String.class); SimpleSerializer s2 = new SimpleSerializer(String.class); SimpleSerializer s3 = new SimpleSerializer(String.class); SimpleSerializer s4 = new SimpleSerializer(String.class); s1.addTypedSerializer(String.class, s1); s2.addTypedSerializer(String.class, s2); s2.addTypedSerializer(String.class, s3); s3.addTypedSerializer(String.class, s4); s4.addTypedSerializer(String.class, s1); s4.addTypedSerializer(String.class, s2); s4.
@Test public void testResetTyped() { SimpleSerializer s1 = new SimpleSerializer(String.class); SimpleSerializer s2 = new SimpleSerializer(String.class); SimpleSerializer s3 = new SimpleSerializer(String.class); s1.addTypedSerializer(String.class, s1); s2.addTypedSerializer(String.class, s1); s2.addTypedSerializer(String.class, s2); s3.addTypedSerializer(String.class, s2); s3.addTypedSerializer(String.class, s3); s1.resetTyped(String.class); s2.resetTyped(String.class); s3.resetTyped(String.class);
@Test public void testResetTyped() { SimpleSerializer s1 = new SimpleSerializer(String.class); SimpleSerializer s2 = new SimpleSerializer(String.class); SimpleSerializer s3 = new SimpleSerializer(String.class); SimpleSerializer s4 = new SimpleSerializer(String.class); s1.addTypedSerializer(String.class, s1); s2.addTypedSerializer(String.class, s2); s2.addTypedSerializer(String.class, s3); s3.addTypedSerializer(String.class, s4); s4.addTypedSerializer(String.class, s1); s4.addTypedSerializer(String.class, s2); s4.
@Test public void testDefaultSerializerCache() { SerializerCache cache = new SerializerCache(); assertEquals(cache.size(), 0); Class<?> type = String.class; cache.resetTyped(type); assertEquals(cache.size(), 1); assertEquals(cache.hashCode(), 0); cache.addTypedSerializer(type, new JsonSerializer<Object>() { @Override public JsonSerializer<Object> createNamedSerializer(Class<?> type, boolean typed) throws JsonMappingException { return new JsonSerializer<Object>() { @Override public JsonSerializer<Object> createNamedSerializer(Class<?> type, boolean typed) throws JsonMappingException { return new JsonSerializer<Object>() { @Override public void
@Test public void testRenameAll() { BeanPropertyMap map = new BeanPropertyMap(); List<SettableBeanProperty> properties = new ArrayList<SettableBeanProperty>(); for (int i = 0; i < 5; i++) { properties.add(set("a" + i, "b" + i)); } for (int i = 0; i < 5; i++) { SettableBeanProperty a = map.find("a" + i); SettableBeanProperty b = map.find("b" + i); SettableBeanProperty c = map.find("c" + i); SettableBeanProperty d = map.find("d"); SettableBeanProperty e = map.
@Test public void testRenameAll() { SettableBeanProperty p1 = new SettableBeanProperty("p1", "value1"); SettableBeanProperty p2 = new SettableBeanProperty("p2", "value2"); SettableBeanProperty p3 = new SettableBeanProperty("p3", "value3"); SettableBeanProperty p4 = new SettableBeanProperty("p4", "value4"); SettableBeanProperty p5 = new SettableBeanProperty("p5", "value5"); SettableBeanProperty p6 = new SettableBeanProperty("p6", "value6"); SettableBeanProperty p7 = new SettableBeanProperty("p7", "value7
@Test public void testRenameAll() { BeanPropertyMap map = new BeanPropertyMap().withProperty(prop("a")).withProperty(prop("b")).withProperty(prop("c")); SettableBeanProperty a = map.find("a"); SettableBeanProperty b = map.find("b"); SettableBeanProperty c = map.find("c"); SettableBeanProperty d = map.find("d"); SettableBeanProperty e = map.find("e"); SettableBeanProperty f = map.find("f"); SettableBeanProperty g = map.find("g"); SettableBeanProperty h = map.find("h"); SettableBeanProperty i = map.find
@Test public void testRenameAll() { BeanPropertyMap map = new BeanPropertyMap(); SettableBeanProperty p1 = new SettableBeanProperty("p1", "value1"); SettableBeanProperty p2 = new SettableBeanProperty("p2", "value2"); SettableBeanProperty p3 = new SettableBeanProperty("p3", "value3"); SettableBeanProperty p4 = new SettableBeanProperty("p4", "value4"); SettableBeanProperty p5 = new SettableBeanProperty("p5", "value5"); SettableBeanProperty p6 = new SettableBeanProperty("p6", "value6"); SettableBeanProperty p7 = new Set
@Test public void testRenameAll() { SettableBeanProperty a = new SettableBeanProperty("a", "a"); SettableBeanProperty b = new SettableBeanProperty("b", "b"); SettableBeanProperty c = new SettableBeanProperty("c", "c"); SettableBeanProperty d = new SettableBeanProperty("d", "d"); SettableBeanProperty e = new SettableBeanProperty("e", "e"); SettableBeanProperty f = new SettableBeanProperty("f", "f"); SettableBeanProperty g = new SettableBeanProperty("g", "g"); SettableBeanProperty h = new SettableBeanProperty("h", "h"); SettableBean
@Test public void testRenameAll() { SettableBeanProperty a = new SettableBeanProperty("a", "a"); SettableBeanProperty b = new SettableBeanProperty("b", "b"); SettableBeanProperty c = new SettableBeanProperty("c", "c"); SettableBeanProperty d = new SettableBeanProperty("d", "d"); SettableBeanProperty e = new SettableBeanProperty("e", "e"); SettableBeanProperty f = new SettableBeanProperty("f", "f"); SettableBeanProperty g = new SettableBeanProperty("g", "g"); SettableBeanProperty h = new SettableBeanProperty("h", "h"); SettableBean
@Test public void testRenameAll() { SettableBeanProperty a = new SettableBeanProperty("a", "a"); SettableBeanProperty b = new SettableBeanProperty("b", "b"); SettableBeanProperty c = new SettableBeanProperty("c", "c"); SettableBeanProperty d = new SettableBeanProperty("d", "d"); SettableBeanProperty e = new SettableBeanProperty("e", "e"); SettableBeanProperty f = new SettableBeanProperty("f", "f"); SettableBeanProperty g = new SettableBeanProperty("g", "g"); SettableBeanProperty h = new SettableBeanProperty("h", "h"); SettableBean
@Test public void testRenameAll() { BeanPropertyMap map = new BeanPropertyMap().withProperty(prop("a")).withProperty(prop("b")).withProperty(prop("c")); SettableBeanProperty a = map.find("a"); SettableBeanProperty b = map.find("b"); SettableBeanProperty c = map.find("c"); SettableBeanProperty d = map.find("d"); SettableBeanProperty e = map.find("e"); SettableBeanProperty f = map.find("f"); SettableBeanProperty g = map.find("g"); SettableBeanProperty h = map.find("h"); SettableBeanProperty i = map.find
@Test public void testRenameAll() { SettableBeanProperty p1 = new SettableBeanProperty("p1", "value1"); SettableBeanProperty p2 = new SettableBeanProperty("p2", "value2"); SettableBeanProperty p3 = new SettableBeanProperty("p3", "value3"); SettableBeanProperty p4 = new SettableBeanProperty("p4", "value4"); SettableBeanProperty p5 = new SettableBeanProperty("p5", "value5"); SettableBeanProperty p6 = new SettableBeanProperty("p6", "value6"); SettableBeanProperty p7 = new SettableBeanProperty("p7", "value7
@Test public void testRenameAll() { BeanPropertyMap map = new BeanPropertyMap(); List<SettableBeanProperty> properties = new ArrayList<SettableBeanProperty>(); for (int i = 0; i < 5; i++) { properties.add(set("a" + i, "b" + i)); } SettableBeanProperty a = map.find("a"); SettableBeanProperty b = map.find("b"); SettableBeanProperty c = map.find("c"); SettableBeanProperty d = map.find("d"); SettableBeanProperty e = map.find("e"); SettableBeanProperty f = map.find("f"); SettableBeanProperty g = map
@Test public void testRenameAll() { SettableBeanProperty p1 = new SettableBeanProperty("p1", "value1"); SettableBeanProperty p2 = new SettableBeanProperty("p2", "value2"); SettableBeanProperty p3 = new SettableBeanProperty("p3", "value3"); SettableBeanProperty p4 = new SettableBeanProperty("p4", "value4"); SettableBeanProperty p5 = new SettableBeanProperty("p5", "value5"); SettableBeanProperty p6 = new SettableBeanProperty("p6", "value6"); SettableBeanProperty p7 = new SettableBeanProperty("p7", "value7
@Test public void testRenameAll() { BeanPropertyMap map = new BeanPropertyMap().withProperty(prop("a")).renameAll(new NameTransformer() { @Override public String transform(String name) { return "b"; } @Override public String transform(String name) { return "c"; } }); SettableBeanProperty a = map.find("a"); SettableBeanProperty b = map.find("b"); SettableBeanProperty c = map.find("c"); SettableBeanProperty d = map.find("d"); SettableBeanProperty e = map.find("e"); SettableBeanProperty f = map.find("f"); SettableBeanProperty g = map.find("
@Test public void testRemove() { SettableBeanProperty a = new SettableBeanProperty("a", "a"); SettableBeanProperty b = new SettableBeanProperty("b", "b"); SettableBeanProperty c = new SettableBeanProperty("c", "c"); SettableBeanProperty d = new SettableBeanProperty("d", "d"); SettableBeanProperty e = new SettableBeanProperty("e", "e"); SettableBeanProperty f = new SettableBeanProperty("f", "f"); SettableBeanProperty g = new SettableBeanProperty("g", "g"); SettableBeanProperty h = new SettableBeanProperty("h", "h"); SettableBeanProperty
@Test public void testValueType() throws Exception { assertEquals(IntDeser.instance, PrimitiveArrayDeserializers.forType(Integer.class)); assertEquals(IntDeser.class, PrimitiveArrayDeserializers.forType(Integer.class).getClass()); assertEquals(LongDeser.class, PrimitiveArrayDeserializers.forType(Long.class).getClass()); assertEquals(ShortDeser.class, PrimitiveArrayDeserializers.forType(Short.class).getClass()); assertEquals(FloatDeser.class, PrimitiveArrayDeserializers.forType(Float.class).getClass()); assertEquals(FloatDeser.class, PrimitiveArrayDeserializers.forType(Float.class).getClass()); assertEquals(
@Test void testDeserializeWithType() throws Exception { assertEquals(1, new SimpleTypeDeserializer().deserializeWithType(jp, null, new SimpleTypeDeserializer()).length); assertEquals(1, new SimpleTypeDeserializer().deserializeWithType(jp, null, new SimpleTypeDeserializer()).length); assertEquals(2, new SimpleTypeDeserializer().deserializeWithType(jp, null, new SimpleTypeDeserializer()).length); assertEquals(3, new SimpleTypeDeserializer().deserializeWithType(jp, null, new SimpleTypeDeserializer()).length); assertEquals(4, new SimpleTypeDeserializer().deserializeWithType(jp, null, new SimpleTypeDeserializer()).length); assertEquals(5, new Simple
@Test public void testFloats() throws IOException { float[] floats = new float[]{1.0f, 2.0f, 3.0f}; assertArrayEquals(floats, deserializer.deserialize(jp, null)); verify(typeDeserializer, times(1)).deserializeTypedFromArray(jp, null); verify(typeDeserializer, times(1)).deserializeTypedFromArray(jp, null); float[] floats2 = new float[]{1.0f, 2.0f, 3.0f}; assertArrayEquals(floats2, deserializer.deserialize(jp, null)); verify(typeDeserializer, times(1)).deserializeTypedFromArray(jp, null); float[] floats
@Test public void testIntDeser() throws IOException { assertEquals(1, new IntDeser().deserialize(jp, new DeserializationContext()).length); assertEquals(1, new IntDeser().deserialize(jp, new DeserializationContext()).length); assertEquals(2, new IntDeser().deserialize(jp, new DeserializationContext()).length); assertEquals(3, new IntDeser().deserialize(jp, new DeserializationContext()).length); assertEquals(4, new IntDeser().deserialize(jp, new DeserializationContext()).length); assertEquals(5, new IntDeser().deserialize(jp, new DeserializationContext()).length); }
@Test public void testFloat() throws IOException { Float[] expected = new Float[]{1f, 2f, 3f}; assertArrayEquals(expected, new Float[]{1f, 2f, 3f}, 0); assertArrayEquals(expected, new Float[]{1f, 2f, 3f}, 0); assertArrayEquals(expected, new Float[]{1f, 2f, 3f}, 0); assertArrayEquals(expected, new Float[]{1f, 2f, 3f}, 0); assertArrayEquals(expected, new Float[]{1f, 2f, 3f}, 0); assertArrayEquals(expected, new Float[]{1f, 2f,
@Test public void testIntArray() throws Exception { Integer[] values = new Integer[]{1, 2, 3}; when(jp.nextToken()).thenReturn(JsonToken.START_ARRAY_TOKEN); when(jp.isExpectedStartArrayToken()).thenReturn(true); when(jp.isExpectedEndArrayToken()).thenReturn(false); values.deserialize(jp, ctxt); verify(jp, times(1)).nextToken(); verify(jp, times(1)).isExpectedStartArrayToken(); verify(jp, times(1)).isExpectedEndArrayToken(); verify(jp, times(1)).nextToken(); verify(jp, times(1)).
@Test public void testFloat() throws IOException { Float[] expected = new Float[]{1f, 2f, 3f}; assertArrayEquals(expected, new Float[]{1f, 2f, 3f}, 0); assertArrayEquals(expected, new Float[]{1f, 2f, 3f}, 0); assertArrayEquals(expected, new Float[]{1f, 2f, 3f}, 0); assertArrayEquals(expected, new Float[]{1f, 2f, 3f}, 0); assertArrayEquals(expected, new Float[]{1f, 2f, 3f}, 0); assertArrayEquals(expected, new Float[]{1f, 2f,
@Test public void testFloat() throws IOException { Float[] expected = new Float[]{1f, 2f, 3f, 4f}; assertArrayEquals(expected, new Float[]{1f, 2f, 3f, 4f}, 0); assertArrayEquals(expected, new Float[]{1f, 2f, 3f, 4f}, 0); assertArrayEquals(expected, new Float[]{1f, 2f, 3f, 4f}, 0); assertArrayEquals(expected, new Float[]{1f, 2f, 3f, 4f}, 0); assertArrayEquals(expected, new Float[]{1f, 2f, 3f, 4f},
@Test public void testFloat() throws IOException, JsonProcessingException { Float[] values = new Float[]{1f, 2f, 3f}; assertArrayEquals(values, new Float[]{1f, 2f, 3f}); assertArrayEquals(new Float[]{1f, 2f, 3f}, new Float[]{1f, 2f, 3f}); assertArrayEquals(new Float[]{1f, 2f, 3f}, new Float[]{1f, 2f, 3f}); assertArrayEquals(new Float[]{1f, 2f, 3f}, new Float[]{1f, 2f, 3f}); assertArrayEquals(new Float[]{1
@Test public void testIntDeserialization() throws Exception { Integer[] values = new Integer[]{1, 2, 3, 4}; assertArrayEquals(values, new Integer[]{1, 2, 3, 4}); assertArrayEquals(new Integer[]{1, 2, 3, 4}, new Integer[]{1, 2, 3, 4}); assertArrayEquals(new Integer[]{1, 2, 3, 4}, new Integer[]{1, 2, 3, 4}); assertArrayEquals(new Integer[]{1, 2, 3, 4}, new Integer[]{1, 2, 3, 4}); assertArrayEquals(new Integer[]{1, 2, 3, 4}, new Integer
@Test public void testIntDeserialization() throws IOException, JsonProcessingException { Integer[] values = new Integer[]{1, 2, 3, 4}; when(jp.nextToken()).thenReturn(JsonToken.START_ARRAY); when(jp.isExpectedStartArrayToken()).thenReturn(true); when(jp.getValue()).thenReturn(values[0]); when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); assertArrayEquals(values, new Integer[] {1, 2, 3, 4}); assertArrayEquals(values, new Integer[] {1, 2, 3, 4}); when(jp.nextToken()).thenReturn(JsonToken.END
@Test public void testFloat() throws IOException { Float[] expected = new Float[]{1f, 2f, 3f}; assertArrayEquals(expected, new Float[]{1f, 2f, 3f}, 0); assertArrayEquals(expected, new Float[]{1f, 2f, 3f}, 0); assertArrayEquals(expected, new Float[]{1f, 2f, 3f}, 0); assertArrayEquals(expected, new Float[]{1f, 2f, 3f}, 0); assertArrayEquals(expected, new Float[]{1f, 2f, 3f}, 0); assertArrayEquals(expected, new Float[]{1f, 2f,
@Test public void testFloat() throws IOException { Float[] expected = new Float[]{1f, 2f, 3f}; assertArrayEquals(expected, new Float[]{1f, 2f, 3f}, 0); assertArrayEquals(expected, new Float[]{1f, 2f, 3f}, 0); assertArrayEquals(expected, new Float[]{1f, 2f, 3f}, 0); assertArrayEquals(expected, new Float[]{1f, 2f, 3f}, 0); assertArrayEquals(expected, new Float[]{1f, 2f, 3f}, 0); assertArrayEquals(expected, new Float[]{1f, 2f,
@Test public void test() throws IOException, JsonProcessingException { List<Integer> values = new ArrayList<Integer>(); values.add(1); values.add(2); values.add(3); values.add(4); values.add(5); values.add(6); values.add(7); assertEquals(3, values.size()); assertEquals(1, values.get(0).intValue()); assertEquals(2, values.get(1).intValue()); assertEquals(3, values.get(2).intValue()); assertEquals(4, values.get(3).intValue()); assertEquals(5, values.get(4).intValue()); assertEquals(
@Test public void testFloat() throws IOException { Float[] expected = new Float[]{1f, 2f, 3f}; assertArrayEquals(expected, new Float[]{1f, 2f, 3f}, 0); assertArrayEquals(expected, new Float[]{1f, 2f, 3f}, 0); assertArrayEquals(expected, new Float[]{1f, 2f, 3f}, 0); assertArrayEquals(expected, new Float[]{1f, 2f, 3f}, 0); assertArrayEquals(expected, new Float[]{1f, 2f, 3f}, 0); assertArrayEquals(expected, new Float[]{1f, 2f,
@Test public void testFloat() throws IOException { Float[] values = new Float[]{1f, 2f, 3f, 4f}; assertArrayEquals(values, new Float[]{1f, 2f, 3f, 4f, 5f}); assertArrayEquals(new Float[]{1f, 2f, 3f, 4f, 5f}, new Float[]{1f, 2f, 3f, 4f, 5f}, new Float[]{1f, 2f, 3f, 4f, 5f}); assertArrayEquals(new Float[]{1f, 2f, 3f, 4f, 5f}, new Float[]{1f, 2f
@Test public void testPropertyValueBuffer() { String s = "{\\n" + " \\"id\\": \\"1\\",\\n" + " \\"properties\\": [\\n" + " {\\n" + " \\"prop1\\": \\"value1\\",\\n" + " \\"prop2\\": \\"value2\\",\\n" + " \\"prop3\\": \\"value3\\"\\n" + " },\\n" + " {\\n" + " \\"prop1\\": \\"value1\\",\\n" + " \\"prop2\\": \\"value2\\",\\n" + " \\"
@Test public void testPropertyValueBuffer() { ObjectIdReader oir = mock(ObjectIdReader.class); JsonParser jp = mock(JsonParser.class); SimpleDeserializationContext ctxt = mock(SimpleDeserializationContext.class); SimpleDeserializationContext context = mock(SimpleDeserializationContext.class); PropertyValueBuffer pvb = new PropertyValueBuffer(jp, ctxt, 1, oir); pvb.buffered(); assertEquals(jp, pvb._parser); assertSame(jp, pvb._context); assertEquals(1, pvb._paramsNeeded); assertSame(oir, pvb._objectIdReader); assertSame(context, pvb._context); assertEquals(1, pvb
@Test public void testPropertyValueBuffer() { ObjectIdReader oir = mock(ObjectIdReader.class); JsonParser jp = mock(JsonParser.class); DeserializationContext ctxt = mock(DeserializationContext.class); PropertyValueBuffer pvb = new PropertyValueBuffer(jp, ctxt, 1, oir); assertSame(vpb.jsonParser(), jp); assertSame(vpb.context(), ctxt); pvb.buffered(); assertSame(vpb.jsonParser(), jp); assertSame(vpb.context(), ctxt); pvb.buffered(); assertSame(vpb.objectIdReader(), oir); pvb.buffered(); assertSame(vpb.objectIdReader(), oir
@Test public void testPropertyValueBuffer() { ObjectIdReader oir = Mockito.mock(ObjectIdReader.class); JsonParser jp = Mockito.mock(JsonParser.class); SimpleDeserializationContext ctxt = Mockito.mock(SimpleDeserializationContext.class); Mockito.doReturn(jp).when(ctxt).getParser(); Mockito.doReturn(ctxt).when(jsonParser).getContext(); Mockito.doReturn(1).when(jsonParser).readValue("1"); Mockito.doReturn(2).when(jsonParser).readValue("2"); Mockito.doReturn(3).when(jsonParser).readValue("4"); new PropertyValueBuffer(jp, ctxt
@Test public void testPropertyValueBuffer() { ObjectIdReader oir = Mockito.mock(ObjectIdReader.class); JsonParser jp = Mockito.mock(JsonParser.class); SimpleDeserializationContext ctxt = Mockito.mock(SimpleDeserializationContext.class); Mockito.doReturn(jp).when(ctxt).getParser(); Mockito.doReturn(ctxt).when(jsonParser).getContext(); Mockito.doReturn(1).when(oir).readObjectId("1"); Mockito.doReturn(2).when(oir).readObjectId("2"); Mockito.doReturn(3).when(oir).readObjectId("3"); PropertyValueBuffer pvb = new Property
@Test public void testPropertyValueBuffer() { ObjectIdReader oir = Mockito.mock(ObjectIdReader.class); JsonParser jp = Mockito.mock(JsonParser.class); SimpleDeserializationContext ctxt = Mockito.mock(SimpleDeserializationContext.class); SimpleDeserializationContext ctxt2 = Mockito.mock(SimpleDeserializationContext.class); SimpleDeserializationContext ctxt3 = Mockito.mock(SimpleDeserializationContext.class); SimpleDeserializationContext ctxt4 = Mockito.mock(SimpleDeserializationContext.class); SimpleDeserializationContext ctxt5 = Mockito.mock(SimpleDeserializationContext.class); SimpleDeserializationContext ctxt6 = Mockito.mock(SimpleDeserializationContext
@Test public void testGetParameters() { Object[] params = classUnderTest.getParameters(null); assertNotNull(params); assertEquals(0, params.length); params = classUnderTest.getParameters(new Object[0]); assertNotNull(params); assertEquals(0, params.length); params = classUnderTest.getParameters(new Object[0]); assertNotNull(params); assertEquals(0, params.length); }
@Test public void testGetParameters() { SimpleDeserializationContext ctxt = new SimpleDeserializationContext(); SimpleDeserializationContext context2 = new SimpleDeserializationContext(); SimpleDeserializationContext context3 = new SimpleDeserializationContext(); SimpleDeserializationContext context4 = new SimpleDeserializationContext(); SimpleDeserializationContext context5 = new SimpleDeserializationContext(); SimpleDeserializationContext context6 = new SimpleDeserializationContext(); SimpleDeserializationContext context7 = new SimpleDeserializationContext(); SimpleDeserializationContext context8 = new SimpleDeserializationContext(); SimpleDeserializationContext context9 = new SimpleDeserializationContext(); SimpleDeserializationContext contextA = new SimpleDeserializationContext(); SimpleDeserializationContext contextB = new SimpleDeserial
@Test public void testGetParameters() { SimpleDeserializationContext ctxt = new SimpleDeserializationContext(); SimpleDeserializationContextBuilder builder = new SimpleDeserializationContextBuilder(); SimpleDeserializationContext ctxt2 = builder.build(); SimpleDeserializationContext ctxt3 = builder.build(); SimpleDeserializationContext ctxt4 = builder.build(); SimpleDeserializationContext ctxt5 = builder.build(); SimpleDeserializationContext ctxt6 = builder.build(); SimpleDeserializationContext ctxt7 = builder.build(); SimpleDeserializationContext ctxt8 = builder.build(); SimpleDeserializationContext ctxt9 = builder.build(); SimpleDeserializationContext ctxt10 = builder.build(); SimpleDeserializationContext ctxt11 = builder.build(); SimpleDeserialization
@Test public void testGetParameters() { SimpleDeserializationContext ctxt = new SimpleDeserializationContext(); SimpleDeserializationContext context2 = new SimpleDeserializationContext(); SimpleDeserializationContext context3 = new SimpleDeserializationContext(); SimpleDeserializationContext context4 = new SimpleDeserializationContext(); SimpleDeserializationContext context5 = new SimpleDeserializationContext(); SimpleDeserializationContext context6 = new SimpleDeserializationContext(); SimpleDeserializationContext context7 = new SimpleDeserializationContext(); SimpleDeserializationContext context8 = new SimpleDeserializationContext(); SimpleDeserializationContext context9 = new SimpleDeserializationContext(); SimpleDeserializationContext contextA = new SimpleDeserializationContext(); SimpleDeserializationContext contextB = new SimpleDeserial
@Test public void testGetParameters() { SimpleDeserializationContext ctxt = new SimpleDeserializationContext(); SimpleDeserializationContext ctxt2 = new SimpleDeserializationContext(); SimpleDeserializationContext ctxt3 = new SimpleDeserializationContext(); SimpleDeserializationContext ctxt4 = new SimpleDeserializationContext(); SimpleDeserializationContext ctxt5 = new SimpleDeserializationContext(); SimpleDeserializationContext ctxt6 = new SimpleDeserializationContext(); SimpleDeserializationContext ctxt7 = new SimpleDeserializationContext(); SimpleDeserializationContext ctxt8 = new SimpleDeserializationContext(); SimpleDeserializationContext ctxt9 = new SimpleDeserializationContext(); SimpleDeserializationContext ctxt10 = new SimpleDeserializationContext(); SimpleDeserializationContext ctxt11 = new SimpleDeserial
@Test public void testReadIdProperty() throws IOException { ObjectIdReader oir = new ObjectIdReader() { @Override public Object deserialize(JsonParser jp, DeserializationContext ctxt, DeserializationContext ctxt) { return null; } @Override public void readIdProperty(String propName, Object value) { } @Override public void readIdProperty(String propName, Object value) { } @Override public void readIdProperty(String propName, Object value) { } @Override public void readIdProperty(String propName, Object value) { } @Override public void readIdProperty(String propName, Object value) { } @Override public void readIdProperty(String propName, Object value) { } @Override public
@Test public void testReadIdProperty() throws IOException { ObjectIdReader mockReader = createMock(ObjectIdReader.class); expect(mockReader.getPropertyName()).andReturn("id"); expect(mockReader.deserializer.deserialize(anyObject(JsonParser.class), anyObject(DeserializationContext.class))).andReturn(null); expect(mockReader.deserializer.deserialize(anyObject(JsonParser.class), anyObject(DeserializationContext.class))).andReturn(null); replay(mockReader); ObjectIdReader mockReader2 = createMock(ObjectIdReader.class); expect(mockReader2.getPropertyName()).andReturn("id"); expect(mockReader2.deserializer.
@Test public void testHandleIdValue() throws IOException { SimpleDeserializationContext ctxt = createMock(SimpleDeserializationContext.class); SimpleDeserializationContext ctxt2 = createMock(SimpleDeserializationContext.class); SimpleDeserializationContext ctxt3 = createMock(SimpleDeserializationContext.class); SimpleDeserializationContext ctxt4 = createMock(SimpleDeserializationContext.class); SimpleDeserializationContext ctxt5 = createMock(SimpleDeserializationContext.class); SimpleDeserializationContext ctxt6 = createMock(SimpleDeserializationContext.class); SimpleDeserializationContext ctxt7 = createMock(SimpleDeserializationContext.class); SimpleDeserializationContext ctxt8 = createMock(SimpleDeserializationContext.class); Simple
@Test public void testHandleIdValue() throws IOException { final SimpleDeserializationContext ctxt = createMock(SimpleDeserializationContext.class); final SimpleDeserializationContext ctxt2 = createMock(SimpleDeserializationContext.class); final SimpleDeserializationContext ctxt3 = createMock(SimpleDeserializationContext.class); final SimpleDeserializationContext ctxt4 = createMock(SimpleDeserializationContext.class); final SimpleDeserializationContext ctxt5 = createMock(SimpleDeserializationContext.class); final SimpleDeserializationContext ctxt6 = createMock(SimpleDeserializationContext.class); final SimpleDeserializationContext ctxt7 = createMock(SimpleDeserializationContext.class); final SimpleDeserializationContext ctxt8 = createMock(
@Test public void testHandleIdValue() throws IOException { final SimpleDeserializationContext ctxt = createMock(SimpleDeserializationContext.class); final SimpleDeserializationContext ctxt2 = createMock(SimpleDeserializationContext.class); final SimpleDeserializationContext ctxt3 = createMock(SimpleDeserializationContext.class); final SimpleDeserializationContext ctxt4 = createMock(SimpleDeserializationContext.class); final SimpleDeserializationContext ctxt5 = createMock(SimpleDeserializationContext.class); final SimpleDeserializationContext ctxt6 = createMock(SimpleDeserializationContext.class); final SimpleDeserializationContext ctxt7 = createMock(SimpleDeserializationContext.class); final SimpleDeserializationContext ctxt8 = createMock(
@Test public void testHandleIdValue() throws IOException { final SimpleDeserializationContext ctxt = createMock(SimpleDeserializationContext.class); final IdentifierReader idReader = createMock(IdentifierReader.class); final IdentifierReader idReader1 = createMock(IdentifierReader.class); final IdentifierReader idReader2 = createMock(IdentifierReader.class); final IdentifierReader idReader3 = createMock(IdentifierReader.class); final SimpleDeserializationContext ctxt = createMock(SimpleDeserializationContext.class); final SimpleDeserializationContext ctxt1 = createMock(SimpleDeserializationContext.class); final SimpleDeserializationContext ctxt2 = createMock(SimpleDeserializationContext.class); final SimpleDeserializationContext ctxt3
@Test public void testHandleIdValue() throws IOException { final SimpleDeserializationContext ctxt = createMock(SimpleDeserializationContext.class); final SimpleDeserializationContext ctxt2 = createMock(SimpleDeserializationContext.class); final SimpleDeserializationContext ctxt3 = createMock(SimpleDeserializationContext.class); final SimpleDeserializationContext ctxt4 = createMock(SimpleDeserializationContext.class); final SimpleDeserializationContext ctxt5 = createMock(SimpleDeserializationContext.class); final SimpleDeserializationContext ctxt6 = createMock(SimpleDeserializationContext.class); final SimpleDeserializationContext ctxt7 = createMock(SimpleDeserializationContext.class); final SimpleDeserializationContext ctxt8 = createMock(
@Test public void testHandleIdValue() throws IOException { SimpleDeserializationContext ctxt = createMock(SimpleDeserializationContext.class); ObjectIdReader idReader = createMock(ObjectIdReader.class); SettableBeanProperty property = createMock(SettableBeanProperty.class); expect(idReader.idProperty()).andReturn(property); expect(ctxt.findObjectId(property, idReader.generator)).andReturn(null); expect(idReader.idProperty()).andReturn(property); expect(ctxt.findObjectId(property, idReader.generator)).andReturn(objectId); expect(objectIdReader.idProperty()).andReturn(property); expect(objectIdReader.generator
@Test public void testHandleIdValue() throws IOException { final SimpleDeserializationContext ctxt = createMock(SimpleDeserializationContext.class); final SimpleDeserializationContext ctxt2 = createMock(SimpleDeserializationContext.class); final SimpleDeserializationContext ctxt3 = createMock(SimpleDeserializationContext.class); final SimpleDeserializationContext ctxt4 = createMock(SimpleDeserializationContext.class); final SimpleDeserializationContext ctxt5 = createMock(SimpleDeserializationContext.class); final SimpleDeserializationContext ctxt6 = createMock(SimpleDeserializationContext.class); final SimpleDeserializationContext ctxt7 = createMock(SimpleDeserializationContext.class); final SimpleDeserializationContext ctxt8 = createMock(
@Test public void testHandleIdValue() throws IOException { SimpleDeserializationContext ctxt = createMock(SimpleDeserializationContext.class); ObjectIdReader oir = createMock(ObjectIdReader.class); SimpleDeserializationContext ctxt2 = createMock(SimpleDeserializationContext.class); SimpleDeserializationContext ctxt3 = createMock(SimpleDeserializationContext.class); SimpleDeserializationContext ctxt4 = createMock(SimpleDeserializationContext.class); SimpleDeserializationContext ctxt5 = createMock(SimpleDeserializationContext.class); SimpleDeserializationContext ctxt6 = createMock(SimpleDeserializationContext.class); SimpleDeserializationContext ctxt7 = createMock(SimpleDeserializationContext.class); SimpleDeserializationContext ctxt
@Test public void testbuffered() { PropertyValueBuffer pvb = new PropertyValueBuffer(null, null, 0, new ObjectIdReader() { @Override public int readIdProperty(String propName) throws IOException { return 0; } @Override public void readIdProperty(String propName, Object value) throws IOException { } @Override public void readIdProperty(String propName, Object value) throws IOException { } @Override public void readIdProperty(String propName, Object value) throws IOException { } @Override public void readIdProperty(String propName, Object value) throws IOException { } @Override public void readIdProperty(String propName, Object value) throws IOException { } @Override public void readIdProperty(String propName
@Test public void testAssignParameter() { Map<String, Object> map = new HashMap<String, Object>(); map.put("a", "a"); map.put("b", "b"); map.put("c", "c"); map.put("d", "d"); map.put("e", "e"); map.put("f", "f"); map.put("g", "g"); map.put("h", "h"); map.put("i", "i"); map.put("j", "j"); map.put("k", "k"); map.put("l", "l"); map.put("m", "m"); map.put("n",
@Test public void testAssignParameter() { Map<String, Object> map = new HashMap<String, Object>(); map.put("a", "a"); map.put("b", "b"); map.put("c", "c"); map.put("d", "d"); map.put("e", "e"); map.put("f", "f"); map.put("g", "g"); map.put("h", "h"); map.put("i", "i"); Map<String, Object> params = new HashMap<String, Object>(); params.put("a", "a"); params.put("b", "b"); params.put("c", "c
@Test public void testAssignParameter() { for (int i = 0; i < 20; i++) { assertTrue(cut.isComplete()); assertTrue(cut.buffered().isComplete()); cut.assignParameter(0, "foo"); assertFalse(cut.isComplete()); assertTrue(cut.buffered().isComplete()); assertEquals("foo", cut._creatorParameters[0]); assertEquals("foo", cut._creatorParameters[1]); cut.assignParameter(1, "bar"); assertTrue(cut.isComplete()); assertEquals("bar", cut._creatorParameters[1]); assertEquals("foo", cut._creatorParameters[2]); assertEquals("bar", cut._creatorParameters[3]); }
@Test public void testBufferMapProperty() { Map<String, Object> map = new HashMap<String, Object>(); map.put("a", 1); map.put("b", 2); map.put("c", 3); Map<String, Object> expected = new HashMap<String, Object>(); expected.put("a", 1); expected.put("b", 2); expected.put("c", 3); try { instance.bufferMapProperty("a", map); fail(); } catch (UnsupportedOperationException e) { } try { instance.bufferMapProperty("b", map); fail(); } catch (UnsupportedOperationException e) { } }
@Test public void testBufferMapProperty() throws IOException { Map<String, Long> map = new HashMap<>(); map.put("a", 1L); map.put("b", 2L); map.put("c", 3L); PropertyValueBuffer pvb = new PropertyValueBuffer(jp, null, 0, new ObjectIdReader() { @Override public int readIdProperty(String propName) throws IOException { return 0; } @Override public void readIdProperty(String propName, Long propValue) throws IOException { } @Override public void readIdProperty(String propName, Long propValue) throws IOException { } @Override public void readIdProperty(String propName, Long propValue) throws IOException { } @Override public
@Test public void testListSerializer() throws IOException, JsonGenerationException { List<String> value = Arrays.asList("a", "b", "c"); serializer.serializeContentsUsing(value, jgen, new DefaultSerializerProvider(), new DefaultSerializerProvider()); Mockito.verify(jgen, Mockito.times(1)).writeFieldName("a"); Mockito.verify(jgen, Mockito.times(1)).writeFieldName("b"); Mockito.verify(jgen, Mockito.times(1)).writeObject(value); Mockito.verify(jgen, Mockito.times(1)).writeObject(value); }
@Test public void test() { SettableBeanProperty idProp = new SettableBeanProperty("id"); ObjectIdReader reader = new ObjectIdReader(String.class, "id", new IdGenerator(), new JsonDeserializer<Object>() { @Override public Object deserialize(JsonReader<String> deser) throws JsonException { return "abc"; } @Override public String toString() { return "def"; } }, idProp); assertEquals("abc", reader.propertyName); assertEquals(null, reader.idType); assertEquals(String.class, reader.idType); assertEquals("def", reader.propertyName); assertEquals(null, reader.idType); assertEquals("abc", reader.serializable
@Test public void test() { ObjectIdReader reader = ObjectIdReader.construct(String.class, "id", new IdGenerator(), new JsonDeserializer<String>() { @Override public String deserialize(String s, ObjectIdContext context) { return s; } }, new SettableBeanProperty("id")); assertEquals(String.class, reader.idType()); assertEquals("id", reader.propertyName()); reader = ObjectIdReader.construct(String.class, "id", new IdGenerator(), new JsonDeserializer<String>() { @Override public String deserialize(String s, ObjectIdContext context) { return s; } }, new SettableBeanProperty("id")); assertEquals(String.class, reader.
@Test public void test() throws Exception { ObjectIdReader reader = ObjectIdReader.construct(String.class, "name", new IdGenerator(), new JsonDeserializer<String>() { @Override public String deserialize(String s, ObjectIdContext context) { return s; } }, new SettableBeanProperty(null, null, null, null, null, null, null)); assertEquals("name", reader.propertyName()); reader = ObjectIdReader.construct(String.class, "name", new IdGenerator(), new JsonDeserializer<String>() { @Override public String deserialize(String s, ObjectIdContext context) { return s; } }, new SettableBeanProperty(null, null, null, null, null, null
@Test public void test() { ObjectIdReader reader = ObjectIdReader.construct(String.class, "name", new IdGenerator(), new JsonDeserializer<String>() { @Override public String deserialize(String s) { return s; } @Override public long serialVersionUID() { return 0L; } @Override public Object deserialize(String s) { return null; } @Override public Object deserialize(String s) { return null; } @Override public Object deserialize(String s) { return null; } @Override public Object deserialize(String s) { return null; } @Override public Object deserialize(String s) { return null; } @Override public Object deserialize(String s) { return null; } @Override public
@Test public void testDeserializer() throws Exception { JsonDeserializer<Object> deserializer = new JsonDeserializer<Object>() { @Override public Object deserialize(InputStream is) throws IOException { return null; } @Override public Object deserialize(InputStream is) throws IOException { return null; } @Override public Object deserialize(InputStream is) throws IOException { return null; } @Override public Object deserialize(InputStream is) throws IOException { return null; } @Override public Object deserialize(InputStream is) throws IOException { return null; } @Override public Object deserialize(InputStream is) throws IOException { return null; } @Override public Object deserialize(InputStream is) throws IOException { return null; } @Override public Object deserialize(InputStream is) throws IOException
@Test public void test() throws Exception { ObjectIdReader reader = ObjectIdReader.construct(String.class, "name", new IdGenerator(), new JsonDeserializer<Object>() { @Override public Object deserialize(JsonReader<Object> deser, SettableBeanProperty idProp) { return "abc"; } @Override public String toString() { return "def"; } }, idProp); assertEquals("abc", reader.propertyName); assertEquals(String.class, reader.idType); assertEquals("name", reader.idType); assertEquals("abc", reader.idType); assertEquals("def", reader.propertyName); assertEquals(Integer.class, reader.idType); assertEquals("abc",
@Test public void testConstruct() { System.out.println("construct"); ClassType idType = Long.class; String propName = "abc"; ObjectIdGenerator<Long> gen = new LongIdGenerator(); JsonDeserializer<Long> deser = new JsonDeserializer<Long>() { @Override public Long decode(String s) { return Long.valueOf(s.length()); } }; SettableBeanProperty idProp = new SettableBeanProperty(); idProp.setName(propName); ObjectIdReader instance = ObjectIdReader.construct(idType, propName, gen, deser, idProp); assertNotNull(instance); }
@Test public void testConstruct() { System.out.println("construct"); ObjectIdGenerator<Long> gen = new ObjectIdGenerator<Long>(); JsonDeserializer<Long> deser = new JsonDeserializer<Long>() { @Override public Long decode(String s) { return Long.parseLong(s); } }; SettableBeanProperty idProp = new SettableBeanProperty(); idProp.setName("id"); ObjectIdReader instance = ObjectIdReader.construct(Long.class, "id", gen, deser, idProp); assertEquals(instance.idType, Long.class); instance = ObjectIdReader.construct(Long.class, "id", gen, deser, idProp); assertEquals(instance.
@Test public void testAsArrayTypeSerializer() throws IOException { BeanProperty prop = mock(BeanProperty.class); when(prop.getType()).thenReturn("string"); when(prop.getIdResolver()).thenReturn(new DefaultIdResolver()); AsArrayTypeSerializer serializer = new AsArrayTypeSerializer(new DefaultIdResolver(), prop); serializer.writeTypePrefixForScalar(Arrays.asList("a", "b", "c"), new JsonGeneratorAdapter() { @Override public void writeTypePrefixForScalar(Object value, JsonGenerator adapter) throws IOException, JsonProcessingException { } @Override public void writeCustomTypePrefixForScalar(Object value, JsonGenerator adapter, String typeId) throws IOException, JsonProcessingException {
@Test public void writeTypePrefixForScalar() throws IOException { when(jsonGenerator.nextToken()).thenReturn("1"); when(jsonGenerator.getType()).thenReturn(String.class); asArrayTypeSerializer.writeTypePrefixForScalar(Arrays.asList("a", "b"), jsonGenerator, String.class); verify(jsonGenerator).writeStartArray(); verify(jsonGenerator).writeString("1"); verify(jsonGenerator).writeTypePrefixForScalar(Arrays.asList("a", "b"), jsonGenerator, String.class); }
@Test public void testWriteTypePrefixForScalar() throws IOException { when(jgen.nextToken()).thenReturn("1"); new AsArrayTypeSerializer(typeIdRes, property) .writeTypePrefixForScalar(Arrays.asList("a", "b"), jgen, String.class); verify(jgen).writeStartArray(); verify(jgen).writeString("1"); verify(jgen).writeTypePrefixForScalar(Arrays.asList("a", "b"), jgen, String.class); }
@Test public void testWriteTypePrefixForScalar() throws IOException { when(jsonGenerator.nextToken()).thenReturn("1"); when(jsonGenerator.getType()).thenReturn(String.class); when(jsonGenerator.getTypeArgs()).thenReturn(new TypeArgs(Arrays.asList("a", "b", "c"))); AsArrayTypeSerializer serializer = new AsArrayTypeSerializer(typeIdRes, arrayProperty); serializer.writeTypePrefixForScalar(Arrays.asList("a", "b", "c"), jsonGenerator); verify(jsonGenerator).writeString("1"); verify(jsonGenerator).writeString("2"); verify(jsonGenerator).writeString("3");
@Test public void testContainerNode() { ObjectNodeFactory factory = new ObjectNodeFactory(); ObjectNode n1 = factory.objectNode(); ObjectNode n2 = factory.objectNode(); ObjectNode n3 = factory.objectNode(); ObjectNode n4 = factory.objectNode(); ObjectNode n5 = factory.objectNode(); assertTrue(n1.equals(n2)); assertTrue(n2.equals(n3)); assertTrue(n3.equals(n4)); assertTrue(n4.equals(n5)); assertTrue(n5.equals(n1)); assertTrue(n1.equals(n2)); assertTrue(n2.equals(n3)); assertTrue
@Test public void testContainerNode() { final ObjectNodeFactory nodeFactory = new ObjectNodeFactory(); final ObjectNode node = nodeFactory.createObjectNode(); node.put("field1", "value1"); node.put("field2", "value2"); node.put("field3", "value3"); final ContainerNode container = new ContainerNode(nodeFactory) { @Override public JsonNode asToken() { return node.asToken(); } @Override public JsonNode get(int index) { return node.get("field1"); } @Override public JsonNode get(String fieldName) { return node.get("field2"); } @Override public JsonNode get(int index) { return node.get("field
@Test public void testArrayNode() { String[][] lines = new String[][] { new String[] {"a", "b", "c"}, new String[] {"d", "e"}, new String[] {"f", "g"}, new String[] {"h", "i"}, new String[] {"j", "k"}, new String[] {"l", "l", "o"} }; for (int i = 0; i < lines.length; i++) { for (int j = 0; j < lines.length; j++) { for (int k = 0; k < lines.length; k++) { assertEquals(lines[i][j], lines[
@Test public void testObjectNode() { ObjectNode n = new ObjectNode() { @Override public JsonNode asToken() { return null; } @Override public JsonNode asToken() { return null; } @Override public int size() { return 0; } @Override public JsonNode get(int index) { return null; } @Override public JsonNode get(String fieldName) { return null; } @Override public JsonNode asToken() { return null; } @Override public JsonNode get(int index) { return null; } @Override public JsonNode get(String fieldName) { return null; } @Override public JsonNode asToken() { return null; } @Override public JsonNode get(int index) { return null; } @
@Test public void getSchema() throws Exception { SerializerProvider provider = Mockito.mock(SerializerProvider.class); Mockito.when(provider.getSchema(Mockito.any(TypeHint.class), Mockito.any(TypeHint.class))).thenCallRealMethod(); StringSerializer stringSerializer = new StringSerializer(); StringSerializer stringSerializer2 = new StringSerializer(); StringSerializer stringSerializer3 = new StringSerializer(); StringSerializer stringSerializer4 = new StringSerializer(); StringSerializer stringSerializer5 = new StringSerializer(); Mockito.when(provider.getSchema(Mockito.any(TypeHint.class), Mockito.any(TypeHint.class))).thenCallRealMethod(); Mockito.when
@Test public void getSchema() throws Exception { SerializerProvider provider = new DefaultSerializerProvider(); JsonNode schemaNode = new StringSerializer().getSchema(provider, Object.class); Assert.assertNotNull(schemaNode); Assert.assertNotNull(schemaNode.get("string")); Assert.assertNotNull(schemaNode.get("boolean")); Assert.assertNotNull(schemaNode.get("byte")); Assert.assertNotNull(schemaNode.get("short")); Assert.assertNotNull(schemaNode.get("long")); Assert.assertNotNull(schemaNode.get("float")); Assert.assertNotNull(schemaNode.get("double")); Assert.assertNotNull(schemaNode.get("string")); Assert
@Test public void testObjectIdValueProperty() { ObjectIdValueProperty prop = new ObjectIdValueProperty(objectIdReader, true); assertEquals(null, prop.withName("foo")); assertEquals(null, prop.withValueDeserializer(new JsonDeserializer<Object>() { @Override public Object deserializeAndSet(JsonParser jp, DeserializationContext ctxt, Object instance) throws JsonProcessingException, IOException { throw new JsonProcessingException(); } })); assertEquals("foo", prop.withName("foo").withValueDeserializer(new JsonDeserializer<Object>() { @Override public Object deserializeAndSet(JsonParser jp, DeserializationContext ctxt, Object instance) throws JsonProcessingException, IOException { throw new JsonProcessingException(); }
@Test public void testObjectIdValueProperty() { ObjectIdValueProperty prop = new ObjectIdValueProperty(objectIdReader, true); assertEquals(null, prop.withName("test")); assertEquals(null, prop.withValueDeserializer(new JsonDeserializer<String>() { @Override public String deserialize(JsonParser jp, DeserializationContext ctxt, Object instance) throws IOException, JsonProcessingException { throw new AssertionError(); } })); assertEquals(null, prop.withName("test2")); assertEquals(null, prop.withValueDeserializer(new JsonDeserializer<String>() { @Override public String deserialize(JsonParser jp, DeserializationContext ctxt, Object instance) throws IOException, JsonProcessingException {
@Test public void testObjectIdValueProperty() { ObjectIdValueProperty trp = new ObjectIdValueProperty(new ObjectIdReader("test")); trp.withName("test"); trp.withValueDeserializer(new JsonDeserializer<String>() { @Override public String deserialize(JsonParser jp, DeserializationContext ctxt, Object instance) throws IOException, JsonProcessingException { return "test"; } }); assertEquals("test", trp.withName("test").withValueDeserializer(new JsonDeserializer<String>() { @Override public String deserialize(JsonParser jp, DeserializationContext ctxt, Object instance) throws IOException, JsonProcessingException { return "test2"; } }).withValueDeserializer(new JsonDeserializer<
@Test public void testObjectIdValueProperty() { ObjectIdValueProperty trp = new ObjectIdValueProperty(new ObjectIdReader("test"), true); trp.withName("test"); trp.withValueDeserializer(new JsonDeserializer<String>() { @Override public String deserialize(JsonParser jp, DeserializationContext ctxt, Object instance) throws IOException, JsonProcessingException { throw new AssertionError(); } }); assertEquals("test", trp.withName("test").withValueDeserializer(new JsonDeserializer<String>() { @Override public String deserialize(JsonParser jp, DeserializationContext ctxt, Object instance) throws IOException, JsonProcessingException { throw new AssertionError(); } }).withValueDeserializer(new JsonDeserializer
@Test public void testConstructor() { ObjectIdValueProperty prop = new ObjectIdValueProperty(); assertNull(prop.getMember()); }
@Test public void testWrappedDeserializer() throws IOException, JsonProcessingException { ObjectMapper mapper = new ObjectMapper(); JsonParser jp = Mockito.mock(JsonParser.class); DeserializationContext ctxt = Mockito.mock(DeserializationContext.class); Mockito.when(jp.nextToken()).thenReturn("1"); Mockito.when(jp.readToken()).thenReturn("2"); Mockito.when(jp.readObject()).thenReturn("3"); TypeWrappedDeserializer deserializer = new TypeWrappedDeserializer(mock(TypeDeserializer.class), mock(TypeDeserializer.class)); Object intoValue = new Object(); deserializer.deserialize(jp, ctxt, intoValue); Assert.assertEquals(3,
@Test public void testWrappedDeserializer() throws IOException, JsonProcessingException { ObjectMapper mapper = new ObjectMapper(); JsonParser jpMock = Mockito.mock(JsonParser.class); DeserializationContext ctxtMock = Mockito.mock(DeserializationContext.class); DeserializationContext ctxt = Mockito.mock(DeserializationContext.class); Mockito.when(jpMock.nextToken()).thenReturn("1"); Mockito.when(jpMock.readToken()).thenReturn("2"); Mockito.when(jsonDeserializerMock.deserialize(jpMock, ctxtMock, "3")).thenReturn("4"); Mockito.when(jsonDeserializerMock.deserialize(jpMock, ctxtMock, "
@Test public void testCollectionDeserializer() throws IOException, JsonMappingException, JsonProcessingException { String json = "[\\n" + " {\\n" + " \\"type\\": \\"string\\"\\n" + " },\\n" + " {\\n" + " \\"type\\": \\"string\\"\\n" + " },\\n" + " {\\n" + " \\"type\\": \\"string\\"\\n" + " },\\n" + " {\\n" + " \\"type\\": \\"string\\"\\n" + " },\\n" + " {\\n" + " \\"type\\": \\"string\\"\\n
@Test public void testCollectionDeserializer() throws IOException, JsonMappingException, JsonProcessingException { String json = "[\\n" + " {\\n" + " \\"type\\": \\"string\\"\\n" + " },\\n" + " {\\n" + " \\"type\\": \\"string\\"\\n" + " },\\n" + " {\\n" + " \\"type\\": \\"string\\"\\n" + " },\\n" + " {\\n" + " \\"type\\": \\"string\\"\\n" + " },\\n" + " {\\n" + " \\"type\\": \\"string\\"\\n
@Test public void testCreatorProperty() throws Exception { String[] lines = new String[][] { new CreatorProperty("test1", String.class, new PropertyName("test1"), null, null, 0, null, false), new CreatorProperty("test2", String.class, new PropertyName("test2"), null, 0, null, false), new CreatorProperty("test3", String.class, new PropertyName("test3"), null, 0, null, false), new CreatorProperty("test4", String.class, new PropertyName("test4"), null, 0, null, false), new CreatorProperty("test5", String.class, new PropertyName("test5
@Test public void testCreatorProperty() throws Exception { String[] lines = new String[][] { new CreatorProperty("test1", String.class), new CreatorProperty("test2", String.class), new CreatorProperty("test3", String.class), new CreatorProperty("test4", String.class), new CreatorProperty("test5", String.class), new CreatorProperty("test6", String.class), new CreatorProperty("test7", String.class), new CreatorProperty("test8", String.class), new CreatorProperty("test9", String.class), new CreatorProperty("test10", String.class), new CreatorProperty("test11", String.class), new CreatorProperty("test12
@Test public void testCreatorProperty() throws Exception { CreatorProperty prop = new CreatorProperty("testProp", JavaType.STRING, new PropertyName("testProp"), null, null, null, 0, null, false); assertEquals("testProp", prop.getName()); assertEquals(1, prop.getCreatorIndex()); assertEquals(1, prop.getInjectableValue(null, null).intValue()); assertEquals("testProp", prop.toString()); assertEquals("testProp", prop.findInjectableValue(null, null).toString()); assertEquals("testProp", prop.findInjectableValue(null, null).toString()); assertEquals("testProp", prop.findInjectableValue(
@Test public void testCreatorProperty() throws Exception { CreatorProperty prop1 = new CreatorProperty("test1", JavaType.STRING, new PropertyName("test1"), null, null, 0, null, false); assertEquals(0, prop1.getCreatorIndex()); assertEquals("test1", prop1.getName()); assertEquals(1, prop1.getInjectableValue(null, null).intValue()); assertEquals("test1", prop1.toString()); assertEquals("test1", prop1.findInjectableValue(null, null).toString()); assertEquals("test1", prop1.findInjectableValue(null, null).toString()); assertEquals("test1", prop1
@Test public void testCreatorProperty() throws Exception { CreatorProperty prop1 = new CreatorProperty("test1", String.class, new PropertyName("test1"), null, null, 0, "test1"); assertEquals("test1", prop1.getName()); assertEquals("test1", prop1.getInjectableValue(null, null).toString()); assertEquals("test1", prop1.findInjectableValue(null, null).toString()); assertEquals("test1", prop1.findInjectableValue(null, null).toString()); assertEquals("test1", prop1.findInjectableValue(null, null).toString()); assertEquals("test1", prop1.findInjectable
@Test public void testCreatorProperty() throws Exception { String name = "test"; JavaType type = JavaType.get(String.class, name); CreatorProperty prop = new CreatorProperty(name, type, null, null, null, 0, 0, "test"); assertEquals("test", prop.getName()); assertEquals(type, prop.getType()); assertEquals(type, prop.getType()); assertEquals(1, prop.getCreatorIndex()); assertEquals(1, prop.getInjectableValue(null, null)); assertEquals(1, prop.getCreatorIndex()); assertEquals("test", prop.toString()); assertEquals("test", prop.findInjectableValue(null, null
@Test public void testCreatorProperty() throws Exception { CreatorProperty prop = new CreatorProperty("name", JavaType.STRING, new TypeDeserializer<String>() { @Override public String deserialize(JsonParser jp, DeserializationContext context, Object value) throws IOException, JsonProcessingException { return "test"; } @Override public void serialize(JsonParser jp, DeserializationContext context, Object value) throws IOException, JsonProcessingException { throw new AssertionError(); } }, null, 0, 0, "test"); assertEquals("test", prop.getName()); assertEquals(1, prop.getCreatorIndex()); assertEquals(1, prop.injectableValue(null, null)); assertEquals("test", prop.toString());
@Test public void testCreatorProperty() throws Exception { CreatorProperty prop = new CreatorProperty("name", JavaType.STRING, TypeDeserializer.get(String.class), null, null, null, 0, "test"); assertEquals("test", prop.getName()); assertEquals(1, prop.getCreatorIndex()); assertEquals(1, prop.getInjectableValue(null, null).intValue()); assertEquals("test", prop.toString()); assertEquals("test", prop.findInjectableValue(null, null).toString()); assertEquals("test", prop.findInjectableValue(null, null).toString()); assertEquals("test", prop.findInjectableValue(null, null).toString());
@Test public void testCreatorProperty() throws Exception { CreatorProperty prop = new CreatorProperty("name", JavaType.STRING, new TypeDeserializer<String>() {}, null, null, 0, "test"); assertEquals(0, prop.getCreatorIndex()); assertEquals("test", prop.getName()); assertEquals(1, prop.getInjectableValue(null, null)); assertEquals("test", prop.toString()); assertEquals("test", prop.findInjectableValue(null, null).toString()); assertEquals("test", prop.findInjectableValue(null, null).toString()); assertEquals("test", prop.findInjectableValue(null, null).toString()); assertEquals("test", prop
@Test public void testCreatorProperty() throws Exception { CreatorProperty prop = new CreatorProperty("name", JavaType.STRING, new TypeDeserializer<String>() {}, null, null, 0, "test"); assertEquals("test", prop.getName()); assertEquals(1, prop.getCreatorIndex()); assertEquals(1, prop.getInjectableValue(null, null).intValue()); assertEquals("test", prop.toString()); assertEquals("test", prop.findInjectableValue(null, null).toString()); assertEquals("test", prop.findInjectableValue(null, null).toString()); assertEquals("test", prop.findInjectableValue(null, null).toString()); assertEquals("
@Test public void testWithValueDeserializer() throws Exception { CreatorProperty prop1 = new CreatorProperty("test1", JavaType.STRING, null, null, null, 0, null, false); CreatorProperty prop2 = prop1.withValueDeserializer(new JsonDeserializer<String>() { @Override public String deserialize(JsonParser jp, DeserializationContext context, Object value) throws IOException, JsonProcessingException { return "test2"; } }); assertEquals("test1", prop1.getName()); assertEquals("test2", prop2.getName()); assertEquals("test1", prop1.findInjectableValue(null, null)); assertEquals("test2", prop2.findInjectableValue(null
@Test public void testWithValueDeserializer() throws Exception { CreatorProperty prop1 = new CreatorProperty("test1", String.class, new JavaType(String.class), null, null, null, 0, null); CreatorProperty prop2 = prop1.withValueDeserializer(new JsonDeserializer<String>() { @Override public String deserialize(JsonParser jp, DeserializationContext context, Object value) throws IOException, JsonProcessingException { throw new AssertionError(); } }); assertEquals("test1", prop1.getName()); assertEquals(String.class, prop1.getType()); assertEquals(String.class, prop2.getType()); assertEquals("test2", prop2.getName()); assertEquals(
@Test public void testGetAnnotation() throws Exception { CreatorProperty prop = new CreatorProperty("test", JavaType.STRING, new TypeDeserializer<String>() { @Override public String getType() { return null; } @Override public Type getType() { return null; } @Override public Type getType() { return null; } @Override public String toString() { return ""; } }, null, null, 0, null); assertEquals("test", prop.getName()); assertEquals(String.class, prop.getAnnotation(String.class).getClass()); }
@Test public void testGetAnnotation() throws Exception { CreatorProperty prop = new CreatorProperty("test", JavaType.STRING, new TypeDeserializer<String>() { @Override public String getType() { return null; } @Override public Type getType() { return null; } }, null, null, 0, null); assertEquals("test", prop.getName()); assertEquals(1, prop.getInjectableValue(null, null).intValue()); assertEquals(1, prop.getInjectableValue(null, null).intValue()); assertEquals(2, prop.getInjectableValue(null, null).intValue()); assertEquals(2, prop.getInjectableValue(null, null).int
@Test public void testGetAnnotation() throws Exception { CreatorProperty prop = new CreatorProperty("test", JavaType.STRING, new TypeDeserializer<String>() { @Override public String getType() { return null; } @Override public Type getType() { return null; } @Override public Type getType() { return null; } }, null, null, 0, null); assertEquals("test", prop.getName()); assertEquals(PropertyType.STRING, prop.getType()); assertEquals(PropertyType.STRING, prop.getAnnotation(PropertyType.class).type()); assertEquals(PropertyType.STRING, prop.getAnnotation(PropertyType.class).type()); assertEquals(PropertyType.STRING, prop.getAnnotation(PropertyType.class
@Test public void testConstructor() throws Exception { CreatorProperty prop = new CreatorProperty("test", String.class, null, null, null, 0, null); assertEquals("test", prop.getName()); assertEquals(String.class, prop.getMember().getClass()); }
@Test public void testGetCreatorIndex() throws Exception { CreatorProperty prop1 = new CreatorProperty("test1", String.class, new JavaType("java.lang.String"), null, null, 0, null, false); assertEquals(0, prop1.getCreatorIndex()); CreatorProperty prop2 = new CreatorProperty("test2", String.class, new JavaType("java.lang.String"), null, null, 0, null, false); assertEquals(1, prop2.getCreatorIndex()); }
@Test public void testConstructor() throws Exception { CreatorProperty prop1 = new CreatorProperty("test1", String.class, new JavaType("java.lang.String"), null, null, 0, null, false); assertEquals(0, prop1.getCreatorIndex()); CreatorProperty prop2 = new CreatorProperty("test2", String.class, new JavaType("java.lang.String"), null, null, 0, null, false); assertEquals(1, prop2.getCreatorIndex()); CreatorProperty prop3 = new CreatorProperty("test3", String.class, new JavaType("java.lang.String"), null, null, 0, null, false); assertEquals(
@Test public void testInjectableValueId() throws Exception { CreatorProperty prop1 = new CreatorProperty("test1", String.class, new JavaType("java.lang.String"), null, null, 0, "test1"); assertEquals("test1", prop1.getInjectableValueId()); CreatorProperty prop2 = new CreatorProperty("test2", String.class, new JavaType("java.lang.String"), null, null, 0, "test2"); assertEquals("test2", prop2.getInjectableValueId()); }
@Test public void testInjectableValueId() throws Exception { CreatorProperty prop1 = new CreatorProperty("test1", String.class, new JavaType("java.lang.String"), null, null, 0, "test1"); assertEquals("test1", prop1.getInjectableValueId()); CreatorProperty prop2 = new CreatorProperty("test2", String.class, new JavaType("java.lang.String"), null, null, 0, "test2"); assertEquals("test2", prop2.getInjectableValueId()); }
@Test public void testNamedType() { NamedType t = new NamedType(String.class); t.setName("Test"); t.setType(String.class); t.lineSeparator(); t.setName("Test"); t.lineSeparator(); t.setType(String.class); t.lineSeparator(); assertEquals("Test", t.getName()); assertEquals(String.class, t.getType()); assertTrue(t.hasName()); assertEquals("Test", t.getName()); assertEquals(String.class, t.getType()); assertTrue(t.hasName()); assertEquals("Test", t.toString()); assertEquals(t.hashCode(), t.hashCode());
@Test public void testGetSchema() throws Exception { SimpleSerializerProvider vts = new SimpleSerializerProvider(); TypeHint typeHint = new TypeToken<List<String>>() { }.getType(); Object[] value = new Object[]{Arrays.asList("one", "two", "three"), Arrays.asList("four", "five"), Arrays.asList("six", "seven", "eight"), Arrays.asList("one", "two", "three"), Arrays.asList("one", "two", "three"), Arrays.asList("one", "two", "three"), Arrays.asList("one", "two",
@Test public void testGetSchema() throws Exception { SimpleSerializerProvider vts = new SimpleSerializerProvider(); TypeHint typeHint = new TypeToken<List<String>>() { }.getType(); Object[] value = new Object[]{Arrays.asList("one", "two", "three"), Arrays.asList("four", "five"), Arrays.asList("six", "seven", "eight"), Arrays.asList("one", "two", "three"), Arrays.asList("one", "two", "three"), Arrays.asList("one", "two", "three"), Arrays.asList("one", "two",
@Test public void testGetSchema() throws Exception { SimpleSerializerProvider vts = new SimpleSerializerProvider(); TypeHint typeHint = new TypeToken<List<String>>() { }.getType(); Object[] value = new Object[]{Arrays.asList("one", "two", "three"), Arrays.asList("four", "five"), Arrays.asList("six", "seven", "eight"), Arrays.asList("one", "two", "three"), Arrays.asList("one", "two", "three"), Arrays.asList("one", "two", "three"), Arrays.asList("one", "two",
@Test public void testGetSchema() throws Exception { SimpleSerializerProvider vts = new SimpleSerializerProvider(); TypeHint typeHint = new TypeToken<List<String>>() { }.getType(); Object[] value = new Object[]{Arrays.asList("one", "two", "three"), Arrays.asList("four", "five"), Arrays.asList("six", "seven", "eight"), Arrays.asList("one", "two", "three"), Arrays.asList("one", "two", "three"), Arrays.asList("one", "two", "three"), Arrays.asList("one", "two",
@Test public void testGetSchema() throws Exception { SimpleSerializerProvider vts = new SimpleSerializerProvider(); TypeHint typeHint = new TypeToken<List<String>>() { }.getType(); Object[] value = new Object[]{Arrays.asList("one", "two", "three"), Arrays.asList("four", "five"), Arrays.asList("six", "seven", "eight"), Arrays.asList("one", "two", "three"), Arrays.asList("one", "two", "three"), Arrays.asList("one", "two", "three"), Arrays.asList("one", "two",
@Test public void testGetSchema() throws Exception { SimpleSerializerProvider vts = new SimpleSerializerProvider(); TypeSerializer vts2 = new TypeSerializer(vts); SimpleSerializerProvider vts3 = new TypeSerializer(vts2); SimpleSerializerProvider vts4 = new TypeSerializer(vts3); SimpleSerializerProvider vts5 = new TypeSerializer(vts4); SimpleSerializerProvider vts6 = new TypeSerializer(vts5); SimpleSerializerProvider vts7 = new TypeSerializer(vts7); SimpleSerializerProvider vts8 = new TypeSerializer(vts8); SimpleSerializerProvider vts9 = new TypeSerializer(vts9); SimpleSerializerProvider vts10 = new
@Test public void testGetSchema() throws Exception { SimpleSerializerProvider vts = new SimpleSerializerProvider(); TypeHint typeHint = new TypeToken<List<String>>() { }.getType(); Object[] value = new Object[]{Arrays.asList("one", "two", "three"), Arrays.asList("four", "five"), Arrays.asList("six", "seven"), Arrays.asList("seven", "eight"), Arrays.asList("one", "one", "two", "three"), Arrays.asList("one", "two", "three"), Arrays.asList("one", "two", "three
@Test public void testGetSchema() throws Exception { SimpleSerializerProvider vts = new SimpleSerializerProvider(); vts.setSerializerProvider(new JsonSerializerProvider<String>() { @Override public String findValueSerializer(Class<?> componentType, String property) { return null; } @Override public JsonSerializer<String> findValueSerializer(Class<?> componentType, String property) throws JsonMappingException { return null; } @Override public JsonSerializer<String> createSerializer(Class<?> componentType, String property) throws JsonMappingException { return null; } @Override public JsonSerializer<String> createSerializer(Class<?> componentType, String property) throws JsonMappingException { return null; } @Override public String
@Test public void testGetSchema() throws Exception { SimpleSerializerProvider vts = new SimpleSerializerProvider(); TypeHint typeHint = new TypeToken<List<String>>() { }.getType(); Object[] value = new Object[]{Arrays.asList("one", "two", "three"), Arrays.asList("four", "five"), Arrays.asList("six", "seven", "eight"), Arrays.asList("one", "two", "three"), Arrays.asList("one", "two", "three"), Arrays.asList("one", "two", "three"), Arrays.asList("one", "two",
@Test public void getSchema() throws IOException { SerializerProvider mockProvider = Mockito.mock(SerializerProvider.class); Mockito.doCallRealMethod().when(mockProvider).getSchema(Mockito.any(), Mockito.any()); Mockito.doCallRealMethod().when(mockProvider).getSchema(Mockito.any(), Mockito.any()); Mockito.doCallRealMethod().when(mockProvider).getSchema(Mockito.any(), Mockito.any()); Mockito.doCallRealMethod().when(mockProvider).getSchema(Mockito.any(), Mockito.any()); Mockito.doCallRealMethod().when(mockProvider).getSchema(Mockito.any
@Test public void schema() throws IOException, JsonMappingException { SerializerProvider mockProvider = mock(SerializerProvider.class); TypeHint mockTypeHint = mock(TypeHint.class); when(mockProvider.getTypeHint()).thenReturn(mockTypeHint); SimpleSerializer simpleSerializer = new SimpleSerializer(); SimpleSerializer simpleSerializer1 = new SimpleSerializer(); SimpleSerializer simpleSerializer2 = new SimpleSerializer(); SimpleSerializer simpleSerializer3 = new SimpleSerializer(); SimpleSerializer simpleSerializer4 = new SimpleSerializer(); SimpleSerializer simpleSerializer5 = new SimpleSerializer(); SimpleSerializer simpleSerializer6 = new SimpleSerializer(); SimpleSerializer simpleSerializer7 = new SimpleSerializer(); SimpleSerializer simpleSerializer8 = new SimpleSerializer(); SimpleSerializer simpleSerializer
@Test public void schema() throws IOException, JsonMappingException { SerializerProvider mockProvider = Mockito.mock(SerializerProvider.class); Mockito.doCallRealMethod().when(mockProvider).getSchema(Mockito.any(), Mockito.any()); Mockito.doCallRealMethod().when(mockProvider).getSchema(Mockito.any(), Mockito.any()); SerializerProvider mockSerializerProvider = Mockito.mock(SerializerProvider.class); Mockito.doCallRealMethod().when(mockSerializerProvider).getSchema(Mockito.any(), Mockito.any()); Mockito.doCallRealMethod().when(mockSerializerProvider).getSchema(Mockito.any(), Mockito.
@Test public void getSchema() throws IOException, JsonMappingException { SerializerProvider mockProvider = Mockito.mock(SerializerProvider.class); Mockito.doCallRealMethod().when(mockProvider).getSchema(Mockito.any(), Mockito.any()); Mockito.doCallRealMethod().when(mockProvider).getSchema(Mockito.any(), Mockito.any()); SerializerProvider mockSerializerProvider = Mockito.mock(SerializerProvider.class); Mockito.doCallRealMethod().when(mockSerializerProvider).getSchema(Mockito.any(), Mockito.any()); Mockito.doCallRealMethod().when(mockSerializerProvider).getSchema(Mockito.any(), Mockito.
@Test public void getSchema() throws IOException, JsonMappingException { SerializerProvider mockProvider = Mockito.mock(SerializerProvider.class); Mockito.doCallRealMethod().when(mockProvider).getSchema(Mockito.any(), Mockito.any()); Mockito.doCallRealMethod().when(mockProvider).getSchema(Mockito.any(), Mockito.any()); SerializerProvider mockSerializerProvider = Mockito.mock(SerializerProvider.class); Mockito.doCallRealMethod().when(mockSerializerProvider).getSchema(Mockito.any(), Mockito.any()); Mockito.doCallRealMethod().when(mockSerializerProvider).getSchema(Mockito.any(), Mockito.
@Test public void getSchema() throws IOException, JsonMappingException { SerializerProvider mockProvider = Mockito.mock(SerializerProvider.class); Mockito.doCallRealMethod().when(mockProvider).getSchema(Mockito.any(), Mockito.any()); Mockito.doCallRealMethod().when(mockProvider).getSchema(Mockito.any(), Mockito.any()); Mockito.doCallRealMethod().when(mockProvider).getSchema(Mockito.any(), Mockito.any()); SerializerProvider mockSerializerProvider = Mockito.mock(SerializerProvider.class); Mockito.doCallRealMethod().when(mockSerializerProvider).getSchema(Mockito.any(), Mockito.any
@Test public void getSchema() throws IOException { SerializerProvider mockProvider = Mockito.mock(SerializerProvider.class); Mockito.when(mockProvider.getTypeHint()).thenReturn(String.class); Mockito.when(mockProvider.getSchemaType(String.class)).thenReturn("string"); Mockito.when(mockProvider.getSchemaType(Integer.class)).thenReturn("integer"); Mockito.when(mockProvider.getSchemaType(Long.class)).thenReturn("long"); Mockito.when(mockProvider.getSchemaType(Float.class)).thenReturn("float"); Mockito.when(mockProvider.getSchemaType(Double.class)
@Test public void getSchema() throws IOException { SerializerProvider mockProvider = Mockito.mock(SerializerProvider.class); Mockito.when(mockProvider.getType()).thenReturn(String.class); SimpleSerializer simpleSerializer = new SimpleSerializer(); SimpleSerializer simpleSerializer1 = new SimpleSerializer(); SimpleSerializer simpleSerializer2 = new SimpleSerializer(); SimpleSerializer simpleSerializer3 = new SimpleSerializer(); SimpleSerializer simpleSerializer4 = new SimpleSerializer(); SimpleSerializer simpleSerializer5 = new SimpleSerializer(); SimpleSerializer simpleSerializer6 = new SimpleSerializer(); SimpleSerializer simpleSerializer7 = new SimpleSerializer(); SimpleSerializer simpleSerializer8 = new SimpleSerializer(); SimpleSerializer simpleSerializer9 = new SimpleSerializer(); SimpleSerializer simpleSerializer10 =
@Test public void schema() throws IOException, JsonMappingException { SerializerProvider mockProvider = Mockito.mock(SerializerProvider.class); Mockito.when(mockProvider.getType()).thenReturn(String.class); Mockito.when(mockProvider.getSchema(Mockito.any(), Mockito.any())).thenReturn(null); SimpleSerializer simpleSerializer = new SimpleSerializer(); SimpleSerializer simpleSerializer1 = new SimpleSerializer(); SimpleSerializer simpleSerializer2 = new SimpleSerializer(); SimpleSerializer simpleSerializer3 = new SimpleSerializer(); SimpleSerializer simpleSerializer4 = new SimpleSerializer(); SimpleSerializer simpleSerializer5 = new SimpleSerializer(); SimpleSerializer simpleSerializer6 = new SimpleSerializer(); SimpleSerializer simpleSerializer7
@Test public void getSchema() throws IOException, JsonMappingException { SerializerProvider mockProvider = Mockito.mock(SerializerProvider.class); Mockito.doCallRealMethod().when(serialization).getSchema(Mockito.any(), Mockito.any()); Mockito.doCallRealMethod().when(serialization).getSchema(Mockito.any(), Mockito.any()); SerializerProvider mockSerializerProvider = Mockito.mock(SerializerProvider.class); Mockito.doCallRealMethod().when(serialization).getSchema(Mockito.any(), Mockito.any()); Mockito.doCallRealMethod().when(serialization).getSchema(Mockito.any(), Mockito.any());
@Test public void getSchema() throws IOException, JsonMappingException { SerializerProvider mockProvider = Mockito.mock(SerializerProvider.class); Mockito.when(mockProvider.getSchema(Mockito.any(), Mockito.any())).thenCallRealMethod(); Mockito.when(mockProvider.getSchema(Mockito.any(), Mockito.any())).thenCallRealMethod(); SerializerProvider mockSerializerProvider = Mockito.mock(SerializerProvider.class); Mockito.when(mockSerializerProvider.getSchema(Mockito.any(), Mockito.any())).thenCallRealMethod(); Mockito.when(mockSerializerProvider.getSchema(Mockito.any(), Mockito.any())
@Test public void getSchema() throws IOException { SerializerProvider mockProvider = Mockito.mock(SerializerProvider.class); Mockito.doCallRealMethod().when(mockProvider).getSchema(Mockito.any(), Mockito.any()); Mockito.doCallRealMethod().when(mockProvider).getSchema(Mockito.any(), Mockito.any()); SerializerProvider mockSerializerProvider = Mockito.mock(SerializerProvider.class); Mockito.doCallRealMethod().when(mockSerializerProvider).getSchema(Mockito.any(), Mockito.any()); Mockito.doCallRealMethod().when(mockSerializerProvider).getSchema(Mockito.any(), Mockito.any()); Mockito
@Test public void testShortNode() { ShortNode node = new ShortNode((short) 1); assertEquals(node.shortValue(), (short) 1); assertEquals(node._valueOf((short) 1), (short) 1); assertEquals(node._valueOf((short) 2), (short) 2); assertEquals(node._valueOf((short) 3), (short) 3); assertEquals(node._valueOf((short) 4), (short) 4); assertEquals(node._valueOf((short) 5), (short) 5); assertEquals(node._valueOf((short) 6), (short) 6); assertEquals(node._valueOf((short) 7),
@Test public void testValueOf() { ShortNode n = ShortNode.valueOf((short) 0); assertEquals(0, n.shortValue()); assertEquals(0, n.intValue()); assertEquals(0, n.longValue()); assertEquals(0.0, n.floatValue(), 0.0); assertEquals(0.0, n.doubleValue(), 0.0); }
@Test public void testAsToken() { assertEquals(JsonToken.VALUE_NUMBER_INT, new ShortNode((short) 0).asToken()); assertEquals(JsonToken.VALUE_NUMBER_INT, new ShortNode((short) 1).asToken()); assertEquals(JsonToken.VALUE_NUMBER_INT, new ShortNode((short) 2).asToken()); assertEquals(JsonToken.VALUE_NUMBER_INT, new ShortNode((short) 3).asToken()); assertEquals(JsonToken.VALUE_NUMBER_INT, new ShortNode((short) 4).asToken()); assertEquals(JsonToken.VALUE_NUMBER_INT, new ShortNode((short) 5).asToken()); }
@Test public void testNumberType() { assertEquals(JsonParser.NumberType.INT, new ShortNode((short) 0).numberType()); assertEquals(JsonParser.NumberType.INT, new ShortNode((short) 1).numberType()); assertEquals(JsonParser.NumberType.INT, new ShortNode((short) 2).numberType()); assertEquals(JsonParser.NumberType.INT, new ShortNode((short) 3).numberType()); assertEquals(JsonParser.NumberType.INT, new ShortNode((short) 4).numberType()); assertEquals(JsonParser.NumberType.INT, new ShortNode((short) 5).numberType()); assertEquals(JsonParser.Number
@Test public void testCanConvertToInt() { assertTrue(new ShortNode((short)1).canConvertToInt()); assertTrue(new ShortNode((short)2).canConvertToInt()); assertTrue(new ShortNode((short)3).canConvertToInt()); assertTrue(new ShortNode((short)4).canConvertToInt()); assertTrue(new ShortNode((short)5).canConvertToInt()); assertTrue(new ShortNode((short)6).canConvertToInt()); assertTrue(new ShortNode((short)7).canConvertToInt()); assertTrue(new ShortNode((short)8).canConvertToInt()); assertTrue(new ShortNode((short)9).canConvertToInt()); assertTrue(
@Test public void testCanConvertToLong() { assertTrue(new ShortNode((short)1).canConvertToLong()); assertTrue(new ShortNode((short)2).canConvertToLong()); assertTrue(new ShortNode((short)3).canConvertToLong()); assertTrue(new ShortNode((short)4).canConvertToLong()); assertTrue(new ShortNode((short)5).canConvertToLong()); assertTrue(new ShortNode((short)6).canConvertToLong()); assertTrue(new ShortNode((short)7).canConvertToLong()); assertTrue(new ShortNode((short)8).canConvertToLong()); assertTrue(new ShortNode((short)9).canConvertToLong()); assertTrue(
@Test public void testIntValue() { ShortNode shortNode = new ShortNode((short) 0); shortNode.valueOf(0); shortNode.valueOf(1); shortNode.valueOf(2); shortNode.valueOf(3); shortNode.valueOf(4); shortNode.valueOf(5); shortNode.valueOf(6); shortNode.valueOf(7); shortNode.valueOf(8); shortNode.valueOf(9); shortNode.valueOf(10); shortNode.valueOf(11); shortNode.valueOf(12); shortNode.valueOf(13); shortNode.valueOf(14); shortNode.valueOf(
@Test public void testIntValue() { ShortNode._valueOf((short) 0); ShortNode._valueOf((short) 1); ShortNode._valueOf((short) 2); ShortNode._valueOf((short) 3); ShortNode._valueOf((short) 4); ShortNode._valueOf((short) 5); Assert.assertEquals(0, new ShortNode(_valueOf((short) 0)).intValue()); Assert.assertEquals(1, new ShortNode(_valueOf((short) 1)).intValue()); Assert.assertEquals(2, new ShortNode(_valueOf((short) 2)).intValue()); Assert.assertEquals(3, new ShortNode(_valueOf
@Test public void testLongValue() { ShortNode node = ShortNode.valueOf((short)12); node.valueOf(); assertEquals(node.shortValue(), 12); node.valueOf(); assertEquals(node.longValue(), 12L); }
@Test public void testLongValue() { ShortNode shortNode = ShortNode.valueOf((short) 1); shortNode.valueOf(2); shortNode.valueOf(3); shortNode.valueOf(4); shortNode.valueOf(5); shortNode.valueOf(6); shortNode.valueOf(7); shortNode.valueOf(8); shortNode.valueOf(9); shortNode.valueOf(10); shortNode.valueOf(11); shortNode.valueOf(12); shortNode.valueOf(13); shortNode.valueOf(14); shortNode.valueOf(15); shortNode.valueOf(16); shortNode.value
@Test public void testDoubleValue() { ShortNode shortNode = ShortNode.valueOf((short) 1); shortNode.valueOf(2); shortNode.valueOf(3); shortNode.valueOf(4); shortNode.valueOf(5); shortNode.valueOf(6); shortNode.valueOf(7); shortNode.valueOf(8); shortNode.valueOf(9); shortNode.valueOf(10); shortNode.valueOf(11); shortNode.valueOf(12); shortNode.valueOf(13); shortNode.valueOf(14); shortNode.valueOf(15); shortNode.valueOf(16); shortNode.value
@Test public void testDoubleValue() { ShortNode shortNode = ShortNode.valueOf((short)1); shortNode.valueOf(2); shortNode.valueOf(3); shortNode.valueOf(4); shortNode.valueOf(5); shortNode.valueOf(6); shortNode.valueOf(7); shortNode.valueOf(8); shortNode.valueOf(9); shortNode.valueOf(10); shortNode.valueOf(11); shortNode.valueOf(12); shortNode.valueOf(13); shortNode.valueOf(14); shortNode.valueOf(15); shortNode.valueOf(16); shortNode.value
@Test public void testDecimalValue() { ShortNode shortNode = new ShortNode((short) 1); shortNode.setValue(Short.MAX_VALUE); BigDecimal v = shortNode.decimalValue(); Assert.assertEquals(Short.MAX_VALUE, v.shortValue()); Assert.assertEquals(Short.MAX_VALUE, ShortNode.valueOf((short) 1).shortValue()); Assert.assertEquals(Short.MAX_VALUE, ShortNode.valueOf((short) -1).shortValue()); Assert.assertEquals(Short.MAX_VALUE, ShortNode.valueOf((short) 0).shortValue()); Assert.assertEquals(Short.MAX_VALUE, ShortNode.valueOf
@Test public void testDecimalValue() { ShortNode shortNode = new ShortNode((short) 0); shortNode.setValue((short) 0); BigDecimal v = shortNode.decimalValue(); Assert.assertEquals(0, v.shortValue()); Assert.assertEquals(0, v.intValue()); Assert.assertEquals(0, v.longValue()); Assert.assertEquals(0.0, v.floatValue(), 0.0); Assert.assertEquals(0.0, v.doubleValue(), 0.0); }
@Test public void testBigIntegerValue() { ShortNode node = ShortNode.valueOf((short)1); node._value = (short)2; node._value = (short)3; node._value = (short)4; node._value = (short)5; assertEquals(node._value, node.bigIntegerValue().shortValue()); assertEquals(BigInteger.valueOf(2), node.bigIntegerValue()); assertEquals(BigInteger.valueOf(3), node.bigIntegerValue().shortValue()); assertEquals(BigInteger.valueOf(4), node.bigIntegerValue().shortValue()); assertEquals(BigInteger.valueOf(5), node.bigIntegerValue().shortValue
@Test public void testBigIntegerValue() { String[][] lines = new String[][] { new String[] {"1", "1"}, new String[] {"1.1", "1.1"}, new String[] {"1.1", "1.1"}, new String[] {"1.1", "1.1"}, new String[] {"1.1", "1.1"}, new String[] {"1.1", "1.1"}, new String[] {"1.1", "1.1"}, new String[] {"1.1", "1.1"}, new String[] {"1.1", "1.1"}, new String[] {"
@Test public void testAsText() { ShortNode shortNode = ShortNode.valueOf((short)1); shortNode.valueOf(2); shortNode.valueOf(3); shortNode.valueOf(4); shortNode.valueOf(5); shortNode.valueOf(6); shortNode.valueOf(7); shortNode.valueOf(8); shortNode.valueOf(9); shortNode.valueOf(10); shortNode.valueOf(11); shortNode.valueOf(12); shortNode.valueOf(13); shortNode.valueOf(14); shortNode.valueOf(15); shortNode.valueOf(16); shortNode.value
@Test public void testAsText() { ShortNode n = ShortNode.valueOf((short)1); n.setValue(Short.valueOf(1)); assertEquals("1", n.asText()); n.setValue((short)2); assertEquals("2", n.asText()); n.setValue((short)3); assertEquals("3", n.asText()); n.setValue((short)4); assertEquals("4", n.asText()); n.setValue((short)5); assertEquals("5", n.asText()); n.setValue((short)6); assertEquals("6", n.asText()); n.setValue((short)7
@Test public void equals() { ShortNode n = ShortNode.valueOf((short) 0); ShortNode n2 = ShortNode.valueOf((short) 0); ShortNode n3 = ShortNode.valueOf((short) 1); ShortNode n4 = ShortNode.valueOf((short) 2); ShortNode n5 = ShortNode.valueOf((short) 3); ShortNode n6 = ShortNode.valueOf((short) 4); assertEquals(n.shortValue(), n.shortValue()); assertEquals(n.shortValue(), n2.shortValue()); assertEquals(n.shortValue(), n3.shortValue()); assertEquals(n.shortValue(), n4.
@Test public void testEquals() { ShortNode v1 = ShortNode.valueOf((short) 0); ShortNode v2 = ShortNode.valueOf((short) 1); ShortNode v3 = ShortNode.valueOf((short) 2); ShortNode v4 = ShortNode.valueOf((short) 3); ShortNode v5 = ShortNode.valueOf((short) 4); ShortNode v6 = ShortNode.valueOf((short) 5); ShortNode v7 = ShortNode.valueOf((short) 6); ShortNode v8 = ShortNode.valueOf((short) 8); ShortNode v9 = ShortNode.valueOf((short) 9); ShortNode v10 =
@Test public void testEquals() { ShortNode v1 = ShortNode.valueOf((short) 0); ShortNode v2 = ShortNode.valueOf((short) 1); ShortNode v3 = ShortNode.valueOf((short) 2); ShortNode v4 = ShortNode.valueOf((short) 3); ShortNode v5 = ShortNode.valueOf((short) 4); ShortNode v6 = ShortNode.valueOf((short) 5); ShortNode v7 = ShortNode.valueOf((short) 6); ShortNode v8 = ShortNode.valueOf((short) 8); ShortNode v9 = ShortNode.valueOf((short) 9); ShortNode v10 =
@Test public void testEquals() { ShortNode n = ShortNode.valueOf((short) 0); ShortNode n2 = ShortNode.valueOf((short) 0); ShortNode n3 = ShortNode.valueOf((short) 1); ShortNode n4 = ShortNode.valueOf((short) 2); ShortNode n5 = ShortNode.valueOf((short) 3); ShortNode n6 = ShortNode.valueOf((short) 4); ShortNode n7 = ShortNode.valueOf((short) 5); ShortNode n8 = ShortNode.valueOf((short) 6); ShortNode n9 = ShortNode.valueOf((short) 7); assertEquals(n, n
@Test public void testEquals() { ShortNode n = ShortNode.valueOf((short) 0); ShortNode n2 = ShortNode.valueOf((short) 0); ShortNode n3 = ShortNode.valueOf((short) 1); ShortNode n4 = ShortNode.valueOf((short) 2); ShortNode n5 = ShortNode.valueOf((short) 3); ShortNode n6 = ShortNode.valueOf((short) 4); ShortNode n7 = ShortNode.valueOf((short) 5); ShortNode n8 = ShortNode.valueOf((short) 6); ShortNode n9 = ShortNode.valueOf((short) 7); assertEquals(n, n
@Test public void testHashCode() { ShortNode n = ShortNode.valueOf((short) 1); ShortNode n2 = ShortNode.valueOf((short) 2); ShortNode n3 = ShortNode.valueOf((short) 3); ShortNode n4 = ShortNode.valueOf((short) 4); ShortNode n5 = ShortNode.valueOf((short) 5); assertEquals(n.hashCode(), n.hashCode()); assertEquals(n.hashCode(), n2.hashCode()); assertEquals(n.hashCode(), n3.hashCode()); assertEquals(n.hashCode(), n4.hashCode()); assertEquals(n.hashCode(), n5.
@Test public void testHashCode() { ShortNode n = ShortNode.valueOf((short) 1); ShortNode n2 = ShortNode.valueOf((short) 2); ShortNode n3 = ShortNode.valueOf((short) 3); ShortNode n4 = ShortNode.valueOf((short) 4); ShortNode n5 = ShortNode.valueOf((short) 5); assertEquals(n.hashCode(), n.hashCode()); assertEquals(n.hashCode(), n2.hashCode()); assertEquals(n.hashCode(), n3.hashCode()); assertEquals(n.hashCode(), n4.hashCode()); assertEquals(n.hashCode(), n5.
@Test public void testIteratorSerializer() { List<String> a = Arrays.asList("a", "b", "c"); List<String> b = Arrays.asList("d", "e", "f"); ListSerializer vts = new ListSerializer(Arrays.asList(String.class, String.class), vts); BeanProperty property = Mockito.mock(BeanProperty.class); Mockito.doReturn(a).when(property).getType(); Mockito.doReturn(b).when(property).getType(); Mockito.doReturn(true).when(property).isStatic(); Mockito.doReturn(true).when(property).isResolved(); Mockito
@Test public void testIteratorSerializer() { List<String> a = Arrays.asList("a", "b", "c"); List<String> b = Arrays.asList("d", "e", "f"); List<String> c = Arrays.asList("g", "h", "i"); ListSerializer vts = new ListSerializer(vts); BeanProperty property = mock(BeanProperty.class); TypeSerializer vts2 = mock(TypeSerializer.class); TypeSerializer vts3 = mock(TypeSerializer.class); when(vts2.getClassName()).thenReturn(String.class); when(vts3.getClassName()).thenReturn(String.class
@Test public void testWithResolved() throws Exception { Set<String> set = new HashSet<String>(); set.add("a"); set.add("b"); Set<String> set2 = new HashSet<String>(); set2.add("c"); Set<String> set3 = new HashSet<String>(); set3.add("d"); Set<String> set4 = new HashSet<String>(); set4.add("e"); SetSerializer vts = new SetSerializer(Sets.newHashSet(set, set2, set3, set4)); TypeSerializer vts2 = new TypeSerializer(Set.class); TypeSerializer vts3 = new TypeSerializer(Set.class);
@Test public void testIteratorSerializer() throws Exception { Set<String> set = new HashSet<String>(); set.add("a"); set.add("b"); Set<String> set2 = new HashSet<String>(); set2.add("c"); Set<String> set3 = new HashSet<String>(); set3.add("d"); Set<String> set4 = new HashSet<String>(); set4.add("e"); Set<String> set5 = new HashSet<String>(); set5.add("f"); set6.add("g"); set.add("h"); set.add("i"); TypeSerializer vts = new TypeSerializer(Set.class, set
@Test public void typedValueSerializer() throws Exception { JsonSerializer<Object> serializer = ReadOnlyClassToSerializerMap.instance().typedValueSerializer(String.class); assertTrue(serializer instanceof StringSerializer); assertSame(serializer, ReadOnlyClassToSerializerMap.instance().typedValueSerializer(String.class)); assertSame(serializer, ReadOnlyClassToSerializerMap.instance().typedValueSerializer(String.class)); }
@Test public void typedValueSerializer() { ReadOnlyClassToSerializerMap classMap = ReadOnlyClassToSerializerMap.from(Collections.emptyMap()); JsonSerializer<Object> serializer1 = classMap.typedValueSerializer(String.class); JsonSerializer<Object> serializer2 = classMap.typedValueSerializer(String.class); assertSame(serializer1, serializer2); }
@Test public void testBeanSerializerFactory() throws Exception { String json = "{\\n" + " \\"serializers\\": [\\n" + " {\\n" + " \\"type\\": \\"byte\\",\\n" + " \\"id\\": \\"byte\\",\\n" + " \\"serializers\\": [\\n" + " {\\n" + " \\"type\\": \\"byte\\",\\n" + " \\"id\\": \\"int\\",\\n" + " \\"serializers\\": [\\n" + " {\\n" + " \\"type\\": \\"byte\\",\\n"
@Test public void testFindBeanSerializer() throws Exception { String json = "{\\n" + " \\"class\\" : \\"uk.gov.gchq.gaffer.serializers.test.TestBean\\",\\n" + " \\"serializers\\" : [\\n" + " {\\n" + " \\"class\\" : \\"uk.gov.gchq.gaffer.serializers.test.CustomSerializerProvider\\",\\n" + " \\"serializers[0].class\\" : \\"uk.gov.gchq.gaffer.serializers.test.CustomSerializerProvider\\",\\n" + "
@Test public void testWithConfig() { SerializerFactoryConfig config = new SerializerFactoryConfig(); config.setSerializers(Arrays.asList(new TestBeanSerializerProvider(), new TestBeanSerializerProvider())); BeanSerializerFactory serializerFactory = new BeanSerializerFactory(config).withConfig(config); assertTrue(serializerFactory instanceof TestBeanSerializerFactory); serializerFactory = serializerFactory.withConfig(config); assertTrue(serializerFactory instanceof TestBeanSerializerFactory); serializerFactory = serializerFactory.withConfig(config); assertTrue(serializerFactory instanceof TestBeanSerializerFactory); serializerFactory = serializerFactory.withConfig(config); assertTrue(serializerFactory instanceof TestBeanSerializerFactory); }
@Test public void testWithConfig() { SerializerFactoryConfig config = new SerializerFactoryConfig(); config.setSerializers(Arrays.asList(new TestBeanSerializerProvider(), new TestBeanSerializerProvider())); BeanSerializerFactory factory = new BeanSerializerFactory(config) { @Override protected Serializer createSerializer(SerializerProvider provider, JavaType type, SerializationConfig config, AnnotatedMember accessor) throws JsonMappingException { return new TestBeanSerializer(provider, type, accessor); } }; JsonSerializer<Object> serializer = factory.withConfig(config); assertTrue(serializer instanceof TestBeanSerializer); serializer = factory.withConfig(config); assertTrue(serializer instanceof TestBeanSerializer); serializer = factory.withConfig(config
@Test public void testFindBeanSerializer() throws Exception { SimpleSerializerProvider provider = new SimpleSerializerProvider(); BeanDescription type = new BeanDescription("org.apache.cxf.tools.fortest.testclasses.TestBean", null); TypeSerializer ts = _factory.findPropertyTypeSerializer(provider, type, type); assertNotNull(ts); assertTrue(ts instanceof TestBeanSerializer); }
@Test public void testFindBeanSerializer() throws Exception { String json = "{\\n" + " \\"serializers\\": [\\n" + " {\\n" + " \\"type\\": \\"byte\\",\\n" + " \\"name\\": \\"byte\\",\\n" + " \\"version\\": 1,\\n" + " \\"serializers\\": [\\n" + " {\\n" + " \\"type\\": \\"byte\\",\\n" + " \\"name\\": \\"byte\\",\\n" + " \\"version\\": 1,\\n" + " \\"serializers\\": [
@Test public void testCreateSerializer() throws Exception { SimpleSerializerProvider prov = new SimpleSerializerProvider(); prov.setConfig(new SerializationConfig()); SimpleSerializer s1 = new SimpleSerializer(SimpleSerializerProvider.class.getClassLoader(), "s1"); SimpleSerializer s2 = new SimpleSerializer(SimpleSerializerProvider.class.getClassLoader(), "s2"); SimpleSerializer s3 = new SimpleSerializer(SimpleSerializerProvider.class.getClassLoader(), "s3"); SimpleSerializer s4 = new SimpleSerializer(SimpleSerializerProvider.class.getClassLoader(), "s4"); SimpleSerializer s5 = new SimpleSerializer(SimpleSerializerProvider.class.getClassLoader(), "s5"); SimpleSerializer s6 = new SimpleSerializer
@Test public void testCreateSerializer() throws Exception { SimpleSerializerProvider prov = new SimpleSerializerProvider(); JavaType type = JavaType.get(String.class); JsonSerializer<String> ser1 = new StdDelegatingSerializer(prov, type, null); JsonSerializer<String> ser2 = new StdDelegatingSerializer(prov, type, null); JsonSerializer<String> ser3 = new StdDelegatingSerializer(prov, type, null); JsonSerializer<String> ser4 = new StdDelegatingSerializer(prov, type, null); JsonSerializer<String> ser5 = new StdDelegatingSerializer(prov, type, null); JsonSerializer<String> ser6 = new StdDelegatingSerializer(
@Test public void testCustomSerializer() throws Exception { SimpleSerializerProvider prov = new SimpleSerializerProvider(); SimpleBean bean = new SimpleBean(); bean.setBeanClass(SimpleBean.class); BeanDescription desc = new BeanDescription("testBean", SimpleBean.class); BeanSerializerModifier mod = new BeanSerializerModifier(bean.getClass().getAnnotation(SimpleBean.class), null); mod.modifySerializer(prov, desc, bean); SimpleSerializer s = (SimpleSerializer) _factory.createSerializer2(prov, bean.getClass(), desc, true); assertTrue(s instanceof SimpleBeanSerializer); s = (SimpleBeanSerializer) _factory.createSerializer2(prov, bean.getClass(),
@Test public void testCustomSerializer() throws Exception { SimpleSerializerProvider prov = new SimpleSerializerProvider(); SimpleBean bean = new SimpleBean(); bean.setBeanClass(Foo.class); BeanDescription beanDesc = new BeanDescription(); beanDesc.setBeanClass(Bar.class); beanDesc.setBeanDesc(bean); SimpleSerializer SER = new SimpleSerializer(); SimpleSerializerModifier mod = new SimpleSerializerModifier(); mod.addSerializer(bean, SER, null); prov.getConfig().setCustomSerializers(Lists.newArrayList(new SimpleSerializers() { @Override public JsonSerializer buildSerializer( SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping) { return SER
@Test public void testFindPropertyTypeSerializer() throws Exception { SimpleSerializerProvider prov = new SimpleSerializerProvider(); Class<?> baseType = String.class; Class<?> subtype = String.class; MockSerializationConfig config = new MockSerializationConfig(); config.setSerializerProvider(prov); config.setSubtypes(Arrays.asList(baseType, subtype)); MockAnnotatedMember accessor = new MockAnnotatedMember(baseType, accessor); TypeSerializer serializer = factory.findPropertyTypeSerializer(baseType, config, accessor); assertTrue(serializer instanceof StringSerializer); assertSame(provider, serializer.getProvider()); assertSame(baseType, serializer.getType()); assertSame(subtype, serializer.getType());
@Test public void testFindPropertyTypeSerializer() throws Exception { SimpleSerializerProvider prov = new SimpleSerializerProvider(); Class<?> baseType = String.class; MockSerializationConfig config = new MockSerializationConfig(); config.addSerializerProvider(prov); TypeSerializer serializer = factory.findPropertyTypeSerializer(baseType, config, null); assertTrue(serializer instanceof StringSerializer); serializer = factory.findPropertyTypeSerializer(baseType, config, null); assertTrue(serializer instanceof StringSerializer); config.addSerializerProvider(prov); serializer = factory.findPropertyTypeSerializer(baseType, config, null); assertTrue(serializer instanceof StringSerializer); config.addSerializerProvider(prov); serializer = factory.findPropertyTypeSerializer(baseType, config
@Test public void constructBeanSerializer() throws JsonMappingException { SimpleSerializerProvider prov = new SimpleSerializerProvider(); SimpleSerializerProvider.Config config = new SimpleSerializerProvider.Config(); config.addBeanSerializerModifier(new BeanSerializerModifier() { @Override public void orderProperties(SerializationConfig config, BeanDescription beanDesc, List<BeanPropertyWriter> properties) throws JsonMappingException { properties.add(new BeanPropertyWriter() { @Override public void fixProperties(SerializationConfig config, BeanDescription beanDesc, List<BeanPropertyWriter> properties) throws JsonMappingException { super.fixProperties(config, beanDesc, properties); } @Override public JavaType getType(BeanDescription beanDesc) { return JavaType.
@Test public void testGetters() throws JsonMappingException { SimpleSerializerProvider prov = new SimpleSerializerProvider(); SimpleSerializerProvider.Config config = new SimpleSerializerProvider.Config(); SimpleBean bean = new SimpleBean(); bean.setBeanClass(SimpleBean.class); BeanDescription desc = new BeanDescription(bean, SimpleBean.class); desc.setConfig(config); JsonSerializer<SimpleBean> serialiser = new JsonSerializer<SimpleBean>() { @Override public JsonSerializer<SimpleBean> constructBeanSerializer(SerializerProvider provider, BeanDescription desc) throws JsonMappingException { return serialiser; } }; SimpleBean bean2 = new SimpleBean(); bean2.setBeanClass(SimpleBean.
@Test public void constructBeanSerializer() throws JsonMappingException { SimpleSerializerProvider prov = new SimpleSerializerProvider(); SimpleSerializerProvider.Config config = new SimpleSerializerProvider.Config(); config.addBeanSerializerModifier(new BeanSerializerModifier() { @Override public void orderProperties(SerializationConfig config, BeanDescription beanDesc, List<BeanPropertyWriter> properties) throws JsonMappingException { properties.add(new BeanPropertyWriter() { @Override public void fixProperties(SerializationConfig config, BeanDescription beanDesc, List<BeanPropertyWriter> properties) throws JsonMappingException { super.fixProperties(config, beanDesc, properties); } @Override public JavaType getType(BeanDescription beanDesc) { return JavaType.
@Test public void testGetters() throws JsonMappingException { SimpleSerializerProvider prov = new SimpleSerializerProvider(); SimpleSerializerProvider.Builder builder = new SimpleSerializerProvider.Builder(); SimpleSerializerProvider.Builder builder2 = new SimpleSerializerProvider.Builder(); SimpleSerializerProvider.Builder builder3 = new SimpleSerializerProvider.Builder(); SimpleSerializerProvider.Builder builder4 = new SimpleSerializerProvider.Builder(); SimpleSerializerProvider.Builder builder5 = new SimpleSerializerProvider.Builder(); SimpleSerializerProvider.Builder builder6 = new SimpleSerializerProvider.Builder(); SimpleSerializerProvider.Builder builder7 = new SimpleSerializerProvider.Builder(); SimpleSerializerProvider.Builder builder8 = new SimpleSerializerProvider.Builder(); SimpleSerializerProvider.Builder builder
@Test public void constructBeanSerializer() throws JsonMappingException { SimpleSerializerProvider prov = new SimpleSerializerProvider(); SimpleSerializerProvider.Config config = new SimpleSerializerProvider.Config(); config.addBeanSerializerModifier(new BeanSerializerModifier() { @Override public void orderProperties(SerializationConfig config, BeanDescription beanDesc, List<BeanPropertyWriter> properties) throws JsonMappingException { properties.add(new BeanPropertyWriter() { @Override public void fixProperties(SerializationConfig config, BeanDescription beanDesc, List<BeanPropertyWriter> properties) throws JsonMappingException { super.fixProperties(config, beanDesc, properties); } @Override public JavaType getType(BeanDescription beanDesc) { return JavaType.
@Test public void constructSimpleSerializer() throws JsonMappingException { SimpleSerializerProvider prov = new SimpleSerializerProvider(); SimpleSerializerBuilder builder = new SimpleSerializerBuilder(); SimpleBean bean = new SimpleBean(); bean.setBeanClass(SimpleBean.class); builder.addBean(bean); JsonSerializer<SimpleBean> SERVLET = builder.build(); SimpleBean bean2 = new SimpleBean(); bean2.setBeanClass(SimpleBean.class); builder.addBean(bean2); SimpleBean bean3 = new SimpleBean(); bean3.setBeanClass(SimpleBean.class); builder.addBean(bean3); SimpleBean bean4 = new SimpleBean(); bean4.setBeanClass(Simple
@Test public void testConstructObjectIdHandler() throws JsonMappingException { SimpleSerializerProvider prov = new SimpleSerializerProvider(); SimpleBean bean = new SimpleBean(); bean.setBeanClass(SimpleBean.class); BeanDescription beanDesc = new BeanDescription(); beanDesc.setClassName(SimpleBean.class.getName()); beanDesc.setObjectIdInfo(new SimpleObjectIdInfo(SimpleBean.class.getName(), SimpleBean.class.getName())); List<BeanPropertyWriter> list = new ArrayList<BeanPropertyWriter>(); list.add(new BeanPropertyWriter(SimpleBean.class.getName(), SimpleBean.class.getName())); list.add(new BeanPropertyWriter(SimpleBean.class.getName(),
@Test public void testConstructObjectIdHandler() throws JsonMappingException { SimpleSerializerProvider prov = new SimpleSerializerProvider(); SimpleBean bean = new SimpleBean(); bean.setBeanClass(SimpleBean.class); ObjectIdInfo objectIdInfo = new ObjectIdInfo(SimpleBean.class, SimpleBean.class.getName()); bean.setObjectIdInfo(objectIdInfo); List<BeanPropertyWriter> propList = new ArrayList<BeanPropertyWriter>(); propList.add(new BeanPropertyWriter(SimpleBean.class.getName(), SimpleBean.class.getName())); propList.add(new BeanPropertyWriter(SimpleBean.class.getName(), SimpleBean.class.getName())); ObjectIdWriter writer1 = new Simple
@Test public void constructObjectIdHandler() throws Exception { SimpleSerializerProvider mockProv = new SimpleSerializerProvider(); BeanDescription beanDesc = new BeanDescription(); BeanPropertyWriter writer1 = new BeanPropertyWriter(); BeanPropertyWriter writer2 = new BeanPropertyWriter(); BeanPropertyWriter writer3 = new BeanPropertyWriter(); List<BeanPropertyWriter> list = new ArrayList<BeanPropertyWriter>(); list.add(writer1); list.add(writer2); list.add(writer3); ObjectIdWriter idWriter1 = new SimpleObjectIdGenerator(); ObjectIdWriter idWriter2 = new SimpleObjectIdGenerator(); ObjectIdWriter idWriter3 = new SimpleObjectIdGenerator(); ObjectIdInfo idInfo = new SimpleObjectIdInfo(); idInfo.
@Test public void constructObjectIdHandler() throws JsonMappingException { SimpleSerializerProvider prov = new SimpleSerializerProvider(); SimpleBean bean = new SimpleBean(); BeanPropertyWriter writer1 = new BeanPropertyWriter(); BeanPropertyWriter writer2 = new BeanPropertyWriter(); List<BeanPropertyWriter> list = new ArrayList<BeanPropertyWriter>(); list.add(writer1); list.add(writer2); ObjectIdInfo objectIdInfo = new ObjectIdInfo(); objectIdInfo.setClassName(SimpleBean.class.getName()); ObjectIdInfo objectIdInfo = new ObjectIdInfo(); objectIdInfo.setClassName(SimpleBean.class.getName()); list.add(objectIdInfo); bean.setObjectIdInfo(objectIdInfo); ObjectId
@Test public void testRemoveIgnorableTypes() throws Exception { SimpleSerializerProvider prov = new SimpleSerializerProvider(); SimpleSerializerProvider prov2 = new SimpleSerializerProvider(); SimpleSerializerProvider prov3 = new SimpleSerializerProvider(); SimpleSerializerProvider prov4 = new SimpleSerializerProvider(); SimpleSerializerProvider prov5 = new SimpleSerializerProvider(); SimpleSerializerProvider prov6 = new SimpleSerializerProvider(); SimpleSerializerProvider prov7 = new SimpleSerializerProvider(); SimpleSerializerProvider prov8 = new SimpleSerializerProvider(); SimpleSerializerProvider prov9 = new SimpleSerializerProvider(); SimpleSerializerProvider prov10 = new SimpleSerializerProvider(); SimpleSerializerProvider prov11 = new SimpleSerializerProvider(); SimpleSerializerProvider prov12 = new SimpleSerializerProvider(); SimpleSerializerProvider
@Test public void testObjectIdGenerator() throws JsonMappingException { ObjectIdInfo objectIdInfo = new ObjectIdInfo(); ObjectIdGenerator<Integer> gen1 = mapper.objectIdGeneratorInstance(this.annotated, objectIdInfo); ObjectIdGenerator<Integer> gen2 = mapper.objectIdGeneratorInstance(this.annotated, objectIdInfo); ObjectIdGenerator<Integer> gen3 = mapper.objectIdGeneratorInstance(this.annotated, objectIdInfo); ObjectIdGenerator<Integer> gen4 = mapper.objectIdGeneratorInstance(this.annotated, objectIdInfo); ObjectIdGenerator<Integer> gen5 = mapper.objectIdGeneratorInstance(this.annotated, objectIdInfo); ObjectIdGenerator<Integer> gen6 = mapper.
@Test public void testObjectIdGeneratorInstance() throws JsonMappingException { ObjectIdInfo objectIdInfo = new ObjectIdInfo(); ObjectIdGenerator<?> gen1 = mapper.objectIdGeneratorInstance(null, objectIdInfo); ObjectIdGenerator<?> gen2 = mapper.objectIdGeneratorInstance(null, objectIdInfo); ObjectIdGenerator<?> gen3 = mapper.objectIdGeneratorInstance(null, objectIdInfo); ObjectIdGenerator<?> gen4 = mapper.objectIdGeneratorInstance(null, objectIdInfo); ObjectIdGenerator<?> gen5 = mapper.objectIdGeneratorInstance(null, objectIdInfo); ObjectIdGenerator<?> gen6 = mapper.objectIdGeneratorInstance(null, objectIdInfo); ObjectIdGenerator<?> gen7 = mapper.object
@Test public void testObjectIdGeneratorInstance() throws JsonMappingException { ObjectIdInfo objectIdInfo = new ObjectIdInfo(); ObjectIdGenerator<?> gen1 = config.objectIdGeneratorInstance(null, objectIdInfo); ObjectIdGenerator<?> gen2 = config.objectIdGeneratorInstance(null, objectIdInfo); ObjectIdGenerator<?> gen3 = config.objectIdGeneratorInstance(null, objectIdInfo); ObjectIdGenerator<?> gen4 = config.objectIdGeneratorInstance(null, objectIdInfo); ObjectIdGenerator<?> gen5 = config.objectIdGeneratorInstance(null, objectIdInfo); ObjectIdGenerator<?> gen6 = config.objectIdGeneratorInstance(null, objectIdInfo); ObjectIdGenerator<?> gen7 = config.objectId
@Test public void testObjectIdGeneratorInstance() throws JsonMappingException { ObjectIdInfo objectIdInfo = new ObjectIdInfo(); ObjectIdGenerator<?> gen1 = config.objectIdGeneratorInstance(annotated, objectIdInfo); ObjectIdGenerator<?> gen2 = config.objectIdGeneratorInstance(annotated, objectIdInfo); ObjectIdGenerator<?> gen3 = config.objectIdGeneratorInstance(annotated, objectIdInfo); ObjectIdGenerator<?> gen4 = config.objectIdGeneratorInstance(annotated, objectIdInfo); ObjectIdGenerator<?> gen5 = config.objectIdGeneratorInstance(annotated, objectIdInfo); ObjectIdGenerator<?> gen6 = config.objectIdGeneratorInstance(annotated, objectIdInfo); assertEquals(gen1
@Test public void testObjectIdGeneratorInstance() throws JsonMappingException { ObjectIdInfo objectIdInfo = new ObjectIdInfo(); ObjectIdGenerator<Integer> gen1 = config.objectIdGeneratorInstance(null, objectIdInfo); ObjectIdGenerator<Integer> gen2 = config.objectIdGeneratorInstance(null, objectIdInfo); ObjectIdGenerator<Integer> gen3 = config.objectIdGeneratorInstance(null, objectIdInfo); ObjectIdGenerator<Integer> gen4 = config.objectIdGeneratorInstance(null, objectIdInfo); ObjectIdGenerator<Integer> gen5 = config.objectIdGeneratorInstance(null, objectIdInfo); ObjectIdGenerator<Integer> gen6 = config.objectIdGeneratorInstance(null, objectIdInfo); ObjectIdGenerator<Integer
@Test public void testObjectIdGeneratorInstance() throws JsonMappingException { ObjectIdInfo objectIdInfo = new ObjectIdInfo(); ObjectIdGenerator<Integer> gen1 = mapper.objectIdGeneratorInstance(null, objectIdInfo); ObjectIdGenerator<Integer> gen2 = mapper.objectIdGeneratorInstance(null, objectIdInfo); ObjectIdGenerator<Integer> gen3 = mapper.objectIdGeneratorInstance(null, objectIdInfo); ObjectIdGenerator<Integer> gen4 = mapper.objectIdGeneratorInstance(null, objectIdInfo); ObjectIdGenerator<Integer> gen5 = mapper.objectIdGeneratorInstance(null, objectIdInfo); ObjectIdGenerator<Integer> gen6 = mapper.objectIdGeneratorInstance(null, objectIdInfo); ObjectIdGenerator<Integer>
@Test public void testObjectIdGeneratorInstance() throws JsonMappingException { ObjectIdInfo objectIdInfo = new ObjectIdInfo(); ObjectIdGenerator<?> gen1 = mapper.objectIdGeneratorInstance(null, objectIdInfo); ObjectIdGenerator<?> gen2 = mapper.objectIdGeneratorInstance(null, objectIdInfo); ObjectIdGenerator<?> gen3 = mapper.objectIdGeneratorInstance(null, objectIdInfo); ObjectIdGenerator<?> gen4 = mapper.objectIdGeneratorInstance(null, objectIdInfo); ObjectIdGenerator<?> gen5 = mapper.objectIdGeneratorInstance(null, objectIdInfo); ObjectIdGenerator<?> gen6 = mapper.objectIdGeneratorInstance(null, objectIdInfo); ObjectIdGenerator<?> gen7 = mapper.object
@Test public void testObjectIdGeneratorInstance() throws JsonMappingException { ObjectIdInfo objectIdInfo = new ObjectIdInfo(); ObjectIdGenerator<?> gen1 = config.objectIdGeneratorInstance(null, objectIdInfo); ObjectIdGenerator<?> gen2 = config.objectIdGeneratorInstance(null, objectIdInfo); ObjectIdGenerator<?> gen3 = config.objectIdGeneratorInstance(null, objectIdInfo); ObjectIdGenerator<?> gen4 = config.objectIdGeneratorInstance(null, objectIdInfo); ObjectIdGenerator<?> gen5 = config.objectIdGeneratorInstance(null, objectIdInfo); ObjectIdGenerator<?> gen6 = config.objectIdGeneratorInstance(null, objectIdInfo); ObjectIdGenerator<?> gen7 = config.object
@Test public void testCall() throws Exception { String[][] tests = new String[][] { new String[] { "1" }, new String[] { "2" }, new String[] { "3" }, new String[] { "4" }, new String[] { "5" }, new String[] { "6" }, new String[] { "7" }, new String[] { "8" }, new String[] { "9" }, new String[] { "10" }, new String[] { "11" }, new String[] { "12" }, new String[] { "13" }, new String[] { "14" }, new String[] { "15" }, new String[] { "16
@Test public void testCustomConstructor() throws Exception { Class<?> c = Class.forName("com.foo.Bar"); Constructor<?> c2 = c.getConstructor(); assertEquals(c2.getClass(), c.getRawType()); assertEquals(c2.getType(TypeBindings.EMPTY), c.getType(TypeBindings.EMPTY)); assertEquals(c2.call(new Object[0]), c.call(new Object[0])); assertEquals(c2.call(new Object[0]), c.call(new Object[0])); assertEquals(c2.call(new Object[0]), c.call(new Object[0])
@Test public void collectionSerializer() { ContainerSerializer<?> serializer = StdContainerSerializers.collectionSerializer(String.class, true, vts, new JsonSerializer<String>() { @Override public String serialize(String obj) { return obj; } }); assertEquals(Arrays.asList("a", "b", "c"), serializer.getValues()); serializer = StdContainerSerializers.collectionSerializer(String.class, false, vts, new JsonSerializer<String>() { @Override public String serialize(String obj) { return obj; } }); assertEquals(Arrays.asList("a", "b", "c"), serializer.getValues()); serializer = StdContainerSerializers.collection
@Test public void testCollectionSerializer() { ContainerSerializer<?> serializer = StdContainerSerializers.collectionSerializer(String.class, false, vts, new JsonSerializer<String>() { @Override public String serialize(Object obj) { return obj.toString(); } }); assertEquals("[\\n" + " \\"a\\",\\n" + " \\"b\\",\\n" + " \\"c\\",\\n" + " \\"d\\",\\n" + " \\"e\\",\\n" + " \\"f\\",\\n" + " \\"g\\",\\n" + " \\"h\\",\\n" + " \\"
@Test public void testIteratorSerializer() { ContainerSerializer<?> serializer = StdContainerSerializers.iteratorSerializer(String.class, true, vts); assertTrue(serializer.getSerializer() instanceof IteratorSerializer); serializer = StdContainerSerializers.iteratorSerializer(String.class, false, vts); assertTrue(serializer.getSerializer() instanceof ListSerializer); serializer = StdContainerSerializers.iteratorSerializer(String.class, true, vts); assertTrue(serializer.getSerializer() instanceof ListSerializer); serializer = StdContainerSerializers.iteratorSerializer(String.class, false, vts); assertTrue(serializer.getSerializer() instanceof ListSerializer); serializer = StdContainerSerializers.iteratorSerializer(String
@Test public void testIteratorSerializer() { ContainerSerializer<?> serializer = StdContainerSerializers.iteratorSerializer(String.class, true, vts); assertTrue(serializer.equals(new IteratorSerializer(String.class, true, vts, null))); serializer = StdContainerSerializers.iteratorSerializer(String.class, false, vts); assertTrue(serializer.equals(new IteratorSerializer(String.class, true, vts, null))); serializer = StdContainerSerializers.iteratorSerializer(String.class, false, vts); assertTrue(serializer.equals(new IteratorSerializer(String.class, false, vts, null))); serializer = StdContainerSerializers.iteratorSerializer
@Test public void testIterableSerializer() { ContainerSerializer<?> serializer = StdContainerSerializers.iterableSerializer(String.class, true, vts); assertTrue(serializer.getSerializer() instanceof IterableSerializer); serializer = StdContainerSerializers.iterableSerializer(String.class, false, vts); assertTrue(serializer.getSerializer() instanceof ListSerializer); serializer = StdContainerSerializers.iterableSerializer(String.class, true, vts); assertTrue(serializer.getSerializer() instanceof ListSerializer); serializer = StdContainerSerializers.iterableSerializer(String.class, false, vts); assertTrue(serializer.getSerializer() instanceof ListSerializer); serializer = StdContainerSerializers.iterableSerializer(String
@Test public void testIterableSerializer() { ContainerSerializer<?> serializer = StdContainerSerializers.iterableSerializer(String.class, true, vts); assertTrue(serializer.equals(new IterableSerializer(String.class, true, vts))); serializer = StdContainerSerializers.iterableSerializer(String.class, false, vts); assertTrue(serializer.equals(new IterableSerializer(String.class, false, vts))); serializer = StdContainerSerializers.iterableSerializer(String.class, true, vts); assertTrue(serializer.equals(new IterableSerializer(String.class, true, vts))); serializer = StdContainerSerializers.iterableSerializer(String.class, false
@Test public void testEnumSetSerializer() { Set<String> enumValues = new HashSet<String>(); enumValues.add("AAA"); enumValues.add("BBB"); enumValues.add("CCC"); Class<?> type = EnumSet.class; JsonSerializer<?> serializer = EnumSetSerializer.enumSetSerializer(type); Set<String> result = serializer.serialize(enumValues); assertEquals(Arrays.asList("AAA", "BBB", "CCC"), result); result = serializer.deserialize(new ByteArrayInputStream(result.toArray())); assertEquals(Arrays.asList("AAA", "BBB", "CCC"), result); }
@Test public void testEnumSetSerializer() { Set<String> actual; actual = EnumSetSerializer.enumSetSerializer(String.class).serialize(actual); assertEquals(actual, Sets.newHashSet("a", "b", "c")); actual = EnumSetSerializer.enumSetSerializer(String.class).serialize(actual); assertEquals(actual, Sets.newHashSet("a", "b", "c")); actual = EnumSetSerializer.enumSetSerializer(String.class).serialize(actual); assertEquals(actual, Sets.newHashSet("a", "b", "c")); actual = EnumSetSerializer.enumSetSerializer(String.class).serialize(actual); assertEquals(actual, Sets.
@Test public void testRawSerializer() throws Exception { ObjectMapper mapper = new ObjectMapper(); Map<String, Object> data = new LinkedHashMap<String, Object>(); data.put("a", 1); data.put("b", 2); data.put("c", 3); ObjectMapper mapper = new ObjectMapper(mapper); RawSerializer rawSerializer = new RawSerializer(String.class); String result = mapper.writeValueAsString(rawSerializer); Assert.assertEquals(result, "{\\"a\\":1,\\"b\\":2,\\"c\\":3}"); result = mapper.readValue(result, RawSerializer.class); Assert.assertEquals(result, "{\\"a\\":1,\\"b\\
@Test public void testRawSerializer() throws IOException, JsonGenerationException { ObjectMapper mapper = new ObjectMapper(); Map<String, Object> data = new HashMap<String, Object>(); data.put("key1", "value1"); data.put("key2", "value2"); data.put("key3", "value3"); mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL); value.put("key4", "value4"); value.put("key5", "value5"); value.put("key6", "value6"); mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL); value.put("key7", "value7"); value.
@Test public void parseNull() throws Exception { JsonDeserializer<?> deserializer = find(null, "NULL"); assertNull(deserializer); deserializer = find(String.class, "NULL"); assertNull(deserializer); deserializer = find(String.class, "NULL"); assertNull(deserializer); }
@Test public void parseNull() throws Exception { JsonDeserializer<?> deserializer = find(Null.class, "NULL"); Assert.assertNull(deserializer); deserializer = find(null, "NULL"); Assert.assertNull(deserializer); }
@Test public void parseNull() throws Exception { JsonDeserializer<?> deserializer = find(null, "NULL"); assertNull(deserializer); deserializer = find(Byte.class, "NULL"); assertNull(deserializer); deserializer = find(Byte.class, "NULL"); assertNull(deserializer); deserializer = find(Byte.class, "NULL"); assertNull(deserializer); }
@Test public void parseNull() throws Exception { JsonDeserializer<?> deserializer = find(null, "NULL"); assertNull(deserializer); deserializer = find(Byte.TYPE, "NULL"); assertNull(deserializer); deserializer = find(Byte.class, "NULL"); assertNull(deserializer); deserializer = find(Byte.class, "NULL"); assertNull(deserializer); }
@Test public void parseNull() throws Exception { JsonDeserializer<?> deserializer = find(null, "NULL"); assertNull(deserializer); deserializer = find(String.class, "NULL"); assertNull(deserializer); deserializer = find(String.class, "NULL"); assertNull(deserializer); }
@Test public void parseNull() throws Exception { JsonDeserializer<?> deserializer = find("null", null); Assert.assertNull(deserializer); deserializer = find("", null); Assert.assertNull(deserializer); }
@Test public void parseNull() throws Exception { JsonDeserializer<?> deserializer = find("null", null); Assert.assertNull(deserializer); deserializer = find("", null); Assert.assertNull(deserializer); deserializer = find("", null); Assert.assertNull(deserializer); deserializer = find("", null); Assert.assertNull(deserializer); deserializer = find("NULL", null); Assert.assertNull(deserializer); deserializer = find("NULL", "NULL"); Assert.assertNull(deserializer); deserializer = find("NULL", "NULL"); Assert.assertNull(deserializer); deserializer = find("NULL", "NULL"); Assert.assertNull(deserializer); }
@Test(expected = JsonProcessingException.class) public void testDeserialize() throws JsonProcessingException, IOException { JsonParser jp = Mockito.mock(JsonParser.class); DeserializationContext ctxt = Mockito.mock(DeserializationContext.class); Mockito.when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); Mockito.when(jp.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)).thenReturn(true); Mockito.when(jp.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)).thenReturn(true); Mockito.when(jp.getText()).then
@Test(expected = JsonProcessingException.class) public void testException() throws JsonProcessingException, IOException { JsonParser jp = mock(JsonParser.class); DeserializationContext ctxt = mock(DeserializationContext.class); when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); when(jp.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)).thenReturn(true); when(jp.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)).thenReturn(true); when(jp.getText()).thenThrow(JsonProcessingException.class); new MyDeserializer().deserialize(jp, ctxt); }
@Test(expected = JsonProcessingException.class) public void testDeserializationError() throws JsonProcessingException, IOException { JsonParser jp = mock(JsonParser.class); DeserializationContext ctxt = mock(DeserializationContext.class); when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); when(jp.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)).thenReturn(false); new MyDeserializer().deserialize(jp, ctxt); }
@Test(expected = JsonProcessingException.class) public void testDeserializationError() throws JsonProcessingException, IOException { JsonParser jp = Mockito.mock(JsonParser.class); DeserializationContext ctxt = Mockito.mock(DeserializationContext.class); Mockito.when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); Mockito.when(jp.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)).thenReturn(true); Mockito.when(jp.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)).thenReturn(true); Mockito.when(jp.getText()
@Test(expected = JsonProcessingException.class) public void testException() throws JsonProcessingException, IOException { JsonParser jp = mock(JsonParser.class); DeserializationContext ctxt = mock(DeserializationContext.class); when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); when(jp.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)).thenReturn(false); when(jp.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)).thenReturn(true); when(jp.getText()).thenThrow(JsonProcessingException.class); new MyClass().deserialize(jp, ctxt); }
@Test(expected = JsonProcessingException.class) public void testException() throws JsonProcessingException, IOException { JsonParser jp = mock(JsonParser.class); DeserializationContext ctxt = mock(DeserializationContext.class); when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); when(jp.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)).thenReturn(true); when(jp.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)).thenReturn(true); when(jp.getText()).thenThrow(JsonProcessingException.class); new MyDeserializer().deserialize(jp, ctxt); }
@Test(expected=JsonMappingException.class) public void testBadKey() throws IOException, JsonProcessingException { StringKD d = new StringKD() { @Override public Class<?> getKeyClass() { return String.class; } @Override public String _parse(String key, DeserializationContext context) throws IOException, JsonProcessingException { throw new JsonMappingException("bad key"); } }; d.deserializeKey("", null); }
@Test public void testIntDeserialization() throws Exception { int value = _parseInt("10"); assertEquals(10, value); value = _parseInt("0"); assertEquals(0, value); value = _parseInt("1"); assertEquals(1, value); value = _parseInt("2"); assertEquals(2, value); value = _parseInt("3"); assertEquals(3, value); value = _parseInt("4"); assertEquals(4, value); value = _parseInt("5"); assertEquals(5, value); value = _parseInt("6"); assertEquals(6, value); value = _parseInt("7"); assertEquals(7, value);
@Test public void testIntDeserialization() throws JsonMappingException, IOException { int value = Integer.MIN_VALUE; assertEquals(value, kd._parseInt("0")); assertEquals(value, kd._parseInt("1")); assertEquals(value, kd._parseInt("2")); assertEquals(value, kd._parseInt("3")); assertEquals(value, kd._parseInt("4")); assertEquals(value, kd._parseInt("5")); assertEquals(value, kd._parseInt("6")); assertEquals(value, kd._parseInt("7")); assertEquals(
@Test public void testStringDeserialization() throws JsonMappingException, IOException { String str = new StringKD()._parse("string", null); assertEquals(str, "string"); String str2 = new StringKD()._parse("string2", null); assertEquals(str2, "string2"); String str3 = new StringKD()._parse("string3", null); assertEquals(str3, "string3"); String str4 = new StringKD()._parse("string4", null); assertEquals(str4, "string4"); String str5 = new StringKD()._parse("string5", null); assertEquals(str5, "string5"); String
@Test public void testStringDeserialization() throws JsonMappingException, IOException { String str1 = new StringKD()._parse("string1", null); String str2 = new StringKD()._parse("string2", null); String str3 = new StringKD()._parse("string3", null); String str4 = new StringKD()._parse("string4", null); String str5 = new StringKD()._parse("string5", null); String str6 = new StringKD()._parse("string6", null); String str7 = new StringKD()._parse("string7", null); String str8 = new StringKD()._parse("string
@Test public void testIntKD() throws Exception { IntKD kd = new IntKD() { @Override public Class<?> getKeyClass() { return Integer.class; } }; assertEquals(kd.getKeyClass(), Integer.class); assertEquals(kd._parse("1", null), 1); assertEquals(kd._parse("2", null), 2); assertEquals(kd._parse("3", null), 3); assertEquals(kd._parse("4", null), 4); assertEquals(kd._parse("5", null), 5); assertEquals(kd._parse("6", null), 6); assertEquals(kd._parse("
@Test(expected = JsonMappingException.class) public void testNull() throws JsonMappingException, IOException { _parse("null"); }
@Test public void testIntDeserialization() throws JsonMappingException, IOException { int value = _parse("10"); assertEquals(value, 10); value = _parse("10"); assertEquals(value, 10); value = _parse("10"); assertEquals(value, 10); value = _parse("10"); assertEquals(value, 10); value = _parse("10"); assertEquals(value, 10); value = _parse("10"); assertEquals(value, 10); value = _parse("10"); assertEquals(value, 10); value = _parse("10"); assertEquals(value, 10); value = _parse("10"); assertEquals(value, 10); value = _parse("
@Test(expected=JsonMappingException.class) public void testBadKey() throws JsonMappingException { StringKD d = new StringKD() { @Override public String _parse(String key, DeserializationContext context) throws IOException, JsonMappingException { return "bad key"; } }; d._parse("bad key", null); }
@Test(expected=JsonMappingException.class) public void testBadParse() throws JsonMappingException { StringKD d = new StringKD() { private static final long serialVersionUID = 1L; @Override protected String _getKeyClass() { return String.class; } @Override protected Object _parseString(String key, DeserializationContext context) throws Exception { return d._parseString(key, context); } }; d.getHelper().setEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL, true); d.getHelper().setEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL, false); d.getHelper().
@Test(expected=JsonMappingException.class) public void testBadKey() throws JsonMappingException { StringKD kd = new StringKD() { @Override public String _parse(String key, DeserializationContext context) throws Exception { return null; } }; kd._parse("bla", new MockDeserializationContext()); }
@Test public void testDateKD() throws Exception { DateKD d = DateKD.forType(Date.class); Assert.assertEquals(d.getKeyClass(), Date.class); Assert.assertEquals(d.getKey("boolean"), true); Assert.assertEquals(d.getKey("short"), Short.class); Assert.assertEquals(d.getKey("int"), Integer.class); Assert.assertEquals(d.getKey("long"), Long.class); Assert.assertEquals(d.getKey("float"), Float.class); Assert.assertEquals(d.getKey("double"), Double.class); Assert.assertEquals(
@Test public void testDateDeserialization() throws IOException, JsonMappingException { DateKD d = new DateKD() { @Override public Class<? extends Date> getKeyClass() { return Date.class; } }; assertEquals(d.getKeyClass(), Date.class); assertEquals(d.getKey("date"), new Date(0)); assertEquals(d.getKey("bool"), new Boolean(false)); assertEquals(d.getKey("char"), new Character(0)); assertEquals(d.getKey("long"), new Long(0)); assertEquals(d.getKey("float"), new Float(0)); assertEquals(d.getKey("
@Test(expected = JsonMappingException.class) public void testDateParse() throws JsonMappingException, IOException { Date d = new Date((long) 123); SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); format.setTimeZone(TimeZone.getTimeZone("UTC")); String str = "date"; DeserializationContext context = createMock(DeserializationContext.class); expect(context.parseDate(str)).andReturn(d); replay(context); SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); dateFormat.setTimeZone(TimeZone.getTimeZone
@Test(expected = JsonMappingException.class) public void testDateParse() throws JsonMappingException, IOException { Date expectedDate = new Date((long)14161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616
@Test public void testDateDeserialization() throws Exception { CalendarKD kd = new CalendarKD() { @Override public Class<? extends Date> getKeyClass() { return Date.class; } @Override public String _parse(String key, DeserializationContext ctx) throws JsonMappingException, JsonProcessingException { return null; } }; assertNull(kd.date); assertNull(kd.date2); assertNull(kd.date3); assertNull(kd.date4); assertNull(kd.date5); assertNull(kd.date6); assertNull(kd.date7); assertNull(kd.date8); assertNull(kd
@Test public void testDateDeserialization() throws Exception { Calendar c = Calendar.getInstance(); c.setTime(new Date(0)); assertEquals(c.get(Calendar.YEAR), d_kd.forType(Date.class)._parse("Date", null)); assertEquals(c.get(Calendar.MONTH), d_kd.forType(Month.class)._parse("Month", null)); assertEquals(c.get(Calendar.DAY_OF_MONTH), d_kd.forType(Day.class)._parse("Day", null)); assertEquals(c.get(Calendar.HOUR_OF_DAY), d_kd.forType(Hour
@Test(expected = JsonMappingException.class) public void testDateParse() throws JsonMappingException, IOException { Calendar c = Calendar.getInstance(); Date d = new Date(c.getTimeInMillis()); d.setTimeInMillis(d.getTimeInMillis()); String str = "date"; DeserializationContext context = new DeserializationContext(d); _parse(str, context); }
@Test(expected = JsonMappingException.class) public void testDateParse() throws JsonMappingException, IOException { Calendar cal = Calendar.getInstance(); cal.setTime(new Date(cal.getTimeInMillis())); String str = "date"; DeserializationContext context = mock(DeserializationContext.class); when(context.parseDate(str)).thenReturn(cal); new DateKD()._parse(str, context); }
@Test public void testDateDeserialization() throws JsonMappingException, IOException { Calendar cal = Calendar.getInstance(); cal.setTimeInMillis(0); cal.set(Calendar.HOUR_OF_DAY, 0); cal.set(Calendar.MINUTE, 0); cal.set(Calendar.SECOND, 0); SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); Date expectedDate = format.parse(cal.getTime()); assertEquals(expectedDate, new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'").parse(expectedDate.toString())); }
@Test public void testUuidDeserializer() throws Exception { StringKD kd = new StringKD() { @Override protected String _parseString(String str, DeserializationContext ctx) throws IOException, JsonMappingException { return str; } @Override protected Class<? extends DeserializationContext> getKeyClass() { return this.getClass(); } }; assertEquals(kd.getKeyClass(), String.class); assertEquals(kd.getKeyDeserializer(Boolean.class), Boolean.class); assertEquals(kd.getKeyDeserializer(Byte.class), Byte.class); assertEquals(kd.getKeyDeserializer(Short.class), Short.class); assertEquals(kd
@Test public void testConstructor() throws Exception { StringKD kd = new StringKD(); assertEquals(kd.getKeyClass(), String.class); assertEquals(kd.getKeyString("string"), "string"); assertEquals(kd.getKeyString("boolean"), true); assertEquals(kd.getKeyString("short"), Short.class); assertEquals(kd.getKeyString("int"), Integer.class); assertEquals(kd.getKeyString("long"), Long.class); assertEquals(kd.getKeyString("float"), Float.class); assertEquals(kd.getKeyString("double"), Double
@Test(expected = JsonMappingException.class) public void testDateParse() throws JsonMappingException, IOException { DateDoubleKD d = new DateDoubleKD(); SimpleDateFormat f = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); d.setTimeZone(TimeZone.getTimeZone("UTC")); d._parse("date", null); }
@Test(expected = JsonMappingException.class) public void testString() throws JsonMappingException, IOException { StringStringDeserializer kd = new StringStringDeserializer(String.class); kd._parse("string", null); }
@Test public void testIterateChildren() { Array<JsonNode> nodes = new Array<JsonNode>(JsonNodeFactory.instance.objectNode(), null); assertEquals(0, nodes.size()); nodes.nextNode(); assertEquals(1, nodes.size()); nodes.nextNode(); assertEquals(2, nodes.size()); nodes.nextNode(); assertEquals(3, nodes.size()); nodes.nextNode(); assertEquals(4, nodes.size()); nodes.nextNode(); assertEquals(5, nodes.size()); nodes.nextNode(); assertEquals(6, nodes.size()); nodes.nextNode(); assertEquals(7, nodes.size()); nodes.nextNode(); assertEquals
@Test(expected = IllegalStateException.class) public void testIterateChildren_Null() { final JsonNode node = JsonNodeFactory.instance.objectNode(); node.set("test", null); node.set("test2", null); node.set("test3", null); node.set("test4", null); node.set("test5", null); node.set("test6", null); node.set("test7", null); node.set("test8", null); node.set("test9", null); node.set("test10", null); node.set("test11", null); node.set("test12", null); node.set("test13", null); node.
@Test(expected = IllegalStateException.class) public void testIterateChildren_Null() { NodeCursor l = new RootValue(null, null); l.iterateChildren(); }
@Test public void testIterateChildren() { Array<String> arr = new Array<String>(JsonNodeFactory.instance.objectNode(), null); arr.set(0, "foo"); arr.set(1, "bar"); arr.set(2, "baz"); arr.set(3, "qux"); arr.set(4, new DefaultArrayNode(JsonNodeFactory.instance.objectNode(), null)); arr.set(5, new DefaultArrayNode(JsonNodeFactory.instance.objectNode(), null)); arr.set(6, new DefaultArrayNode(JsonNodeFactory.instance.objectNode(), null)); arr.set(7, new DefaultArrayNode(Json
@Test public void testIterateChildren() { Array a = new Array(null, null); assertEquals(null, a.nextNode()); assertEquals(null, a.nextNode()); assertEquals(null, a.nextNode()); assertEquals(null, a.nextNode()); assertEquals(null, a.nextNode()); assertEquals(null, a.nextNode()); assertEquals(null, a.nextNode()); assertEquals(null, a.nextNode()); assertEquals(null, a.nextNode()); assertEquals(null, a.nextNode()); assertEquals(null, a.nextNode()); assertEquals(null, a.nextNode()); assertEquals(null, a.nextNode
@Test public void testIterateChildren() { Array<JsonNode> nodes = new Array<JsonNode>(JsonNodeFactory.instance.objectNode(), null); for (int i = 0; i < 10; i++) { nodes.add(nodes.nextNode()); } assertEquals(10, nodes.size()); for (int i = 0; i < 10; i++) { nodes.add(nodes.nextNode()); } assertEquals(10, nodes.size()); for (int i = 0; i < 10; i++) { nodes.add(nodes.nextNode()); } assertEquals(10, nodes.size()); for (int i = 0; i < 10; i++) { nodes
@Test(expected = IllegalStateException.class) public void testIterateChildren_Null() { final Object m = new Object() { @Override public JsonNode currentNode() { return null; } @Override public JsonNode nextNode() { return null; } }; m.iterateChildren(); }
@Test public void testArray() { Array a = new Array(JsonNodeFactory.instance.objectNode(), null); assertEquals(1, a.nextNode().asInt()); assertEquals(2, a.nextNode().asInt()); assertEquals(3, a.nextNode().asInt()); assertEquals(4, a.nextNode().asInt()); assertEquals(5, a.nextNode().asInt()); assertEquals(6, a.nextNode().asInt()); assertEquals(7, a.nextNode().asInt()); assertEquals(8, a.nextNode().asInt()); assertEquals(9, a.nextNode().asInt()); assertEquals(11, a
@Test public void testArray() { Array a = new Array(JsonNode.createObjectNode(), null); assertEquals(JsonStreamContext.TYPE_ARRAY, a.currentType()); assertEquals(JsonStreamContext.TYPE_ARRAY, a.getCurrentType()); assertNull(a.nextToken()); assertNull(a.nextValue()); assertNull(a.nextValue()); assertEquals(JsonStreamContext.TYPE_ARRAY, a.getCurrentType()); assertNull(a.nextValue()); assertEquals(JsonStreamContext.TYPE_ARRAY, a.getCurrentType()); assertNull(a.nextValue()); assertEquals(JsonStreamContext.TYPE_ARRAY, a.getCurrentType()); assert
@Test public void testArray() { Array a = new Array(JsonNodeFactory.instance.objectNode(), null); for (int i = 0; i < 1000; i++) { a.nextToken(); } assertEquals(1000, a.size()); for (int i = 0; i < 1000; i++) { a.nextValue(); } assertEquals(1000, a.size()); for (int i = 0; i < 1000; i++) { a.nextValue(); } assertEquals(1000, a.size()); for (int i = 0; i < 1000; i++) { a.nextValue(); } assertEquals(1000, a.size()); for (int i = 0;
@Test public void testNextToken() { assertNull(JsonNode.NULL.nextToken()); assertNull(JsonNode.NULL.nextToken()); assertNull(JsonNode.NULL.nextToken()); assertNull(JsonNode.NULL.nextToken()); assertNull(JsonNode.NULL.nextToken()); assertNull(JsonNode.NULL.nextToken()); assertNull(JsonNode.NULL.nextToken()); assertNull(JsonNode.NULL.nextToken()); assertNull(JsonNode.NULL.nextToken()); assertNull(JsonNode.NULL.nextToken()); assertNull(JsonNode.NULL.nextToken()); assertNull(JsonNode.NULL.nextToken()); assertNull(JsonNode.NULL
@Test public void testNextToken() { String s = "{\\n" + " \\"foo\\": \\"bar\\",\\n" + " \\"baz\\": \\"baz\\"\\n" + "}"; JsonNode n = JsonUtils.createObjectNode(s); assertEquals(null, n.nextToken()); assertEquals(null, n.nextToken()); assertEquals("foo", n.nextString()); assertEquals("bar", n.nextString()); assertEquals("baz", n.nextString()); assertEquals("baz", n.nextString()); assertEquals(null, n.nextToken()); assertEquals("baz", n.nextString()); assertEquals("
@Test public void testNextToken() { assertEquals(null, _nextToken().nextObject()); assertEquals(null, _nextToken().nextObject()); assertEquals(null, _nextToken().nextValue()); assertEquals(null, _nextToken().nextValue()); assertEquals(null, _nextToken().nextValue()); assertEquals(null, _nextToken().nextValue()); assertEquals(null, _nextToken().nextValue()); assertEquals(null, _nextToken().nextValue()); assertEquals(null, _nextToken().nextValue()); assertEquals(null, _nextToken().nextValue()); assertEquals(null, _nextToken().nextValue()); assertEquals(null, _next
@Test public void testNextToken() { Array<JsonNode> nodes = new Array<JsonNode>(); for (int i = 0; i < 10; i++) { nodes.add(JsonNode.createObjectNode()); } assertEquals(null, nodes.nextToken()); assertEquals(null, nodes.nextToken()); assertEquals(null, nodes.nextToken()); assertEquals(null, nodes.nextToken()); assertEquals(null, nodes.nextToken()); assertEquals(null, nodes.nextToken()); assertEquals(null, nodes.nextToken()); assertEquals(null, nodes.nextToken()); assertEquals(null, nodes.nextToken()); assertEquals(null, nodes.nextToken());
@Test public void testNextToken() { String s = "{\\n" + " \\"a\\": {\\n" + " \\"b\\": \\"c\\"\\n" + " },\\n" + " \\"c\\": [\\n" + " \\"d\\",\\n" + " \\"e\\",\\n" + " \\"f\\",\\n" + " \\"g\\",\\n" + " \\"h\\",\\n" + " \\"i\\",\\n" + " \\"j\\",\\n" + " \\"k\\",\\n" + " \\"l\\",\\n"
@Test public void testNextToken() { assertEquals(JsonNode.NULL, _node.nextToken()); assertEquals(JsonNode.OBJECT_TYPE, _node.nextType().type()); assertEquals(JsonNode.OBJECT_TYPE, _node.nextType().type()); assertEquals(JsonNode.OBJECT_TYPE, _node.nextType().type()); assertEquals(JsonNode.OBJECT_TYPE, _node.nextType().type()); assertEquals(JsonNode.OBJECT_TYPE, _node.nextType().type()); assertEquals(JsonNode.OBJECT_TYPE, _node.nextType().type()); assertEquals(JsonNode.OBJECT_TYPE, _node.nextType().type
@Test public void testEndToken() { assertEquals(JsonNode.END_ARRAY, new Array(JsonNode.EMPTY_NODE, null).endToken()); assertEquals(JsonNode.END_ARRAY, new Array(JsonNode.EMPTY_NODE, null).endToken()); assertEquals(JsonNode.END_ARRAY, new Array(JsonNode.EMPTY_NODE, null).endToken()); assertEquals(JsonNode.END_ARRAY, new Array(JsonNode.EMPTY_NODE, null).endToken()); assertEquals(JsonNode.END_ARRAY, new Array(JsonNode.EMPTY_NODE, null).endToken()); }
@Test public void testEndToken() { assertEquals(JsonNode.END_ARRAY, new Array(JsonNode.EMPTY_NODE, null).endToken()); assertEquals(JsonNode.END_ARRAY, new Array(JsonNode.EMPTY_NODE, null).endToken()); assertEquals(JsonNode.END_ARRAY, new Array(JsonNode.EMPTY_NODE, null).endToken()); assertEquals(JsonNode.END_ARRAY, new Array(JsonNode.EMPTY_NODE, null).endToken()); assertEquals(JsonNode.END_ARRAY, new Array(JsonNode.EMPTY_NODE, null).endToken()); }
@Test public void testCurrentNode() { assertEquals(JsonNode.NULL, _node.currentNode()); assertEquals(JsonNode.ROOT_NODE, _node.nextNode()); assertEquals(JsonNode.ROOT_NODE, _node.nextNode()); assertEquals(JsonNode.ROOT_NODE, _node.nextNode()); assertEquals(JsonNode.ROOT_NODE, _node.nextNode()); assertEquals(JsonNode.ROOT_NODE, _node.nextNode()); assertEquals(JsonNode.ROOT_NODE, _node.nextNode()); assertEquals(JsonNode.ROOT_NODE, _node.nextNode()); assertEquals(JsonNode.ROOT_NODE, _node.
@Test public void testCurrentNode() { assertEquals("foo", new ArrayNode(null, null).nextNode().asText()); assertEquals("bar", new ArrayNode(null, null).nextNode().asText()); assertEquals("baz", new ArrayNode(null, null).nextNode().asText()); assertEquals("qux", new ArrayNode(null, null).nextNode().asText()); assertEquals("bar", new ArrayNode(null, null).nextNode().asText()); assertEquals("baz", new ArrayNode(null, null).nextNode().asText()); assertEquals("qux", new ArrayNode(null, null).nextNode().asText()); assertEquals
@Test public void shouldReturnNullSerializerForNullType() { JsonSerializer<Object> serializer = new JsonSerializer<Object>() { @Override public void serialize(Object obj, Logger logger) { logger.info("{}", obj); } }; assertNull(serializer.serializerFor(null)); }
@Test public void testEnumDeserializer() throws JsonMappingException, JsonProcessingException { Set<String> expectedEnumSet = new HashSet<String>(); expectedEnumSet.add("ONE"); expectedEnumSet.add("TWO"); expectedEnumSet.add("THREE"); Set<String> actualEnumSet = new HashSet<String>(); actualEnumSet.add("ONE"); actualEnumSet.add("TWO"); actualEnumSet.add("THREE"); actualEnumSet.add("FOUR"); actualEnumSet.add("FOUR"); Set<String> actualEnumSet2 = new HashSet<String>(); actualEnumSet2.add("ONE"); actualEnumSet2.add("TWO");
@Test public void testEnumDeserializer() throws JsonMappingException, IOException { Set<String> enumSet = new HashSet<String>(); enumSet.add("ONE"); enumSet.add("TWO"); enumSet.add("THREE"); Set<String> deserialized = new HashSet<String>(); deserialized.add("ONE"); deserialized.add("TWO"); deserialized.add("THREE"); Set<String> deserialized2 = new HashSet<String>(); deserialized2.add("ONE"); deserialized2.add("TWO"); deserialized2.add("THREE"); Set<String> deserialized3 = new HashSet<String>(); deserialized3.add("ONE"); deserialized3.add("TWO"); deserialized
@Test public void testEnumDeserializer() throws JsonMappingException, JsonProcessingException { SimpleEnumSet enumSet = new SimpleEnumSet(); enumSet.add(TestEnum.ONE); enumSet.add(TestEnum.TWO); enumSet.add(TestEnum.THREE); JsonDeserializer<SimpleEnumSet> _enumDeserializer = new JsonDeserializer<SimpleEnumSet>() { @Override public SimpleEnumSet deserialize(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws JsonMappingException, JsonProcessingException { return enumSet; } }; SimpleEnumSet deserialized = (SimpleEnumSet) _enumDeserializer.withDeserializer(_enumDeserializer).deserialize(jp, null); assertEquals(
@Test public void testEnumDeserializer() throws JsonMappingException, IOException { Set<String> expectedEnums = new HashSet<String>(); expectedEnums.add("ONE"); expectedEnums.add("TWO"); expectedEnums.add("THREE"); Set<String> actualEnums = new HashSet<String>(); expectedEnums.add("ONE"); expectedEnums.add("TWO"); expectedEnums.add("THREE"); expectedEnums.add("FOUR"); expectedEnums.add("FOUR"); Set<String> deserializedEnums = new HashSet<String>(); deserializedEnums.add("ONE"); deserializedEnums.add("TWO"); deserializedEnums.
@Test public void testEnumDeserializer() throws JsonMappingException, JsonProcessingException { Set<String> enumSet = new HashSet<String>(); enumSet.add("ONE"); enumSet.add("TWO"); enumSet.add("THREE"); JsonDeserializer<Enum<?>> enumDeserializer = new JsonDeserializer<Enum<?>>() { @Override public Object deserialize(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws JsonMappingException, JsonProcessingException { return enumSet; } }; enumDeserializer.withDeserializer(enumDeserializer); assertEquals(enumSet, enumDeserializer.deserialize(jp, null)); }
@Test public void testWithDeserializer() throws JsonMappingException, JsonProcessingException { JsonDeserializer<TestEnum> testEnumDeserializer = new JsonDeserializer<TestEnum>() { @Override public Object deserialize(JsonParser jp, DeserializationContext ctxt, BeanProperty property) throws JsonMappingException, JsonProcessingException { throw new JsonMappingException(); } @Override public void createContextual(JsonParser jp, DeserializationContext ctxt, BeanProperty property) throws JsonMappingException, JsonProcessingException { throw new JsonMappingException(); } }; EnumSetDeserializer deserializer = new EnumSetDeserializer(TestEnum.class, testEnumDeserializer) .withDeserializer(new JsonDeserializer<TestEnum>() { @Override public Object deserialize(JsonParser jp
@Test public void testWithDeserializer() throws JsonMappingException, JsonProcessingException { JsonDeserializer<TestEnum> testEnumDeserializer = new JsonDeserializer<TestEnum>() { @Override public Object deserialize(JsonParser jp, DeserializationContext ctxt, BeanProperty property) throws JsonMappingException, JsonProcessingException { return null; } @Override public boolean isCachable() { return false; } }; EnumSetDeserializer deserializer = new EnumSetDeserializer(TestEnum.class, testEnumDeserializer) .withDeserializer(new JsonDeserializer<TestEnum>() { @Override public Object deserialize(JsonParser jp, DeserializationContext ctxt, BeanProperty property) throws JsonMappingException, JsonProcessingException { return null; } @Override public boolean
@Test public void testEnumDeserializer() throws JsonMappingException, JsonProcessingException { Set<String> expectedEnums = new HashSet<String>(); expectedEnums.add("A"); expectedEnums.add("B"); expectedEnums.add("C"); expectedEnums.add("D"); expectedEnums.add("E"); Set<String> actualEnums = new HashSet<String>(); actualEnums.add("A"); actualEnums.add("B"); actualEnums.add("C"); actualEnums.add("D"); actualEnums.add("E"); actualEnums.add("F"); actualEnums.add("G"); actualEnums.add("H");
@Test public void testIsCachable() throws Exception { assertTrue(new EnumSetDeserializer(MyEnum.class, new JsonDeserializer<MyEnum>() { @Override public boolean isCachable() { return true; } }).isCachable()); assertTrue(new EnumSetDeserializer(MyEnum.class, new JsonDeserializer<MyEnum>() { @Override public boolean isCachable() { return false; } }).isCachable()); assertTrue(new EnumSetDeserializer(MyEnum.class, new JsonDeserializer<MyEnum>() { @Override public boolean isCachable() { return true; } }).withDeserializer(new JsonDeserializer<MyEnum>() { @Override public boolean createContextual(
@Test public void testIsCachable() { assertTrue(new EnumSetDeserializer(MyEnum.class, new JsonDeserializer<MyEnum>() { @Override public boolean isCachable() { return true; } }).isCachable()); assertTrue(new EnumSetDeserializer(MyEnum.class, new JsonDeserializer<MyEnum>() { @Override public boolean isCachable() { return true; } }).isCachable()); assertTrue(new EnumSetDeserializer(MyEnum.class, new JsonDeserializer<MyEnum>() { @Override public boolean isCachable() { return true; } }).isCachable()); assertTrue(new EnumSetDeserializer(MyEnum.class, new JsonDeserializer<MyEnum
@Test public void testCreateContextual() throws Exception { Set<String> expected = new HashSet<String>(Arrays.asList( "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21", "22", "23", "24", "25", "26", "26", "25", "26", "26", "26", "26", "26", "26", "26", "26", "26", "26", "26", "26
@Test public void testCreateContextual() throws Exception { Set<String> expected = new HashSet<String>(Arrays.asList( "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21", "22", "33", "44", "55", "66", "77", "88", "88", "88", "88", "88", "88", "88", "88", "88", "88", "88", "88", "88
@Test public void testCreateContextual() throws Exception { Set<String> expected = new HashSet<String>(); expected.add("one"); expected.add("two"); expected.add("three"); Set<String> actual = new HashSet<String>(); actual.add("one"); actual.add("two"); actual.add("three"); Set<String> expected2 = new HashSet<String>(); expected2.add("one"); expected2.add("two"); expected2.add("three"); Set<String> actual2 = new HashSet<String>(); expected2.add("one"); expected2.add("two"); expected2.add("three"); expected2.add
@Test public void testCreateContextual() throws Exception { Set<String> expected = new HashSet<String>(); expected.add("one"); expected.add("two"); expected.add("three"); expected.add("four"); Set<String> actual = new HashSet<String>(); Set<String> expected2 = new HashSet<String>(); expected2.add("one"); expected2.add("two"); expected2.add("three"); expected2.add("four"); expected2.add("five"); expected2.add("six"); expected2.add("seven"); expected2.add("eight"); expected2.add("nine"); expected2.add
@Test public void testCreateContextual() throws Exception { Set<String> expected = new HashSet<String>(); expected.add("one"); expected.add("two"); expected.add("three"); Set<String> actual = new HashSet<String>(); actual.add("one"); actual.add("two"); actual.add("three"); Set<String> expected2 = new HashSet<String>(); expected2.add("one"); expected2.add("two"); expected2.add("three"); Set<String> actual2 = new HashSet<String>(); expected2.add("one"); expected2.add("two"); expected2.add("three"); actual.add("
@Test(expected = JsonMappingException.class) public void fail2() throws JsonMappingException, IOException { String enumJson = "{\\n" + " \\"enum\\": [\\n" + " {\\n" + " \\"value\\": 1\\n" + " },\\n" + " {\\n" + " \\"value\\": 2\\n" + " }\\n" + " ]\\n" + "}"; JsonFactory f = new JsonFactory(); JsonParser jp = f.createParser(enumJson); jp.nextToken(); f.deserialize(jp, mock(DeserializationContext.class)); }
@Test public void testDeserialize() throws JsonMappingException, JsonProcessingException, IOException { String enumJson = "{\\n" + " \\"enum\\": [\\n" + " {\\n" + " \\"value\\": 1\\n" + " },\\n" + " {\\n" + " \\"value\\": 2\\n" + " },\\n" + " {\\n" + " \\"value\\": 3\\n" + " },\\n" + " {\\n" + " \\"value\\": 4\\n" + " },\\n" + " {\\n" + " \\"value\\": 5\\n" + " }
@Test(expected = JsonMappingException.class) public void testEnumSet_IOException() throws Exception { String enumJson = "{\\n" + " \\"enum\\": [\\n" + " {\\n" + " \\"value\\": 1\\n" + " }\\n" + " ]\\n" + "}"; JsonFactory f = new JsonFactory(); JsonParser jp = f.createParser(enumJson); jp.nextToken(); EasyMock.expectLastCall().andThrow(new JsonMappingException(enumJson)); replayAll(); new EnumSetDeserializer(TestEnum.class, new JsonDeserializer<TestEnum>() { @Override public Object deserialize(JsonParser jp, Des
@Test(expected = JsonMappingException.class) public void testEnumSet() throws Exception { String enumJson = "{\\n" + " \\"enum\\": [\\n" + " {\\n" + " \\"value\\": 1\\n" + " },\\n" + " {\\n" + " \\"value\\": 2\\n" + " },\\n" + " {\\n" + " \\"value\\": 3\\n" + " }\\n" + " ]\\n" + "}"; JsonFactory f = new JsonFactory(); JsonParser jp = f.createParser(enumJson); jp.nextToken(); EasyMock.expectLastCall
@Test(expected = JsonMappingException.class) public void fail2() throws JsonMappingException, IOException { String enumJson = "{\\n" + " \\"enum\\": [\\n" + " {\\n" + " \\"value\\": 1\\n" + " },\\n" + " {\\n" + " \\"value\\": 2\\n" + " },\\n" + " {\\n" + " \\"value\\": 3\\n" + " }\\n" + " ]\\n" + "}"; JsonFactory f = new JsonFactory(); JsonParser jp = f.createParser(enumJson); jp.nextToken(); EasyMock.
@Test public void testDeserializer() throws JsonMappingException, JsonProcessingException, IOException { String enumJson = "{\\n" + " \\"enum\\": [\\n" + " {\\n" + " \\"value\\": 1\\n" + " },\\n" + " {\\n" + " \\"value\\": 2\\n" + " },\\n" + " {\\n" + " \\"value\\": 3\\n" + " },\\n" + " {\\n" + " \\"value\\": 4\\n" + " },\\n" + " {\\n" + " \\"value\\": 5\\n" + " }
@Test(expected = JsonMappingException.class) public void testInvalidEnumSet() throws JsonMappingException, IOException { String enumJson = "[\\n" + " {\\n" + " \\"value\\": \\"FOO\\"\\n" + " }\\n" + "]"; JsonFactory f = new JsonFactory(); JsonParser jp = f.createParser(enumJson); jp.nextToken(); EasyMock.expect(jp.isExpectedStartArrayToken()).andReturn(true).anyTimes(); jp.nextToken(); EasyMock.expect(jp.nextToken()).andReturn(JsonToken.END_ARRAY); EasyMock.expect(jp.nextToken()).and
@Test(expected = JsonMappingException.class) public void testEnumSetDeserializer() throws Exception { String enumJson = "{\\n" + " \\"enum\\": [\\n" + " {\\n" + " \\"value\\": 1\\n" + " },\\n" + " {\\n" + " \\"value\\": 2\\n" + " }\\n" + " ]\\n" + "}"; JsonFactory f = new JsonFactory(); JsonParser jp = f.createParser(enumJson); jp.nextToken(); EasyMock.expect(jp.isExpectedStartArrayToken()).andReturn(true); jp.nextToken(); EasyMock.expect
@Test(expected = JsonMappingException.class) public void fail2() throws JsonMappingException, IOException { String enumJson = "{\\n" + " \\"enum\\": [\\n" + " {\\n" + " \\"value\\": 1\\n" + " },\\n" + " {\\n" + " \\"value\\": 2\\n" + " }\\n" + " ]\\n" + "}"; JsonFactory f = new JsonFactory(); JsonParser jp = f.createParser(enumJson); jp.nextToken(); EasyMock.expect(jp.isExpectedStartArrayToken()).andReturn(true); jp.nextToken(); EasyMock
@Test public void testConstructSet() throws JsonMappingException, JsonProcessingException, IOException { Set<String> expectedEnumSet = new HashSet<String>(Arrays.asList(TestEnum.ONE, TestEnum.TWO, TestEnum.THREE)); assertEquals(expectedEnumSet, new EnumSetDeserializer(TestEnum.ONE, null).constructSet()); assertEquals(expectedEnumSet, new EnumSetDeserializer(TestEnum.ONE, null).constructSet()); assertEquals(expectedEnumSet, new EnumSetDeserializer(TestEnum.TWO, null).constructSet()); assertEquals(expectedEnumSet, new EnumSetDeserializer(TestEnum.THREE, null).constructSet()); assertEquals(expectedEnumSet, new
@Test public void testConstructSet() throws Exception { assertEquals(EnumSet.ONE, new EnumSetDeserializer(MyEnum.class, null).constructSet()); assertEquals(EnumSet.TWO, new EnumSetDeserializer(MyEnum.class, null).constructSet()); assertEquals(EnumSet.THREE, new EnumSetDeserializer(MyEnum.class, null).constructSet()); assertEquals(EnumSet.ONE, new EnumSetDeserializer(MyEnum.class, null).constructSet()); assertEquals(EnumSet.TWO, new EnumSetDeserializer(MyEnum.class, null).constructSet()); assertEquals(EnumSet.THREE, new EnumSetDeserializer(MyEnum.class, null).constructSet()); assert
@Test public void test() throws Exception { final String[][] lines = new String[][] { new String[] { "A", "B", "C" }, new String[] { "D", "E", "F" }, new String[] { "G", "H", "I", "J" }, new String[] { "G", "H", "I", "J" }, new String[] { "G", "H", "I", "J" }, new String[] { "G", "H", "I", "J" }, new String[] { "G", "H", "I", "J" }, new String[] { "G", "H", "I",
@Test public void test() throws Exception { String[][] lines = new String[][] { new String[] {"A", "B", "C"}, new String[] {"A", "B", "C"}, new String[] {"A", "B", "C"}, new String[] {"A", "B", "C"}, new String[] {"A", "B", "C"}, new String[] {"A", "B", "C"}, new String[] {"A", "B", "C"}, new String[] {"A", "B", "C"}, new String[] {"A", "B", "C"}, new String[] {"A", "B", "
@Test public void findKeyDeserializer() throws JsonMappingException { SimpleKeyConverter converter = new SimpleKeyConverter(); SimpleKeyConverter.KeyDeserializer stringKeyDeserializer = converter.findKeyDeserializer(String.class, null, null); assertNotNull(stringKeyDeserializer); SimpleKeyConverter.KeyDeserializer uuidKeyDeserializer = converter.findKeyDeserializer(UUID.class, null, null); assertNotNull(uuidKeyDeserializer); SimpleKeyConverter.KeyDeserializer dateKeyDeserializer = converter.findKeyDeserializer(Date.class, null, null); assertNotNull(dateKeyDeserializer); SimpleKeyConverter.KeyDeserializer booleanKeyDeserializer = converter.findKeyDeserializer(Boolean.class, null, null); assertNotNull(booleanKeyDeserializer); SimpleKeyConverter.Key
@Test public void findKeyDeserializer() throws JsonMappingException { SimpleKeyDeserializer simpleKeyDeserializer = new SimpleKeyDeserializer(); SimpleKeyDeserializer simpleKeyDeserializer2 = new SimpleKeyDeserializer(); SimpleKeyDeserializer simpleKeyDeserializer3 = new SimpleKeyDeserializer(); KeyDeserializer simpleKeyDeserializer4 = new SimpleKeyDeserializer(); KeyDeserializer simpleKeyDeserializer5 = new SimpleKeyDeserializer(); KeyDeserializer simpleKeyDeserializer6 = new SimpleKeyDeserializer(); KeyDeserializer simpleKeyDeserializer7 = new SimpleKeyDeserializer(); KeyDeserializer simpleKeyDeserializer8 = new SimpleKeyDeserializer(); KeyDeserializer simpleKeyDeserializer9 = new SimpleKeyDeserializer(); KeyDeserializer simpleKeyDeserializer10 = new SimpleKeyDeserializer(); KeyDeserializer simpleKeyDeserializer11 = new SimpleKeyDeserializer(); Key
@Test public void findKeyDeserializer() throws JsonMappingException { SimpleKeyDeserializer simpleKeyDeserializer = new SimpleKeyDeserializer(); SimpleKeyDeserializer simpleKeyDeserializer2 = new SimpleKeyDeserializer(); SimpleKeyDeserializer simpleKeyDeserializer3 = new SimpleKeyDeserializer(); KeyDeserializer simpleKeyDeserializer4 = new SimpleKeyDeserializer(); KeyDeserializer simpleKeyDeserializer5 = new SimpleKeyDeserializer(); KeyDeserializer simpleKeyDeserializer6 = new SimpleKeyDeserializer(); KeyDeserializer simpleKeyDeserializer7 = new SimpleKeyDeserializer(); KeyDeserializer simpleKeyDeserializer8 = new SimpleKeyDeserializer(); KeyDeserializer simpleKeyDeserializer9 = new SimpleKeyDeserializer(); KeyDeserializer simpleKeyDeserializer10 = new SimpleKeyDeserializer(); KeyDeserializer simpleKeyDeserializer11 = new SimpleKeyDeserializer(); Key
@Test public void findKeyDeserializer() throws JsonMappingException { SimpleConverter simpleConverter = new SimpleConverter(); SimpleConverter simpleConverter2 = new SimpleConverter(); SimpleConverter simpleConverter3 = new SimpleConverter(); SimpleConverter simpleConverter4 = new SimpleConverter(); SimpleConverter simpleConverter5 = new SimpleConverter(); SimpleConverter simpleConverter6 = new SimpleConverter(); SimpleConverter simpleConverter7 = new SimpleConverter(); SimpleConverter simpleConverter8 = new SimpleConverter(); SimpleConverter simpleConverter9 = new SimpleConverter(); SimpleConverter simpleConverter10 = new SimpleConverter(); SimpleConverter simpleConverter11 = new SimpleConverter(); SimpleConverter simpleConverter12 = new SimpleConverter(); SimpleConverter simpleConverter13 = new SimpleConverter(); SimpleConverter simpleConverter14 =
@Test public void testLinkedNode() { LinkedNode<String> node1 = new LinkedNode<String>("a", new LinkedNode<String>("b", new LinkedNode<String>("c"))); LinkedNode<String> node2 = new LinkedNode<String>("d", new LinkedNode<String>("e", new LinkedNode<String>("f"))); LinkedNode<String> node3 = new LinkedNode<String>("g", new LinkedNode<String>("h")); LinkedNode<String> node4 = new LinkedNode<String>("i", new LinkedNode<String>("j")); LinkedNode<String> node5 = new LinkedNode
@Test public void testLinkedNode() { LinkedNode<String> node1 = new LinkedNode<String>("a", new LinkedNode<String>("b", new LinkedNode<String>("c"))); LinkedNode<String> node2 = new LinkedNode<String>("d", new LinkedNode<String>("e", new LinkedNode<String>("f"))); LinkedNode<String> node3 = new LinkedNode<String>("g", new LinkedNode<String>("h")); LinkedNode<String> node4 = new LinkedNode<String>("i", new LinkedNode<String>("j")); LinkedNode<String> node5 = new LinkedNode
@Test public void testLinkedNode() { LinkedNode<String> node1 = new LinkedNode<String>("a", new LinkedNode<String>("b", new LinkedNode<String>("c"))); LinkedNode<String> node2 = new LinkedNode<String>("d", new LinkedNode<String>("e", new LinkedNode<String>("f"))); LinkedNode<String> node3 = new LinkedNode<String>("g", new LinkedNode<String>("h")); LinkedNode<String> node4 = new LinkedNode<String>("i", new LinkedNode<String>("j")); LinkedNode<String> node5 = new LinkedNode
@Test public void testValue() { String[][] lines = new String[][] { new String[] { "A", "B", "C" }, new String[] { "D", "E", "F" }, new String[] { "G", "H", "I", "J" }, new String[] { "G", "H", "I", "J" }, new String[] { "G", "H", "I", "J" }, new String[] { "G", "H", "I", "J" }, new String[] { "G", "H", "I", "J" }, new String[] { "G", "H", "I", "J
@Test public void testContains() { List<Integer> numbers = new ArrayList<Integer>(); for (int i = 0; i < 10; i++) { numbers.add(i); } LinkedNode<Integer> node = new LinkedNode<Integer>(0, numbers); Assert.assertEquals(true, contains(node, 0)); Assert.assertEquals(true, contains(node, 1)); Assert.assertEquals(true, contains(node, 2)); Assert.assertEquals(true, contains(node, 3)); Assert.assertEquals(true, contains(node, 4)); Assert.assertEquals(true, contains(node, 5)); Assert.assertEquals(true, contains(node,
@Test public void testContains() { List<LinkedNode<Integer>> nodes = new ArrayList<LinkedNode<Integer>>(); LinkedNode<Integer> first = new LinkedNode<Integer>(1); LinkedNode<Integer> second = new LinkedNode<Integer>(2); LinkedNode<Integer> third = new LinkedNode<Integer>(3); LinkedNode<Integer> fourth = new LinkedNode<Integer>(4); nodes.add(first); nodes.add(second); nodes.add(third); nodes.add(fourth); LinkedNode<Integer> fourth = new LinkedNode<Integer>(5); nodes.add(fourth); nodes.add(f
@Test public void testContains() { List<LinkedNode<Integer>> nodes = new ArrayList<LinkedNode<Integer>>(); LinkedNode<Integer> a = new LinkedNode<Integer>(1); LinkedNode<Integer> b = new LinkedNode<Integer>(2); LinkedNode<Integer> c = new LinkedNode<Integer>(3); LinkedNode<Integer> d = new LinkedNode<Integer>(4); nodes.add(a); nodes.add(b); nodes.add(c); nodes.add(d); Assert.assertTrue(contains(nodes, 1)); Assert.assertTrue(contains(nodes, 2)); Assert.assertTrue(contains(nodes, 3)); Assert
@Test public void testSerializeContents() throws IOException, JsonMappingException { List<String> value = Arrays.asList("a", "b", "c"); serializer.serializeContents(value, jgen, provider); Mockito.verify(jgen, Mockito.times(1)).writeString(value.get(0)); Mockito.verify(jgen, Mockito.times(1)).writeString("a"); Mockito.verify(jgen, Mockito.times(1)).writeString("b"); Mockito.verify(jgen, Mockito.times(1)).writeString("c"); }
@Test public void testSerializeContents() throws Exception { List<String> value = Arrays.asList("a", "b", "c"); serializer.serializeContents(value, jgen, provider); Mockito.verify(jgen, Mockito.times(1)).writeString(value.get(0)); Mockito.verify(jgen, Mockito.times(1)).writeString("a"); Mockito.verify(jgen, Mockito.times(1)).writeString("b"); Mockito.verify(jgen, Mockito.times(1)).writeString("c"); }
@Test public void testSerializeContents() throws Exception { MockSerializerProvider provider = new MockSerializerProvider(); List<String> value = Arrays.asList("a", "b", "c"); serializer.serialize(value, provider, provider); Assert.assertEquals("[\\n" + " {\\n" + " \\"a\\": \\"a\\",\\n" + " \\"b\\": \\"b\\",\\n" + " \\"c\\": \\"c\\"\\n" + " },\\n" + " {\\n" + " \\"a\\": \\"a\\",\\n" + " \\"b\\": \\"b\\",
@Test public void testAtomicLongSerializer() throws Exception { StringWriter out = new StringWriter(); AtomicLongSerializer serializer = new AtomicLongSerializer(); serializer.serialize(new AtomicLong(1), new JsonGeneratorFactory().createGenerator(out), null); serializer.serialize(new AtomicLong(2), new JsonGeneratorFactory().createGenerator(out), null); serializer.serialize(new AtomicLong(3), new JsonGeneratorFactory().createGenerator(out), null); serializer.serialize(new AtomicLong(4), new JsonGeneratorFactory().createGenerator(out), null); serializer.serialize(new AtomicLong(5), new JsonGeneratorFactory().createGenerator(out), null); serializer.serialize(new AtomicLong(6),
@Test public void testAtomicLongSerializer() throws IOException, JsonGenerationException { AtomicLong value = new AtomicLong(42); ByteArrayOutputStream out = new ByteArrayOutputStream(); JsonGenerator jgen = new JsonFactory().createGenerator(out); new AtomicLongSerializer().serialize(value, jgen, null); jgen.flush(); Assert.assertEquals("42", out.toString()); }
@Test public void testAtomicLongSerializer() throws IOException, JsonGenerationException { AtomicLong value = new AtomicLong(42); ByteArrayOutputStream out = new ByteArrayOutputStream(); JsonGeneratorProvider provider = new JsonGeneratorProvider(out); AtomicBooleanSerializer serializer = new AtomicBooleanSerializer(); serializer.serialize(value, provider); serializer.serialize(value, provider); serializer.serialize(value, provider); assertEquals("42", out.toString()); }
@Test public void testGetNodeType() { assertEquals(JsonNodeType.OBJECT, new ObjectNode(JsonNodeFactory.instance).getNodeType()); }
@Test public void testGetNodeType() { assertEquals(JsonNodeType.OBJECT, new ObjectNode(JsonNodeFactory.instance).getNodeType()); }
@Test public void testPath() { for (Map.Entry<String, JsonNode> entry : _node.fields().entrySet()) { assertEquals(entry.getValue(), _node.path(entry.getKey()).asText()); } for (Map.Entry<String, JsonNode> entry : _node.fields().entrySet()) { assertEquals(entry.getValue(), _node.path(entry.getKey()).asText()); } for (Map.Entry<String, JsonNode> entry : _node.fields().entrySet()) { assertEquals(entry.getValue(), _node.path(entry.getKey()).asText()); } }
@Test public void testPath() { for (Map.Entry<String, JsonNode> entry : _node.fields().entrySet()) { Assert.assertEquals(entry.getValue(), entry.getKey()); } for (Map.Entry<String, JsonNode> entry : _node.fields().entrySet()) { Assert.assertEquals(entry.getValue(), entry.getKey()); } for (Map.Entry<String, JsonNode> entry : _node.fields().entrySet()) { Assert.assertEquals(entry.getValue(), entry.getKey()); } for (Map.Entry<String, JsonNode> entry : _node.fields().entrySet()) { Assert.assertEquals(entry.getValue(), entry.
@Test public void testPath() { for (Map.Entry<String, JsonNode> entry : _node.fields().entrySet()) { Assert.assertNotNull(entry.getValue()); } for (Map.Entry<String, JsonNode> entry : _node.fields().entrySet()) { Assert.assertNotNull(entry.getValue()); } for (Map.Entry<String, JsonNode> entry : _node.fields().entrySet()) { Assert.assertNotNull(entry.getValue()); } for (Map.Entry<String, JsonNode> entry : _node.fields().entrySet()) { Assert.assertNotNull(entry.getValue()); } }
@Test public void testPath() { List<Map.Entry<String, JsonNode>> fields = new ArrayList<Map.Entry<String, JsonNode>>(); fields.add(new Map.Entry<String, JsonNode>("x", new JsonNodeFactory().objectNode())); fields.add(new Map.Entry<String, JsonNode>("y", new JsonNodeFactory().objectNode())); fields.add(new Map.Entry<String, JsonNode>("z", new JsonNodeFactory().objectNode())); JsonNode node = new ObjectNode(new ObjectMapper()); node.set("x", new JsonNodeFactory().objectNode()); node.set("y", new JsonNodeFactory().objectNode()); node.set("z", new JsonNode
@Test public void testFindValues() { List<JsonNode> foundSoFar = new ArrayList<JsonNode>(); foundSoFar.add(new ObjectNode(JsonNodeFactory.instance.objectNode())); foundSoFar.add(new ObjectNode(JsonNodeFactory.instance.objectNode())); foundSoFar.add(new ObjectNode(JsonNodeFactory.instance.objectNode())); foundSoFar.add(new ObjectNode(JsonNodeFactory.instance.objectNode())); foundSoFar.add(new ObjectNode(JsonNodeFactory.instance.objectNode())); foundSoFar.add(new ObjectNode(JsonNodeFactory.instance.objectNode())); foundSoFar.add(new ObjectNode(Json
@Test public void testFindValues() { List<JsonNode> found = new ArrayList<JsonNode>(); for (Map.Entry<String, JsonNode> entry : _children.entrySet()) { found.add(entry.getValue()); } for (Map.Entry<String, JsonNode> entry : _children.entrySet()) { found.add(entry.getValue()); } for (Map.Entry<String, JsonNode> entry : found) { found.add(entry.getValue()); } for (Map.Entry<String, JsonNode> entry : _children.entrySet()) { found.add(entry.getValue()); } for (Map.Entry<String, JsonNode> entry : _children.entrySet
@Test public void testFindValues() { List<JsonNode> foundSoFar = new ArrayList<JsonNode>(); foundSoFar.add(new ObjectNode(JsonNodeFactory.instance.objectNode())); foundSoFar.add(new ObjectNode(JsonNodeFactory.instance.objectNode())); foundSoFar.add(new ObjectNode(JsonNodeFactory.instance.objectNode())); foundSoFar.add(new ObjectNode(JsonNodeFactory.instance.objectNode())); foundSoFar.add(new ObjectNode(JsonNodeFactory.instance.objectNode())); foundSoFar.add(new ObjectNode(JsonNodeFactory.instance.objectNode())); foundSoFar.add(new ObjectNode(Json
@Test public void testFindValues() { List<JsonNode> foundSoFar = new ArrayList<JsonNode>(); foundSoFar.add(new ObjectNode(JsonNodeFactory.instance.objectNode())); foundSoFar.add(new ObjectNode(JsonNodeFactory.instance.objectNode())); foundSoFar.add(new ObjectNode(JsonNodeFactory.instance.objectNode())); foundSoFar.add(new ObjectNode(JsonNodeFactory.instance.objectNode())); foundSoFar.add(new ObjectNode(JsonNodeFactory.instance.objectNode())); foundSoFar.add(new ObjectNode(JsonNodeFactory.instance.objectNode())); foundSoFar.add(new ObjectNode(Json
@Test public void testFindValues() { List<JsonNode> foundSoFar = new ArrayList<JsonNode>(); foundSoFar.add(new ObjectNode(JsonNodeFactory.instance.objectNode())); foundSoFar.add(new ObjectNode(JsonNodeFactory.instance.objectNode())); foundSoFar.add(new ObjectNode(JsonNodeFactory.instance.objectNode())); foundSoFar.add(new ObjectNode(JsonNodeFactory.instance.objectNode())); foundSoFar.add(new ObjectNode(JsonNodeFactory.instance.objectNode())); foundSoFar.add(new ObjectNode(JsonNodeFactory.instance.objectNode())); foundSoFar.add(new ObjectNode(Json
@Test public void testFindParents() { List<JsonNode> foundSoFar = new ArrayList<JsonNode>(); foundSoFar.add(new ObjectNode(JsonNodeFactory.instance.objectNode())); foundSoFar.add(new ObjectNode(JsonNodeFactory.instance.objectNode())); foundSoFar.add(new ObjectNode(JsonNodeFactory.instance.objectNode())); foundSoFar.add(new ObjectNode(JsonNodeFactory.instance.objectNode())); List<JsonNode> children = new ArrayList<JsonNode>(); children.add(new ObjectNode(JsonNodeFactory.instance.objectNode())); children.add(new ObjectNode(JsonNodeFactory.instance.objectNode
@Test public void testFindParents() { Map<String, JsonNode> children = new HashMap<String, JsonNode>(); children.put("x", JsonNodeFactory.instance.objectNode()); children.put("y", JsonNodeFactory.instance.objectNode()); children.put("z", JsonNodeFactory.instance.objectNode()); children.put("n1", JsonNodeFactory.instance.objectNode()); children.put("n2", JsonNodeFactory.instance.objectNode()); children.put("n3", JsonNodeFactory.instance.objectNode()); List<JsonNode> found = new ArrayList<JsonNode>(); for (Map.Entry<String, JsonNode> entry : children.entrySet()) { found.add(
@Test public void testFindParents() { List<JsonNode> foundSoFar = new ArrayList<JsonNode>(); foundSoFar.add(new ObjectNode(JsonNodeFactory.instance.objectNode())); foundSoFar.add(new ObjectNode(JsonNodeFactory.instance.objectNode())); foundSoFar.add(new ObjectNode(JsonNodeFactory.instance.objectNode())); foundSoFar.add(new ObjectNode(JsonNodeFactory.instance.objectNode())); foundSoFar.add(new ObjectNode(JsonNodeFactory.instance.objectNode())); foundSoFar.add(new ObjectNode(JsonNodeFactory.instance.objectNode())); foundSoFar.add(new ObjectNode(Json
@Test public void testFindParents() { List<JsonNode> foundSoFar = new ArrayList<JsonNode>(); foundSoFar.add(new ObjectNode(JsonNodeFactory.instance.objectNode())); foundSoFar.add(new ObjectNode(JsonNodeFactory.instance.objectNode())); foundSoFar.add(new ObjectNode(JsonNodeFactory.instance.objectNode())); foundSoFar.add(new ObjectNode(JsonNodeFactory.instance.objectNode())); foundSoFar.add(new ObjectNode(JsonNodeFactory.instance.objectNode())); foundSoFar.add(new ObjectNode(JsonNodeFactory.instance.objectNode())); foundSoFar.add(new ObjectNode(Json
@Test public void testFindParents() { List<JsonNode> foundSoFar = new ArrayList<JsonNode>(); foundSoFar.add(new ObjectNode(JsonNodeFactory.instance.objectNode())); foundSoFar.add(new ObjectNode(JsonNodeFactory.instance.objectNode())); foundSoFar.add(new ObjectNode(JsonNodeFactory.instance.objectNode())); List<JsonNode> children = new ArrayList<JsonNode>(); children.add(new ObjectNode(JsonNodeFactory.instance.objectNode())); children.add(new ObjectNode(JsonNodeFactory.instance.objectNode())); children.add(new ObjectNode(JsonNodeFactory.instance.objectNode()
@Test public void testSetAll() { Map<String, JsonNode> m = new HashMap<String, JsonNode>(); m.put("x", new TextNode("x")); m.put("y", new TextNode("y")); m.put("z", new TextNode("z")); JsonNode n = new ObjectNode(); n.setAll(m); Assert.assertEquals("x", n.get("x").asText()); Assert.assertEquals("y", n.get("y").asText()); Assert.assertEquals("z", n.get("z").asText()); }
@Test public void testSetAll() { Map<String, JsonNode> m = new HashMap<String, JsonNode>(); m.put("a", new JsonNodeFactory().objectNode()); m.put("b", new JsonNodeFactory().objectNode()); m.put("c", new JsonNodeFactory().objectNode()); m.put("d", new JsonNodeFactory().objectNode()); m.put("e", new JsonNodeFactory().objectNode()); Map<String, JsonNode> m2 = new HashMap<String, JsonNode>(); m2.put("a", new JsonNodeFactory().objectNode()); m2.put("b", new JsonNodeFactory().objectNode()); m2.put("c", new JsonNodeFactory().objectNode
@Test public void testSetAll() { Map<String, JsonNode> m = new HashMap<String, JsonNode>(); m.put("a", new JsonNodeFactory().objectNode()); m.put("b", new JsonNodeFactory().objectNode()); m.put("c", new JsonNodeFactory().objectNode()); m.put("d", new JsonNodeFactory().objectNode()); m.put("e", new JsonNodeFactory().objectNode()); m.put("f", new JsonNodeFactory().objectNode()); m.put("g", new JsonNodeFactory().objectNode()); m.put("h", new JsonNodeFactory().objectNode()); m.put("i", new JsonNodeFactory().objectNode()); m.put("j",
@Test public void testSetAll() { Map<String, JsonNode> m = new HashMap<String, JsonNode>(); m.put("a", new JsonNodeFactory().objectNode()); m.put("b", new JsonNodeFactory().objectNode()); m.put("c", new JsonNodeFactory().objectNode()); m.put("d", new JsonNodeFactory().objectNode()); Map<String, JsonNode> m2 = new HashMap<String, JsonNode>(); m2.put("a", new JsonNodeFactory().objectNode()); m2.put("b", new JsonNodeFactory().objectNode()); m2.put("c", new JsonNodeFactory().objectNode()); m2.put("d", new JsonNodeFactory().object
@Test public void testSetAll() { Map<String, JsonNode> m = new HashMap<String, JsonNode>(); m.put("a", new JsonNodeFactory().objectNode()); m.put("b", new JsonNodeFactory().objectNode()); m.put("c", new JsonNodeFactory().objectNode()); m.put("d", new JsonNodeFactory().objectNode()); Map<String, JsonNode> m2 = new HashMap<String, JsonNode>(); m2.put("a", new JsonNodeFactory().objectNode()); m2.put("b", new JsonNodeFactory().objectNode()); m2.put("c", new JsonNodeFactory().objectNode()); m2.put("d", new JsonNodeFactory().object
@Test public void testSetAll() { Map<String, JsonNode> m = new HashMap<String, JsonNode>(); m.put("a", new JsonNodeFactory().objectNode()); m.put("b", new JsonNodeFactory().objectNode()); m.put("c", new JsonNodeFactory().objectNode()); m.put("d", new JsonNodeFactory().objectNode()); Map<String, JsonNode> m2 = new HashMap<String, JsonNode>(); m2.put("a", new JsonNodeFactory().objectNode()); m2.put("b", new JsonNodeFactory().objectNode()); m2.put("c", new JsonNodeFactory().objectNode()); m2.put("d", new JsonNodeFactory().object
@Test public void testSetAllMap() { Map<String, JsonNode> m = new HashMap<String, JsonNode>(); m.put("x", new JsonNodeFactory().objectNode()); m.put("y", new JsonNodeFactory().objectNode()); m.put("z", new JsonNodeFactory().objectNode()); Map<String, JsonNode> m2 = new HashMap<String, JsonNode>(); m2.put("x", new JsonNodeFactory().objectNode()); m2.put("y", new JsonNodeFactory().objectNode()); m2.put("z", new JsonNodeFactory().objectNode()); m2.put("x", new JsonNodeFactory().objectNode()); m2.put("y", new JsonNodeFactory
@Test public void testSetAll() { Map<String, JsonNode> m = new HashMap<String, JsonNode>(); m.put("a", new JsonNodeFactory().objectNode()); m.put("b", new JsonNodeFactory().objectNode()); m.put("c", new JsonNodeFactory().objectNode()); m.put("d", new JsonNodeFactory().objectNode()); m.put("e", new JsonNodeFactory().objectNode()); m.put("f", new JsonNodeFactory().objectNode()); m.put("g", new JsonNodeFactory().objectNode()); m.put("h", new JsonNodeFactory().objectNode()); m.put("i", new JsonNodeFactory().objectNode()); m.put("j",
@Test public void testSetAll() { Map<String, JsonNode> m = new HashMap<String, JsonNode>(); m.put("x", new JsonNodeFactory().objectNode()); m.put("y", new JsonNodeFactory().objectNode()); m.put("z", new JsonNodeFactory().objectNode()); Map<String, JsonNode> m2 = new HashMap<String, JsonNode>(); m2.put("x", new JsonNodeFactory().objectNode()); m2.put("y", new JsonNodeFactory().objectNode()); m2.put("z", new JsonNodeFactory().objectNode()); m2.put("x", new JsonNodeFactory().objectNode()); m2.put("y", new JsonNodeFactory().
@Test public void testReplace() { Map<String, JsonNode> fields = new HashMap<String, JsonNode>(); fields.put("f1", new TextNode("1")); fields.put("f2", new TextNode("2")); fields.put("f3", new TextNode("3")); JsonNode root = new ObjectNode(new ObjectMapper()); root.set("f1", new TextNode("1")); root.set("f2", new TextNode("2")); root.set("f3", new TextNode("3")); JsonNode foo = new ObjectNode(new ObjectMapper()); foo.set("f1", new TextNode("1")); foo.set("f2
@Test public void testReplace() { Map<String, JsonNode> fields = new HashMap<String, JsonNode>(); fields.put("x", new JsonNodeFactory().objectNode()); fields.put("y", new JsonNodeFactory().objectNode()); fields.put("z", new JsonNodeFactory().objectNode()); JsonNode root = new ObjectNode(new ObjectMapper()); root.set("x", new JsonNodeFactory().objectNode()); root.set("y", new JsonNodeFactory().objectNode()); root.set("z", new JsonNodeFactory().objectNode()); root.set("x", new JsonNodeFactory().objectNode()); root.set("y", new JsonNodeFactory().objectNode()); root.set("z", new JsonNodeFactory().
@Test public final void testReplace() { Map<String, JsonNode> fields = new HashMap<String, JsonNode>(); fields.put("f1", new JsonNodeFactory().objectNode()); fields.put("f2", new JsonNodeFactory().objectNode()); fields.put("f3", new JsonNodeFactory().objectNode()); JsonNode root = new ObjectNode(new ObjectMapper()); root.put("f1", new JsonNodeFactory().objectNode()); root.put("f2", new JsonNodeFactory().objectNode()); root.put("f3", new JsonNodeFactory().objectNode()); root.put("f4", new JsonNodeFactory().objectNode()); root.put("f5", new JsonNodeFactory().objectNode()); root
@Test public final void testPut() { JsonNode node = new ObjectNode(); node.put("a", new TextNode("b")); node.put("c", new TextNode("d")); node.put("e", new TextNode("f")); node.put("f", new TextNode("g")); node.put("h", new TextNode("h")); node.put("i", new TextNode("i")); Assert.assertEquals("b", node.get("a").asText()); Assert.assertEquals("c", node.get("c").asText()); Assert.assertEquals("d", node.get("e").asText()); Assert.assertEquals("f
@Test public void testPut() { Map<String, JsonNode> map = new HashMap<String, JsonNode>(); map.put("x", new JsonNodeFactory().objectNode()); map.put("y", new JsonNodeFactory().objectNode()); map.put("z", new JsonNodeFactory().objectNode()); JsonNode node = new ObjectNode(new ObjectMapper()); node.put("x", new JsonNodeFactory().objectNode()); node.put("y", new JsonNodeFactory().objectNode()); node.put("z", new JsonNodeFactory().objectNode()); node.put("x", new JsonNodeFactory().objectNode()); node.put("y", new JsonNodeFactory().objectNode()); node.put("z", new JsonNodeFactory().
@Test public final void testPut() { JsonNode node = new ObjectNode(JsonNodeFactory.instance); node.put("foo", new TextNode("bar")); node.put("baz", new TextNode("baz")); Assert.assertEquals(node.get("foo"), new TextNode("bar")); Assert.assertEquals(node.get("baz"), new TextNode("baz")); node.put("foo", new TextNode("baz")); Assert.assertEquals(node.get("foo"), new TextNode("baz")); Assert.assertEquals(node.get("baz"), new TextNode("baz")); }
@Test public void testPutArray() { ArrayNode a = new ArrayNode(); a.putArray("a"); a.putArray("b"); a.putArray("c"); a.putArray("d"); a.putArray("e"); a.putArray("f"); a.putArray("g"); a.putArray("h"); a.putArray("i"); a.putArray("j"); a.putArray("k"); a.putArray("l"); a.putArray("m"); a.putArray("n"); }
@Test public void testPutArray() { ArrayNode n = new ArrayNode(); n.putArray("a"); n.putArray("b"); n.putArray("c"); n.putArray("d"); n.putArray("e"); n.putArray("f"); n.putArray("g"); n.putArray("h"); n.putArray("i"); n.putArray("j"); n.putArray("k"); assertEquals("{\\n" + " \\"a\\": 1,\\n" + " \\"b\\": 2,\\n" + " \\"c\\": 3,\\n" + " \\"d\\": 4,\\n
@Test public void testPutArray() { ArrayNode root = new ArrayNode(); root.putArray("a"); root.putArray("b"); root.putArray("c"); root.putArray("d"); root.putArray("e"); root.putArray("f"); root.putArray("g"); root.putArray("h"); root.putArray("i"); root.putArray("j"); root.putArray("k"); root.putArray("l"); }
@Test public void testPutArray() { ArrayNode n = new ArrayNode(); n.putArray("a"); n.putArray("b"); n.putArray("c"); n.putArray("d"); n.putArray("e"); n.putArray("f"); n.putArray("g"); n.putArray("h"); n.putArray("i"); n.putArray("j"); n.putArray("k"); n.putArray("l"); }
@Test public void testPutObject() { ObjectNode n = new ObjectNode(); n.putObject("s1").putObject("s2").putObject("s3").putObject("s4").putObject("s5").putObject("s6").putObject("s7").putObject("s8").putObject("s9").putObject("s10").putObject("s11").putObject("s12").putObject("s13").putObject("s14").putObject("s21").putObject("s22").putObject("s23").putObject("s24").putObject("s31").putObject("s32").putObject("s31").putObject("
@Test public void testPutObject() { ObjectNode n = new ObjectNode(); n.putObject("x"); n.putObject("y"); n.putObject("z"); assertEquals(1, n.fields().size()); assertEquals("x", n.get("x").asText()); assertEquals(1, n.get("y").asInt()); }
@Test public void testPutObject() { ObjectNode n = new ObjectNode(); n.putObject("x").putObject("y").putObject("z"); assertEquals(1, n.fields().size()); assertEquals("x", n.get("x").asText()); assertEquals(2, n.fields().size()); assertEquals("y", n.get("y").asText()); assertEquals("z", n.get("z").asText()); }
@Test public void testPutObject() { ObjectNode n = new ObjectNode(); n.putObject("x", 1); n.putObject("y", 2); assertEquals(1, n.putObject("x").get(0).asInt()); assertEquals(2, n.putObject("y").get(0).asInt()); }
@Test public void testAnnotated() { Annotated annotated = new Annotated() { @Override public Class<?> getRawType() { return String.class; } @Override public Type getType(TypeBindings context) { return null; } @Override public TypeBindings getTypeBindings() { return null; } @Override public Class<? extends Annotation> annotationType() { return null; } @Override public Class<? extends Annotation> annotationType() { return null; } @Override public Annotation[] getAnnotations() { return new Annotation[0]; } @Override public Class<? extends Annotation> annotationType() { return null; } @Override public Class<? extends Annotation> annotationType() { return null; } @Override public Class<? extends Annotation> annotationType() { return null;
@Test public void testHasAnnotation() { String[][] tests = new String[][] { new String[] { "public static void main(String[] args) {" }, new String[] { "public static void main(String[] args) {" }, new String[] { "public static void main(String[] args) {" }, new String[] { "public static void main(String[] args) {" }, new String[] { "public static void main(String[] args) {" }, new String[] { "public static void main(String[] args) {" }, new String[] { "public static void main(String[] args) {" }, new String[] { "public static void main(String[] args) {"
@Test public void testSimpleAnnotations() { Annotated annotated = createAnnotated(); assertTrue(annotated.hasAnnotation(SimpleAcl.class)); assertTrue(annotated.hasAnnotation(SimpleAcl2.class)); assertTrue(annotated.hasAnnotation(SimpleAcl3.class)); assertTrue(annotated.hasAnnotation(SimpleAcl4.class)); assertTrue(annotated.hasAnnotation(SimpleAcl5.class)); assertTrue(annotated.hasAnnotation(SimpleAcl6.class)); assertTrue(annotated.hasAnnotation(SimpleAcl7.class)); assertTrue(annotated.hasAnnotation(SimpleAcl8.class)); assertTrue(annotated.hasAnnotation(SimpleAcl9.class
@Test public void testRegularGetter() throws Exception { assertEquals("", okNameForRegularGetter(getMethod(Foo.class, "getFoo"), "getFoo")); assertNull(okNameForRegularGetter(getMethod(Foo.class, "getBar"), "getBar")); assertNull(okNameForRegularGetter(getMethod(Foo.class, "getBar"), "getBar")); assertNull(okNameForRegularGetter(getMethod(Foo.class, "getBaz"), "getBaz")); assertNull(okNameForRegularGetter(getMethod(Foo.class, "getBaz"), "
@Test public void testRegularGetter() throws Exception { assertNull(okNameForRegularGetter(getMethod("getFoo"), "getFoo")); assertNull(okNameForRegularGetter(getMethod("getBar"), "getBar")); assertNull(okNameForRegularGetter(getMethod("getBaz"), "getBaz")); assertNull(okNameForRegularGetter(getMethod("getBaz"), "getBaz")); assertNull(okNameForRegularGetter(getMethod("getBar"), "getBar")); assertNull(okNameForRegularGetter(getMethod("getBaz"), "getBar")); assertNull(ok
@Test public void testRegularGetter() throws Exception { assertNull(okNameForRegularGetter(getMethod(Foo.class, "getFoo"), "getFoo")); assertNull(okNameForRegularGetter(getMethod(Foo.class, "getBar"), "getBar")); assertNull(okNameForRegularGetter(getMethod(Foo.class, "getBar"), "getBar")); assertNull(okNameForRegularGetter(getMethod(Foo.class, "getBaz"), "getBaz")); assertNull(okNameForRegularGetter(getMethod(Foo.class, "getBaz"), "get
@Test public void testRegularGetter() throws Exception { assertNull(okNameForRegularGetter(getMethod("getFoo"), "getFoo")); assertNull(okNameForRegularGetter(getMethod("getBar"), "getBar")); assertNull(okNameForRegularGetter(getMethod("getBaz"), "getBaz")); assertNull(okNameForRegularGetter(getMethod("getBaz"), "getBaz")); assertNull(okNameForRegularGetter(getMethod("getBar"), "getBar")); assertNull(okNameForRegularGetter(getMethod("getBaz"), "getBar")); assertNull(ok
@Test public void isCglibGetCallbacks() throws Exception { assertTrue(isCglibGetCallbacks(getMethod("getCallback"))); assertTrue(isCglibGetCallbacks(getMethod("getCallback2"))); assertTrue(isCglibGetCallbacks(getMethod("getCallback3"))); assertTrue(isCglibGetCallbacks(getMethod("getCallback4"))); assertTrue(isCglibGetCallbacks(getMethod("getCallback5"))); assertTrue(isCglibGetCallbacks(getMethod("getCallback6"))); assertTrue(isCglibGetCallbacks(getMethod("getCallback7"))); assertTrue(
@Test public void isCglibGetCallbacks() throws Exception { assertTrue(isCglibGetCallbacks(getMethod(TestClass.class, "getCallback"))); assertTrue(isCglibGetCallbacks(getMethod(TestClass.class, "getCallback2"))); assertTrue(isCglibGetCallbacks(getMethod(TestClass.class, "getCallback3"))); assertTrue(isCglibGetCallbacks(getMethod(TestClass.class, "getCallback4"))); assertTrue(isCglibGetCallbacks(getMethod(TestClass.class, "getCallback5"))); assertTrue(isCglibGetCallbacks(get
@Test public void isCglibGetCallbacks() throws Exception { assertFalse(isCglibGetCallbacks(null)); assertFalse(isCglibGetCallbacks(getClass().getDeclaredMethod("getCallback"))); assertFalse(isCglibGetCallbacks(getClass().getDeclaredMethod("getCallback2"))); assertFalse(isCglibGetCallbacks(getClass().getDeclaredMethod("getCallback3"))); assertFalse(isCglibGetCallbacks(getClass().getDeclaredMethod("getCallback4"))); assertFalse(isCglibGetCallbacks(getClass().getDeclaredMethod("getCallback5"))); assertFalse(isCglibGetCallbacks
@Test public void isCglibGetCallbacks() throws Exception { assertTrue(isCglibGetCallbacks(getMethod(TestClass.class, "getCallback"))); assertTrue(isCglibGetCallbacks(getMethod(TestClass.class, "setCallback"))); assertTrue(isCglibGetCallbacks(getMethod(TestClass.class, "setCallback2"))); assertTrue(isCglibGetCallbacks(getMethod(TestClass.class, "setCallback3"))); assertTrue(isCglibGetCallbacks(getMethod(TestClass.class, "setCallback4"))); assertTrue(isCglibGetCallbacks(getMethod
@Test public void isCglibGetCallbacks() throws Exception { assertTrue(isCglibGetCallbacks(getClass().getDeclaredMethod("getCallback"))); assertTrue(isCglibGetCallbacks(getClass().getDeclaredMethod("getCallback2"))); assertTrue(isCglibGetCallbacks(getClass().getDeclaredMethod("getCallback3"))); assertTrue(isCglibGetCallbacks(getClass().getDeclaredMethod("getCallback4"))); assertTrue(isCglibGetCallbacks(getClass().getDeclaredMethod("getCallback5"))); assertTrue(isCglibGetCallbacks(getClass().getDeclaredMethod("getCallback6"
@Test public void isCglibGetCallbacks() throws Exception { assertTrue(isCglibGetCallbacks(getClass().getDeclaredMethod("getCallback"))); assertTrue(isCglibGetCallbacks(getClass().getDeclaredMethod("getCallback2"))); assertTrue(isCglibGetCallbacks(getClass().getDeclaredMethod("getCallback3"))); assertTrue(isCglibGetCallbacks(getClass().getDeclaredMethod("getCallback4"))); assertTrue(isCglibGetCallbacks(getClass().getDeclaredMethod("getCallback5"))); assertTrue(isCglibGetCallbacks(getClass().getDeclaredMethod("getCallback6"
@Test public void isCglibGetCallbacks() throws Exception { assertTrue(isCglibGetCallbacks(getMethod("getCallback"))); assertTrue(isCglibGetCallbacks(getMethod("getCallback2"))); assertTrue(isCglibGetCallbacks(getMethod("getCallback3"))); assertTrue(isCglibGetCallbacks(getMethod("getCallback4"))); assertTrue(isCglibGetCallbacks(getMethod("getCallback5"))); assertTrue(isCglibGetCallbacks(getMethod("getCallback6"))); assertTrue(isCglibGetCallbacks(getMethod("getCallback7"))); assertTrue(
@Test public void isCglibGetCallbacks() throws Exception { assertTrue(isCglibGetCallbacks(getMethod("getCallback"))); assertTrue(isCglibGetCallbacks(getMethod("getCallback2"))); assertTrue(isCglibGetCallbacks(getMethod("getCallback3"))); assertTrue(isCglibGetCallbacks(getMethod("getCallback4"))); assertTrue(isCglibGetCallbacks(getMethod("getCallback5"))); assertTrue(isCglibGetCallbacks(getMethod("getCallback6"))); assertTrue(isCglibGetCallbacks(getMethod("getCallback7"))); assertTrue(
@Test public void isCglibGetCallbacks() throws Exception { assertTrue(isCglibGetCallbacks(getMethod(TestClass.class, "getCallback"))); assertTrue(isCglibGetCallbacks(getMethod(TestClass.class, "getCallback2"))); assertTrue(isCglibGetCallbacks(getMethod(TestClass.class, "getCallback3"))); assertTrue(isCglibGetCallbacks(getMethod(TestClass.class, "getCallback4"))); assertTrue(isCglibGetCallbacks(getMethod(TestClass.class, "getCallback5"))); assertTrue(isCglibGetCallbacks(get
@Test public void isGroovyMetaClassGetter() throws Exception { assertTrue(isGroovyMetaClassGetter(getMethod(getClass(), "getUrl"))); assertTrue(isGroovyMetaClassGetter(getMethod(getClass(), "getUrl2"))); assertTrue(isGroovyMetaClassGetter(getMethod(getClass(), "getUrl3"))); assertTrue(isGroovyMetaClassGetter(getMethod(getClass(), "getUrl4"))); assertTrue(isGroovyMetaClassGetter(getMethod(getClass(), "getUrl5"))); assertTrue(isGroovyMetaClassGetter(getMethod(getClass(), "getUrl6
@Test public void isGroovyMetaClassGetter() throws Exception { assertTrue(isGroovyMetaClassGetter(getMethod(class, "getUrl"))); assertFalse(isGroovyMetaClassGetter(getMethod(class, "getUrl2"))); assertFalse(isGroovyMetaClassGetter(getMethod(class, "getUrl3"))); assertFalse(isGroovyMetaClassGetter(getMethod(class, "getUrl4"))); assertFalse(isGroovyMetaClassGetter(getMethod(class, "getUrl5"))); assertFalse(isGroovyMetaClassGetter(getMethod(class, "getUrl6"))); assertFalse(
@Test public void isGroovyMetaClassGetter() throws Exception { assertTrue(isGroovyMetaClassGetter(getMethod(Class.class, "getPath"))); assertTrue(isGroovyMetaClassGetter(getMethod(Class.class, "setPath"))); assertTrue(isGroovyMetaClassGetter(getMethod(Class.class, "setPath2"))); assertTrue(isGroovyMetaClassGetter(getMethod(Class.class, "setPath3"))); assertTrue(isGroovyMetaClassGetter(getMethod(Class.class, "setPath4"))); assertTrue(isGroovyMetaClassGetter(getMethod(Class.class
@Test public void isGroovyMetaClassGetter() throws Exception { assertTrue(isGroovyMetaClassGetter(getMethod(class, "getUrl"))); assertTrue(isGroovyMetaClassGetter(getMethod(class, "getUrl2"))); assertTrue(isGroovyMetaClassGetter(getMethod(class, "getUrl3"))); assertTrue(isGroovyMetaClassGetter(getMethod(class, "getUrl4"))); assertTrue(isGroovyMetaClassGetter(getMethod(class, "getUrl5"))); assertTrue(isGroovyMetaClassGetter(getMethod(class, "getUrl6"))); assertTrue(
@Test public void isGroovyMetaClassGetter() throws Exception { assertTrue(isGroovyMetaClassGetter(getMethod(Class.class, "getClass"))); assertTrue(isGroovyMetaClassGetter(getMethod(Class.class, "getClass2"))); assertTrue(isGroovyMetaClassGetter(getMethod(Class.class, "getClass3"))); assertTrue(isGroovyMetaClassGetter(getMethod(Class.class, "getClass4"))); assertTrue(isGroovyMetaClassGetter(getMethod(Class.class, "getClass5"))); assertTrue(isGroovyMetaClassGetter(getMethod(Class.
@Test public void isGroovyMetaClassGetter() throws Exception { assertTrue(isGroovyMetaClassGetter(getMethod(getClass(), "getUrl"))); assertTrue(isGroovyMetaClassGetter(getMethod(getClass(), "getUrl2"))); assertTrue(isGroovyMetaClassGetter(getMethod(getClass(), "getUrl3"))); assertTrue(isGroovyMetaClassGetter(getMethod(getClass(), "getUrl4"))); assertTrue(isGroovyMetaClassGetter(getMethod(getClass(), "getUrl5"))); assertTrue(isGroovyMetaClassGetter(getMethod(getClass(), "getUrl6
@Test public void testManglePropertyName() throws Exception { assertNull(manglePropertyName(null)); assertNull(manglePropertyName("")); assertEquals("a", manglePropertyName("a")); assertEquals("b", manglePropertyName("b")); assertEquals("c", manglePropertyName("c")); assertEquals("d", manglePropertyName("d")); assertEquals("e", manglePropertyName("e")); assertEquals("f", manglePropertyName("f")); assertEquals("g", manglePropertyName("g")); assertEquals("h", manglePropertyName("h")); assertEquals("i", manglePropertyName("i")); assertEquals("j", manglePropertyName("j
@Test public void testIntNode() { IntNode n = new IntNode(1); assertEquals(1, n.intValue()); assertEquals(1, n.shortValue()); assertEquals(1, n.intValue()); assertEquals(1, n.longValue()); assertEquals(1.0, n.floatValue(), 0.0); assertEquals(1.0, n.doubleValue(), 0.0); }
@Test public void testValueOf() { IntNode n = IntNode.valueOf(0); assertEquals(0, n.intValue()); n = IntNode.valueOf(1); assertEquals(1, n.intValue()); n = IntNode.valueOf(2); assertEquals(2, n.intValue()); n = IntNode.valueOf(3); assertEquals(3, n.intValue()); n = IntNode.valueOf(4); assertEquals(4, n.intValue()); n = IntNode.valueOf(5); assertEquals(5, n.intValue()); n = IntNode.valueOf(6); assertEquals(6, n.
@Test public void test() { IntNode[] ts = new IntNode[3]; ts[0] = new IntNode(0); ts[1] = new IntNode(1); ts[2] = new IntNode(2); ts[3] = new IntNode(3); ts[4] = new IntNode(4); ts[5] = new IntNode(5); ts[6] = new IntNode(6); ts[7] = new IntNode(7); ts[8] = new IntNode(8); ts[9] = new IntNode(9); ts[10] = new IntNode(10); ts[11] = new IntNode(
@Test public void testIntegration() { assertTrue(new IntNode(0).isIntegrationNumber()); assertTrue(new IntNode(1).isIntegrationNumber()); assertTrue(new IntNode(2).isIntegrationNumber()); assertTrue(new IntNode(3).isIntegrationNumber()); assertTrue(new IntNode(4).isIntegrationNumber()); assertTrue(new IntNode(5).isIntegrationNumber()); assertTrue(new IntNode(6).isIntegrationNumber()); assertTrue(new IntNode(7).isIntegrationNumber()); assertTrue(new IntNode(8).isIntegrationNumber()); assertTrue(new IntNode(9).isIntegrationNumber()); assertTrue(new IntNode(10).is
@Test public void testIntegration() { assertTrue(new IntNode(0).isIntegrationNumber()); assertTrue(new IntNode(1).isIntegrationNumber()); assertTrue(new IntNode(2).isIntegrationNumber()); assertTrue(new IntNode(3).isIntegrationNumber()); assertTrue(new IntNode(4).isIntegrationNumber()); assertTrue(new IntNode(5).isIntegrationNumber()); assertTrue(new IntNode(6).isIntegrationNumber()); assertTrue(new IntNode(7).isIntegrationNumber()); assertTrue(new IntNode(8).isIntegrationNumber()); assertTrue(new IntNode(9).isIntegrationNumber()); assertTrue(new IntNode(10).is
@Test public void testIntValue() { IntNode[] ts = new IntNode[1]; ts[0] = new IntNode(0); assertEquals(0, ts[0].intValue()); ts[0] = new IntNode(1); assertEquals(1, ts[0].intValue()); ts[0] = new IntNode(2); assertEquals(2, ts[0].intValue()); ts[0] = new IntNode(3); assertEquals(3, ts[0].intValue()); ts[0] = new IntNode(4); assertEquals(4, ts[0].intValue()); ts[0] = new IntNode(5); assertEquals
@Test public void testIntValue() { IntNode node = new IntNode(0); assertEquals(node.intValue(), 0); node.setValue(1); assertEquals(node.intValue(), 1); node.setValue(2); assertEquals(node.intValue(), 2); node.setValue(3); assertEquals(node.intValue(), 3); node.setValue(4); assertEquals(node.intValue(), 4); node.setValue(5); assertEquals(node.intValue(), 5); node.setValue(6); assertEquals(node.intValue(), 6); node.setValue(7); assertEquals(node.intValue(), 7);
@Test public void testUnwrappedPropertyHandler() throws IOException, JsonProcessingException { UnwrappedPropertyHandler handler = new UnwrappedPropertyHandler(); SettableBeanProperty prop1=new SettableBeanProperty(); prop1.setName("prop1"); SettableBeanProperty prop2=new SettableBeanProperty(); prop2.setName("prop2"); SettableBeanProperty prop3=new SettableBeanProperty(); prop3.setName("prop3"); SettableBeanProperty prop4=new SettableBeanProperty(); prop4.setName("prop4"); handler.addProperty(prop1); handler.addProperty(prop2); handler.addProperty(prop3); handler.addProperty(prop4);
@Test public void testUnwrappedPropertyHandler() throws IOException, JsonProcessingException { UnwrappedPropertyHandler handler = new UnwrappedPropertyHandler(); SettableBeanProperty property1=new SettableBeanProperty(); property1.setName("name1"); SettableBeanProperty property2=new SettableBeanProperty(); property2.setName("name2"); SettableBeanProperty property3=new SettableBeanProperty(); property3.setName("name3"); SettableBeanProperty property4=new SettableBeanProperty(); property4.setName("name4"); handler.addProperty(property1); handler.addProperty(property2); handler.addProperty(property3); handler.addProperty(property4);
@Test public void testPropertyHandler() throws IOException, JsonProcessingException { UnwrappedPropertyHandler handler = new UnwrappedPropertyHandler(); SettableBeanProperty property1=new SettableBeanProperty(); property1.setName("name1"); SettableBeanProperty property2=new SettableBeanProperty(); property2.setName("name2"); SettableBeanProperty property3=new SettableBeanProperty(); property3.setName("name3"); SettableBeanProperty property4=new SettableBeanProperty(); property4.setName("name4"); SettableBeanProperty property5=new SettableBeanProperty(); property5.setName("name5"); SettableBeanProperty property6=new SettableBeanProperty
@Test public void test() throws IOException, JsonProcessingException { UnwrappedPropertyHandler handler = new UnwrappedPropertyHandler(); handler.addProperty(new SettableBeanProperty("firstName", "firstName")); handler.addProperty(new SettableBeanProperty("lastName", "lastName")); String json = "{\\n" + " \\"firstName\\" : \\"firstName\\",\\n" + " \\"lastName\\" : \\"lastName\\"\\n" + "}"; String expected = "{\\n" + " \\"firstName\\" : \\"firstName\\",\\n" + " \\"lastName\\" : \\"lastName\\"\\n" + "}";
@Test public void testProcessUnwrapped() throws IOException, JsonProcessingException { UnwrappedPropertyHandler handler = new UnwrappedPropertyHandler(); SettableBeanProperty prop1=new SettableBeanProperty(); prop1.setName("prop1"); SettableBeanProperty prop2=new SettableBeanProperty(); prop2.setName("prop2"); SettableBeanProperty prop3=new SettableBeanProperty(); prop3.setName("prop3"); SettableBeanProperty prop4=new SettableBeanProperty(); prop4.setName("prop4"); SettableBeanProperty prop5=new SettableBeanProperty(); prop5.setName("prop5"); SettableBeanProperty prop6=new SettableBean
@Test public void testProcessUnwrapped() throws IOException, JsonProcessingException { UnwrappedPropertyHandler handler = new UnwrappedPropertyHandler(); handler.addProperty(new SettableBeanProperty("firstName", "firstName")); handler.addProperty(new SettableBeanProperty("lastName", "lastName")); handler.addProperty(new SettableBeanProperty("birthday", "birthday")); String json = "{\\n" + " \\"firstName\\" : \\"firstName\\",\\n" + " \\"lastName\\" : \\"lastName\\",\\n" + " \\"birthday\\" : \\"birthday\\",\\n" + " \\"birthday
@Test public void testProcessUnwrapped() throws IOException, JsonProcessingException { UnwrappedPropertyHandler handler = new UnwrappedPropertyHandler(); handler.addProperty(SettableBeanProperty.create("firstName", "firstName")); handler.addProperty(SettableBeanProperty.create("lastName", "lastName")); handler.addProperty(SettableBeanProperty.create("birthday", "birthday")); handler.addProperty(SettableBeanProperty.create("birthday", "birthday")); String json = "{\\n" + " \\"firstName\\" : \\"firstName\\",\\n" + " \\"lastName\\" : \\"lastName\\"\\n" +
@Test public void testProcessUnwrapped() throws IOException, JsonProcessingException { UnwrappedPropertyHandler handler = new UnwrappedPropertyHandler(); handler.addProperty(SettableBeanProperty.create("firstName", "firstName")); handler.addProperty(SettableBeanProperty.create("lastName", "lastName")); handler.addProperty(SettableBeanProperty.create("birthday", "birthday")); String json = "{\\n" + " \\"firstName\\" : \\"firstName\\",\\n" + " \\"lastName\\" : \\"lastName\\",\\n" + " \\"birthday\\" : \\"birthday\\",\\n" + " \\
@Test public void test() throws IOException, JsonProcessingException { UnwrappedPropertyHandler handler = new UnwrappedPropertyHandler(); List<SettableBeanProperty> properties = Lists.newArrayList(); SettableBeanProperty p1 = mock(SettableBeanProperty.class); SettableBeanProperty p2 = mock(SettableBeanProperty.class); SettableBeanProperty p3 = mock(SettableBeanProperty.class); when(p1.getPropertyName()).thenReturn("p1"); when(p2.getPropertyName()).thenReturn("p2"); when(p3.getPropertyName()).thenReturn("p3"); properties.add(p1); properties.add(p2); properties.add
@Test public void testProcessUnwrapped() throws IOException, JsonProcessingException { UnwrappedPropertyHandler handler = new UnwrappedPropertyHandler(); handler.addProperty(SettableBeanProperty.create("firstName", "firstName")); handler.addProperty(SettableBeanProperty.create("lastName", "lastName")); handler.addProperty(SettableBeanProperty.create("birthday", "birthday")); String json = "{\\n" + " \\"firstName\\" : \\"firstName\\",\\n" + " \\"lastName\\" : \\"lastName\\",\\n" + " \\"birthday\\" : \\"birthday\\",\\n" + " \\
@Test public void testSimpleDeserializers() throws Exception { Map<Class<?>, JsonDeserializer<?>> mapDeserializer = new HashMap<Class<?>, JsonDeserializer<?>>(); mapDeserializer.put(String.class, new StringDeserializer()); mapDeserializer.put(Integer.class, new IntegerDeserializer()); mapDeserializer.put(Long.class, new LongDeserializer()); mapDeserializer.put(Float.class, new FloatDeserializer()); mapDeserializer.put(Double.class, new DoubleDeserializer()); mapDeserializer.put(Boolean.class, new BooleanDeserializer()); mapDeserializer.put(Float.class, new FloatDeserializer()); mapDeserializer.put(Long.class, new LongDeserializer()); mapDeserializer.put(Double.class,
@Test public void testMapDeserializer() throws Exception { SimpleDeserializers deserializers = new SimpleDeserializers(); Map<Class<?>, JsonDeserializer<?>> mapDeserializer = deserializers.findMapDeserializer(MapLikeType.class, null, null, null, null); mapDeserializer.addDeserializer(MapLikeType.class, null); mapDeserializer.addDeserializer(MapLikeType.class, null); mapDeserializer.addDeserializer(MapLikeType.class, null); mapDeserializer.addDeserializer(MapLikeType.class, null); mapDeserializer.addDeserializer(MapLikeType.class, null); mapDeserializer.addDeserializer(MapLikeType.class, null); mapDeserializer.addDeserializer(MapLikeType
@Test public void testEnumDeserializer() throws Exception { Map<Class<?>, JsonDeserializer<?>> classMap = new HashMap<Class<?>, JsonDeserializer<?>>(); classMap.put(String.class, new JsonEnumDeserializer<String>(String.class)); classMap.put(Integer.class, new JsonEnumDeserializer<Integer>(Integer.class)); classMap.put(Long.class, new JsonEnumDeserializer<Long>(Long.class)); classMap.put(Float.class, new JsonEnumDeserializer<Float>(Float.class)); classMap.put(Double.class, new JsonEnumDeserializer<Double>(Double.class)); classMap.put(Float.class,
@Test public void testMapDeserializer() throws Exception { Map<Class<?>, JsonDeserializer<?>> classMap = new HashMap<Class<?>, JsonDeserializer<?>>(); classMap.put(String.class, new JsonStringDeserializer()); classMap.put(Integer.class, new JsonIntegerDeserializer()); classMap.put(Long.class, new JsonLongDeserializer()); classMap.put(Float.class, new JsonFloatDeserializer()); classMap.put(Double.class, new JsonDoubleDeserializer()); classMap.put(Float.class, new JsonFloatDeserializer()); SimpleDeserializers deserializers = new SimpleDeserializers(); deserializers.addDeserializer(String.class, new JsonStringDeserializer()); Assert.assertEquals
@Test public void testEnumDeserializer() throws Exception { Map<Class<?>, JsonDeserializer<?>> classMap = new HashMap<Class<?>, JsonDeserializer<?>>(); classMap.put(Enum.class, new JsonEnumDeserializer<Enum>(Enum.class)); classMap.put(String.class, new JsonEnumDeserializer<String>(String.class)); classMap.put(Integer.class, new JsonEnumDeserializer<Integer>(Integer.class)); classMap.put(Long.class, new JsonEnumDeserializer<Long>(Long.class)); classMap.put(Float.class, new JsonEnumDeserializer<Float>(Float.class)); classMap.put(Double.class,
@Test public void testMapDeserializer() throws Exception { Map<Class<?>, JsonDeserializer<?>> classMap = new HashMap<Class<?>, JsonDeserializer<?>>(); classMap.put(String.class, new JsonStringDeserializer()); classMap.put(Integer.class, new JsonIntegerDeserializer()); classMap.put(Long.class, new JsonLongDeserializer()); classMap.put(Float.class, new JsonFloatDeserializer()); classMap.put(Double.class, new JsonDoubleDeserializer()); classMap.put(Boolean.class, new JsonBooleanDeserializer()); classMap.put(String.class, new JsonStringDeserializer()); SimpleDeserializers deserializers = new SimpleDeserializers(); deserializers.addDeserializer
@Test public void testArrayDeserializer() throws Exception { String[][] lines = new String[][] { new String[] {"a", "b"}, new String[] {"c"}, new String[] {"d"}, new String[] {"e"}, new String[] {"f"}, new String[] {"g"}, new String[] {"h"}, new String[] {"i"}, new String[] {"j"}, new String[] {"k"}, new String[] {"l"}, new String[] {"i"}, new String[] {"j"}, new String[] {"k"}, new String[] {"l"}, new String[] {"i"}, new String[] {"j"}, new String[]
@Test public void testArrayDeserializer() throws Exception { SimpleDeserializers classUnderTest = new SimpleDeserializers(); classUnderTest.addDeserializer(String.class, new StringDeserializer()); classUnderTest.addDeserializer(String[].class, new StringDeserializer()); classUnderTest.addDeserializer(int[].class, new intDeserializer()); classUnderTest.addDeserializer(long[].class, new longDeserializer()); classUnderTest.addDeserializer(short[].class, new shortDeserializer()); classUnderTest.addDeserializer(int[].class, new intDeserializer()); classUnderTest.addDeserializer(long[].class, new longDeserializer()); classUnderTest.addDeserializer(short[].class, new short
@Test public void testFindBeanDeserializer() throws Exception { JsonDeserializer<?> deserializer = new SimpleDeserializers().findBeanDeserializer(String.class, null, null); assertNull(deserializer); deserializer = new SimpleDeserializers().findBeanDeserializer(String.class, null, null); assertNull(deserializer); deserializer = new SimpleDeserializers().findBeanDeserializer(String.class, null, null); assertNull(deserializer); deserializer = new SimpleDeserializers().findBeanDeserializer(String.class, null, null); assertNull(deserializer); deserializer = new SimpleDeserializers().findBeanDeserializer(String.class, null, null); assertNull(deserializer); deserializer = new SimpleDeserializers().
@Test public void testEnumDeserializer() throws Exception { Map<Class<?>, JsonDeserializer<?>> classMap = new HashMap<Class<?>, JsonDeserializer<?>>(); classMap.put(MyEnum.class, new JsonDeserializer<MyEnum>() { @Override public JsonDeserializer<?> createDeserializer(Class<?> type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException { return new JsonEnumDeserializer<MyEnum>(type); } }); classMap.put(MyEnum.class, new JsonDeserializer<MyEnum>() { @Override public JsonDeserializer<?> createDeserializer(Class<?> type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException {
@Test public void testEnumDeserializer() throws Exception { JsonDeserializer<?> d = new SimpleDeserializers().findEnumDeserializer(TestEnum.class, null, null); assertNull(d); d = new SimpleDeserializers().findEnumDeserializer(TestEnum.class, null, null); assertNull(d); d = new SimpleDeserializers().findEnumDeserializer(TestEnum.class, null, null); assertNull(d); d = new SimpleDeserializers().findEnumDeserializer(TestEnum.class, null, null); assertNull(d); d = new SimpleDeserializers().findEnumDeserializer(TestEnum.class, null, null); assertNull(d); d = new SimpleDeserializers().find
@Test public void testEnumDeserializer() throws Exception { JsonDeserializer<?> d = _deserializer.findEnumDeserializer(TestEnum.class, _config, _beanDesc); assertEquals(d, _enumDeserializer); d = _deserializer.findEnumDeserializer(TestEnum2.class, _config, _beanDesc); assertEquals(d, _enumDeserializer2); d = _deserializer.findEnumDeserializer(TestEnum3.class, _config, _beanDesc); assertEquals(d, _enumDeserializer3); d = _deserializer.findEnumDeserializer(TestEnum4.class, _config, _beanDesc); assertEquals(d, _enumDeserializer4); }
@Test public void testReplaceParameterAnnotations() { System.out.println("testReplaceParameterAnnotations"); int index = 0; AnnotationMap ann = new AnnotationMap(); AnnotatedWithParams instance = new AnnotatedWithParams(annotations, new AnnotationMap[] {ann}); AnnotatedParameter result = instance.replaceParameterAnnotations(index, ann); assertEquals(1, result.getParameterAnnotations().length); assertEquals(ann, result.getAnnotationMap()); assertEquals(index, result.getParameterIndex()); }
@Test public void testReplaceParameterAnnotations() { Class<?>[] types = new Class<?>[] {String.class, String.class}; for (int i = 0; i < types.length; i++) { AnnotatedParam param1 = new AnnotatedParam("param1", "param1", types[i]); AnnotatedParam param2 = new AnnotatedParam("param2", "param2", types[i]); AnnotatedParam param3 = new AnnotatedParam("param3", "param3", types[i]); AnnotatedParam param4 = new AnnotatedParam("param4", "param4", types[i]); AnnotatedParam param5 = new AnnotatedParam("param5", "param5", types[i]); AnnotationMap
@Test(expected=IndexOutOfBoundsException.class) public void testOutOfBounds() { new AnnotatedWithParams(annotations, paramAnnotations) { @Override public AnnotatedParameter getParameter(int index) { return null; } @Override public Class<?> getType(TypeBindings bindings, Class<?>[] typeParams) { return null; } }.replaceParameterAnnotations(0, annotationMap); }
@Test public void testIgnoredPropertyNames() { Set<String> ignored = _beanDescription.getIgnoredPropertyNames(); Set<String> expected = new HashSet<String>(Arrays.asList("a", "b", "c")); assertEquals(expected, ignored); }
@Test public void testFindInjectables() { MyBean bean = new MyBean(); Map<Object, AnnotatedMember>injectables = bean.findInjectables(); assertEquals(2, injectables.size()); assertTrue(injectables.containsKey("a")); assertTrue(injectables.containsKey("b")); assertTrue(injectables.containsKey("c")); assertTrue(injectables.containsKey("d")); assertTrue(injectables.containsKey("e")); assertTrue(injectables.containsKey("f")); assertTrue(injectables.containsKey("g")); assertTrue(injectables.containsKey("h")); assertTrue(injectables.containsKey
@Test public void testFindInjectables() { MyBean bean = new MyBean(); Map<String, AnnotatedMember>injectables = bean.findInjectables(); assertEquals(2, injectables.size()); assertTrue(injectables.containsKey("a")); assertTrue(injectables.containsKey("b")); assertTrue(injectables.containsKey("c")); assertTrue(injectables.containsKey("d")); assertTrue(injectables.containsKey("e")); assertTrue(injectables.containsKey("f")); assertTrue(injectables.containsKey("g")); assertTrue(injectables.containsKey("h")); assertTrue(injectables.containsKey
@Test public void testFindBackReferenceProperties() { MyBean bean = new MyBean(); Map<String, AnnotatedMember> map = bean.findBackReferenceProperties(); assertNotNull(map); assertEquals(0, map.size()); }
@Test public void testFindBackReferenceProperties() { MyBean bean = new MyBean(); Map<String, AnnotatedMember> map = bean.findBackReferenceProperties(); assertNotNull(map); assertTrue(map.isEmpty()); }
@Test public void testFindBackReferenceProperties() { List<BeanPropertyDefinition> props = new ArrayList<BeanPropertyDefinition>(); props.add(new BeanPropertyDefinition(String.class, "string", true)); props.add(new BeanPropertyDefinition(String.class, "integer", true)); props.add(new BeanPropertyDefinition(Integer.class, "long", true)); props.add(new BeanPropertyDefinition(Long.class, "float", true)); props.add(new BeanPropertyDefinition(Double.class, "double", true)); props.add(new BeanPropertyDefinition(Float.class, "float", true)); props.add(new BeanPropertyDefinition(Double.class,
@Test public void testFindBackReferenceProperties() { MyBean bean = new MyBean(); Map<String, AnnotatedMember> map = bean.findBackReferenceProperties(); assertEquals(2, map.size()); assertTrue(map.containsKey("a")); assertTrue(map.containsKey("b")); assertTrue(map.containsKey("c")); assertTrue(map.containsKey("d")); assertTrue(map.containsKey("e")); assertTrue(map.containsKey("f")); assertTrue(map.containsKey("g")); assertTrue(map.containsKey("h")); assertTrue(map.containsKey("i")); assertTrue(map.
@Test public void testFindBackReferenceProperties() { MyBean bean = new MyBean(); Map<String, AnnotatedMember> map = bean.findBackReferenceProperties(); assertNotNull(map); assertTrue(map.isEmpty()); }
@Test public void testFindBackReferenceProperties() throws Exception { Map<String, AnnotatedMember> findBackReferenceProperties = createBeanDescription().findBackReferenceProperties(); assertNotNull(findBackReferenceProperties); assertEquals(2, findBackReferenceProperties.size()); assertTrue(findBackReferenceProperties.containsKey("foo")); assertTrue(findBackReferenceProperties.containsKey("bar")); assertTrue(findBackReferenceProperties.containsKey("baz")); assertNull(findBackReferenceProperties.get("foo")); assertNull(findBackReferenceProperties.get("bar")); assertNull(findBackReferenceProperties.get("baz")); }
@Test public void testFindBackReferenceProperties() { MyBean bean = new MyBean(); Map<String, AnnotatedMember> map = bean.findBackReferenceProperties(); assertNotNull(map); assertTrue(map.isEmpty()); }
@Test public void testFindBackReferenceProperties() { MyBean bean = new MyBean(); Map<String, AnnotatedMember> map = bean.findBackReferenceProperties(); assertEquals(0, map.size()); assertNull(map.get("foo")); assertNull(map.get("bar")); map.put("foo", new AnnotatedMember()); map.put("bar", new AnnotatedMember()); map.put("baz", new AnnotatedMember()); map.put("baz", new AnnotatedMember()); assertEquals(2, map.size()); assertEquals("foo", map.get("foo")); assertEquals("bar", map.get("bar")); assertNull(map.get("baz
@Test(expected=IllegalStateException.class) public void createConverter_NoClass() { MapConfig config = new MapConfig(); config.setHandlerInstantiator(new HandlerInstantiator() { @Override public void converterInstance(MapperConfig<?, ?> config, Class<Converter> type, Class<Converter> converterClass) { } @Override public boolean canOverrideAccessModifiers() { return false; } }); BasicBeanDescription beanDesc = new BasicBeanDescription(); beanDesc.setClazz(NoClass.class); beanDesc.setProperties(Collections.<BeanPropertyDefinition>emptyList()); BeanPropertyDefinition[] properties = beanDesc.findProperties(); assertEquals(1, properties.length); assertTrue(properties[0
@Test public void createConverter() { MyConfig config = new MyConfig(); config.setHandlerInstantiator(new MyHandlerInstantiator()); MyConverter tc = new MyConverter(); Converter<Object, Object> tc1 = config.getConverter(tc); Converter<Object, Object> tc2 = config.getConverter(tc); assertSame(tc1, tc2); }
@Test(expected=IllegalStateException.class) public void createConverter_NoClass() { MyConfig config = new MyConfig(); config.setHandlerInstantiator(new MyHandlerInstantiator()); MyConverter tc = new MyConverter(); config.setConverterClass(tc.getClass()); config.setCanOverrideAccessModifiers(true); MyConverter tc2 = new MyConverter(); config.setConverterClass(tc2.getClass()); config.setCanOverrideAccessModifiers(false); MyConverter tc3 = new MyConverter(); config.setConverterClass(tc3.getClass()); config.setCanOverrideAccessModifiers(true); MyConverter tc4 = new MyConverter(); config.setConverterClass(tc4
@Test(expected=IllegalStateException.class) public void createConverter_NoClass() { MapConfig config = new MapConfig(); config.setHandlerInstantiator(new HandlerInstantiator() { @Override public Converter<Object, Object> converterInstance(MapperConfig<?, ?> config, Class<Converter> type, Class<Converter> converterClass) { return null; } @Override public boolean canOverrideAccessModifiers() { return false; } }); new MyObject()._createConverter(new MyObject()); }
@Test(expected=IllegalStateException.class) public void createConverter_NoClass() { MapConfig config = new MapConfig(); config.setHandlerInstantiator(new HandlerInstantiator() { @Override public void converterInstance(MapperConfig<?, ?> config, Class<Converter> type, Class<Converter> converterClass) { } @Override public boolean canOverrideAccessModifiers() { return false; } }); BasicBeanDescription beanDesc = new BasicBeanDescription(); beanDesc.setClazz(NoClass.class); beanDesc.setProperties(Collections.<BeanPropertyDefinition>emptyList()); BeanPropertyDefinition[] properties = beanDesc.getProperties(); assertEquals(1, properties.length); assertTrue(properties[0
@Test(expected=IllegalStateException.class) public void createConverter_WrongConverterType() { class MyBadConverter extends Converter { private static final long serialVersionUID = 1L; @Override public Converter<Object, Object> createConverter(Object converterDef) { return new MyBadConverter(); } } MyBadConverter myBadConverter = new MyBadConverter(); MyBadConverter myBadConverter2 = new MyBadConverter(); MyBadConverter myBadConverter3 = new MyBadConverter(); MyBadConverter myBadConverter4 = new MyBadConverter(); MyBadConverter myBadConverter5 = new MyBadConverter(); MyBadConverter myBadConverter6 = new MyBadConverter(); MyBadConverter myBadConverter7 = new My
@Test(expected=IllegalStateException.class) public void createConverter_NoClass() { MyConfig config = new MyConfig(); config.setHandlerInstantiator(new HandlerInstantiator() { @Override public Class<?> getHandlerInstantiator() { return null; } @Override public boolean canOverrideAccessModifiers() { return false; } @Override public Converter<Object, Object> createConverter(Object converterDef) { return null; } }); config.createConverter(new MyConverter()); }
@Test public void createConverter() { MyConfig config = new MyConfig(); config.setHandlerInstantiator(new MyHandlerInstantiator()); MyConverter tc = new MyConverter(); config.setConverterInstance(tc); Converter<Object, Object> tc2 = config.createConverter(tc); assertEquals(tc, tc2); }
@Test(expected=IllegalStateException.class) public void createConverter_NoClass() { MapConfig config = new MapConfig(); config.setHandlerInstantiator(new MyHandlerInstantiator()); MyConverter tc = new MyConverter(); config.setConverter(tc); MyConverter tc2 = new MyConverter(); config.setConverterInstance(tc2); MyConverter tc3 = new MyConverter(); config.setConverterInstance(tc3); config.setHandlerInstantiator(new MyHandlerInstantiator()); MyConverter tc4 = new MyConverter(); config.setConverterInstance(tc4); config.setHandlerInstantiator(new MyHandlerInstantiator()); MyConverter tc5 = new MyConverter(); config.setConverter
@Test(expected=IllegalStateException.class) public void createConverter_WrongConverterType() { MyConfig config = new MyConfig(); config.setHandlerInstantiator(new MyHandlerInstantiator()); config.setConverterClass(MyConverter.class); MyConverter converter = (MyConverter)config._createConverter(new MyConverter()); }
@Test public void testGetValueTypeDesc() { System.out.println("getValueTypeDesc"); StdValueInstantiator instance = new StdValueInstantiator(null, String.class); String expResult = "String"; String result = instance.getValueTypeDesc(); assertEquals(expResult, result); }
@Test public void testGetValueTypeDesc() { System.out.println("getValueTypeDesc"); StdValueInstantiator instance = new StdValueInstantiator(null, String.class); String expResult = "String"; String result = instance.getValueTypeDesc(); assertEquals(expResult, result); }
@Test public void testCanCreateFromString() { assertTrue(new StdValueInstantiator(null, String.class).canCreateFromString()); assertFalse(new StdValueInstantiator(null, String.class).canCreateFromString()); }
@Test public void testCanCreateFromString() throws IOException, JsonProcessingException { assertTrue(new StdValueInstantiator(null, String.class).canCreateFromString()); assertFalse(new StdValueInstantiator(new DeserializationConfig("test"), String.class).canCreateFromString()); assertTrue(new StdValueInstantiator(new DeserializationConfig("test\\n"), String.class).canCreateFromString()); assertFalse(new StdValueInstantiator(new DeserializationConfig("test\\n"), String.class).canCreateFromString()); assertFalse(new StdValueInstantiator(new DeserializationConfig("test\\n"), String.class).canCreateFromString()); }
@Test public void testCanCreateFromInt() { assertTrue(new StdValueInstantiator(config, Integer.class).canCreateFromInt()); assertFalse(new StdValueInstantiator(config, String.class).canCreateFromInt()); }
@Test public void testCanCreateFromInt() throws IOException, JsonProcessingException { assertTrue(new StdValueInstantiator(null, String.class).canCreateFromInt()); assertTrue(new StdValueInstantiator(new DeserializationConfig("test"), String.class).canCreateFromInt()); assertFalse(new StdValueInstantiator(new DeserializationConfig("test"), String.class).canCreateFromInt()); assertFalse(new StdValueInstantiator(new DeserializationConfig("test"), Long.class).canCreateFromInt()); assertFalse(new StdValueInstantiator(new DeserializationConfig("test"), Long.class).canCreateFromInt()); }
@Test public void testCanCreateFromLong() { assertTrue(new StdValueInstantiator(config, Long.class).canCreateFromLong()); assertFalse(new StdValueInstantiator(config, String.class).canCreateFromLong()); }
@Test public void testCanCreateFromLong() { var gf = new StdValueInstantiator(null, String.class); assertTrue(gf.canCreateFromLong()); var gf2 = new StdValueInstantiator(null, String.class); assertFalse(gf2.canCreateFromLong()); var gf3 = new StdValueInstantiator(null, String.class); assertFalse(gf3.canCreateFromLong()); var gf4 = new StdValueInstantiator(null, String.class); assertTrue(gf4.canCreateFromLong()); var gf5 = new StdValueInstantiator(null, String.class); assertTrue(gf5.canCreateFromLong
@Test public void testCanCreateFromDouble() { assertTrue(new StdValueInstantiator(config, Double.class).canCreateFromDouble()); assertFalse(new StdValueInstantiator(config, String.class).canCreateFromDouble()); }
@Test public void testCanCreateFromDouble() { var dt = new StdValueInstantiator(null, Double.class); assertTrue(dt.canCreateFromDouble()); var dt2 = new StdValueInstantiator(new DeserializationConfig("test"), Double.class); assertFalse(dt2.canCreateFromDouble()); }
@Test public void testCanCreateFromBoolean() { assertTrue(new StdValueInstantiator(DeserializationConfig.DEFAULT_DESERIALIZATION, String.class).canCreateFromBoolean()); assertFalse(new StdValueInstantiator(DeserializationConfig.DEFAULT_DESERIALIZATION, String.class).canCreateFromBoolean()); }
@Test public void testCanCreateFromBoolean() { assertFalse(new StdValueInstantiator(null, String.class).canCreateFromBoolean()); assertTrue(new StdValueInstantiator(null, boolean.class).canCreateFromBoolean()); assertFalse(new StdValueInstantiator(null, long.class).canCreateFromBoolean()); assertFalse(new StdValueInstantiator(null, double.class).canCreateFromBoolean()); assertTrue(new StdValueInstantiator(null, float.class).canCreateFromBoolean()); assertTrue(new StdValueInstantiator(null, double.class).canCreateFromDouble()); assertTrue(new StdValueInstantiator(null, boolean.class).canCreate
@Test public void test_cfgEmptyStringsAsObjects() throws IOException, JsonProcessingException { final DeserializationContext ctxt = new DeserializationContext() { @Override public Object createFromObjectWith(DeserializationContext ctxt, Object[] args) throws IOException, JsonProcessingException { return null; } @Override public boolean canCreateFromBoolean() { return true; } @Override public boolean canCreateFromInt() { return true; } @Override public boolean canCreateFromLong() { return true; } @Override public Object createUsingDefault(DeserializationContext ctxt, Object args) throws IOException, JsonProcessingException { return null; } @Override public boolean canCreateUsingObjectWith(DeserializationContext ctxt, Object args) throws IOException
@Test public final void test_createFromStringFallbacks() throws IOException, JsonMappingException { final Object obj = new StdValueInstantiator() { @Override protected Object createFromBooleanFallbacks(DeserializationContext ctxt, boolean fromBoolean) throws IOException, JsonProcessingException { return true; } @Override protected String getValueTypeDesc() { return "boolean"; } @Override protected boolean canCreateFromInt() { return true; } @Override protected boolean canCreateFromLong() { return true; } @Override protected String _createFromStringFallbacks(DeserializationContext ctxt, String value) throws IOException, JsonProcessingException { return "true"; } @Override protected Object createFromObjectWith(DeserializationContext ctxt, Object[] args)
@Test public void testGetSchema() throws Exception { StdArraySerializers<TestClass> serializers = new StdArraySerializers<TestClass>() { private static final long serialVersionUID = 1L; @Override protected ObjectSerializer createSchemaNode(boolean value) { return new ObjectSerializer() { @Override public JsonNode getSchema(SerializerProvider provider, TypeHint typeHint) throws IOException, JsonMappingException { return null; } @Override public JsonNode getSchema(SerializerProvider provider, TypeHint typeHint) throws IOException, JsonGenerationException { return null; } @Override public JsonNode getSchema(SerializerProvider provider, TypeHint typeHint) throws IOException, JsonGenerationException { return null; } @Override public JsonNode getSchema(SerializerProvider provider
@Test public void testGetSchema() throws Exception { StdArraySerializers<TestClass> serializers = new StdArraySerializers<TestClass>() { @Override protected ListSerializer<TestClass> findStandardImpl(Class<?> cls) { return new ListSerializer<TestClass>(Arrays.asList(new TestClass("a"), new TestClass("b"))); } @Override protected ListSerializer<TestClass> findStandardImpl(Class<?> cls) { return new ListSerializer<TestClass>(Arrays.asList(new TestClass("c"), new TestClass("d"))); } @Override protected ListSerializer<TestClass> findStandardImpl(Class<?> cls
@Test public void testGetSchema() throws Exception { StdArraySerializers<TestClass> serializers = new StdArraySerializers<TestClass>() { private static final long serialVersionUID = 1L; @Override protected JsonNode getSchema(SerializerProvider provider, TypeHint typeHint) { return null; } @Override protected JsonNode createSchemaNode(String typeHint) { return null; } @Override protected ObjectNode createSchemaNode(boolean value) { return null; } @Override protected JsonNode createSchemaNode(String typeHint) { return null; } @Override protected ObjectNode createSchemaNode(boolean value) { return null; } @Override protected JsonNode createSchemaNode(String typeHint) { return null; } @
@Test public void testGetSchema() throws Exception { StdArraySerializers<TestClass> serializers = new StdArraySerializers<TestClass>() { private static final long serialVersionUID = 1L; @Override protected JsonNode getSchema(SerializerProvider provider, TypeHint typeHint) throws IOException, JsonMappingException { return null; } @Override protected ObjectSerializer createSchemaNode(String typeHint) throws IOException, JsonGenerationException { return new ObjectSerializer() { @Override public JsonNode getSchema(SerializerProvider provider, TypeHint typeHint) throws IOException, JsonGenerationException { return null; } @Override public JsonNode getSchema(SerializerProvider provider, TypeHint typeHint) throws IOException, JsonGenerationException { return null; } @Override
@Test public void getSchema() throws Exception { StdArraySerializers<TestClass> serializers = new StdArraySerializers<TestClass>() { @Override protected ListSerializer<TestClass> findStandardImpl(Class<?> cls) { return new ListSerializer<TestClass>(Arrays.asList("a", "b", "c")); } @Override protected ListSerializer<TestClass> findStandardImpl(Class<?> cls) { return new ListSerializer<TestClass>(Arrays.asList("a", "b", "c")); } @Override protected ListSerializer<TestClass> findStandardImpl(Class<?> cls) { return new ListSerializer<TestClass>(Arrays.as
@Test public void testGetSchema() throws Exception { StdArraySerializers<TestClass> serializers = new StdArraySerializers<TestClass>() { @Override protected ListSerializer<TestClass> findStandardImpl(Class<?> cls) { return new ListSerializer<TestClass>(Arrays.asList("a", "b", "c")); } @Override protected ListSerializer<TestClass> findStandardImpl(Class<?> cls) { return new ListSerializer<TestClass>(Arrays.asList("a", "b", "c")); } @Override protected ListSerializer<TestClass> findStandardImpl(Class<?> cls) { return new ListSerializer<TestClass>(Arrays
@Test public void testGetSchema() throws Exception { StdArraySerializers<TestClass> serializers = new StdArraySerializers<TestClass>() { private static final long serialVersionUID = 1L; @Override protected ListSerializer<TestClass> findStandardImpl(Class<?> cls) { return new ListSerializer<TestClass>(Arrays.asList(TestClass.class)); } @Override protected ListSerializer<TestClass> findStandardImpl(Class<?> cls) { return new ListSerializer<TestClass>(Arrays.asList(TestClass.class)); } @Override protected ListSerializer<TestClass> findStandardImpl(Class<?> cls) { return new ListSerializer<TestClass>(
@Test public void testGetSchema() throws Exception { StdArraySerializers<TestClass> serializers = new StdArraySerializers<TestClass>() { @Override protected ListSerializer<TestClass> findStandardImpl(Class<?> cls) { return new ListSerializer<TestClass>(Arrays.asList("a", "b", "c")); } @Override protected ListSerializer<TestClass> findStandardImpl(Class<?> cls) { return new ListSerializer<TestClass>(Arrays.asList("a", "b", "c")); } @Override protected ListSerializer<TestClass> findStandardImpl(Class<?> cls) { return new ListSerializer<TestClass>(Arrays
@Test public void testGetSchema() throws Exception { StdArraySerializers<TestClass> serializers = new StdArraySerializers<TestClass>() { private static final long serialVersionUID = 1L; @Override protected JsonNode getSchema(SerializerProvider provider, TypeHint typeHint) { return new ObjectNode("array", true); } @Override protected ObjectNode createSchemaNode(String typeHint) { return new ObjectNode("string", true); } @Override protected JsonNode createSchemaNode(String typeHint) { return new ObjectNode("array", true); } @Override protected ObjectNode createSchemaNode(String typeHint) { return new ObjectNode("string", true); } @Override protected JsonNode createSchemaNode(boolean
@Test public void getSchema() throws Exception { StdArraySerializers<TestClass> serializers = new StdArraySerializers<TestClass>() { @Override protected ListSerializer<TestClass> findStandardImpl(Class<?> cls) { return new ListSerializer<TestClass>(Arrays.asList(TestClass.class)); } @Override protected ListSerializer<TestClass> findStandardImpl(ListSerializer<TestClass> cls) { return new ListSerializer<TestClass>(Arrays.asList(TestClass.class)); } @Override protected ListSerializer<TestClass> findStandardImpl(Class<?> cls) { return new ListSerializer<TestClass>(Arrays.asList(TestClass.
@Test public void testGetSchema() throws Exception { StdArraySerializers<TestClass> serializers = new StdArraySerializers<TestClass>() { private static final long serialVersionUID = 1L; @Override protected ListSerializer<TestClass> newSerializerProvider(SerializerProvider provider, TypeHint typeHint) { return new ListSerializer<TestClass>(TestClass.class); } @Override protected ListSerializer<TestClass> newSerializerProvider(SerializerProvider provider, TypeHint typeHint) { return new ListSerializer<TestClass>(TestClass.class); } @Override protected ListSerializer<TestClass> newSerializerProvider(SerializerProvider provider, TypeHint typeHint) { return new ListSerializer<TestClass
@Test public void testGetSchema() throws Exception { StdArraySerializers<String> serializers = new StdArraySerializers<String>() { @Override protected ListSerializer<String> findStandardImpl(Class<?> cls) { return new ListSerializer<String>(Arrays.asList("a", "b", "c")); } @Override protected ListSerializer<String> findStandardImpl(Class<?> cls) { return new ListSerializer<String>(Arrays.asList("a", "b", "c")); } @Override protected ListSerializer<String> findStandardImpl(Class<?> cls) { return new ListSerializer<String>(Arrays.asList("a", "b
@Test public void testGetSchema() throws Exception { StdArraySerializers<TestClass> serializers = new StdArraySerializers<TestClass>() { @Override protected ListSerializer<TestClass> findStandardImpl(Class<?> typeHint) { return new ListSerializer<TestClass>(Arrays.asList(TestClass.class)); } @Override protected ListSerializer<TestClass> findStandardImpl(Class<?> typeHint) { return new ListSerializer<TestClass>(Arrays.asList(TestClass.class)); } @Override protected ListSerializer<TestClass> findStandardImpl(Class<?> typeHint) { return new ListSerializer<TestClass>(Arrays.asList(Test
@Test public void testGetSchema() throws Exception { StdArraySerializers<TestClass> serializers = new StdArraySerializers<TestClass>() { @Override protected ListSerializer<TestClass> findStandardImpl(Class<?> typeHint) { return new ListSerializer<TestClass>(TestClass.class) { @Override public JsonNode getSchema(SerializerProvider provider, TypeHint typeHint) throws IOException, JsonMappingException { throw new AssertionError(); } @Override public JsonNode getSchema(SerializerProvider provider, TypeHint typeHint) throws IOException, JsonMappingException { throw new AssertionError(); } @Override public JsonNode getSchema(SerializerProvider provider, TypeHint typeHint) throws IOException, JsonMappingException { throw new AssertionError();
@Test public void testGetSchema() throws Exception { StdArraySerializers<TestClass> serializers = new StdArraySerializers<TestClass>() { private static final long serialVersionUID = 1L; @Override protected ListSerializer<TestClass> newSerializerProvider(SerializerProvider provider) { return new ListSerializer<TestClass>(TestClass.class); } @Override protected ListSerializer<TestClass> newSerializerProvider(SerializerProvider provider) { return new ListSerializer<TestClass>(TestClass.class); } @Override protected ListSerializer<TestClass> newSerializerProvider(SerializerProvider provider) { return new ListSerializer<TestClass>(TestClass.class); } @Override protected ListSerializer<Test
@Test public void testGetSchema() throws Exception { StdArraySerializers<TestClass> serializers = new StdArraySerializers<TestClass>() { private static final long serialVersionUID = 1L; @Override protected ObjectSerializer createSchemaNode(String typeHint) { return new ObjectSerializer() { @Override public JsonNode getSchema(SerializerProvider provider, TypeHint typeHint) throws IOException, JsonMappingException { return null; } @Override public JsonNode getSchema(SerializerProvider provider, TypeHint typeHint) throws IOException, JsonGenerationException { return null; } @Override public JsonNode getSchema(SerializerProvider provider, TypeHint typeHint) throws IOException, JsonGenerationException { return null; } @Override public JsonNode getSchema(SerializerProvider
@Test public void testGetSchema() throws Exception { StdArraySerializers<TestClass> serializers = new StdArraySerializers<TestClass>() { @Override protected ListSerializer<TestClass> findStandardImpl(Class<?> cls) { return new ListSerializer<TestClass>(Arrays.asList("a", "b", "c")); } @Override protected ListSerializer<TestClass> findStandardImpl(Class<?> cls) { return new ListSerializer<TestClass>(Arrays.asList("a", "b", "c")); } @Override protected ListSerializer<TestClass> findStandardImpl(Class<?> cls) { return new ListSerializer<TestClass>(Arrays
@Test public void testFloatArraySerializer() throws Exception { StdArraySerializers<Float[]> serializers = new StdArraySerializers<Float[]>() { @Override protected JsonNode createSchemaNode(String typeHint) { return null; } }; SchemaNode schemaNode = serializers.getSchema(null, null); Assert.assertNotNull(schemaNode); Assert.assertEquals("array", schemaNode.get("items").get(0).get("name").asText()); Assert.assertEquals("integer", schemaNode.get("items").get(1).get("name").asText()); schemaNode = serializers.getSchema(null, null); Assert.assertNotNull(schemaNode); Assert
@Test public void testGetSchema() throws Exception { StdArraySerializers<TestClass> serializers = new StdArraySerializers<TestClass>() { private static final long serialVersionUID = 1L; @Override protected ObjectSerializer createSchemaNode(String typeHint) { return new ObjectSerializer() { @Override public JsonNode getSchema(SerializerProvider provider, TypeHint typeHint) throws IOException, JsonMappingException { return null; } @Override public JsonNode getSchema(SerializerProvider provider, TypeHint typeHint) throws IOException, JsonMappingException { return null; } @Override public JsonNode getSchema(SerializerProvider provider, TypeHint typeHint) throws IOException, JsonMappingException { return null; } @Override public JsonNode getSchema(SerializerProvider
@Test public void testBooleanSerializer() throws IOException, JsonGenerationException { ByteArrayOutputStream baos = new ByteArrayOutputStream(); JsonGenerator jgen = new JsonFactory().createGenerator(baos); BooleanArraySerializer bs = new BooleanArraySerializer(); bs.serializeContents(true, jgen, null); bs.serializeContents(false, jgen, null); jgen.flush(); ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray()); BooleanArraySerializer bs2 = new BooleanArraySerializer(); bs2.serializeContents(true, jgen, null); bs2.serializeContents(false, jgen, null); jgen.flush(); ByteArrayInputStream bais2 = new ByteArrayInputStream(baos.toByteArray()); BooleanArraySerializer bs
@Test public void testFloatArraySerializer() throws IOException, JsonGenerationException { float[] values = {1.1f, 2.2f, 3.3f}; MockJsonGenerator jgen = new MockJsonGenerator(); StdArraySerializers.FloatArraySerializer floatArraySerializer = new StdArraySerializers.FloatArraySerializer(); floatArraySerializer.setValueTypeSerializer(floatArraySerializer); floatArraySerializer.serializeContents(values, jgen, null); jgen.flush(); String str = jgen.toString(); Assert.assertEquals("[1.1, 2.2, 3.3]", str); }
@Test public void testLongArraySerializer() throws IOException, JsonGenerationException { ByteArrayOutputStream baos = new ByteArrayOutputStream(); JsonGenerator jgen = new JsonFactory().createGenerator(baos); new IntArraySerializer().serializeContents(new long[]{1, 2, 3}, jgen, null); jgen.flush(); String str = baos.toString(); Assert.assertEquals("[1, 2, 3]", str); }
@Test public void testLongArraySerializer() throws IOException, JsonGenerationException { ByteArrayOutputStream out = new ByteArrayOutputStream(); JsonGenerator jgen = new JsonFactory().createGenerator(out); long[] value = {1, 2, 3}; _arraySerializer.serializeContents(value, jgen, null); jgen.flush(); JsonNode actualObj = mapper.readTree(out.toString()); Assert.assertEquals(value[0], actualObj.get("1").asDouble(), 0.00001); Assert.assertEquals(value[1], actualObj.get("2").asDouble(), 0.00001); Assert.assertEquals(value[2], actualObj.get("3").asDouble(), 0.
@Test public void testGetSchema() throws Exception { StdArraySerializers<TestClass> serializers = new StdArraySerializers<TestClass>() { private static final long serialVersionUID = 1L; @Override protected ObjectSerializer<TestClass> newSerializer() { return new TestClassSerializer(TestClass.class); } @Override protected ObjectSerializer<TestClass> newSerializer() { return new TestClassSerializer(TestClass.class); } @Override protected ObjectSerializer<TestClass> newSerializer() { return new TestClassSerializer(TestClass.class); } }; assertEquals("[\\n" + " {\\n" + " \\"array\\": [\\n" + " {\\n
@Test public void testGetSchema() throws Exception { StdArraySerializers<TestClass> serializers = new StdArraySerializers<TestClass>() { @Override protected ListSerializer<TestClass> findStandardImpl(Class<?> cls) { return new ListSerializer<TestClass>(Arrays.asList(new TestClass("a"), new TestClass("b"))); } @Override protected ListSerializer<TestClass> findStandardImpl(Class<?> cls) { return new ListSerializer<TestClass>(Arrays.asList(new TestClass("c"), new TestClass("d"))); } @Override protected ListSerializer<TestClass> findStandardImpl(Class<?> cls
@Test public void testGetSchema() throws Exception { StdArraySerializers<TestClass> serializers = new StdArraySerializers<TestClass>() { private static final long serialVersionUID = 1L; @Override protected JsonNode getSchema(SerializerProvider provider, TypeHint typeHint) { return null; } @Override protected JsonNode createSchemaNode(String typeHint, boolean anyBoolean) { return null; } @Override protected JsonNode createSchemaNode(String typeHint, boolean anyBoolean) { return null; } @Override protected JsonNode createSchemaNode(ObjectNode items, boolean anyBoolean) { return null; } @Override protected JsonNode createSchemaNode(String typeHint, boolean anyBoolean) { return null; } };
@Test public void testGetSchema() throws Exception { StdArraySerializers<TestClass> serializers = new StdArraySerializers<TestClass>() { private static final long serialVersionUID = 1L; @Override protected JsonNode getSchema(SerializerProvider provider, TypeHint typeHint) throws IOException, JsonMappingException { return null; } }; for (TestClass testClass : TestClass.values()) { JsonNode schemaNode = serializers.getSchema(null, null); Assert.assertNotNull(schemaNode); Assert.assertEquals("array", schemaNode.get("array").asText()); Assert.assertEquals("number", schemaNode.get("items").asText()); } }
@Test public void testGetSchema() throws Exception { StdArraySerializers<TestClass> serializers = new StdArraySerializers<TestClass>() { private static final long serialVersionUID = 1L; @Override protected JsonNode createSchemaNode(boolean a, boolean b) { return createSchemaNode(a, b); } @Override protected JsonNode createSchemaNode(String s, boolean b) { return createSchemaNode(s, b); } }; Set<String> names = new HashSet<String>(); names.add("a"); names.add("b"); names.add("c"); Set<String> names2 = new HashSet<String>(); names2.add("d"); names2.add
@Test public void testGetSchema() throws Exception { StdArraySerializers<TestClass> serializers = new StdArraySerializers<TestClass>() { @Override protected ListSerializer<TestClass> findStandardImpl(Class<?> cls) { return new ListSerializer<TestClass>(Arrays.asList(new TestClass("a"), new TestClass("b"))); } @Override protected ListSerializer<TestClass> findStandardImpl(Class<?> cls) { return new ListSerializer<TestClass>(Arrays.asList(new TestClass("c"), new TestClass("d"))); } @Override protected ListSerializer<TestClass> findStandardImpl(Class<?> cls
@Test public void testGetSchema() throws Exception { Set<String> values = new HashSet<String>(); values.add("a"); values.add("b"); values.add("c"); values.add("d"); values.add("e"); values.add("f"); values.add("g"); values.add("h"); values.add("i"); values.add("j"); values.add("j"); values.add("k"); values.add("l"); values.add("l"); values.add("s"); values.add("s"); values.add("d"); values.add("e"); values.add("f"); values.add("g"); values.add("h
@Test public void testGetSchema() throws Exception { StdArraySerializers<TestClass> serializers = new StdArraySerializers<TestClass>() { private static final long serialVersionUID = 1L; @Override protected JsonNode getSchema(SerializerProvider provider, TypeHint typeHint) throws IOException, JsonMappingException { return null; } @Override protected JsonNode createSchemaNode(String typeHint, boolean include) throws IOException, JsonGenerationException { return null; } }; for (TestClass testClass : TestClass.values()) { JsonNode schemaNode = serializers.getSchema(null, null); Assert.assertNotNull(schemaNode); Assert.assertEquals("array", schemaNode.get("array").asText());
@Test public void testWithContentValueHandler() throws Exception { MapType map = MapType.construct(Map.class, _keyType, _valueType); Object h = new Object(); map.withContentValueHandler(h); }
@Test public void testWithContentValueHandler() throws Exception { final MapType m = MapType.construct(Map.class, PARAM_KEY_OBJECT, PARAM_VALUE_OBJECT); final MapType m2 = m.withContentValueHandler(new Object()); assertSame(m.getMapType(), m2.getMapType()); assertSame(m.keyType(), m2.keyType()); assertSame(m.valueType(), m2.valueType()); assertEquals(m.typeHandler(), m2.typeHandler()); assertEquals(m.valueHandler(), m2.valueHandler()); assertEquals(m.typeHandler(), m2.typeHandler()); }
@Test public void testWithKeyValueHandler() { final Object h = new Object(); final MapType map = MapType.construct(Map.class, DefaultKey.class, DefaultValue.class) .withKeyValueHandler(h); assertSame(DefaultKey.class, map.getKeyType()); assertSame(h, map.getKeyType()); assertSame(DefaultValue.class, map.getValueType()); assertSame(h, map.getValueHandler()); assertSame(h, map.getTypeHandler()); }
@Test public void testWithKeyValueHandler() throws Exception { final MapType m = MapType.construct(Map.class, DefaultKey.class, DefaultValue.class); final MapType m2 = m.withKeyValueHandler(new Object()); assertSame(m.getMapType(), m2.getMapType()); assertSame(m.keyType(), m2.keyType()); assertSame(m.valueType(), m2.valueType()); assertSame(m.typeHandler(), m2.typeHandler()); }
@Test public void testDateDeserializer() throws Exception { JsonDeserializer<?> d = new TimestampDeserializer().findBeanDeserializer(Date.class, null, null); Assert.assertNotNull(d); Assert.assertTrue(d instanceof DateDeserializer); d = new TimestampDeserializer().findBeanDeserializer(LocalDate.class, null, null); Assert.assertNotNull(d); Assert.assertTrue(d instanceof TimestampDeserializer); d = new TimestampDeserializer().findBeanDeserializer(LocalDateTime.class, null, null); Assert.assertNotNull(d); Assert.assertTrue(d instanceof TimestampDeserializer); d = new TimestampDeserializer().findBeanDeserializer(LocalDateTime.class, null, null); Assert.assertNotNull(d);
@Test public void testSimpleDateDeserializer() throws Exception { JsonDeserializer<?> d = new SimpleDateDeserializer().findBeanDeserializer(Date.class, null, null); Assert.assertNotNull(d); d = new SimpleDateDeserializer().findBeanDeserializer(LocalDate.class, null, null); Assert.assertNotNull(d); d = new SimpleDateDeserializer().findBeanDeserializer(LocalDate.class, null, null); Assert.assertNotNull(d); d = new SimpleDateDeserializer().findBeanDeserializer(LocalDate.class, null, null); Assert.assertNotNull(d); d = new SimpleDateDeserializer().findBeanDeserializer(LocalDate.class, null, null); Assert.assertNotNull(
@Test public void testDateDeserializer() throws Exception { JsonDeserializer<?> d = new DateDeserializer().findBeanDeserializer(Date.class, null, null); Assert.assertNotNull(d); d = new DateDeserializer().findBeanDeserializer(LocalDate.class, null, null); Assert.assertNotNull(d); d = new DateDeserializer().findBeanDeserializer(LocalDateTime.class, null, null); Assert.assertNotNull(d); d = new DateDeserializer().findBeanDeserializer(LocalDateTime.class, null, null); Assert.assertNotNull(d); d = new DateDeserializer().findBeanDeserializer(LocalDateTime.class, null, null); Assert.assertNotNull(d); d = new Date
@Test public void testDateDeserializer() throws Exception { JsonDeserializer<?> d = new DateDeserializer().findBeanDeserializer(Date.class, null, null); Assert.assertNotNull(d); Assert.assertTrue(d instanceof DateDeserializer); d = new DateDeserializer().findBeanDeserializer(java.sql.Date.class, null, null); Assert.assertNotNull(d); Assert.assertTrue(d instanceof DateDeserializer); d = new DateDeserializer().findBeanDeserializer(java.sql.Date.class, null, null); Assert.assertNotNull(d); Assert.assertTrue(d instanceof DateDeserializer); d = new DateDeserializer().findBeanDeserializer(java.sql.Date.class, null,
@Test public void testDurationDeserializer() throws Exception { SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); sdf.applyPattern("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); sdf.applyPattern("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); sdf.applyPattern("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); sdf.applyPattern("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); sdf.applyPattern("yyyy-MM-dd\'
@Test public void testGregorianDeserializer() throws Exception { SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); sdf.applyPattern("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); String[] lines = new String[] { "yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'", "yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'", "yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'", "yyyy-MM-dd\'T\'HH:mm:ss.
@Test public void testQNameDeserializer() throws Exception { QNameDeserializer deserializer = new QNameDeserializer(); Assert.assertEquals(QName.class, deserializer.getClass()); Assert.assertEquals(new QName("http: deserializer.findBeanDeserializer(QName.class, null, null).getClass()); Assert.assertEquals(new QName("http: deserializer.findBeanDeserializer(String.class, null, null).getClass()); Assert.assertEquals(new QName("http: deserializer.findBeanDeserializer(String.class, null, null).getClass()); Assert.assertEquals(new QName("http: deserializer.findBeanDeserializer(String.class, null, null).getClass()); Assert.assertEquals(new QName
@Test public void test_deserialize() throws Exception { Date d = new Date(); SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); sdf.applyPattern("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); sdf.applyPattern("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); sdf.applyPattern("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); SimpleDateFormat expected = sdf.parse("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'"); assertEquals(
@Test public void test_deserialize() throws Exception { Assert.assertEquals(new QName("http: new DurationDeserializer()._deserialize("P1Y2M", null)); Assert.assertEquals(new QName("http: new DurationDeserializer()._deserialize("P1Y2M", null)); Assert.assertEquals(new QName("http: new DurationDeserializer()._deserialize("P1Y2M", null)); Assert.assertEquals(new QName("http: new DurationDeserializer()._deserialize("P1Y2M", null)); Assert.assertEquals(new QName("http: new DurationDeserializer()._deserialize("P1Y2M", null)); Assert.assertEquals(new QName("http: new Duration
@Test public void testGetFieldType() { BeanPropertyDefinition propDef = new BeanPropertyDefinition(getField("stringField"), field, null, null, JavaType.STRING, null, null, null, null, null); assertEquals(String.class, propDef.getPropertyType()); }
@Test public void test() throws IOException, JsonMappingException, JsonProcessingException { ObjectMapper mapper = new ObjectMapper(); JsonParser jp = mock(JsonParser.class); DeserializationContext ctxt = mock(DeserializationContext.class); TypeDeserializer typeDeserializer = mock(TypeDeserializer.class); when(typeDeserializer.deserializeTypedFromArray(jp, ctxt)) .thenReturn(new Object[0]); when(jp.nextToken()).thenReturn("1"); assertArrayEquals(new Object[0], _arrayDeserializer.deserializeWithType(jp, ctxt, typeDeserializer)); when(jp.nextToken()).thenReturn("2"); assertArrayEquals(new Object[0], _arrayDeserializer.deserializeWithType(
@Test public void test() throws IOException, JsonMappingException, JsonProcessingException { ObjectMapper mapper = new ObjectMapper(); JsonParser jp = mock(JsonParser.class); DeserializationContext ctxt = mock(DeserializationContext.class); TypeDeserializer typeDeserializer = mock(TypeDeserializer.class); when(typeDeserializer.deserializeTypedFromArray(jp, ctxt)).thenReturn(new Object[0]); when(jp.nextToken()).thenReturn("1"); when(typeDeserializer.deserializeTypedFromArray(jp, ctxt)).thenReturn(new Object[0]); when(jp.nextToken()).thenReturn("2"); when(typeDeserializer.deserializeTypedFromArray(jp, ctxt)).thenReturn(new Object
@Test public void testFindWrapperName() { Method m = Foo.class.getMethods()[0]; PropertyName p = findWrapperName(m); assertNull(p); p = findWrapperName(m); assertNull(p); m = Foo.class.getMethods()[1]; p = findWrapperName(m); assertNull(p); m = Foo.class.getMethods()[2]; p = findWrapperName(m); assertNull(p); m = Foo.class.getMethods()[3]; p = findWrapperName(m); assertNull(p); m = Foo.class.getMethods()[4]; p = findWrapperName(m); assertNull
@Test public void testFindWrapperName() throws Exception { Method m = Foo.class.getDeclaredMethod("getString"); PropertyName p = findWrapperName(m, Simple.class); assertNull(p); p = findWrapperName(m, Simple.class.getDeclaredMethod("setString", String.class)); assertNull(p); p = findWrapperName(m, Simple.class.getDeclaredMethod("setInt", int.class)); assertNull(p); p = findWrapperName(m, Simple.class.getDeclaredMethod("setList", List.class)); assertNull(p); p = findWrapperName(m, Simple.class.getDeclaredMethod("setMap",
@Test public void testEnum() { String[][] tests = new String[][] { new String[] { "A", "B", "C", "D" }, new String[] { "A", "B", "C", "D" }, new String[] { "A", "B", "C", "D" }, new String[] { "A", "B", "C", "D" }, new String[] { "A", "B", "C", "D" }, new String[] { "A", "B", "C", "D" }, new String[] { "A", "B", "C", "D" }, new String[] { "A", "B
@Test public void testEnumValue() { Set<String> expected = new HashSet<String>(); expected.add("A"); expected.add("B"); expected.add("C"); expected.add("D"); expected.add("E"); expected.add("F"); expected.add("G"); expected.add("H"); expected.add("I"); expected.add("J"); expected.add("K"); expected.add("L"); expected.add("M"); expected.add("S"); expected.add("D"); expected.add("E"); expected.add("F"); expected.add("G"); expected.add("H"); expected.add("I"); expected.add("J"); expected
@Test public void testFromStringDeserializer() throws IOException, JsonProcessingException { FromStringDeserializer deserializer = new FromStringDeserializer(String.class) { @Override public String _deserialize(String value, DeserializationContext context) throws IOException, JsonProcessingException { return value; } @Override public String _serialize(JsonParser jp, DeserializationContext context) throws IOException, JsonProcessingException { return "test"; } }; assertEquals("test", deserializer._deserialize(null, null)); assertEquals("test", deserializer._deserialize(null, null)); assertEquals("test", deserializer._deserialize(null, null)); assertEquals("test", deserializer._deserialize(null, null)); assertEquals("test", deserializer._deserialize(null
@Test public void testStringDeserializer() throws IOException, JsonProcessingException { FromStringDeserializer d = new FromStringDeserializer(String.class) { @Override public String _deserialize(String value, DeserializationContext context) throws IOException, JsonProcessingException { return value; } }; assertEquals("foo", d._deserialize(null, null)); assertEquals("bar", d._deserialize(null, null)); assertEquals("baz", d._deserialize(null, null)); assertEquals("baz", d._deserialize(null, null)); assertEquals("foo", d._deserialize(null, null)); assertEquals("bar", d._deserialize(null, null)); assertEquals("baz", d._deserialize(null
@Test public void testDeserialize() throws IOException, JsonProcessingException { FromStringDeserializer<TestPojo> deserializer = new FromStringDeserializer<TestPojo>(TestPojo.class) { @Override public TestPojo deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { return new TestPojo(); } }; TestPojo value = deserializer.deserialize(jp, null); Assert.assertNull(value); value = deserializer.deserialize(jp, null); Assert.assertNull(value); value = deserializer.deserialize(jp, null); Assert.assertNull(value); value = deserializer.deserialize(jp, null); Assert.assertNull(value); value = deserializer.
@Test public void testText() throws IOException, JsonProcessingException { FromStringDeserializer<TestPojo> deserializer = new FromStringDeserializer<TestPojo>(TestPojo.class) { @Override public TestPojo deserialize(JsonParser jp, DeserializationContext jp) throws IOException, JsonProcessingException { return null; } }; assertNull(deserializer.deserialize(jp, null)); TestPojo value = deserializer.deserialize(jp, null); assertNull(value); value = deserializer.deserialize(jp, null); assertNull(value); value = deserializer.deserialize(jp, null); assertNull(value); value = deserializer.deserialize(jp, null); assertNull(value); }
@Test public void testText() throws IOException, JsonProcessingException { FromStringDeserializer<TestPojo> deserializer = new FromStringDeserializer<TestPojo>(TestPojo.class) { @Override public TestPojo deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { return new TestPojo(); } }; Assert.assertEquals(new TestPojo("abc"), deserializer.deserialize(jp, null)); Assert.assertEquals(new TestPojo("abc"), deserializer.deserialize(jp, null)); Assert.assertEquals(new TestPojo("abc"), deserializer.deserialize(jp, null)); }
@Test public void testText() throws IOException, JsonProcessingException { FromStringDeserializer<TestPojo> deserializer = new FromStringDeserializer<TestPojo>(TestPojo.class) { @Override public TestPojo deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { return new TestPojo(); } }; assertNull(deserializer.deserialize(jp, null)); assertNull(deserializer.deserialize(jp, null)); assertNull(deserializer.deserialize(jp, null)); JsonParser jp = mock(JsonParser.class); when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_EMBEDDED_OBJECT); TestPojo value =
@Test public void testText() throws IOException, JsonProcessingException { FromStringDeserializer<TestPojo> deserializer = new FromStringDeserializer<TestPojo>(TestPojo.class) { @Override public TestPojo deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { return new TestPojo(); } }; String text = "Hello, world!"; Assert.assertEquals(text, deserializer.deserialize(jp, null).getText()); text = "Hello, world!"; Assert.assertEquals(text, deserializer.deserialize(jp, null).getText()); text = "Hello, world!"; Assert.assertEquals(text, deserializer.deserialize(jp, null
@Test public void testParseString() throws IOException, JsonProcessingException { FromStringDeserializer<TestPojo> deserializer = new FromStringDeserializer<TestPojo>(TestPojo.class) { @Override public TestPojo deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { return new TestPojo(); } }; Assert.assertNotNull(deserializer.deserialize(jp, null)); }
@Test public void testNull() throws IOException, JsonProcessingException { FromStringDeserializer<TestPojo> deserializer = new FromStringDeserializer<TestPojo>(TestPojo.class) { @Override public TestPojo deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { return null; } }; assertNull(deserializer.deserialize(jp, null)); }
@Test public void testDeserialize() throws IOException, JsonProcessingException { FromStringDeserializer<TestPojo> deserializer = new FromStringDeserializer<TestPojo>(TestPojo.class) { @Override public TestPojo deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { return new TestPojo(); } }; Assert.assertEquals(new TestPojo(1), deserializer.deserialize(jp, null)); Assert.assertEquals(new TestPojo(2), deserializer.deserialize(jp, null)); Assert.assertEquals(new TestPojo(3), deserializer.deserialize(jp, null)); Assert.assertEquals(new TestPojo(4), deserializer.deserialize
@Test public void testDeserialize() throws IOException, JsonProcessingException { FromStringDeserializer<TestPojo> deserializer = new FromStringDeserializer<TestPojo>(TestPojo.class) { @Override public TestPojo deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { return null; } }; assertNull(deserializer.deserialize(jp, null)); JsonParser jp = mock(JsonParser.class); when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_EMBEDDED_OBJECT); TestPojo value = deserializer.deserialize(jp, null); assertNull(value); value = deserializer.deserialize(jp, null); assertNull(value
@Test public void testNull() throws IOException, JsonProcessingException { FromStringDeserializer<TestPojo> deserializer = new FromStringDeserializer<TestPojo>(TestPojo.class) { @Override public TestPojo deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { return null; } }; assertNull(deserializer.deserialize(jp, null)); }
@Test public void testNull() throws IOException, JsonProcessingException { FromStringDeserializer<TestPojo> deserializer = new FromStringDeserializer<TestPojo>(TestPojo.class) { @Override public TestPojo deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { return null; } }; assertNull(deserializer.deserialize(jp, null)); }
@Test public void testNull() throws IOException, JsonProcessingException { FromStringDeserializer<TestPojo> deserializer = new FromStringDeserializer<TestPojo>(TestPojo.class) { @Override public TestPojo deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { return null; } }; assertNull(deserializer.deserialize(jp, null)); }
@Test public void testParseString() throws IOException, JsonProcessingException { FromStringDeserializer<TestPojo> deserializer = new FromStringDeserializer<TestPojo>(TestPojo.class) { @Override public TestPojo deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { return null; } }; assertNull(deserializer.deserialize(jp, null)); TestPojo value = deserializer.deserialize(jp, null); assertNull(value); value = deserializer.deserialize(jp, null); assertNull(value); value = deserializer.deserialize(jp, null); assertNull(value); value = deserializer.deserialize(jp, null); assertNull(value); }
@Test public void testDeserialize() throws IOException, JsonProcessingException { FromStringDeserializer<TestPojo> deserializer = new FromStringDeserializer<TestPojo>(TestPojo.class) { @Override public TestPojo deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { return new TestPojo(); } }; TestPojo value = deserializer.deserialize(jp, null); Assert.assertNull(value); value = deserializer.deserialize(jp, null); Assert.assertNull(value); value = deserializer.deserialize(jp, null); Assert.assertNull(value); value = deserializer.deserialize(jp, null); Assert.assertNull(value); value = deserializer.
@Test public void testMapSerializer() throws Exception { Set<String> ignored = new HashSet<String>(); Object obj1 = new Object(); Object obj2 = new Object(); Object obj3 = new Object(); Map<String, Object> map = new HashMap<String, Object>(); map.put("key1", obj1); map.put("key2", obj2); map.put("key3", obj3); obj1.put("key4", obj4); obj2.put("key5", obj5); obj3.put("key6", obj6); obj1.put("key7", obj7); obj2.put("key8", obj8); obj3.
@Test public void testMapSerializer() throws IOException, JsonMappingException { Set<JavaType> ignored = new HashSet<JavaType>(); Set<JavaType> type = new HashSet<JavaType>(); type.add(JavaType.of(Map.class)); type.add(JavaType.of(String.class)); type.add(JavaType.of(Map.class)); type.add(JavaType.of(Map.class)); type.add(JavaType.of(Map.class)); type.add(JavaType.of(Map.class)); MapSerializer bs = new MapSerializer(ignored, type, JavaType.of(Map.class), false, vts, new JsonSerializer<String>() { @Override public
@Test public void testMapSerializer() throws Exception { Set<String> ignored = new HashSet<String>(); ignored.add("a"); ignored.add("b"); Object obj = new Object(); TypeSerializer vts = mock(TypeSerializer.class); JsonSerializer<Object> keySerializer = new JsonSerializer<Object>() { @Override public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { } @Override public JsonSerializer<Object> createContextual(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { return new JsonSerializer<Object>() { @Override public void serialize(Object value, JsonGenerator jgen
@Test public void testMapSerializer() throws IOException { Set<String> ignored = new HashSet<String>(); Object obj1 = new Object(); Object obj2 = new Object(); Object obj3 = new Object(); Object obj4 = new Object(); Object obj5 = new Object(); Object obj6 = new Object(); Object obj7 = new Object(); Object obj8 = new Object(); Object obj9 = new Object(); Object obj10 = new Object(); Object obj11 = new Object(); Object obj12 = new Object(); Object obj13 = new Object(); Object obj14 = new Object(); Object obj15 = new Object(); Object obj16 = new Object(); Object obj17 = new Object(); Object obj18 = new Object
@Test public void testMapSerializer() throws IOException { Set<String> ignored = new HashSet<String>(); Object obj1 = new Object(); Object obj2 = new Object(); Object obj3 = new Object(); Object obj4 = new Object(); Map<String, Object> map = new HashMap<String, Object>(); map.put("a", obj1); map.put("b", obj2); map.put("c", obj3); map.put("d", obj4); obj1.put("e", obj5); obj2.put("f", obj6); obj3.put("g", obj7); obj4.put("h", obj8); obj1.put("
@Test public void testMapSerializer() throws Exception { Set<String> ignored = new HashSet<String>(); Object obj1 = new Object(); Object obj2 = new Object(); Object obj3 = new Object(); Object obj4 = new Object(); Object obj5 = new Object(); Object obj6 = new Object(); Object obj7 = new Object(); Object obj8 = new Object(); Object obj9 = new Object(); Object obj10 = new Object(); Object obj11 = new Object(); Object obj12 = new Object(); Object obj13 = new Object(); Object obj14 = new Object(); Object obj15 = new Object(); Object obj16 = new Object(); Object obj17 = new Object(); Object obj18 = new Object
@Test public void testMapSerializer() throws IOException, JsonMappingException { Set<JavaType> ignored = new HashSet<JavaType>(); JavaType keyType = JavaType.of(Map.class, Object.class); JavaType valueType = JavaType.of(Map.class, Object.class); MapSerializer myMapSerializer = new MapSerializer(ignored, keyType, valueType, true, vts, new JsonSerializer<Object>() { @Override public void serialize(Map<?, ?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { } }, new JsonSerializer<Object>() { @Override public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException
@Test public void testMapSerializer() throws IOException { Set<String> ignored = new HashSet<String>(); Object obj1 = new Object(); Object obj2 = new Object(); Object obj3 = new Object(); Object obj4 = new Object(); Object obj5 = new Object(); Object obj6 = new Object(); Object obj7 = new Object(); Object obj8 = new Object(); Object obj9 = new Object(); Object obj10 = new Object(); Object obj11 = new Object(); Object obj12 = new Object(); Object obj13 = new Object(); Object obj14 = new Object(); Object obj15 = new Object(); Object obj16 = new Object(); Object obj17 = new Object(); Object obj18 = new Object
@Test public void testMapSerializer() throws IOException { Set<String> ignored = new HashSet<String>(); Object obj = new Object(); Object obj2 = new Object(); Object obj3 = new Object(); Object obj4 = new Object(); Object obj5 = new Object(); Object obj6 = new Object(); Object obj7 = new Object(); Object obj8 = new Object(); Object obj9 = new Object(); Object obj10 = new Object(); Object obj11 = new Object(); Object obj12 = new Object(); Object obj13 = new Object(); obj1 = new Object(); obj2 = new Object(); obj3 = new Object(); obj4 = new Object(); obj5 = new Object(); obj6 = new Object
@Test public void testMapSerializer() throws Exception { Set<String> ignored = new HashSet<String>(); Object obj1 = new Object(); Object obj2 = new Object(); Object obj3 = new Object(); Object obj4 = new Object(); Object obj5 = new Object(); Object obj6 = new Object(); Object obj7 = new Object(); Object obj8 = new Object(); Object obj9 = new Object(); Object obj10 = new Object(); Object obj11 = new Object(); Object obj12 = new Object(); Object obj13 = new Object(); Object obj14 = new Object(); Object obj15 = new Object(); Object obj16 = new Object(); Object obj17 = new Object(); Object obj18 = new Object
@Test public void testMapSerializer() throws Exception { Set<String> ignoredEntries = new HashSet<String>(); Set<String> keyType = new HashSet<String>(); keyType.add("a"); keyType.add("b"); keyType.add("c"); TypeSerializer vts = mock(TypeSerializer.class); JsonSerializer<Object> keySerializer = new JsonSerializer<Object>() { @Override public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { } @Override public JsonSerializer<Object> createContextual(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException { return new JsonSerializer<Object>() { @Override public void
@Test public void construct() { String[] ignoredList = new String[0]; JavaType mapType = mock(JavaType.class); JsonSerializer keySerializer = mock(JsonSerializer.class); JsonSerializer valueSerializer = mock(JsonSerializer.class); when(mapType.getContentType()).thenReturn(mock(JavaType.class)); when(mapType.getKeyType()).thenReturn(mock(JavaType.class)); when(mapType.getKeySerializer()).thenReturn(keySerializer); when(mapType.getValueSerializer()).thenReturn(valueSerializer); MapSerializer result = MapSerializer.construct(ignoredList, mapType, true, mock(TypeSerializer.class), keySerializer, valueSerializer
@Test public void construct() { String[] ignoredList = new String[] { "a", "b", "c" }; JavaType mapType = mock(JavaType.class); when(mapType.getTypeName()).thenReturn(Map.class); when(mapType.getContentType()).thenReturn(mock(JavaType.class)); @SuppressWarnings("unchecked") JsonSerializer<Object> keySerializer = mock(JsonSerializer.class); @SuppressWarnings("unchecked") JsonSerializer<Object> valueSerializer = mock(JsonSerializer.class); MapSerializer result = MapSerializer.construct(ignoredList, mapType, true, mock(TypeSerializer.class), keySerializer, valueSerializer); assertTrue(result
@Test public void construct() { String[] ignoredList = new String[0]; JavaType keyType = new JavaType("java.util.Map", "java.util.Map"); JavaType valueType = new JavaType("java.util.Map", "java.util.Map"); @SuppressWarnings("unchecked") JsonSerializer<Object> keySerializer = mock(JsonSerializer.class); @SuppressWarnings("unchecked") JsonSerializer<Object> valueSerializer = mock(JsonSerializer.class); MapSerializer result = MapSerializer.construct(ignoredList, keyType, valueType, true, mock(TypeSerializer.class), keySerializer, valueSerializer); assertEquals(keySerializer, result.getKeySerializer()); assertEquals(value
@Test public void construct() { String[] ignoredList = new String[0]; JavaType mapType = mock(JavaType.class); when(mapType.getTypeName()).thenReturn(Map.class); when(mapType.getContentType()).thenReturn(mock(JavaType.class)); JsonSerializer<Object> keySerializer = mock(JsonSerializer.class); JsonSerializer<Object> valueSerializer = mock(JsonSerializer.class); MapSerializer result = MapSerializer.construct(ignoredList, mapType, true, mock(TypeSerializer.class), keySerializer, valueSerializer); assertEquals(keySerializer, result.getKeySerializer()); assertEquals(valueSerializer, result.getValueSerializer()); }
@Test public void construct() { String[] ignoredList = new String[] { "a", "b", "c" }; JavaType mapType = mock(JavaType.class); when(mapType.getKeyType()).thenReturn(mock(JavaType.class)); when(mapType.getContentType()).thenReturn(mock(JavaType.class)); JsonSerializer<Object> keySerializer = mock(JsonSerializer.class); JsonSerializer<Object> valueSerializer = mock(JsonSerializer.class); MapSerializer result = MapSerializer.construct(ignoredList, mapType, true, mock(TypeSerializer.class), keySerializer, valueSerializer); assertEquals(keySerializer, result.getKeySerializer()); assertEquals
@Test public void construct() { String[] ignoredList = new String[] { "a", "b", "c" }; JavaType mapType = mock(JavaType.class); when(mapType.getContentType()).thenReturn(mock(JavaType.class)); JsonSerializer<Object> keySerializer = mock(JsonSerializer.class); JsonSerializer<Object> valueSerializer = mock(JsonSerializer.class); MapSerializer result = MapSerializer.construct(ignoredList, mapType, true, mock(TypeSerializer.class), keySerializer, valueSerializer); assertEquals(keySerializer, result.getKeyType()); assertEquals(keySerializer, result.getKeySerializer()); assertEquals(valueSerializer, result.getValue
@Test public void construct() { String[] ignoredList = new String[0]; JavaType keyType = new JavaType("java.util.Map", "java.util.Map"); JavaType valueType = new JavaType("java.util.Map", "java.util.Map"); TypeSerializer vts = mock(TypeSerializer.class); JsonSerializer<Object> keySerializer = mock(JsonSerializer.class); JsonSerializer<Object> valueSerializer = mock(JsonSerializer.class); MapSerializer result = MapSerializer.construct(ignoredList, keyType, false, vts, keySerializer, valueSerializer); assertEquals(keySerializer, result.getKeySerializer()); assertEquals(valueSerializer, result.getValueSerializer
@Test public void construct() { String[] ignoredList = new String[] { "a", "b", "c" }; SimpleType keyType = new SimpleType("java.util.Map", "java.util.Map"); SimpleType mapType = new SimpleType("java.util.Map", "java.util.Map"); TypeSerializer vts = mock(TypeSerializer.class); JsonSerializer keySerializer = mock(JsonSerializer.class); JsonSerializer valueSerializer = mock(JsonSerializer.class); when(vts.getContentType()).thenReturn(mapType); when(mapType.getKeyType()).thenReturn(keyType); when(mapType.isFinal()).thenReturn(
@Test public void construct() { String[] ignoredList = new String[0]; JavaType keyType = new JavaType("java.util.Map", "java.util.Map"); JavaType valueType = new JavaType("java.util.Map", "java.util.Map"); TypeSerializer vts = mock(TypeSerializer.class); JsonSerializer<Object> keySerializer = mock(JsonSerializer.class); JsonSerializer<Object> valueSerializer = mock(JsonSerializer.class); when(vts.getKeySerializer()).thenReturn(keySerializer); when(vts.getValueSerializer()).thenReturn(valueSerializer); MapSerializer tested = MapSerializer.construct(ignoredList, keyType, valueType
@Test public void testToSet() { Set<String> set = new HashSet<String>(); set.add("a"); set.add("b"); set.add("c"); assertEquals(set, MapSerializer.construct(new String[]{"a", "b", "c"}, JavaType.OBJECT, false, new String[]{"a", "b", "c"}, null, set)); set = new HashSet<String>(); set.add("a"); set.add("b"); set.add("c"); assertEquals(set, MapSerializer.construct(new String[]{"a", "b", "c"}, JavaType.OBJECT, false, new String[]{
@Test public void testToSet() throws Exception { Set<String> ignored = new HashSet<String>(); ignored.add("a"); ignored.add("b"); Set<String> result = MapSerializer.construct(ignored, JavaType.get(Map.class), false, JavaType.get(String.class), new HashSet<String>(), null, null).toSet(ignored); Assert.assertEquals(ignored.size(), result.size()); for (int i = 0; i < ignored.size(); i++) { Assert.assertEquals(ignored.contains(result.get(i)), result.contains(result.get(i))); } }
@Test public void testToSet() throws Exception { Set<String> ignoredEntries = new HashSet<String>(); ignoredEntries.add("foo"); ignoredEntries.add("bar"); Set<String> result = MapSerializer.construct(ignoredEntries, JavaType.get(Map.class), false, JavaType.get(String.class), null, ignoredEntries).toSet(); Assert.assertEquals(ignoredEntries.size(), result.size()); for (int i = 0; i < ignoredEntries.size(); i++) { Assert.assertEquals(ignoredEntries.contains(ignoredEntries.get(i)), result.contains(ignoredEntries.get(i))); } }
@Test public void serializeTypedFields_serializers() throws IOException, JsonGenerationException { SimpleValueTypeProvider provider = new SimpleValueTypeProvider(); SimpleValueType simpleValueType = new SimpleValueType(); SimpleValueType simpleValueType2 = new SimpleValueType(); SimpleValueType simpleValueType3 = new SimpleValueType(); SimpleValueType simpleValueType4 = new SimpleValueType(); SimpleValueType simpleValueType5 = new SimpleValueType(); SimpleValueType simpleValueType6 = new SimpleValueType(); SimpleValueType simpleValueType7 = new SimpleValueType(); SimpleValueType simpleValueType8 = new SimpleValueType(); SimpleValueType simpleValueType9 = new SimpleValueType(); SimpleValueType simpleValueType10 = new SimpleValueType(); SimpleValueType simpleValueType11 = new SimpleValueType(); SimpleValueType simpleValueType12 = new SimpleValueType(); simple
@Test public void serializeFields_serializers() throws IOException, JsonGenerationException { final SimpleValueTypeProvider provider = new SimpleValueTypeProvider(); final JsonSerializer<Object> serializer = provider.getDefaultSerializer(); final Map<String, Object> value = new LinkedHashMap<String, Object>(); value.put("key1", "value1"); value.put("key2", "value2"); value.put("key3", "value3"); value.put("key4", "value4"); value.put("key5", "value5"); value.put("key6", "value6"); value.put("key7", "value7"); value.put("key8", "value8"); final
@Test public void serializeTypedFields() throws IOException, JsonGenerationException { Map<String, Object> value = new LinkedHashMap<String, Object>(); value.put("key1", "value1"); value.put("key2", "value2"); value.put("key3", "value3"); JsonGenerator jgen = Mockito.mock(JsonGenerator.class); SerializerProvider provider = Mockito.mock(SerializerProvider.class); Mockito.when(provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES)).thenReturn(true); Mockito.when(provider.findNullKeySerializer(any(Class.class), any(Property.class))).thenReturn(
@Test public void serializeTypedFields() throws IOException, JsonGenerationException { final SimpleValueType<Integer> valType = new SimpleValueType<Integer>(Integer.class); final SimpleValueType<Integer> val1 = new SimpleValueType<Integer>(Integer.class); final SimpleValueType<Integer> val2 = new SimpleValueType<Integer>(Integer.class); final Map<Integer, Object> value = new LinkedHashMap<Integer, Object>(); value.put(val1, val2); value.put(val2, val1); final SimpleValueType<Integer> val3 = new SimpleValueType<Integer>(Integer.class); value.put(val3, val3); final SimpleValueType<Integer>
@Test public void serializeTypedFields_ignore() throws IOException, JsonGenerationException { final SimpleValueTypeProviderImpl provider = new SimpleValueTypeProviderImpl(); final Map<String, Object> value = new LinkedHashMap<String, Object>(); value.put("key1", "value1"); value.put("key2", "value2"); value.put("key3", "value3"); final SimpleValueTypeProviderImpl provider2 = new SimpleValueTypeProviderImpl(); final SimpleValueTypeProviderImpl provider3 = new SimpleValueTypeProviderImpl(); provider2.enable(SerializationFeature.WRITE_NULL_MAP_VALUES); provider2.enable(SerializationFeature.WRITE_NULL_MAP_VALUES); provider3.enable(SerializationFeature.
@Test public void serializeTypedFields() throws IOException, JsonGenerationException { final SimpleValueType<Integer> valType = new SimpleValueType<Integer>(Integer.class); final SimpleValueType<Integer> val1 = new SimpleValueType<Integer>(Integer.class); final SimpleValueType<Integer> val2 = new SimpleValueType<Integer>(Integer.class); final Map<Integer, Object> value = new LinkedHashMap<Integer, Object>(); value.put(val1, val2); value.put(val2, val1); final SimpleValueType<Integer> val3 = new SimpleValueType<Integer>(Integer.class); value.put(val3, val3); final SimpleValueType<Integer>
@Test public void serializeTypedFields() throws IOException, JsonGenerationException { final SimpleValueType<Integer> valType = new SimpleValueType<Integer>() { }; final SimpleValueType<Integer> val1 = new SimpleValueType<Integer>() { }; final SimpleValueType<Integer> val2 = new SimpleValueType<Integer>() { }; final SimpleValueType<Integer> val3 = new SimpleValueType<Integer>() { }; final SimpleValueType<Integer> val4 = new SimpleValueType<Integer>() { }; final SimpleValueType<Integer> val5 = new SimpleValueType<Integer>() { }; final SimpleValueType<Integer> val6 = new SimpleValueType<Integer>() { };
@Test public void serializeTypedFields() throws IOException, JsonGenerationException { final SimpleValueType<Integer> valType = new SimpleValueType<Integer>(Integer.class); final SimpleValueType<Integer> val1 = new SimpleValueType<Integer>(Integer.class); final SimpleValueType<Integer> val2 = new SimpleValueType<Integer>(Integer.class); final SimpleValueType<Integer> val3 = new SimpleValueType<Integer>(Integer.class); final SimpleValueType<Integer> val4 = new SimpleValueType<Integer>(Integer.class); final SimpleValueType<Integer> val5 = new SimpleValueType<Integer>(Integer.class); final SimpleValueType<Integer> val6 = new SimpleValueType<
@Test public void serializeTypedFields() throws IOException, JsonGenerationException { final Map<String, Object> value = new LinkedHashMap<String, Object>(); value.put("key1", "value1"); value.put("key2", "value2"); final JsonGenerator jgen = mock(JsonGenerator.class); final SerializerProvider provider = mock(SerializerProvider.class); when(provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES)).thenReturn(true); when(provider.findNullKeySerializer(any(Class.class), any(String.class))).thenReturn(null); when(provider.findValueSerializer(any(Class.class), any(String.
@Test public void serializeTypedFields() throws IOException, JsonGenerationException { final SimpleValueType<Integer> valType = new SimpleValueType<Integer>(Integer.class); final SimpleValueType<Integer> val1 = new SimpleValueType<Integer>(Integer.class); final SimpleValueType<Integer> val2 = new SimpleValueType<Integer>(Integer.class); final Map<Integer, Object> value = new LinkedHashMap<Integer, Object>(); value.put(val1, val2); value.put(val2, val1); final SimpleValueType<Integer> val3 = new SimpleValueType<Integer>(Integer.class); value.put(val3, val3); final SimpleValueType<Integer>
@Test public void serializeTypedFields() throws IOException, JsonGenerationException { final SimpleValueType<Integer> valType = new SimpleValueType<Integer>() { @Override public Integer convert(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException { return value.intValue(); } }; final SimpleValueType<Integer> valType2 = new SimpleValueType<Integer>() { @Override public Integer convert(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException { return value.intValue(); } }; final SimpleValueType<Integer> valType3 = new SimpleValueType<Integer>() { @Override public Integer convert(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException
@Test public void serializeTypedFields() throws IOException, JsonGenerationException { final SimpleValueType<Integer> valType = new SimpleValueType<Integer>() { @Override public Integer convert(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException { return value.intValue(); } }; final SimpleValueType<Integer> valType2 = new SimpleValueType<Integer>() { @Override public Integer convert(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException { return value.intValue(); } }; final SimpleValueType<Integer> valType3 = new SimpleValueType<Integer>() { @Override public Integer convert(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException
@Test public void serializeTypedFields() throws IOException, JsonGenerationException { final SimpleValueType<Integer> valType = new SimpleValueType<Integer>(Integer.class); final SimpleValueType<Integer> val1 = new SimpleValueType<Integer>(Integer.class); final SimpleValueType<Integer> val2 = new SimpleValueType<Integer>(Integer.class); final Map<Integer, Object> value = new LinkedHashMap<Integer, Object>(); value.put(val1, val2); value.put(val2, val1); final SimpleValueType<Integer> val3 = new SimpleValueType<Integer>(Integer.class); value.put(val3, val3); final SimpleValueType<Integer>
@Test public void serializeTypedFields() throws IOException, JsonGenerationException { final SimpleValueType<Integer> valType = new SimpleValueType<Integer>() { }; final SimpleValueType<Integer> val1 = new SimpleValueType<Integer>() { }; final SimpleValueType<Integer> val2 = new SimpleValueType<Integer>() { }; final SimpleValueType<Integer> val3 = new SimpleValueType<Integer>() { }; final SimpleValueType<Integer> val4 = new SimpleValueType<Integer>() { }; final SimpleValueType<Integer> val5 = new SimpleValueType<Integer>() { }; final SimpleValueType<Integer> val6 = new SimpleValueType<Integer>() { };
@Test public void serializeTypedFields() throws IOException, JsonGenerationException { final SimpleValueTypeProvider provider = new SimpleValueTypeProvider(); final JsonGenerator jgen = mock(JsonGenerator.class); final Map<String, Object> value = new LinkedHashMap<String, Object>(); value.put("key1", "value1"); value.put("key2", "value2"); value.put("key3", "value3"); value.put("key4", "value4"); value.put("key5", "value5"); final SimpleValueTypeSerializer<Object> keySerializer = new SimpleValueTypeSerializer<Object>() { @Override public JsonSerializer<Object> findNullKeySerializer(Class<?> clazz,
@Test public void serializeTypedFields() throws IOException, JsonGenerationException { final SimpleValueType<Integer> valType = new SimpleValueType<Integer>(Integer.class); final SimpleValueType<Integer> val1 = new SimpleValueType<Integer>(Integer.class); val1.put(val1, 1); final SimpleValueType<Integer> val2 = new SimpleValueType<Integer>(Integer.class); val2.put(val1, 2); final SimpleValueType<Integer> val3 = new SimpleValueType<Integer>(Integer.class); val3.put(val1, 3); final SimpleValueType<Integer> val4 = new SimpleValueType<Integer>(Integer.class); val4.
@Test public void serializeTypedFields() throws IOException, JsonGenerationException { final SimpleValueType<Integer> valType = new SimpleValueType<Integer>() { }; final SimpleValueType<Integer> val1 = new SimpleValueType<Integer>() { }; final SimpleValueType<Integer> val2 = new SimpleValueType<Integer>() { }; final SimpleValueType<Integer> val3 = new SimpleValueType<Integer>() { }; final SimpleValueType<Integer> val4 = new SimpleValueType<Integer>() { }; final SimpleValueType<Integer> val5 = new SimpleValueType<Integer>() { }; final SimpleValueType<Integer> val6 = new SimpleValueType<Integer>() { };
@Test public void serializeTypedFields_ignore() throws IOException, JsonGenerationException { final Map<String, Object> value = new LinkedHashMap<String, Object>(); value.put("key1", "value1"); value.put("key2", "value2"); final JsonGenerator jgen = Mockito.mock(JsonGenerator.class); final SerializerProvider provider = Mockito.mock(SerializerProvider.class); Mockito.when(provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES)).thenReturn(true); Mockito.when(provider.findNullKeySerializer(Object.class, "key1")).thenReturn( new JsonSerializer<Object>() { @Override
@Test public void serializeTypedFields() throws IOException, JsonGenerationException { final SimpleValueTypeProvider provider = new SimpleValueTypeProvider(); final SimpleValueType prevValue = new SimpleValueType(); final SimpleValueType prevValue2 = new SimpleValueType(); final SimpleValueType prevValue3 = new SimpleValueType(); final SimpleValueType prevValue4 = new SimpleValueType(); final SimpleValueType prevValue5 = new SimpleValueType(); final SimpleValueType prevValue6 = new SimpleValueType(); final SimpleValueType prevValue7 = new SimpleValueType(); final SimpleValueType prevValue8 = new SimpleValueType(); final SimpleValueType prevValue9 = new SimpleValueType(); final SimpleValueType prevValue10 = new SimpleValueType(); final SimpleValueType prevValue11 = new SimpleValueType(); final Simple
@Test public void serializeTypedFields() throws IOException, JsonGenerationException { final SimpleSerializerProvider provider = new SimpleSerializerProvider(); final Map<String, Object> value = new LinkedHashMap<String, Object>(); value.put("key1", "value1"); value.put("key2", "value2"); value.put("key3", "value3"); final SimpleKey key1 = new SimpleKey("key1"); final SimpleKey key2 = new SimpleKey("key2"); final SimpleKey key3 = new SimpleKey("key3"); value.put(key1, key2); value.put(key3, key3); final SimpleKey key4 = new SimpleKey("key4");
@Test public void serializeTypedFields() throws IOException, JsonGenerationException { final Map<String, Object> value = new LinkedHashMap<String, Object>(); value.put("key1", "value1"); value.put("key2", "value2"); final JsonGenerator jgen = Mockito.mock(JsonGenerator.class); final SerializerProvider provider = Mockito.mock(SerializerProvider.class); Mockito.when(provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES)).thenReturn(true); Mockito.when(provider.findNullKeySerializer(Object.class, "key1")).thenReturn( new JsonSerializer<Object>() { @Override public Json
@Test public void serializeTypedFields() throws IOException, JsonGenerationException { final SimpleValueType<Integer> valType = new SimpleValueType<Integer>(Integer.class); final SimpleValueType<Integer> val1 = new SimpleValueType<Integer>(Integer.class); final SimpleValueType<Integer> val2 = new SimpleValueType<Integer>(Integer.class); final Map<Integer, Object> value = new LinkedHashMap<Integer, Object>(); value.put(val1, val2); value.put(val2, val1); final SimpleValueType<Integer> val3 = new SimpleValueType<Integer>(Integer.class); value.put(val3, val3); final SimpleValueType<Integer>
@Test public void serializeTypedFields() throws IOException, JsonGenerationException { Map<String, Object> value = new LinkedHashMap<String, Object>(); value.put("key1", "value1"); value.put("key2", "value2"); JsonGenerator jgen = mock(JsonGenerator.class); SerializerProvider provider = mock(SerializerProvider.class); when(provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES)).thenReturn(true); when(provider.findNullKeySerializer(any(Class.class), any(String.class))).thenReturn(null); when(provider.findValueSerializer(any(Class.class), any(String.class))).
@Test public void serializeTypedFields() throws IOException, JsonGenerationException { final SimpleValueTypeProviderImpl provider = new SimpleValueTypeProviderImpl(); final Map<String, Object> value = new LinkedHashMap<String, Object>(); value.put("key1", "value1"); value.put("key2", "value2"); value.put("key3", "value3"); final SimpleValueTypeSerializerImpl s1 = new SimpleValueTypeSerializerImpl(); final SimpleValueTypeSerializerImpl s2 = new SimpleValueTypeSerializerImpl(); final SimpleValueTypeSerializerImpl s3 = new SimpleValueTypeSerializerImpl(); value.put("key1", s1); value.put("key2", s2); value.put("key3", s
@Test public void getSchema() throws Exception { MapSerializerProvider provider = mock(MapSerializerProvider.class); when(provider.getSchema(any(TypeHint.class), any(SerializerProvider.class))).thenCallRealMethod(); when(provider.getSchema(any(TypeHint.class), any(SerializerProvider.class))).thenCallRealMethod(); when(provider.getSchema(any(TypeHint.class), any(SerializerProvider.class))).thenCallRealMethod(); when(provider.getSchema(any(TypeHint.class), any(SerializerProvider.class))).thenCallRealMethod(); Map<String, Object> value = new HashMap<String, Object>(); value.
@Test public void testGetSchema() throws Exception { Set<String> ignored = new HashSet<String>(); ignored.add("a"); ignored.add("b"); MockSerializerProvider provider = new MockSerializerProvider(ignored); MapSerializer sp = new MapSerializer(Collections.emptySet(), JavaType.OBJECT, JavaType.STRING, true, new DefaultSerializerProvider(provider), ignored); JsonNode node = sp.getSchema(provider.getTypeHint(), provider.getTypeHint()); Assert.assertEquals("{\\n" + " \\"type\\": \\"object\\",\\n" + " \\"properties\\": [\\n" + " {\\n" + " \\"a\\
@Test public void testGetSchema() { MapSerializerProvider provider = mock(MapSerializerProvider.class); when(provider.getSchema(any(TypeHint.class), any(SerializerProvider.class))).thenCallRealMethod(); when(provider.getSchema(any(TypeHint.class), any(SerializerProvider.class))).thenCallRealMethod(); when(provider.getSchema(any(TypeHint.class), any(SerializerProvider.class))).thenCallRealMethod(); when(provider.getSchema(any(TypeHint.class), any(SerializerProvider.class))).thenCallRealMethod(); Map<String, Object> value = new HashMap<String, Object>(); value.
@Test public void testWithResolved() throws Exception { Set<String> ignorable = new HashSet<String>(); final Map<String, Object> m = new LinkedHashMap<String, Object>(); m.put("key1", "value1"); m.put("key2", "value2"); m.put("key3", "value3"); m.put("key4", "value4"); final Map<String, Object> expected = new LinkedHashMap<String, Object>(); expected.put("key1", "value1"); expected.put("key2", "value2"); expected.put("key3", "value3"); expected.put("key4", "value4"); expected.
@Test public void test() throws Exception { SimpleValueInstantiator valueInstantiator = new SimpleValueInstantiator(); SimpleValueDeserializer simpleValueDeserializer = new SimpleValueDeserializer(SimpleValue.class); SimpleValueDeserializer simpleValueDeserializer2 = new SimpleValueDeserializer(SimpleValue.class); SimpleValueDeserializer simpleValueDeserializer3 = new SimpleValueDeserializer(SimpleValue.class); SimpleValueInstantiator simpleValueInstantiator4 = new SimpleValueInstantiator(SimpleValue.class); SimpleValueDeserializer simpleValueDeserializer5 = new SimpleValueDeserializer(SimpleValue.class); SimpleValueDeserializer simpleValueDeserializer6 = new SimpleValueDeserializer(SimpleValue.class); SimpleValueDeserializer simpleValueDeserializer7 = new SimpleValueDeserializer(SimpleValue
@Test public void testPropertyBasedCreator() throws Exception { SimpleValueInstantiator valueInstantiator = new SimpleValueInstantiator(); SimpleValueDeserializer simpleValueDeserializer = new SimpleValueDeserializer(SimpleType.class); SimpleValueDeserializer simpleValueDeserializer2 = new SimpleValueDeserializer(SimpleType.class); SimpleValueDeserializer simpleValueDeserializer3 = new SimpleValueDeserializer(SimpleType.class); SimpleValueDeserializer simpleValueDeserializer4 = new SimpleValueDeserializer(SimpleType.class); SimpleValueDeserializer simpleValueDeserializer5 = new SimpleValueDeserializer(SimpleType.class); SimpleValueDeserializer simpleValueDeserializer6 = new SimpleValueDeserializer(SimpleType.class); SimpleValueDeserializer simpleValueDeserializer7 = new SimpleValueDeserializer(SimpleType
@Test(expected=JsonMappingException.class) public void noConverter() throws JsonMappingException { SimpleType type = new SimpleType(); SimpleConverter converter = new SimpleConverter(); TypeConverter typeConverter = new SimpleTypeConverter(); SimpleConverter converter2 = new SimpleConverter(); SimpleConverter converter3 = new SimpleConverter(); SimpleConverter converter4 = new SimpleConverter(); SimpleConverter converter5 = new SimpleConverter(); SimpleConverter converter6 = new SimpleConverter(); converter.setConverter(converter); converter2.setConverter(converter3); converter3.setConverter(converter4); converter4.setConverter(converter5); converter5.setConverter(converter6); SimpleDeserializationContext ctxt = new SimpleDeserializationContext(type
@Test(expected=JsonMappingException.class) public void noConverter() throws JsonMappingException { SimpleType type = new SimpleType(); SimpleConverter converter = new SimpleConverter(); SimpleConverter2 converter2 = new SimpleConverter2(); SimpleConverter3 converter3 = new SimpleConverter3(); type.addConverter(converter); type.addConverter(converter2); type.addConverter(converter3); SimpleConverter converter4 = new SimpleConverter4(); type.addConverter(converter4); SimpleConverter converter5 = new SimpleConverter5(); type.addConverter(converter5); type.addConverter(converter6); SimpleConverter converter7 = new SimpleConverter7(); type.addConverter(converter7); type.addConverter
@Test public void testDefaultDeserializer() throws JsonProcessingException, IOException { JsonParser jp = mock(JsonParser.class); DeserializationContext ctxt = mock(DeserializationContext.class); Map<String, Object> map = new HashMap<String, Object>(); when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); when(jp.getText()).thenReturn("test"); when(jsonDeserializer.deserialize(jp, ctxt)).thenReturn(map); Map<String, Object> result = _deserializer.deserialize(jp, ctxt); assertEquals(map, result); verify(jsonDeserializer).deserialize(jp, ctxt); }
@Test public void test_readAndBindStringMap() throws Exception { Map<String, Object> expected = new HashMap<String, Object>(); expected.put("key1", "value1"); expected.put("key2", "value2"); Map<String, Object> actual = new HashMap<String, Object>(); actual.put("key1", "value1"); actual.put("key2", "value2"); when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); when(jsonDeserializer.deserialize(jp, ctxt, actual)).thenReturn(expected); Map<Object, Object> result = deserializer.deserialize(jp, ctxt, actual); assert
@Test public void test() throws Exception { Map<String, Object> expected = new HashMap<String, Object>(); expected.put("key1", "value1"); expected.put("key2", "value2"); expected.put("key3", "value3"); String json = "{\\n" + " \\"map\\": {\\n" + " \\"key1\\": \\"value1\\",\\n" + " \\"key2\\": \\"value2\\",\\n" + " \\"key3\\": \\"value3\\",\\n" + " \\"key4\\": \\"value4\\",\\n" + " \\"
@Test public void test_readAndBindStringMap() throws Exception { Map<String, Object> expected = new HashMap<String, Object>(); expected.put("key1", "value1"); expected.put("key2", "value2"); Map<String, Object> actual = new HashMap<String, Object>(); actual.put("key1", "value1"); actual.put("key2", "value2"); when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); when(jsonDeserializer.deserialize(jp, ctxt, actual)).thenReturn(expected); Map<Object, Object> result = deserializer.deserialize(jp, ctxt, actual); assert
@Test public void testMapDeserializer_StandardStringKey() throws Exception { Map<String, Object> map = new HashMap<String, Object>(); map.put("key1", "value1"); map.put("key2", "value2"); map.put("key3", "value3"); MockJsonParser jp = new MockJsonParser(map); jp.nextToken(); Map<Object, Object> result = new HashMap<Object, Object>(); Map<Object, Object> expect = new HashMap<Object, Object>(); expect.put("key1", "value1"); expect.put("key2", "value2"); expect.put("key3", "value3"); expect.
@Test public void test_readAndBindStringMap() throws Exception { Map<String, Object> result = new HashMap<String, Object>(); when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); Map<String, Object> expected = new HashMap<String, Object>(); expected.put("key1", "value1"); expected.put("key2", "value2"); expected.put("key3", "value3"); Map<Object, Object> actual = _deserializer.deserialize(jp, ctxt, result); assertEquals(expected, actual); verify(jp, times(1)).getCurrentToken(); verify(jp, times(1)).
@Test public void test_readAndBindStringMap() throws Exception { Map<String, Object> expected = new HashMap<String, Object>(); expected.put("key1", "value1"); expected.put("key2", "value2"); expected.put("key3", "value3"); Map<String, Object> actual = new HashMap<String, Object>(); actual.put("key1", "value1"); actual.put("key2", "value2"); actual.put("key3", "value3"); JsonDeserializer deserializer = new MapDeserializer(String.class, null, null, null, null, null); JsonParser jp = jpFactory.createParser("{ \\"
@Test public void readAndBind() throws Exception { String jsonStr = "{\\n" + " \\"a\\" : {\\n" + " \\"b\\" : {\\n" + " \\"c\\" : {\\n" + " \\"d\\" : {\\n" + " \\"e\\" : {\\n" + " \\"f\\" : \\"g\\"\\n" + " }\\n" + " }\\n" + " }\\n" + " },\\n" + " \\"d\\" : {\\n" + " \\"e\\" : {\\n" + " \\"f\\" : \\"g\\"\\n"
@Test public void readAndBindStringMap() throws Exception { String jsonStr = "{\\n" + " \\"a\\" : {\\n" + " \\"b\\" : {\\n" + " \\"c\\" : {\\n" + " \\"d\\" : {\\n" + " \\"e\\" : {\\n" + " \\"f\\" : \\"g\\"\\n" + " }\\n" + " }\\n" + " }\\n" + " },\\n" + " \\"d\\" : {\\n" + " \\"e\\" : {\\n" + " \\"f\\" : \\"g\\"\\
@Test(expected = JsonProcessingException.class) public void badJson() throws JsonProcessingException, IOException { JsonParser jp = Mockito.mock(JsonParser.class); DeserializationContext ctxt = Mockito.mock(DeserializationContext.class); Mockito.when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); Mockito.when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NULL); _line._deserializeUsingCreator(jp, ctxt); }
@Test(expected = JsonProcessingException.class) public void badJson() throws JsonProcessingException, IOException { JsonParser jp = Mockito.mock(JsonParser.class); DeserializationContext ctxt = Mockito.mock(DeserializationContext.class); Mockito.when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); Mockito.when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); Mockito.when(jp.isCurrentToken()).thenReturn(true); Mockito.when(jp.nextToken()).thenReturn(JsonToken.VALUE_STRING); Mockito.when(jp.getCurrentName()).thenReturn("
@Test(expected = JsonProcessingException.class) public void badJson() throws JsonProcessingException, IOException { JsonParser jp = mock(JsonParser.class); DeserializationContext ctxt = mock(DeserializationContext.class); when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); when(jp.nextToken()).thenReturn(JsonToken.END_OBJECT); when(jp.nextToken()).thenReturn(JsonToken.END_STRING); when(jsonDeserializer.deserialize(jp, ctxt)).thenThrow(JsonProcessingException.class); _deserializeUsingCreator(jp, ctxt);
@Test(expected = JsonProcessingException.class) public void badJson() throws JsonProcessingException, IOException { JsonParser jp = Mockito.mock(JsonParser.class); DeserializationContext ctxt = Mockito.mock(DeserializationContext.class); Mockito.when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); Mockito.when(jp.nextToken()).thenReturn(JsonToken.VALUE_NULL); Mockito.when(jp.isCurrentToken()).thenReturn(true); _deserializeUsingCreator(jp, ctxt); }
@Test(expected = JsonProcessingException.class) public void badJson() throws JsonProcessingException, IOException { JsonParser jp = Mockito.mock(JsonParser.class); DeserializationContext ctxt = Mockito.mock(DeserializationContext.class); Mockito.when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); Mockito.when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); Mockito.when(jp.nextToken()).thenReturn(JsonToken.END_OBJECT); Map<String, Object> value = new HashMap<String, Object>(); value.put("key", "value"); Mockito.when(jp.
@Test(expected = JsonProcessingException.class) public void badJson() throws JsonProcessingException, IOException { JsonParser jp = Mockito.mock(JsonParser.class); DeserializationContext ctxt = Mockito.mock(DeserializationContext.class); Mockito.when(jp.nextToken()).thenReturn(Json.START_OBJECT); Mockito.when(jp.getCurrentToken()).thenReturn(Json.START_OBJECT); Mockito.when(jp.nextToken()).thenReturn(Json.END_OBJECT); Mockito.when(jp.nextToken()).thenReturn(Json.END_STRING); _deserializeUsingCreator(jp, ctxt); }
@Test(expected = JsonProcessingException.class) public void badJson() throws JsonProcessingException, IOException { JsonParser jp = Mockito.mock(JsonParser.class); DeserializationContext ctxt = Mockito.mock(DeserializationContext.class); Mockito.when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); Mockito.when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); Mockito.when(jsonDeserializer.deserializeUsingCreator(jp, ctxt, null)).thenThrow(new JsonProcessingException("bad json")); jsonDeserializer._deserializeUsingCreator(jp, ctxt); }
@Test(expected = JsonProcessingException.class) public void badJson() throws JsonProcessingException, IOException { JsonParser jp = Mockito.mock(JsonParser.class); DeserializationContext ctxt = Mockito.mock(DeserializationContext.class); Mockito.when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); Mockito.when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); Mockito.when(jp.nextToken()).thenReturn(JsonToken.VALUE_STRING); Mockito.when(jsonTypeDeserializer.findCreatorProperty(Mockito.anyString())).thenReturn(null); Mockito.when(jsonType
@Test(expected = JsonProcessingException.class) public void badJson() throws JsonProcessingException, IOException { JsonParser jp = mock(JsonParser.class); DeserializationContext ctxt = mock(DeserializationContext.class); when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); when(jp.nextToken()).thenReturn(JsonToken.END_OBJECT); Map<String, Object> map = new HashMap<String, Object>(); map.put("key1", "value1"); map.put("key2", "value2"); when(jp.nextToken()).then
@Test(expected = JsonProcessingException.class) public void badJson() throws JsonProcessingException, IOException { JsonParser jp = Mockito.mock(JsonParser.class); DeserializationContext ctxt = Mockito.mock(DeserializationContext.class); Mockito.when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); Mockito.when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); Mockito.when(jp.isCurrentToken()).thenReturn(true); Mockito.when(jp.nextToken()).thenReturn(JsonToken.VALUE_NULL); Mockito.when(jsonDeserializer.deserialize(jp, ctxt)).
@Test public void deserializeUsingCreator() throws JsonProcessingException, IOException { JsonParser jp = Mockito.mock(JsonParser.class); DeserializationContext ctxt = Mockito.mock(DeserializationContext.class); Mockito.when(jp.nextToken()).thenReturn(Json.START_OBJECT); Mockito.when(jp.getCurrentToken()).thenReturn(0); Map<Object, Object> value = new HashMap<Object, Object>(); Mockito.when(jsonDeserializer.deserialize(jp, ctxt)).thenReturn(value); Map<Object, Object> result = classUnderTest._deserializeUsingCreator(jp, ctxt); Assert.assertEquals(value, result);
@Test public void test_deserializeUsingCreator() throws JsonProcessingException, IOException { JsonParser jp = Mockito.mock(JsonParser.class); DeserializationContext ctxt = Mockito.mock(DeserializationContext.class); Mockito.when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); Mockito.when(jp.getCurrentToken()).thenReturn(JsonToken.START_FIELD_NAME); Mockito.when(jp.nextToken()).thenReturn(JsonToken.END_FIELD_NAME); Mockito.when(jp.isCurrentToken()).thenReturn(true); Mockito.when(jp.nextToken()).thenReturn(JsonToken
@Test(expected = JsonProcessingException.class) public void badJson() throws JsonProcessingException, IOException { JsonParser jp = Mockito.mock(JsonParser.class); DeserializationContext ctxt = Mockito.mock(DeserializationContext.class); Mockito.when(jp.nextToken()).thenReturn(Json.START_OBJECT); Mockito.when(jp.getCurrentToken()).thenReturn(0); SettableBeanProperty property = Mockito.mock(SettableBeanProperty.class); Mockito.when(property.getCreatorIndex()).thenReturn(1); Mockito.when(property.getValueType()).thenReturn(ValueType.INTEGER); Mockito.when(property
@Test(expected = JsonProcessingException.class) public void badJson() throws JsonProcessingException, IOException { JsonParser jp = Mockito.mock(JsonParser.class); DeserializationContext ctxt = Mockito.mock(DeserializationContext.class); Mockito.when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); Mockito.when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); Mockito.when(jp.isCurrentToken()).thenReturn(true); Mockito.when(jp.nextToken()).thenReturn(JsonToken.VALUE_NULL); Mockito.when(jp.getCurrentName()).thenReturn("
@Test(expected = JsonProcessingException.class) public void badJson() throws JsonProcessingException, IOException { JsonParser jp = Mockito.mock(JsonParser.class); DeserializationContext ctxt = Mockito.mock(DeserializationContext.class); Mockito.when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); Mockito.when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); Mockito.when(jp.nextToken()).thenReturn(JsonToken.END_OBJECT); Map<String, Object> value = new HashMap<String, Object>(); value.put("key1", "value1"); value.put("key
@Test public void simple() throws JsonProcessingException, IOException { JsonParser jp = mock(JsonParser.class); DeserializationContext ctxt = mock(DeserializationContext.class); when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); when(jp.nextToken()).thenReturn(JsonToken.END_OBJECT); Map<String, Object> value = new HashMap<String, Object>(); value.put("key1", "value1"); value.put("key2", "value2"); when(jp.nextToken()).thenReturn(JsonToken.END_OBJECT);
@Test public void deserializeUsingCreator() throws JsonProcessingException, IOException { JsonParser jp = mock(JsonParser.class); DeserializationContext ctxt = mock(DeserializationContext.class); when(jp.nextToken()).thenReturn(0).thenReturn(1).thenReturn(2).thenReturn(3).thenReturn(4).thenReturn(5).thenReturn(6).thenReturn(7).thenReturn(8).thenReturn(9).thenReturn(10).thenReturn(11).thenReturn(12).thenReturn(13).thenReturn(14).thenReturn(15).thenReturn(16); Map<Object, Object> value = new HashMap<Object, Object>();
@Test(expected = JsonProcessingException.class) public void badJson() throws JsonProcessingException, IOException { JsonParser jp = Mockito.mock(JsonParser.class); DeserializationContext ctxt = Mockito.mock(DeserializationContext.class); Mockito.when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); Mockito.when(jp.nextToken()).thenReturn(JsonToken.VALUE_NULL); Mockito.when(jp.isCurrentToken()).thenReturn(false); _deserializeUsingCreator(jp, ctxt); }
@Test(expected = JsonProcessingException.class) public void badJson() throws JsonProcessingException, IOException { JsonParser jp = Mockito.mock(JsonParser.class); DeserializationContext ctxt = Mockito.mock(DeserializationContext.class); Mockito.when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); Mockito.when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NULL); _line._deserializeUsingCreator(jp, ctxt); }
@Test(expected = JsonProcessingException.class) public void badJson() throws JsonProcessingException, IOException { JsonParser jp = Mockito.mock(JsonParser.class); DeserializationContext ctxt = Mockito.mock(DeserializationContext.class); Mockito.when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); Mockito.when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); Mockito.when(jp.nextToken()).thenReturn(JsonToken.END_OBJECT); Mockito.when(jp.nextToken()).thenReturn(JsonToken.END_STRING); Mockito.when(jsonDeserializer.deserialize(jp
@Test(expected = JsonProcessingException.class) public void badJson() throws JsonProcessingException, IOException { JsonParser jp = Mockito.mock(JsonParser.class); DeserializationContext ctxt = Mockito.mock(DeserializationContext.class); Mockito.when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); Mockito.when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); Mockito.when(jp.nextToken()).thenReturn(JsonToken.END_OBJECT); _test._readAndBind(jp, ctxt, new HashMap<Object, Object>()); }
@Test(expected = JsonProcessingException.class) public void badJson() throws JsonProcessingException, IOException { JsonParser jp = Mockito.mock(JsonParser.class); DeserializationContext ctxt = Mockito.mock(DeserializationContext.class); Mockito.when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); Mockito.when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); Mockito.when(jp.nextToken()).thenReturn(JsonToken.END_OBJECT); Map<Object, Object> result = new HashMap<Object, Object>(); Mockito.when(jp.nextToken()).thenReturn(JsonToken
@Test(expected = JsonProcessingException.class) public void badJson() throws JsonProcessingException, IOException { JsonParser jp = Mockito.mock(JsonParser.class); DeserializationContext ctxt = Mockito.mock(DeserializationContext.class); Mockito.when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); Mockito.when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NULL); _line._deserializeUsingCreator(jp, ctxt); }
@Test(expected = JsonProcessingException.class) public void badJson() throws JsonProcessingException, IOException { JsonParser jp = Mockito.mock(JsonParser.class); DeserializationContext ctxt = Mockito.mock(DeserializationContext.class); Mockito.when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); Mockito.when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); Mockito.when(jp.isCurrentToken()).thenReturn(true); Mockito.when(jp.nextToken()).thenReturn(JsonToken.VALUE_NULL); Mockito.when(jsonDeserializer.deserialize(jp, ctxt)).
@Test(expected = JsonProcessingException.class) public void badJson() throws JsonProcessingException, IOException { JsonParser jp = Mockito.mock(JsonParser.class); DeserializationContext ctxt = Mockito.mock(DeserializationContext.class); Mockito.when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); Mockito.when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); Mockito.when(jp.nextToken()).thenReturn(JsonToken.END_OBJECT); Mockito.when(jsonDeserializer.deserializeKey(Mockito.anyString(), Mockito.any(DeserializationContext.class))).thenThrow(
@Test(expected = JsonProcessingException.class) public void badJson() throws JsonProcessingException, IOException { JsonParser jp = Mockito.mock(JsonParser.class); DeserializationContext ctxt = Mockito.mock(DeserializationContext.class); Mockito.when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); Mockito.when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); Mockito.when(jp.nextToken()).thenReturn(JsonToken.END_OBJECT); Map<String, Object> value = new HashMap<String, Object>(); value.put("key", "value"); Mockito.when(jp.
@Test public void simple() throws JsonProcessingException, IOException { JsonParser jp = mock(JsonParser.class); DeserializationContext ctxt = mock(DeserializationContext.class); when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NULL); Map<Object, Object> value = new HashMap<Object, Object>(); when(jsonParser.nextToken()).thenReturn(JsonToken.VALUE_STRING); when(jsonParser.nextToken()).thenReturn(JsonToken.VALUE_NUMBER); when(jsonDeserializer.deserialize(jp, ctxt)).thenReturn(value); when(json
@Test(expected = JsonProcessingException.class) public void badJson() throws JsonProcessingException, IOException { JsonParser jp = Mockito.mock(JsonParser.class); DeserializationContext ctxt = Mockito.mock(DeserializationContext.class); Mockito.when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); Mockito.when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); Mockito.when(jp.nextToken()).thenReturn(JsonToken.END_OBJECT); Map<String, Object> value = new HashMap<String, Object>(); value.put("key", "value"); Mockito.when(jp.
@Test(expected = JsonProcessingException.class) public void badJson() throws JsonProcessingException, IOException { JsonParser jp = Mockito.mock(JsonParser.class); DeserializationContext ctxt = Mockito.mock(DeserializationContext.class); Mockito.when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); Mockito.when(jp.nextToken()).thenReturn(JsonToken.END_OBJECT); Mockito.when(jsonDeserializer.deserialize(jp, ctxt)).thenThrow(new JsonProcessingException("bad json")); Mockito.when(jsonDeserializer.findCreatorProperty("test")).thenReturn(null); Mockito.when(jsonDeserializer
@Test(expected = JsonProcessingException.class) public void badJson() throws JsonProcessingException, IOException { JsonParser jp = Mockito.mock(JsonParser.class); DeserializationContext ctxt = Mockito.mock(DeserializationContext.class); Mockito.when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); Mockito.when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); Mockito.when(jp.nextToken()).thenReturn(JsonToken.END_OBJECT); Map<String, Object> map = new HashMap<String, Object>(); map.put("foo", "bar"); map.put("baz",
@Test public void testUnwrappingDeserializer() throws Exception { Map<String, String> map = new HashMap<String, String>(); map.put("key1", "value1"); map.put("key2", "value2"); map.put("key3", "value3"); map.put("key4", "value4"); Map<String, String> map2 = new HashMap<String, String>(); map2.put("key1", "value1"); map2.put("key2", "value2"); map2.put("key3", "value3"); map2.put("key4", "value4"); map2.put("key5", "value
@Test public void testUnwrappingDeserializer() throws Exception { assertSame(None.INSTANCE, none.unwrappingDeserializer(new NameTransformer() { @Override public Object deserialize(JsonParser jp, DeserializationContext ctxt, Object value) throws IOException, JsonProcessingException { return value; } })); assertSame(None.INSTANCE, none.unwrappingDeserializer(new NameTransformer() { @Override public Object deserialize(JsonParser jp, DeserializationContext ctxt, Object value) throws IOException, JsonProcessingException { return value; } })); }
@Test public void testFormat() { Calendar cal = Calendar.getInstance(); cal.setTimeInMillis(0); cal.set(Calendar.HOUR_OF_DAY, 0); cal.set(Calendar.MINUTE, 0); cal.set(Calendar.SECOND, 0); cal.set(Calendar.MILLISECOND, 0); Calendar cal2 = Calendar.getInstance(); cal2.setTimeInMillis(0); cal2.set(Calendar.HOUR_OF_DAY, 0); cal2.set(Calendar.MINUTE, 0); cal2.set(Calendar.SECOND, 0); cal2.set(Calendar.MILLISECOND, 0); cal2.set(Calendar.MILLISECOND, 0);
@Test public void testFormat() throws ParseException { Date date = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'").parse("2011-01-01T00:00:00.000Z"); assertEquals("2011-01-01T00:00:00.000Z", format(date, false)); date = new SimpleDateFormat("yyyy-MM-dd\'T\'HH:mm:ss.SSS\'Z\'").parse("2011-01-01T00:00:00.000Z"); assertEquals("2011-01-01T00:00:00.000Z", format(date, true)); date
@Test public void format() { final Calendar cal = Calendar.getInstance(TimeZone.getTimeZone("UTC")); cal.set(Calendar.YEAR, 2010); cal.set(Calendar.MONTH, 1); cal.set(Calendar.DAY_OF_MONTH, 1); cal.set(Calendar.HOUR_OF_DAY, 1); cal.set(Calendar.MINUTE, 1); cal.set(Calendar.SECOND, 1); cal.set(Calendar.MILLISECOND, 1); cal.setTimeZone(TimeZone.getTimeZone("UTC")); cal.set(Calendar.MILLISECOND, 1); cal.setTimeZone(TimeZone.getTimeZone("UTC")); final Date date = cal.getTime
@Test public void format() { final Calendar cal = Calendar.getInstance(TimeZone.getTimeZone("UTC")); cal.set(Calendar.MILLISECOND, 0); cal.set(Calendar.HOUR_OF_DAY, 0); cal.set(Calendar.DAY_OF_MONTH, 0); cal.set(Calendar.HOUR_OF_DAY, 0); cal.set(Calendar.MINUTE, 0); cal.set(Calendar.SECOND, 0); cal.set(Calendar.MILLISECOND, 0); cal.set(Calendar.MILLISECOND, 0); cal.set(Calendar.HOUR_OF_DAY, 0); cal.set(Calendar.DAY_OF_MONTH, 0); cal
@Test public void format() { final Calendar cal = Calendar.getInstance(TimeZone.getTimeZone("UTC")); cal.set(Calendar.YEAR, 2010); cal.set(Calendar.MONTH, 1); cal.set(Calendar.DAY_OF_MONTH, 1); cal.set(Calendar.HOUR_OF_DAY, 1); cal.set(Calendar.MINUTE, 1); cal.set(Calendar.SECOND, 1); cal.set(Calendar.MILLISECOND, 1); cal.setTimeZone(TimeZone.getTimeZone("UTC")); cal.set(Calendar.MILLISECOND, 1); cal.set(Calendar.MILLISECOND, 1); cal.setTimeZone(TimeZone.getTimeZone("
@Test public void format() { final Calendar cal = Calendar.getInstance(TimeZone.getTimeZone("UTC")); cal.set(Calendar.YEAR, 2010); cal.set(Calendar.MONTH, 1); cal.set(Calendar.DAY_OF_MONTH, 1); cal.set(Calendar.HOUR_OF_DAY, 1); cal.set(Calendar.MINUTE, 1); cal.set(Calendar.SECOND, 1); cal.set(Calendar.MILLISECOND, 1); cal.setTimeZone(TimeZone.getTimeZone("UTC")); cal.set(Calendar.MILLISECOND, 1); cal.set(Calendar.MILLISECOND, 1); cal.setTimeZone(TimeZone.getTimeZone("
@Test public void format() { final Calendar cal = Calendar.getInstance(TimeZone.getTimeZone("UTC")); cal.set(Calendar.YEAR, 2010); cal.set(Calendar.MONTH, Calendar.JULY); cal.set(Calendar.DAY_OF_MONTH, 1); cal.set(Calendar.HOUR_OF_DAY, 0); cal.set(Calendar.MINUTE, 0); cal.set(Calendar.SECOND, 0); cal.set(Calendar.MILLISECOND, 0); cal.setTimeZone(TimeZone.getTimeZone("UTC")); cal.set(Calendar.MILLISECOND, 0); cal.setTimeZone(TimeZone.getTimeZone("UTC")); final String expected =
@Test public void format() { final Calendar cal = Calendar.getInstance(TimeZone.getTimeZone("UTC")); cal.set(Calendar.YEAR, 2010); cal.set(Calendar.MONTH, Calendar.JULY); cal.set(Calendar.DAY_OF_MONTH, 1); cal.set(Calendar.HOUR_OF_DAY, 0); cal.set(Calendar.MINUTE, 0); cal.set(Calendar.SECOND, 0); cal.set(Calendar.MILLISECOND, 0); cal.set(Calendar.MILLISECOND, 0); cal.setTimeZone(TimeZone.getTimeZone("UTC")); final String expected = "1970-01-01T00:00:00
@Test public void format() { final Calendar cal = Calendar.getInstance(TimeZone.getTimeZone("UTC")); cal.set(Calendar.YEAR, 2010); cal.set(Calendar.MONTH, 1); cal.set(Calendar.DAY_OF_MONTH, 1); cal.set(Calendar.HOUR_OF_DAY, 1); cal.set(Calendar.MINUTE, 1); cal.set(Calendar.SECOND, 1); cal.set(Calendar.MILLISECOND, 1); cal.setTimeZone(TimeZone.getTimeZone("UTC")); cal.set(Calendar.MILLISECOND, 1); cal.setTimeZone(TimeZone.getTimeZone("UTC")); final Date date = cal.getTime
@Test public void format() { final Calendar cal = Calendar.getInstance(TimeZone.getTimeZone("UTC")); cal.set(Calendar.YEAR, 2010); cal.set(Calendar.MONTH, Calendar.JULY); cal.set(Calendar.DAY_OF_MONTH, 1); cal.set(Calendar.HOUR_OF_DAY, 0); cal.set(Calendar.MINUTE, 0); cal.set(Calendar.SECOND, 0); cal.set(Calendar.MILLISECOND, 0); cal.set(Calendar.MILLISECOND, 0); cal.setTimeZone(TimeZone.getTimeZone("UTC")); final Date date = cal.getTime(); final String actual = format(date,
@Test public void testFind() throws Exception { JsonDeserializer<?> deserializer = JavaTypeDeserializer.find(TokenBuffer.class); Assert.assertNotNull(deserializer); }
@Test public void testJavaTypeDeserializer() throws Exception { Map<String, String> map = new HashMap<String, String>(); map.put("byte", "1"); map.put("short", "2"); map.put("int", "3"); map.put("long", "4"); map.put("float", "5.6"); map.put("double", "7.8"); map.put("boolean", "true"); map.put("byteArray", new byte[]{1, 2, 3, 4}); map.put("floatArray", new float[]{1, 2, 3, 4}); map.put("doubleArray", new double[]{1, 2, 3
@Test(expected = JsonProcessingException.class) public void testEmptyString() throws Exception { String str = ""; when(jsonParser.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); when(jsonParser.getText()).thenReturn(str); new JavaTypeDeserializer().deserialize(jsonParser, jsonContext); }
@Test(expected = JsonProcessingException.class) public void testEmptyString() throws Exception { String str = ""; when(jsonParser.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); when(jsonParser.getText()).thenReturn(str); deserializer.deserialize(jsonParser, jsonContext); }
@Test(expected = JsonProcessingException.class) public void testEmptyString() throws Exception { String str = ""; when(jp.getText()).thenReturn(str); when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); new JavaTypeDeserializer().deserialize(jp, jp); }
@Test(expected = JsonProcessingException.class) public void testEmptyString() throws Exception { String str = ""; when(jsonParser.getText()).thenReturn(str); when(jsonParser.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); new JavaTypeDeserializer().deserialize(jsonParser, jsonContext); }
@Test(expected = JsonProcessingException.class) public void testEmptyString() throws Exception { String str = ""; when(jsonParser.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); when(jsonParser.getText()).thenReturn(str); new JavaTypeDeserializer().deserialize(jsonParser, jsonContext); }
@Test(expected = JsonProcessingException.class) public void testEmptyString() throws Exception { String str = ""; when(jsonParser.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); when(jsonParser.getText()).thenReturn(str); when(jsonTypeFactory.constructFromCanonical(str)).thenReturn(type); new JavaTypeDeserializer().deserialize(jsonParser, jsonDeserializationContext); }
@Test public void testSetDefaultKeySerializer() { JsonSerializer<Object> ks = new JsonSerializer<Object>() { @Override public void defaultSerializerInstance(Object value, JsonGenerator jgen) throws IOException, JsonMappingException { } @Override public void defaultSerializerInstance(Object value, JsonGenerator jgen) throws IOException, JsonMappingException { } @Override public void defaultSerializerInstance(Object value, JsonGenerator jgen) throws IOException, JsonMappingException { } }; provider.setDefaultKeySerializer(ks); assertSame(ks, provider.getDefaultKeySerializer()); provider.setDefaultKeySerializer(null); assertSame(ks, provider.getDefaultKeySerializer()); provider.setDefaultKeySerializer
@Test public void testSetDefaultKeySerializer() { SerializerProvider provider = new SerializerProvider(); provider.setDefaultKeySerializer(new JsonSerializer<Object>() { @Override public Object findValueSerializer(Class<?> type, Object value, JsonGenerator jgen) throws JsonMappingException, JsonProcessingException { return null; } @Override public void defaultSerializerInstance(Object value, JsonGenerator jgen) throws JsonMappingException, JsonProcessingException { } }); provider.setDefaultKeySerializer(new JsonSerializer<Object>() { @Override public Object findValueSerializer(Class<?> type, Object value, JsonGenerator jgen) throws JsonMappingException, JsonProcessingException { return null; } @Override public void defaultSerializerInstance
@Test public void testSetDefaultKeySerializer() { JsonSerializer<Object> ks = new JsonSerializer<Object>() { @Override public void defaultSerializerInstance(Object value, JsonGenerator jgen) throws IOException, JsonMappingException { } @Override public void defaultSerializerInstance(Object value, JsonGenerator jgen) throws IOException, JsonMappingException { } }; ks.setDefaultKeySerializer(ks); assertSame(ks, ks.getDefaultKeySerializer()); }
@Test public void testSetNullValueSerializer() throws Exception { JsonSerializer<Object> bs = new JsonSerializer<Object>() { @Override public void defaultSerializerInstance(Object value, JsonGenerator jgen) throws JsonMappingException, JsonProcessingException { } @Override public void defaultSerializerInstance(Object value, JsonGenerator jgen) throws JsonMappingException, JsonProcessingException { } }; provider.setNullValueSerializer(bs); assertSame(bs, provider.getNullValueSerializer()); provider.setNullValueSerializer(bs); assertSame(bs, provider.getNullValueSerializer()); provider.setNullValueSerializer(bs); assertSame(bs, provider.getNullValueSerializer()); provider.setNullValue
@Test public void testSetNullValueSerializer() { JsonSerializer<Object> bs = new JsonSerializer<Object>() { @Override public void defaultSerializerInstance(Object value, JsonGenerator jgen) throws IOException, JsonMappingException { } @Override public void defaultSerializerInstance(Object value, JsonGenerator jgen) throws IOException, JsonMappingException { } }; SerializerProvider provider = new SerializerProvider(); provider.setNullValueSerializer(bs); assertSame(bs, provider.getNullValueSerializer()); provider.setNullValueSerializer(bs); provider.setNullValueSerializer(bs); assertSame(bs, provider.getNullValueSerializer()); provider.setNullValueSerializer(bs); provider.setNull
@Test public void testSetNullValueSerializer() { JsonSerializer<Object> bs = new JsonSerializer<Object>() { @Override public void defaultSerializerInstance(Object value, JsonGenerator jgen) throws IOException, JsonMappingException { } @Override public void defaultSerializerInstance(Object value, JsonGenerator jgen) throws IOException, JsonMappingException { } @Override public void defaultSerializerInstance(Object value, JsonGenerator jgen) throws IOException, JsonMappingException { } }; SerializerProvider provider = new SerializerProvider(); provider.setNullValueSerializer(bs); assertSame(bs, provider.getNullValueSerializer()); provider.setNullValueSerializer(bs); provider.setNullValueSerializer(bs); provider
@Test public void testGetLocale() { assertEquals(Locale.ENGLISH, new SimpleSerializerProvider().getLocale().getLanguage()); assertEquals(Locale.ENGLISH, new SimpleSerializerProvider().getLocale().getCountry()); assertEquals(Locale.ENGLISH, new SimpleSerializerProvider().getLocale().getBcp47Tag()); assertEquals(Locale.ENGLISH, new SimpleSerializerProvider().getLocale().getEnglishLocale()); assertEquals(Locale.ENGLISH, new SimpleSerializerProvider().getLocale().getGermanLocale()); assertEquals(Locale.ENGLISH, new SimpleSerializerProvider().getLocale().getEnglishLocale()); assertEquals(Locale.ENGLISH, new SimpleSerializerProvider().getLocale().
@Test public void testGetLocale() { SerializerProvider provider = new SerializerProvider(); provider.setLocale(Locale.US); assertEquals(Locale.US, provider.getLocale()); provider.setLocale(Locale.ENGLISH); assertEquals(Locale.ENGLISH, provider.getLocale()); provider.setLocale(Locale.FRENCH); assertEquals(Locale.FRENCH, provider.getLocale()); provider.setLocale(null); assertEquals(null, provider.getLocale()); provider.setLocale(Locale.ENGLISH); assertEquals(Locale.ENGLISH, provider.getLocale()); provider.setLocale(null); assertEquals(null, provider.getLocale()); provider.setLocale(
@Test public void testSerializers() { SerializerProvider provider = new SerializerProvider(); provider.setTimeZone(TimeZone.getTimeZone("UTC")); assertEquals("UTC", provider.getTimeZone().getID()); provider.setTimeZone(TimeZone.getTimeZone("PST")); assertEquals("PST", provider.getTimeZone().getID()); provider.setTimeZone(TimeZone.getTimeZone("America/Los_Angeles")); assertEquals("America/Los_Angeles", provider.getTimeZone().getID()); provider.setTimeZone(TimeZone.getTimeZone("America/Los_Angeles")); assertEquals("America/Los_Angeles", provider.getTimeZone().getID()); provider
@Test public void testSerializerProvider() { SerializerProvider provider = new SerializerProvider(); provider.setDefaultKeySerializer(new StringSerializer()); provider.setDefaultNullValueSerializer(new StringSerializer()); provider.setTimeZone(TimeZone.getTimeZone("UTC")); assertEquals(TimeZone.getTimeZone("UTC"), provider.getTimeZone()); provider.setTimeZone(TimeZone.getTimeZone("PST")); assertEquals(TimeZone.getTimeZone("PST"), provider.getTimeZone()); provider.setNullKeySerializer(new StringSerializer()); provider.setDefaultNullValueSerializer(new StringSerializer()); provider.setTimeZone(TimeZone.getTimeZone("PST")); assertEquals(TimeZone.getTimeZone("PST"
@Test public void testFindTypedValueSerializer() throws Exception { SimpleSerializationProvider provider = new SimpleSerializationProvider(); provider.setConfig(new SimpleSerializationConfig()); SimpleObject obj = new SimpleObject(); obj.setField1("foo"); obj.setField2("bar"); provider.addObject(obj); SimpleObject obj2 = new SimpleObject(); obj2.setField1("foo"); obj2.setField2("bar"); provider.addObject(obj2); SimpleObject obj3 = new SimpleObject(); obj3.setField1("foo"); obj3.setField2("bar"); provider.addObject(obj3); SimpleObject obj4 = new SimpleObject(); obj4.setField
@Test public void testDefaultSerializeNull() throws Exception { JsonGenerator jgen = mock(JsonGenerator.class); provider.defaultSerializeNull(jgen); verify(jgen, times(1)).println("null"); provider.defaultSerializeNull(jgen); verify(jgen, times(1)).println("null"); provider.defaultSerializeNull(jgen); verify(jgen, times(1)).println("null"); provider.defaultSerializeNull(jgen); verify(jgen, times(1)).println("null"); provider.defaultSerializeNull(jgen); verify(jgen, times(1)).println("null"); }
@Test public void testGetDefaultNullSerializer() throws Exception { SerializerProvider provider = new SerializerProvider(); provider.setNullKeySerializer(new StringSerializer()); provider.setDefaultNullValueSerializer(new StringSerializer()); JsonGenerator jgen = mock(JsonGenerator.class); provider.defaultSerializeNull(jgen); verify(jgen, times(1)).println("null"); provider.setNullKeySerializer(new StringSerializer()); provider.defaultSerializeNull(jgen); verify(jgen, times(1)).println("null"); provider.setDefaultNullValueSerializer(new StringSerializer()); provider.defaultSerializeNull(jgen); verify(jgen, times(1)).println("null");
@Test public void testReportIncompatibleRootType() throws Exception { SimpleSerializationProvider provider = new SimpleSerializationProvider(); provider._reportIncompatibleRootType(new TestBean(), TypeFactory.defaultInstance().getType(String.class)); provider._reportIncompatibleRootType(new TestBean(), TypeFactory.defaultInstance().getType(Integer.class)); provider._reportIncompatibleRootType(new TestBean(), TypeFactory.defaultInstance().getType(Long.class)); provider._reportIncompatibleRootType(new TestBean(), TypeFactory.defaultInstance().getType(Float.class)); provider._reportIncompatibleRootType(new TestBean(), TypeFactory.defaultInstance().getType(Float.class)); provider._reportIncompatibleRoot
@Test public void testFindValueSerializer() throws Exception { SerializerProvider provider = new SerializerProvider(); provider.setDefaultKeySerializer(new JsonSerializerProvider() { @Override public JsonSerializer<Object> findValueSerializer(Class<?> type, boolean cache, BeanProperty property) throws JsonMappingException { return new JsonSerializer<Object>() { @Override public void write(Object value, JsonWriter writer) throws IOException { writer.write(value); } @Override public void write(Object value, JsonWriter writer) throws IOException { writer.write(value); } @Override public void write(Object value, JsonWriter writer) throws IOException { writer.write(value); } @Override public void write(Object value
@Test public void testFindValueSerializer() throws Exception { SerializerProvider provider = new SerializerProvider(); provider.setDefaultKeySerializer(new JsonSerializerProvider() { @Override public JsonSerializer<Object> findKeySerializer(Class<?> type, boolean cache, BeanProperty property) throws JsonMappingException { return new JsonSerializer<Object>() { @Override public void setNullValueSerializer(Object value, Class<?> valueType) throws JsonMappingException { throw new JsonMappingException(); } @Override public JsonSerializer<Object> findValueSerializer(Class<?> type, boolean cache, BeanProperty property) throws JsonMappingException { throw new JsonMappingException(); } @Override public Class<?> getRawType() { return Object.
@Test public void testFindValueSerializer() throws Exception { SimpleSerializerProvider provider = new SimpleSerializerProvider(); provider.setDefaultKeySerializer(new JsonSerializer<Object>() { @Override public JsonSerializer<Object> findValueSerializer(Class<?> type, boolean cache, BeanProperty property) throws JsonMappingException { return new JsonSerializer<Object>() { @Override public void write(Object value, JsonWriter writer) throws IOException { writer.write(value); } @Override public void write(Object value, JsonWriter writer) throws IOException { writer.write(value); } @Override public void write(Object value, JsonWriter writer) throws IOException { writer.write(value); } @Override public void
@Test public void test_reportIncompatibleRootType() throws Exception { SimpleSerializerProvider provider = new SimpleSerializerProvider(); provider.setDefaultKeySerializer(new JsonSerializer<Object>() { @Override public JsonSerializer<Object> createSerializer(Object value, Class<Object> baseType) throws JsonMappingException { return new JsonSerializer<Object>() { @Override public void write(Object value, OutputStream out) throws IOException { out.write(value); } @Override public void write(Object value, OutputStream out) throws IOException { out.write(value); } @Override public void write(Object value, OutputStream out) throws IOException { out.write(value); } @Override public void write(Object value,
@Test(expected=JsonMappingException.class) public void testReportIncompatibleRootType_IncompatibleTypes() throws Exception { SerializerProvider provider = new SerializerProvider(); provider._reportIncompatibleRootType(new TestBean(), TypeFactory.defaultInstance().getType(TestBean.class)); provider._reportIncompatibleRootType(new TestBean(), TypeFactory.defaultInstance().getType(String.class)); provider._reportIncompatibleRootType(new TestBean(), TypeFactory.defaultInstance().getType(Integer.class)); provider._reportIncompatibleRootType(new TestBean(), TypeFactory.defaultInstance().getType(Long.class)); provider._reportIncompatibleRootType(new TestBean(), TypeFactory.defaultInstance().get
@Test public void testFindValueSerializer() throws JsonMappingException { SerializerProvider provider = new SerializerProvider(); provider.setConfig(new DefaultSerializationConfig()); provider.findValueSerializer(String.class, null); provider.findValueSerializer(String.class, null); provider.findValueSerializer(String.class, null); provider.findValueSerializer(String.class, null); provider.findValueSerializer(String.class, null); provider.findValueSerializer(String.class, null); provider.findValueSerializer(String.class, null); provider.findValueSerializer(String.class, null); provider.findValueSerializer(String.class, null); provider.findValueSerializer(String.
